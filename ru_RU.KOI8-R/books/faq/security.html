<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>Глава 13. Безопасность</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Часто задаваемые вопросы по FreeBSD 8.X, 9.X и 10.X" /><link rel="up" href="index.html" title="Часто задаваемые вопросы по FreeBSD 8.X, 9.X и 10.X" /><link rel="prev" href="networking.html" title="Глава 12. Работа в сети" /><link rel="next" href="ppp.html" title="Глава 14. PPP" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Глава 13. Безопасность</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="networking.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ppp.html">След.</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security"></a>Глава 13. Безопасность</h1></div></div></div><div class="qandaset"><a id="idp77147856"></a><dl><dt>13.1. <a href="security.html#idp77148112">Что означает термин sandbox (песочница)?</a></dt><dt>13.2. <a href="security.html#idp77266256">Что такое уровень защиты (securelevel)?</a></dt><dt>13.3. <a href="security.html#idp77281232">BIND (named) работает на
	    одном из портов с большим номером.  Что происходит?</a></dt><dt>13.4. <a href="security.html#idp77324624">Даемон Sendmail ждёт
	    соединений как на стандартном порту 25, так и на
	    порту 587!  Что происходит?</a></dt><dt>13.5. <a href="security.html#idp77327440">Что это за пользователь toor с UID 0?  Я
	    подвергся взлому?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp77148112"></a><a id="sandbox"></a><p><strong>13.1.</strong></p></td><td align="left" valign="top"><p>Что означает термин sandbox (песочница)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote"><<<span class="quote">Sandbox</span>>></span> - это термин, используемый при
	    обеспечении безопасности.  Он имеет два значения:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Процесс, помещённый внутрь некоторых виртуальных
		стен, которые предназначены для предотвращения взлома
		всей системы в результате взлома этого конкретного
		процесса.</p><p>Процесс может работать в границах этих стен.
		Поскольку, что бы этот процесс ни делал, он эти стены
		разрушить не может, особый аудит его кода не нужен для
		того, чтобы с уверенностью сказать, насколько его
		работа безопасна для системы.</p><p>Стеной может служить, например, идентификатор
		пользователя.  Вот определение, даваемое на страницах
		Справочника <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=security&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">security</span>(7)</span></a> и <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.</p><p>Рассмотрим, например, службу <code class="literal">ntalk</code>
		(смотрите <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>).  Раньше эта
		служба запускалась с идентификатором пользователя
		<code class="systemitem">root</code>, а сейчас - <code class="systemitem">tty</code>.
		Пользователь <code class="systemitem">tty</code> - это та песочница,
		которая осложняет взлом системы через <code class="literal">ntalk</code>
		посредством использования этого идентификатора
		пользователя.</p></li><li class="listitem"><p>Процесс, помещённый внутрь симулируемой машины.  Это
		даёт больший уровень безопасности.  Это означает, что
		некто, взломавший процесс, может думать, что может сломать и
		систему в целом, однако фактически может сломать только
		симулятор этой машины и не может модифицировать никаких
		реальных данных.</p><p>Самым распространённым способом достигнуть такого
		результата является построение имитирующего окружения в
		каталоге и затем запуск процессов в этом каталоге через
		chroot (т.е. задав этот каталог в качестве
		<code class="filename">/</code> для этого процесса,
		а не реальный <code class="filename">/</code> всей
		системы).</p><p>Другим часто используемым методом является монтирование
		низлежащей файловой системы в режиме "только для чтения" и
		затем создание уровня файловой системы поверх неё, что даёт
		процессу видимость доступа по записи на ту файловую систему.
		Процесс будет полагать, что может записывать в те файлы, но
		это будет единственный процесс, который увидит результат
		- другие процессы не будут этого делать ни в коем
		случае.</p><p>Попытка сделать такой тип песочницы настолько прозрачна, что
		пользователь (или взломщик) даже не поймёт, что он в ней
		находится.</p></li></ul></div><p>В <span class="trademark">UNIX</span>(R) реализованы два типа <span class="quote"><<<span class="quote">песочниц</span>>></span>.  Один на
	    уровне процесса, и один на уровне идентификаторов
	    пользователей.</p><p>Каждый процесс в <span class="trademark">UNIX</span>(R) полностью защищён от других процессов.
	    Никакой процесс не может модифицировать адресное пространство
	    другого процесса.</p><p>В <span class="trademark">UNIX</span>(R) каждым процессом владеет некоторый идентификатор
	    пользователя.  Если этот пользователь не
	    <code class="systemitem">root</code>, он ограждает процесс от других,
	    владельцами которых являются другие пользователи.  Этот
	    идентификатор используется также для защиты данных на диске.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp77266256"></a><a id="securelevel"></a><p><strong>13.2.</strong></p></td><td align="left" valign="top"><p>Что такое уровень защиты (securelevel)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="literal">securelevel</code> является механизмом
	    обеспечения безопасности, который реализован в ядре.  Когда
	    уровень защиты больше нуля,
	    ядро ограничивает выполнение некоторых операций; даже
	    суперпользователю <code class="systemitem">root</code>
	    запрещается их выполнять.  Механизм уровня защиты ограничивает
	    возможности по:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>снятию некоторых флагов с файлов, таких, как
		<code class="literal">schg</code> (системный флаг неизменяемости),</p></li><li class="listitem"><p>записи в память ядра через устройства
		<code class="filename">/dev/mem</code> и
		<code class="filename">/dev/kmem</code>,</p></li><li class="listitem"><p>загрузке модулей ядра и</p></li><li class="listitem"><p>изменению правил сетевого экрана.</p></li></ul></div><p>Для выяснения состояния уровня защиты в работающей
	    системе:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -n kern.securelevel</code></strong></pre><p>Результат содержит текущее значение уровня защиты.
	    Если оно больше нуля, то по крайней мере некоторые
	    из защит этого механизма включены.</p><p>Уровень защиты работающей системы не может быть понижен,
	    поскольку это противоречит назначению этого механизма.
	    Если для задачи требуется неположительный
	    уровень защиты, измените значения переменных
	    <code class="varname">kern_securelevel</code> и
	    <code class="varname">kern_securelevel_enable</code> в файле
	    <code class="filename">/etc/rc.conf</code> и перезагрузите
	    систему.</p><p>Более подробная информация об уровнях защиты и о том, какие
	    специфические действия выполняют все уровни, может быть найдена на
	    справочных страницах о <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>.</p><div xmlns="" class="warning"><h3 class="admontitle">Предупреждение: </h3><p xmlns="http://www.w3.org/1999/xhtml">Уровень защиты не является панацеей; в нём есть много
	      недостатков.  Зачастую он даёт обманчивое чувство
	      безопасности.</p><p xmlns="http://www.w3.org/1999/xhtml">Одной из самых больших проблем является то, что для его
	      эффективной работы все файлы, используемые в процессе загрузки,
	      должны быть защищены.  Если атакующий сможет заставить систему
	      выполнять свой код до установки уровня защиты (что происходит
	      достаточно поздно во время процесса загрузки, так как некоторые
	      вещи, выполняемые системой в это время, не могут быть сделаны при
	      повышенном уровне защиты), то эта защита может быть отключена.
	      Хотя такая задача по защите всех файлов, используемых в процессе
	      загрузки, технически вполне осуществима, если это будет сделано,
	      то поддержка системы станет кошмаром, так как для изменения
	      конфигурационного файла придётся останавливать систему,
	      переводя её по крайней мере в однопользовательский режим.</p><p xmlns="http://www.w3.org/1999/xhtml">Это обстоятельство, а также ряд других, часто обсуждаются в
	      списках рассылки, в частности, во <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-security" target="_top">Список рассылки FreeBSD, посвящённый информационной безопасности</a>.
	      Поищите в <a class="link" href="../../../../search/index.html" target="_top">
	      архивах</a> более подробное обсуждение.  Предпочтителен
	      более гибкий механизм.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp77281232"></a><a id="extra-named-port"></a><p><strong>13.3.</strong></p></td><td align="left" valign="top"><p>BIND (<code class="command">named</code>) работает на
	    одном из портов с большим номером.  Что происходит?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Для исходящих запросов BIND использует случайно
	    выбираемый порт с большим номером.  В последних версиях
	    при каждом запросе выбирается новый случайный порт UDP.
	    Это может вызвать проблемы в некоторых сетевых конфигурациях,
	    особенно если фаервол блокирует входящие UDP пакеты на
	    определенных портах.  Чтобы обеспечить прохождение
	    пакетов через фаервол, попробуйте параметры
	    <code class="literal">avoid-v4-udp-ports</code> и
	    <code class="literal">avoid-v6-udp-ports</code>, чтобы предотвратить
	    случайный выбор номеров портов, пересекающихся с блокируемым
	    диапазоном.</p><div xmlns="" class="warning"><h3 class="admontitle">Предупреждение: </h3><p xmlns="http://www.w3.org/1999/xhtml">Если в <code class="filename">/etc/namedb/named.conf</code>
	      указан номер порта (такой как 53) в параметре
	      <code class="literal">query-source</code> или
	      <code class="literal">query-source-v6</code>, то случайный
	      выбор порта использоваться не будет.  Настоятельно
	      рекомендуется, чтобы эти параметры не использовались для
	      указания фиксированных номеров порта.</p></div><p>Кстати, поздравляем.  Прекрасно, что вы читаете вывод
	    команды <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sockstat</span>(1)</span></a> и обращаете внимание на
	    аномалии!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp77324624"></a><a id="sendmail-port-587"></a><p><strong>13.4.</strong></p></td><td align="left" valign="top"><p>Даемон <span class="application">Sendmail</span> ждёт
	    соединений как на стандартном порту 25, так и на
	    порту 587!  Что происходит?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Последние версии <span class="application">Sendmail</span>
	    поддерживают механизм посылки почты, который работает по
	    порту 587.  Эта возможность пока широко не используется,
	    но её популярность растёт.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp77327440"></a><a id="toor-account"></a><p><strong>13.5.</strong></p></td><td align="left" valign="top"><p>Что это за пользователь <code class="systemitem">toor</code> с UID 0?  Я
	    подвергся взлому?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Не волнуйтесь, <code class="systemitem">toor</code> является
	    <span class="quote"><<<span class="quote">альтернативной</span>>></span> учётной записью
	    суперпользователя (toor - это root, записанный задом
	    наперёд).  Его предлагается использовать с нестандартным
	    командным интерпретатором, так чтобы не нужно было менять
	    используемый по умолчанию командный процессор для
	    <code class="systemitem">root</code>.  Это
	    важно, так как оболочки, не являющиеся частью дистрибутива
	    системы, устанавливаются в каталог
	    <code class="filename">/usr/local/bin</code>, который по
	    умолчанию располагается в другой файловой системе.  Если
	    командный процессор для пользователя <code class="systemitem">root</code> располагается в
	    <code class="filename">/usr/local/bin</code> и файловая система,
	    содержащая <code class="filename">/usr/local/bin</code>, не
	    смонтирована, то <code class="systemitem">root</code> не сможет войти в
	    систему для исправления проблемы и понадобится
	    перезагрузиться в однопользовательском режиме, чтобы
	    указать командный процессор.</p><p>Некоторые используют <code class="systemitem">toor</code> для выполнения
	    повседневных административных работ с нестандартным
	    командным процессором, оставляя <code class="systemitem">root</code> со стандартной
	    оболочкой для работы в однопользовательском режиме или
	    выполнения аварийных работ.  По умолчанию пользователь не
	    сможет войти в систему как <code class="systemitem">toor</code>, потому что для него
	    не указан пароль, поэтому войдите из-под <code class="systemitem">root</code> и установите пароль
	    для <code class="systemitem">toor</code> до того
	    как использовать его для входа в систему.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="networking.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ppp.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 12. Работа в сети </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Глава 14. PPP</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>