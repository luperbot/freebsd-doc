<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>11.8. Дополнительные сведения</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Руководство FreeBSD" /><link rel="up" href="linuxemu.html" title="Глава 11. Двоичная совместимость с Linux" /><link rel="prev" href="sapr3.html" title="11.7. Установка SAP(R) R/3(R)" /><link rel="next" href="system-administration.html" title="Часть III. Системное администрирование" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.8. Дополнительные сведения</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sapr3.html">Пред.</a> </td><th width="60%" align="center">Глава 11. Двоичная совместимость с Linux</th><td width="20%" align="right"> <a accesskey="n" href="system-administration.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="linuxemu-advanced"></a>11.8. Дополнительные сведения</h2></div></div></div><p>Если вы интересуетесь, как обеспечивается двоичная совместимость
      с Linux, этот раздел для вас.  Большинство материала взято из
      электронного письма, адресованного Terry Lambert
      <code class="email">&lt;<a xmlns="" class="email" href="mailto:tlambert@primenet.com">tlambert@primenet.com</a>&gt;</code> в <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat" target="_top">Список рассылки, посвящённый неформальным беседам о FreeBSD</a> (ID письма:
      <code class="literal">&lt;199906020108.SAA07001@usr09.primenet.com&gt;</code>).</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86392912"></a>11.8.1. Как все это устроено?</h3></div></div></div><a id="idp86393680" class="indexterm"></a><p>FreeBSD поддерживает абстракцию, называемую <span class="quote"><<<span class="quote">загрузчик
	выполняемых классов</span>>></span>.  Фактически, он является первой
	стадией системного вызова <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=execve&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a>.</p><p>На самом деле, FreeBSD имеет список загрузчиков вместо
	одного, завершающийся загрузчиком <code class="literal">#!</code> для
	запуска любых командных интерпретаторов и скриптов.</p><p>Исторически сложилось, что единственный загрузчик в <span class="trademark">UNIX</span>(R)
	системах проверял <span class="quote"><<<span class="quote">магическое число</span>>></span> (чаще всего первые
	4 или 8 байт файла), чтобы определить, известен ли формат
	двоичного файла системе, и если да, то вызвал соответствующий
	загрузчик.</p><p>Если файл не опознавался системой как двоичный, системный
	вызов <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=execve&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a> возвращал ошибку, и текущий командный
	интерпретатор начинал выполнять файл как скрипт.</p><p>По умолчанию скрипт выполнялся <span class="quote"><<<span class="quote">текущим командным
	интерпретатором</span>>></span>.</p><p>Позднее, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> был модифицирован, так, чтобы проверять
	первые два символа в файле, и если они оказывались
	<code class="literal">:\n</code>, то файл выполнялся как сценарий для
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=csh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">csh</span>(1)</span></a> (утверждается, что SCO были первыми, кто сделал
	эту модификацию).</p><p>FreeBSD сейчас ведет себя по-другому: пробегает по списку
	загрузчиков,включающему специальный загрузчик <code class="literal">#!</code>,
	который вызывает нужный интерпретатор, указанный после этих символов
	до следующего пробела, или <code class="filename">/bin/sh</code>, если
	не нашел подходящего.</p><a id="idp86407504" class="indexterm"></a><p>Для поддержки Linux ABI FreeBSD ищет магическое число,
	соответствующее двоичному файлу ELF (на этой стадии не различаются
	FreeBSD, <span class="trademark">Solaris</span>TM, Linux или любая другая ОС поддерживающая формат
	ELF).</p><a id="idp86408784" class="indexterm"></a><p>Далее, ELF-загрузчик определяет <span class="quote"><<<span class="quote">марку</span>>></span> (brand)
	двоичного файла ELF (специальный комментарий в ELF-файле,
	отсутствующий в двоичных файлах ELF SVR4/<span class="trademark">Solaris</span>TM).</p><p>Соответственно, Linux программы должны быть
	<span class="quote"><<<span class="quote">маркированы</span>>></span> для <code class="literal">Linux</code> (например, с
	помощью утилиты <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=brandelf&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">brandelf</span>(1)</span></a>):</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>brandelf -t Linux file</code></strong></pre><p>Когда это сделано, загрузчик ELF выявит марку
	<code class="literal">Linux</code> в файле.</p><a id="idp86422352" class="indexterm"></a><p>Когда ELF-загрузчик находит <span class="quote"><<<span class="quote">марку</span>>></span>
	<code class="literal">Linux</code>, он заменяет соответствующий указатель в
	структуре <code class="literal">proc</code>.  Все системные вызовы
	индексируются через этот указатель (в традиционной <span class="trademark">UNIX</span>(R) системе это
	массив структур <code class="literal">sysent[]</code>, содержащий системные
	вызовы).  Кроме того, процесс помечается для специальной обработки
	вектора обработчиков сигналов, а также ряда других (небольших)
	исправлений, которые осуществляются специальным модулем ядра для
	поддержки Linux.</p><p>Вектор системных вызовов Linux содержит, среди прочего, список
	записей <code class="literal">sysent[]</code>, адреса которых находятся в
	модуле ядра.</p><p>При выполнении системного вызова из двоичного файла Linux,
	код обработчика разыменовывает указатель на функцию системного вызова
	из структуры <code class="literal">proc</code>, и получает точки входа
	системных вызовов Linux, а не FreeBSD.</p><p>Плюс ко всему, в Linux-режиме динамически <span class="quote"><<<span class="quote">изменяется
	корень</span>>></span> файловой системы при поиске файлов; фактически
	так же, как и параметр <code class="literal">union</code> при монтировании
	файловых систем (не путать с <code class="literal">unionfs</code>!).
	Сперва, файл ищется в каталоге
	<code class="filename">/compat/linux/<em class="replaceable"><code>исходное_полное_имя</code></em></code>
	и только затем, в случае неудачи, в
	<code class="filename">/<em class="replaceable"><code>исходное_полное_имя</code></em></code>.
	Это гарантирует, что программы, которым требуются другие программы,
	смогут работать (например, весь набор инструментальных средств Linux
	сможет работать в среде поддержки Linux ABI).  Это также дает
	возможность Linux программам выполнять FreeBSD команды, если не
	найдется соответствующих Linux команд.  Например, можно скопировать
	FreeBSD <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=uname&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">uname</span>(1)</span></a> в дерево каталогов
	<code class="filename">/compat/linux</code>, и Linux-программы не смогут
	разобраться, что они работают не в Linux.</p><p>Фактически, имеется ядро Linux в ядре FreeBSD; различные
	базовые функции, реализующие все услуги ядра, идентичны как
	в записях таблицы системных вызовов FreeBSD, так и в записях
	таблицы системных вызовов Linux: операции с файловой системой,
	виртуальная память, средства доставки сигналов,
	System V IPC ...  Единственное отличие в том, что
	FreeBSD-программы получают <span class="emphasis"><em>интерфейсные</em></span> функции
	FreeBSD, а Linux-программы получают <span class="emphasis"><em>интерфейсные</em></span>
	функции Linux (в большинстве более старых ОС есть только их
	собственные интерфейсные функции: функции берутся из статического
	глобального массива структур <code class="literal">sysent[]</code>, а не
	из массива, полученного разыменованием динамически
	проинициализированного указателя в структуре
	<code class="literal">proc</code> процесса, выполняющего вызов).</p><p>Какая же реализация ABI для FreeBSD <span class="quote"><<<span class="quote">родная</span>>></span>?  Это
	не имеет значения.  Единственное различие (на данный момент, в
	будущем все может и, вероятно, изменится), пожалуй, в том, что
	функции системных вызовов FreeBSD зашиты в ядро, а для Linux они
	могут быть либо статически скомпонованы в ядро, либо получаться
	через модуль ядра.</p><p>Да, но можно ли назвать это эмуляцией?  Нет.  Это реализация ABI,
	а не эмуляция. Как таковой, эмулятор (или симулятор)
	отсутствует.</p><p>В таком случае, почему же иногда говорят об
	<span class="quote"><<<span class="quote">эмуляции Linux</span>>></span>?  Чтобы <span class="quote"><<<span class="quote">насолить</span>>></span>
	FreeBSD!  Фактически, причина в том, что на момент первой реализации
	не существовало слова, которое бы точнее описывало этот процесс.
	Нельзя было сказать, что FreeBSD запускает приложения Linux (без
	перекомпиляции или загрузки соответствующего модуля ядра это
	невозможно).  Но надо было как-то описать, что
	загружается - отсюда и <span class="quote"><<<span class="quote">эмулятор Linux</span>>></span>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sapr3.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="linuxemu.html">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="system-administration.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">11.7. Установка <span class="trademark">SAP</span>(R) <span class="trademark">R/3</span>(R) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Часть III. Системное администрирование</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>