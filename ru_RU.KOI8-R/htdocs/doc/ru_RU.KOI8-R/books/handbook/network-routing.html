<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>27.2. Сетевые шлюзы и маршруты</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Руководство FreeBSD" /><link rel="up" href="advanced-networking.html" title="Глава 27. Сложные вопросы работы в сети" /><link rel="prev" href="advanced-networking.html" title="Глава 27. Сложные вопросы работы в сети" /><link rel="next" href="network-wireless.html" title="27.3. Беспроводные сети" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">27.2. Сетевые шлюзы и маршруты</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="advanced-networking.html">Пред.</a> </td><th width="60%" align="center">Глава 27. Сложные вопросы работы в сети</th><td width="20%" align="right"> <a accesskey="n" href="network-wireless.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-routing"></a>27.2. Сетевые шлюзы и маршруты</h2></div><div><span class="authorgroup">Текст предоставил <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Coranth</span> <span class="surname">Gryphon</span></span>. </span></div></div></div><a id="idp75949904" class="indexterm"></a><a id="idp75950416" class="indexterm"></a><a id="idp75950928" class="indexterm"></a><p>Чтобы некоторая машина могла найти в сети другую, должен иметься
      механизм описания того, как добраться от одной машине к другой.  Такой
      механизм называется <em class="firstterm">маршрутизацией</em>.
      <span class="quote"><<<span class="quote">Маршрут</span>>></span> задаётся
      парой адресов: <span class="quote"><<<span class="quote">адресом назначения</span>>></span> (destination) и
      <span class="quote"><<<span class="quote">сетевым шлюзом</span>>></span> (gateway).  Эта пара указывает на то, что
      если Вы пытаетесь соединиться с <span class="emphasis"><em>адресом назначения</em></span>,
      то вам нужно устанавливать связь через <span class="quote"><<<span class="quote">сетевой шлюз</span>>></span>.
      Существует три типа адресов назначения: отдельные хосты, подсети и
      <span class="quote"><<<span class="quote">маршрут по умолчанию</span>>></span> (default).  <span class="quote"><<<span class="quote">Маршрут по
      умолчанию</span>>></span> (default route) используется, если не подходит ни один
      из других маршрутов.  Мы поговорим немного подробнее о маршрутах по
      умолчанию позже.  Также имеется и три типа сетевых шлюзов: отдельные
      хосты, интерфейсы (также называемые <span class="quote"><<<span class="quote">подключениями</span>>></span>
      (links)) и аппаратные адреса Ethernet (MAC-адреса).</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99691728"></a>27.2.1. Пример</h3></div></div></div><p>Для иллюстрации различных аспектов маршрутизации мы будем
	использовать следующий пример использования команды
	<code class="command">netstat</code>:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -r</code></strong>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default 	 outside-gw	    UGSc       37      418	ppp0
localhost	 localhost	    UH		0      181	 lo0
test0		 0:e0:b5:36:cf:4f   UHLW	5    63288	 ed0	 77
10.20.30.255	 link#1 	    UHLW	1     2421
example.com	 link#1 	    UC		0	 0
host1		 0:e0:a8:37:8:1e    UHLW	3     4601	 lo0
host2		 0:e0:a8:37:8:1e    UHLW	0	 5	 lo0 =&gt;
host2.example.com link#1 	    UC		0	 0
224		 link#1 	    UC		0	 0</pre><a id="idp99694160" class="indexterm"></a><p>В первых двух строках задаются маршрут по умолчанию (который
	будет описан в <a class="link" href="network-routing.html#network-routing-default" title="27.2.2. Маршруты по умолчанию">следующем
	разделе</a>) и маршрут на <code class="systemitem">localhost</code>.</p><a id="idp99695952" class="indexterm"></a><p>Интерфейс (колонка <code class="literal">Netif</code>), который указан в
	этой таблице маршрутов для использования с
	<code class="literal">localhost</code> и который назван
	<code class="filename">lo0</code>, имеет также второе название, устройство
	loopback.  Это значит сохранение всего трафика для указанного адреса
	назначения внутри, без посылки его по сети, так как он все равно
	будет направлен туда, где был создан.</p><a id="idp99698128" class="indexterm"></a><p>Следующими выделяющимися адресами являются адреса, начинающиеся с
	<code class="systemitem">0:e0:...</code>.   Это аппаратные адреса Ethernet,
	или MAC-адреса.  FreeBSD будет автоматически распознавать любой хост
	(в нашем примере это <code class="systemitem">test0</code>) в локальной сети Ethernet
	и добавит маршрут для этого хоста, указывающий непосредственно на
	интерфейс Ethernet, <code class="filename">ed0</code>.  С этим типом
	маршрута также связан параметр таймаута (колонка
	<code class="literal">Expire</code>), используемый в случае неудачной попытки
	услышать этот хост в течении некоторого периода времени.  Если такое
	происходит, то маршрут до этого хоста будет автоматически удалён.
	Такие хосты поддерживаются
	при помощи механизма, известного как RIP (Routing Information
	Protocol), который вычисляет маршруты к хостам локальной сети при
	помощи определения кратчайшего расстояния.</p><a id="idp99701456" class="indexterm"></a><p>FreeBSD добавит также все маршруты к подсетям для локальных
	подсетей (<code class="systemitem">10.20.30.255</code> является
	широковещательным адресом для подсети <code class="systemitem">10.20.30</code>, а имя <code class="systemitem">example.com</code> является именем домена, связанным
	с этой подсетью).  Назначение <code class="literal">link#1</code> соответствует
	первому адаптеру Ethernet в машине.  Отметьте отсутствие
	дополнительного интерфейса для этих строк.</p><p>В обеих этих группах (хосты и подсети локальной сети) маршруты
	конфигурируются автоматически даемоном, который называется
	<span class="application">routed</span>.  Если он не запущен, то будут
	существовать только статически заданные (то есть введенные явно)
	маршруты.</p><p>Строка <code class="literal">host1</code> относится к нашему хосту, который
	известен по адресу Ethernet.  Так как мы являемся посылающим хостом,
	FreeBSD знает, что нужно использовать loopback-интерфейс
	(<code class="filename">lo0</code>) вместо того, чтобы осуществлять
	посылку в интерфейс Ethernet.</p><p>Две строки <code class="literal">host2</code> являются примером того, что
	происходит при использовании алиасов в команде <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>
	(обратитесь к разделу об Ethernet для объяснения того, почему мы это
	делаем).  Символ <code class="literal">=&gt;</code> после интерфейса
	<code class="filename">lo0</code> указывает на то, что мы используем не
	просто интерфейс loopback (так как это адрес, обозначающий локальный
	хост), но к тому же это алиас.  Такие маршруты появляются только
	на хосте, поддерживающем алиасы; для всех остальных хостов в локальной
	сети для таких маршрутов будут показаны просто строчки
	<code class="literal">link#1</code>.</p><p>Последняя строчка (подсеть назначения <code class="systemitem">224</code>) имеет отношение к многоадресной посылке,
	которая будет рассмотрена в другом разделе.</p><p>И наконец, различные атрибуты каждого маршрута перечисляются в
	колонке <code class="literal">Flags</code>.  Ниже приводится краткая таблица
	некоторых из этих флагов и их значений:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>U</td><td>Up: Маршрут актуален.</td></tr><tr><td>H</td><td>Host: Адресом назначения является отдельный хост.</td></tr><tr><td>G</td><td>Gateway: Посылать все для этого адреса назначения на
		указанную удаленную систему, которая будет сама определять
		дальнейший путь прохождения информации.</td></tr><tr><td>S</td><td>Static: Маршрут был настроен вручную, а не автоматически
		сгенерирован системой.</td></tr><tr><td>C</td><td>Clone: Новый маршрут сгенерирован на основе указанного для
		машин, к которым мы подключены.  Такой тип маршрута обычно
		используется для локальных сетей.</td></tr><tr><td>W</td><td>WasCloned: Указывает на то, что маршрут был автоматически
		сконфигурирован на основе маршрута в локальной
		сети (Clone).</td></tr><tr><td>L</td><td>Link: Маршрут включает ссылку на аппаратный адрес
		Ethernet.</td></tr></tbody></table></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-routing-default"></a>27.2.2. Маршруты по умолчанию</h3></div></div></div><a id="idp99730384" class="indexterm"></a><p>Когда локальной системе нужно установить соединение с удаленным
	хостом, она обращается к таблице маршрутов для того, чтобы определить,
	существует ли такой маршрут.  Если удаленный хост попадает в подсеть,
	для которой известен способ ее достижения (маршруты типа Cloned), то
	система определяет возможность подключиться к ней по этому
	интерфейсу.</p><p>Если все известные маршруты не подходят, у системы имеется
	последняя возможность: маршрут <span class="quote"><<<span class="quote">default</span>>></span>.  Это маршрут
	с особым типом сетевого шлюза (обычно единственным, присутствующим
	в системе), и в поле флагов он всегда помечен как <code class="literal">c</code>.
	Для хостов в локальной сети этот сетевой шлюз указывает на машину,
	имеющую прямое подключение к внешнему миру (неважно, используется ли
	связь по протоколу PPP, канал DSL, кабельный модем, T1 или какой-то
	другой сетевой интерфейс).</p><p>Если вы настраиваете маршрут по умолчанию на машине, которая сама
	является сетевым шлюзом во внешний мир, то маршрутом по умолчанию
	будет являться сетевой шлюз у Вашего провайдера Интернет (ISP).</p><p>Давайте взглянем на примеры маршрутов по умолчанию.  Вот типичная
	конфигурация:</p><div class="mediaobject"><img src="advanced-networking/net-routing.png" /></div><p>Хосты <code class="systemitem">Local1</code> и <code class="systemitem">Local2</code> находятся в
	нашей сети.  <code class="systemitem">Local1</code> подключён к ISP через
	коммутируемое соединение по протоколу PPP.  Этот компьютер с сервером
	PPP подключён посредством локальной сети к другому шлюзовому компьютеру
	через внешний интерфейс самого ISP к Интернет.</p><p>Маршруты по умолчанию для каждой из ваших машин будут
	следующими:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Хост</th><th>Маршрут по умолчанию</th><th>Интерфейс</th></tr></thead><tbody><tr><td>Local2</td><td>Local1</td><td>Ethernet</td></tr><tr><td>Local1</td><td>T1-GW</td><td>PPP</td></tr></tbody></table></div><p>Часто задаётся вопрос <span class="quote"><<<span class="quote">Почему (или каким образом) в качестве
	шлюза по умолчанию для машины <code class="systemitem">Local1</code> мы указываем
	<code class="systemitem">T1-GW</code>, а не сервер провайдера, к которому
	подключаемся?</span>>></span>.</p><p>Запомните, что из-за использования PPP-интерфейсом адреса в сети
	провайдера Интернет с вашей стороны соединения, маршруты для всех
	других машин в локальной сети провайдера будут сгенерированы
	автоматически.  Таким образом, вы уже будете знать, как достичь машины
	<code class="systemitem">T1-GW</code>, так что нет нужды в промежуточной точке при
	посылке трафика к серверу ISP.</p><p>В локальных сетях адрес <code class="systemitem">X.X.X.1</code> часто используется в качестве адреса
	сетевого шлюза.  Тогда (при использовании того же самого примера)
	если пространство адресов класса C вашей локальной сети было задано
	как <code class="systemitem">10.20.30</code>, а ваш провайдер использует
	<code class="systemitem">10.9.9</code>, то маршруты по умолчанию будут
	такие:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Хост</th><th>Маршрут по умолчанию</th></tr></thead><tbody><tr><td>Local2 (10.20.30.2)</td><td>Local1 (10.20.30.1)</td></tr><tr><td>Local1 (10.20.30.1, 10.9.9.30)</td><td>T1-GW (10.9.9.1)</td></tr></tbody></table></div><p>Вы можете легко задать используемый по умолчанию маршрутизатор
	посредством файла <code class="filename">/etc/rc.conf</code>.  В нашем примере
	на машине <code class="systemitem">Local2</code> мы добавили такую строку в файл
	<code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">defaultrouter="10.20.30.1"</pre><p>Это также возможно сделать и непосредственно из командной строки
	при помощи команды <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add default 10.20.30.1</code></strong></pre><p>Для получения дополнительной информации об управлении таблицами
	маршрутизации обратитесь к справочной странице по команде
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99767504"></a>27.2.3. Хосты с двойным подключением</h3></div></div></div><a id="idp99768144" class="indexterm"></a><p>Есть еще один тип подключения, который мы должны рассмотреть, и это
	случай, когда хост находится в двух различных сетях.  Технически,
	любая машина, работающая как сетевой шлюз (в примере выше
	использовалось PPP-соединение), считается хостом с двойным
	подключением.  Однако этот термин реально используется для описания
	машины, находящейся в двух локальных сетях.</p><p>В одном случае у машины имеется два адаптера Ethernet, каждый
	имеющий адрес в разделенных подсетях.  Как альтернативу можно
	рассмотреть вариант с одним Ethernet-адаптером и использованием
	алиасов в команде <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>.  В первом случае используются два
	физически разделённые сети Ethernet, в последнем имеется один
	физический сегмент сети, но две логически разделённые подсети.</p><p>В любом случае таблицы маршрутизации настраиваются так, что для
	каждой подсети эта машина определена как шлюз (входной маршрут) в
	другую подсеть.  Такая конфигурация, при которой машина выступает в
	роли маршрутизатора между двумя подсетями, часто используется, если
	нужно реализовать систему безопасности на основе фильтрации пакетов или
	функций брандмауэра в одном или обоих направлениях.</p><p>Если вы хотите, чтобы эта машина действительно перемещала пакеты
	между двумя интерфейсами, то вам нужно указать FreeBSD на включение
	этой функции.  Обратитесь к следующей главе, чтобы узнать, как это
	сделать.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-dedicated-router"></a>27.2.4. Построение маршрутизатора</h3></div></div></div><a id="idp99776080" class="indexterm"></a><p>Сетевой маршрутизатор является обычной системой, которая
	пересылает пакеты с одного интерфейса на другой.  Стандарты Интернет и
	хорошая инженерная практика не позволяют Проекту FreeBSD включать эту
	функцию по умолчанию во FreeBSD.  Вы можете включить эту возможность,
	изменив значение следующей переменной в <code class="literal">YES</code> в файле
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>:</p><pre class="programlisting">gateway_enable=YES          # Set to YES if this host will be a gateway</pre><p>Этот параметр изменит значение <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>-переменной
	<code class="varname">net.inet.ip.forwarding</code> в
	<code class="literal">1</code>.  Если вам временно нужно выключить маршрутизацию,
	вы можете на время сбросить это значение в <code class="literal">0</code>.</p><p>Вашему новому маршрутизатору нужна информация о маршрутах для того,
	чтобы знать, куда пересылать трафик.  Если ваша сеть достаточно проста,
	то вы можете использовать статические маршруты.  С FreeBSD также
	поставляется стандартный даемон BSD для маршрутизации <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=routed&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">routed</span>(8)</span></a>,
	который умеет работать с RIP (как версии 1, так и версии 2) и IRDP.
	Поддержка BGP v4, OSPF v2 и других сложных протоколов маршрутизации
	имеется в пакете <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/zebra/pkg-descr">net/zebra</a>.  Также
	существуют и коммерческие продукты, применяемые как более комплексное
	решение проблемы маршрутизации в сети, такие как
	<span class="application"><span class="trademark">GateD</span>(R)</span>.</p><a id="idp99782992" class="indexterm"></a><a id="idp99791824" class="indexterm"></a><a id="idp99792336" class="indexterm"></a></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99792976"></a>27.2.5. Настройка статических маршрутов</h3></div><div><span class="authorgroup">Предоставил <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Al</span> <span class="surname">Hoang</span></span>. </span></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99795664"></a>27.2.5.1. Ручная настройка</h4></div></div></div><p>Предположим, что у нас есть следующая сеть:</p><div class="mediaobject"><img src="advanced-networking/static-routes.png" /></div><p>В этом сценарии, <code class="systemitem">RouterA</code> это наш
	  компьютер с FreeBSD, который выступает в качестве
	  маршрутизатора в сеть Интернет.  Его маршрут по умолчанию
	  настроен на <code class="systemitem">10.0.0.1</code>, что позволяет ему
	  соединяться с внешним миром.  Мы будем предполагать, что
	  <code class="systemitem">RouterB</code> уже правильно настроен и
	  знает все необходимые маршруты (на этом рисунке все
	  просто; добавьте на <code class="systemitem">RouterB</code> маршрут
	  по умолчанию, используя <code class="systemitem">192.168.1.1</code> в качестве шлюза).</p><p>Если мы посмотрим на таблицу маршрутизации
	  <code class="systemitem">RouterA</code>, то увидим примерно следующее:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -nr</code></strong>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</pre><p>С текущей таблицей маршрутизации <code class="systemitem">RouterA</code>
	  не сможет достичь внутренней сети 2 (Internal Net 2).
	  Один из способов обхода этой проблемы - добавление
	  маршрута вручную.  Следующая команда добавляет
	  внутреннюю сеть 2 к таблице маршрутизации
	  <code class="systemitem">RouterA</code> с <code class="systemitem">192.168.1.2</code> в качестве следующего
	  узла:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add -net 192.168.2.0/24 192.168.1.2</code></strong></pre><p>Теперь <code class="systemitem">RouterA</code> сможет достичь любого хоста
	  в сети
	  <code class="systemitem">192.168.2.0/24</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99807440"></a>27.2.5.2. Постоянная конфигурация</h4></div></div></div><p>Предыдущий пример прекрасно подходит для настройки статического
	  маршрута в работающей системе.  Однако, проблема заключается в
	  том, что маршрутная информация не сохранится после перезагрузки
	  FreeBSD.  Способ сохранения добавленного маршрута заключается в
	  добавлении его в файл <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting"># Добавление статического маршрута в Internal Net 2
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</pre><p>В переменной <code class="literal">static_routes</code> находятся
	  строки, разделенные пробелами.  Каждая строка означает имя
	  маршрута.  В примере выше в <code class="literal">static_routes</code>
	  есть только одна строка, это
	  <em class="replaceable"><code>internalnet2</code></em>.  Затем мы добавили
	  переменную
	  <code class="literal">route_<em class="replaceable"><code>internalnet2</code></em></code>,
	  куда помещены все параметры, которые необходимо передать
	  команде <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>.  В примере выше была использована
	  команда:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add -net 192.168.2.0/24 192.168.1.2</code></strong></pre><p>поэтому нам потребуется
	    <code class="literal">"-net 192.168.2.0/24 192.168.1.2"</code>.</p><p>Как было сказано выше, мы можем добавить в
	  <code class="literal">static_routes</code> более чем одну строку.
	  Это позволит создать несколько статических маршрутов.
	  В следующем примере показано добавление маршрутов для сетей <code class="systemitem">192.168.0.0/24</code> и <code class="systemitem">192.168.1.0/24</code> (этот маршрутизатор не
	  показан на рисунке выше:</p><pre class="programlisting">static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99821008"></a>27.2.6. Распространение маршрутов</h3></div></div></div><a id="idp99821648" class="indexterm"></a><p>Мы уже говорили о том, как мы задаем наши маршруты во внешний мир,
	но не упоминали о том, как внешний мир находит нас.</p><p>Мы уже знаем, что таблицы маршрутизации могут быть настроены так,
	что весь трафик для некоторого диапазона адресов (в нашем примере это
	подсеть класса C) может быть направлен заданному хосту в той сети,
	которая будет перенаправлять входящие пакеты дальше.</p><p>При получении адресного пространства, выделенного Вашей сети,
	Ваш провайдер настроит свои таблицы маршрутизации так, что весь трафик
	для Вашей подсети будет пересылаться по PPP-соединению к Вашей сети.
	Но как серверы по всей стране узнают, что Ваш трафик нужно посылать
	Вашему ISP?</p><p>Существует система (подобная распределению информации DNS), которая
	отслеживает все назначенные пространства адресов и определяет точку
	подключения к магистрали Интернет.  <span class="quote"><<<span class="quote">Магистралью</span>>></span> называют
	главные каналы, по которым идет трафик Интернет внутри страны и по
	всему миру.  Каждая магистральная машина имеет копию основного набора
	таблиц, согласно которой трафик для конкретной сети направляется по
	конкретному магистральному каналу, и затем, передаваясь по цепочке
	провайдеров, он достигает вашей сети.</p><p>Задачей вашего провайдера является объявить на магистрали о том,
	что он отвечает за подключение (и поэтому на него указывает маршрут)
	вашей сети.  Этот процесс называется распространением маршрута.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99824592"></a>27.2.7. Устранение неполадок</h3></div></div></div><a id="idp99825232" class="indexterm"></a><p>Иногда с распространением маршрута возникают проблемы, и некоторые
	сайты не могут к вам подключиться.  Наверное, самой полезной командой
	для определения точки неверной работы маршрутизации является
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a>.  Она также полезна и когда вы сами не можете
	подключиться к удаленной машине (то есть команда <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ping</span>(8)</span></a> не
	срабатывает).</p><p>Команда <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a> запускается с именем удаленного хоста, с
	которым вы хотите установить соединение, в качестве параметра.  Она
	показывает промежуточные сетевые шлюзы по пути следования, в конце
	концов достигая адрес назначения или прерывая свою работу из-за
	отсутствия соединения.</p><p>За дополнительной информацией обратитесь к странице Справочника по
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99834704"></a>27.2.8. Маршрутизация многоадресного трафика</h3></div></div></div><a id="idp99835344" class="indexterm"></a><a id="idp99836112" class="indexterm"></a><p>FreeBSD изначально поддерживает как приложения, работающие с
	многоадресным трафиком, так и его маршрутизацию.  Такие приложения не
	требуют особой настройки FreeBSD; обычно они работают сразу.
	Для маршрутизации многоадресного трафика требуется, чтобы поддержка
	этого была включена в ядро:</p><pre class="programlisting">options MROUTING</pre><p>Кроме того, даемон многоадресной маршрутизации, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mrouted&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mrouted</span>(8)</span></a>,
	должен быть настроен посредством файла
	<code class="filename">/etc/mrouted.conf</code> на использование туннелей и
	<acronym class="acronym">DVMRP</acronym>.  Дополнительную информацию о настройки
	многоадресного трафика
	можно найти на страницах справочной системы, посвящённых даемону
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mrouted&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mrouted</span>(8)</span></a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced-networking.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="network-wireless.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 27. Сложные вопросы работы в сети </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> 27.3. Беспроводные сети</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>