<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>31.7. Diskless Operation</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 使用手冊" /><link rel="up" href="advanced-networking.html" title="章 31. 網路進階練功房" /><link rel="prev" href="network-aggregation.html" title="31.6. Link Aggregation and Failover" /><link rel="next" href="network-isdn.html" title="31.8. ISDN" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.7. Diskless Operation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-aggregation.html">前一頁</a> </td><th width="60%" align="center">章 31. 網路進階練功房</th><td width="20%" align="right"> <a accesskey="n" href="network-isdn.html">下一頁</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-diskless"></a>31.7. Diskless Operation</h2></div><div><span class="authorgroup">Updated by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Jean-François</span> <span class="surname">Dockès</span></span>. </span></div><div><span class="authorgroup">Reorganized and enhanced by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Alex</span> <span class="surname">Dupre</span></span>. </span></div></div></div><a id="idp90825040" class="indexterm"></a><a id="idp90829776" class="indexterm"></a><p>A FreeBSD machine can boot over the network and operate without a
      local disk, using file systems mounted from an <acronym class="acronym">NFS</acronym> server.  No system
      modification is necessary, beyond standard configuration files.
      Such a system is relatively easy to  set up because all the necessary elements
      are readily available:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>There are at least two possible methods to load the kernel over
	  the network:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><acronym class="acronym">PXE</acronym>: The <span class="trademark">Intel</span>® Preboot eXecution
	      Environment system is a form of smart boot ROM built into some
	      networking cards or motherboards.  See <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pxeboot</span>(8)</span></a> for more
	      details.</p></li><li class="listitem"><p>The <span class="application">Etherboot</span>
	      port (<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/etherboot/pkg-descr">net/etherboot</a>) produces
	      ROM-able code to boot kernels over the network.  The
	      code can be either burnt into a boot PROM on a network
	      card, or loaded from a local floppy (or hard) disk
	      drive, or from a running <span class="trademark">MS-DOS</span>® system.  Many network
	      cards are supported.</p></li></ul></div></li><li class="listitem"><p>A sample script
	  (<code class="filename">/usr/share/examples/diskless/clone_root</code>) eases
	  the creation and maintenance of the workstation's root file system
	  on the server.  The script will probably require a little
	  customization but it will get you started very quickly.</p></li><li class="listitem"><p>Standard system startup files exist in <code class="filename">/etc</code>
	  to detect and support a diskless system startup.</p></li><li class="listitem"><p>Swapping, if needed, can be done either to an <acronym class="acronym">NFS</acronym> file or to
	  a local disk.</p></li></ul></div><p>There are many ways to set up diskless workstations.  Many
      elements are involved, and most can be customized to suit local
      taste.  The following will describe variations on the setup of a complete system,
      emphasizing simplicity and compatibility with the
      standard FreeBSD startup scripts.  The system described has the
      following characteristics:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The diskless workstations use a shared
	  read-only <code class="filename">/</code> file system, and a shared
	  read-only <code class="filename">/usr</code>.</p><p>The root file system is a copy of a
	  standard FreeBSD root (typically the server's), with some
	  configuration files overridden by ones specific to diskless
	  operation or, possibly, to the workstation they belong to.</p><p>The parts of the root which have to be
	  writable are overlaid with <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">md</span>(4)</span></a> file systems.  Any changes
	  will be lost when the system reboots.</p></li><li class="listitem"><p>The kernel is transferred and loaded either with
	  <span class="application">Etherboot</span> or <acronym class="acronym">PXE</acronym>
	  as some situations may mandate the use of either method.</p></li></ul></div><div xmlns="" class="caution"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">As described, this system is insecure.  It should
	live in a protected area of a network, and be untrusted by
	other hosts.</p></div><p>All the information in this section has been tested
      using FreeBSD 5.2.1-RELEASE.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90851408"></a>31.7.1. Background Information</h3></div></div></div><p>Setting up diskless workstations is both relatively
	straightforward and prone to errors.  These are sometimes
	difficult to diagnose for a number of reasons.  For example:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Compile time options may determine different behaviors at
	    runtime.</p></li><li class="listitem"><p>Error messages are often cryptic or totally absent.</p></li></ul></div><p>In this context, having some knowledge of the background
	mechanisms involved is very useful to solve the problems that
	may arise.</p><p>Several operations need to be performed for a successful
	bootstrap:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The machine needs to obtain initial parameters such as its IP
	    address, executable filename, server name, root path.  This is
	    done using the <acronym class="acronym">DHCP</acronym> or BOOTP protocols.
	    <acronym class="acronym">DHCP</acronym> is a compatible extension of BOOTP, and
	    uses the same port numbers and basic packet format.</p><p>It is possible to configure a system to use only BOOTP.
	    The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bootpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">bootpd</span>(8)</span></a> server program is included in the base FreeBSD
	    system.</p><p>However, <acronym class="acronym">DHCP</acronym> has a number of advantages
	    over BOOTP (nicer configuration files, possibility of using
	    <acronym class="acronym">PXE</acronym>, plus many others not directly related to
	    diskless operation), and we will describe mainly a
	    <acronym class="acronym">DHCP</acronym> configuration, with equivalent examples
	    using <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bootpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">bootpd</span>(8)</span></a> when possible.  The sample configuration will
	    use the <span class="application">ISC DHCP</span> software package
	    (release 3.0.1.r12 was installed on the test server).</p></li><li class="listitem"><p>The machine needs to transfer one or several programs to local
	    memory.  Either <acronym class="acronym">TFTP</acronym> or <acronym class="acronym">NFS</acronym>
	    are used.  The choice between <acronym class="acronym">TFTP</acronym> and
	    <acronym class="acronym">NFS</acronym> is a compile time option in several places.
	    A common source of error is to specify filenames for the wrong
	    protocol: <acronym class="acronym">TFTP</acronym> typically transfers all files from
	    a single directory on the server, and would expect filenames
	    relative to this directory.  <acronym class="acronym">NFS</acronym> needs absolute
	    file paths.</p></li><li class="listitem"><p>The possible intermediate bootstrap programs and the kernel
	    need to be initialized and executed.  There are several important
	    variations in this area:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><acronym class="acronym">PXE</acronym> will load <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pxeboot</span>(8)</span></a>, which is
		a modified version of the FreeBSD third stage loader.  The
		<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">loader</span>(8)</span></a> will obtain most parameters necessary to system
		startup, and leave them in the kernel environment before
		transferring control.  It is possible to use a
		<code class="filename">GENERIC</code> kernel in this case.</p></li><li class="listitem"><p><span class="application">Etherboot</span>, will directly
		load the kernel, with less preparation.  You will need to
		build a kernel with specific options.</p></li></ul></div><p><acronym class="acronym">PXE</acronym> and <span class="application">Etherboot</span>
	    work equally well; however, because kernels
	    normally let the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">loader</span>(8)</span></a> do more work for them,
	    <acronym class="acronym">PXE</acronym> is the preferred method.</p><p>If your <acronym class="acronym">BIOS</acronym> and network cards support
	    <acronym class="acronym">PXE</acronym>, you should probably use it.</p></li><li class="listitem"><p>Finally, the machine needs to access its file systems.
	    <acronym class="acronym">NFS</acronym> is used in all cases.</p></li></ul></div><p>See also <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=diskless&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">diskless</span>(8)</span></a> manual page.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90883536"></a>31.7.2. Setup Instructions</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90884176"></a>31.7.2.1. Configuration Using <span class="application">ISC DHCP</span></h4></div></div></div><a id="idp90885072" class="indexterm"></a><p>The <span class="application">ISC DHCP</span> server can answer
	    both BOOTP and <acronym class="acronym">DHCP</acronym> requests.</p><p><span class="application">ISC DHCP
  	    3.0</span> is not part of the base
	    system.  You will first need to install the
	    <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/isc-dhcp3-server/pkg-descr">net/isc-dhcp3-server</a> port or the
	    corresponding package.</p><p>Once <span class="application">ISC DHCP</span> is installed, it
	    needs a configuration file to run (normally named
	    <code class="filename">/usr/local/etc/dhcpd.conf</code>).  Here follows
	    a commented example, where host <code class="systemitem">margaux</code>
	    uses <span class="application">Etherboot</span> and host
	    <code class="systemitem">corbieres</code> uses <acronym class="acronym">PXE</acronym>:</p><pre class="programlisting">
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <a id="co-dhcp-host-name"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <a id="co-dhcp-next-server"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
    filename "/data/misc/kernel.diskless"; <a id="co-dhcp-filename"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span>
    option root-path "192.168.4.4:/data/misc/diskless"; <a id="co-dhcp-root-path"></a><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
          </pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co-dhcp-host-name"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>This option tells
		<span class="application">dhcpd</span> to send the value in the
		<code class="literal">host</code> declarations as the hostname for the
		diskless host.  An alternate way would be to add an
		<code class="literal">option host-name
		  margaux</code> inside the
		<code class="literal">host</code> declarations.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-dhcp-next-server"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The
		<code class="literal">next-server</code> directive designates
		the <acronym class="acronym">TFTP</acronym> or <acronym class="acronym">NFS</acronym> server to
		use for loading loader or kernel file (the default is to use
		the same host as the
		<acronym class="acronym">DHCP</acronym> server).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-dhcp-filename"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The
		<code class="literal">filename</code> directive defines the file that
		<span class="application">Etherboot</span> or <acronym class="acronym">PXE</acronym>
		will load for the next execution step.  It must be specified
		according to the transfer method used.
		<span class="application">Etherboot</span> can be compiled to use
		<acronym class="acronym">NFS</acronym> or <acronym class="acronym">TFTP</acronym>.  The FreeBSD
		port configures <acronym class="acronym">NFS</acronym> by default.
		<acronym class="acronym">PXE</acronym> uses <acronym class="acronym">TFTP</acronym>, which is
		why a relative filename is used here (this may depend on the
		<acronym class="acronym">TFTP</acronym> server configuration, but would be
		fairly typical).  Also, <acronym class="acronym">PXE</acronym> loads
		<code class="filename">pxeboot</code>, not the kernel.  There are other
		interesting possibilities, like loading
		<code class="filename">pxeboot</code> from a FreeBSD CD-ROM
		<code class="filename">/boot</code> directory (as
		<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pxeboot</span>(8)</span></a> can load a <code class="filename">GENERIC</code> kernel,
		this makes it possible to use <acronym class="acronym">PXE</acronym> to boot
		from a remote CD-ROM).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#co-dhcp-root-path"><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The
		<code class="literal">root-path</code> option defines the path to
		the root file system, in usual <acronym class="acronym">NFS</acronym> notation.
		When using <acronym class="acronym">PXE</acronym>, it is possible to leave off
		the host's IP as long as you do not enable the kernel option
		BOOTP.  The <acronym class="acronym">NFS</acronym> server will then be
		the same as the <acronym class="acronym">TFTP</acronym> one.</p></td></tr></table></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90912976"></a>31.7.2.2. Configuration Using BOOTP</h4></div></div></div><a id="idp90913616" class="indexterm"></a><p>Here follows an equivalent <span class="application">bootpd</span>
	    configuration (reduced to one client).  This would be found in
	    <code class="filename">/etc/bootptab</code>.</p><p>Please note that <span class="application">Etherboot</span>
	    must be compiled with the non-default option
	    <code class="literal">NO_DHCP_SUPPORT</code> in order to use BOOTP,
	    and that <acronym class="acronym">PXE</acronym> <span class="emphasis"><em>needs</em></span> <acronym class="acronym">DHCP</acronym>.  The only
	    obvious advantage of <span class="application">bootpd</span> is
	    that it exists in the base system.</p><pre class="programlisting">
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
          </pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90919120"></a>31.7.2.3. Preparing a Boot Program with
	  <span class="application">Etherboot</span></h4></div></div></div><a id="idp90936528" class="indexterm"></a><p><a class="link" href="http://etherboot.sourceforge.net" target="_top">Etherboot's Web
	  site</a> contains
	  <a class="link" href="http://etherboot.sourceforge.net/doc/html/userman/t1.html" target="_top">
	  extensive documentation</a> mainly intended for Linux
	  systems, but nonetheless containing useful information.  The
	  following will just outline how you would use
	  <span class="application">Etherboot</span> on a FreeBSD
	  system.</p><p>You must first install the <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/etherboot/pkg-descr">net/etherboot</a> package or port.</p><p>You can change the <span class="application">Etherboot</span>
	  configuration (i.e. to use <acronym class="acronym">TFTP</acronym> instead of
	  <acronym class="acronym">NFS</acronym>) by editing the <code class="filename">Config</code>
	  file in the <span class="application">Etherboot</span> source
	  directory.</p><p>For our setup, we shall use a boot floppy.  For other methods
	  (PROM, or <span class="trademark">MS-DOS</span>® program), please refer to the
	  <span class="application">Etherboot</span> documentation.</p><p>To make a boot floppy, insert a floppy in the drive on the
	  machine where you installed <span class="application">Etherboot</span>,
	  then change your current directory to the <code class="filename">src</code>
	  directory in the <span class="application">Etherboot</span> tree and
	  type:</p><pre class="screen">
<code class="prompt">#</code> <strong class="userinput"><code>gmake bin32/devicetype.fd0</code></strong>
	</pre><p><em class="replaceable"><code>devicetype</code></em> depends on the type of
	  the Ethernet card in the diskless workstation.  Refer to the
	  <code class="filename">NIC</code> file in the same directory to determine the
	  right <em class="replaceable"><code>devicetype</code></em>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90951760"></a>31.7.2.4. Booting with <acronym class="acronym">PXE</acronym></h4></div></div></div><p>By default, the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pxeboot</span>(8)</span></a> loader loads the kernel via
	  <acronym class="acronym">NFS</acronym>.  It can be compiled to use
	  <acronym class="acronym">TFTP</acronym> instead by specifying the
	  <code class="literal">LOADER_TFTP_SUPPORT</code> option in
	  <code class="filename">/etc/make.conf</code>.  See the comments in
	  <code class="filename">/usr/share/examples/etc/make.conf</code>
	  for instructions.</p><p>There are two other <code class="filename">make.conf</code>
	  options which may be useful for setting up a serial console diskless
	  machine: <code class="literal">BOOT_PXELDR_PROBE_KEYBOARD</code>, and
	  <code class="literal">BOOT_PXELDR_ALWAYS_SERIAL</code>.</p><p>To use <acronym class="acronym">PXE</acronym> when the machine starts, you will
	  usually need to select the <code class="literal">Boot from network</code>
	  option in your <acronym class="acronym">BIOS</acronym> setup, or type a function key
	  during the PC initialization.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90967248"></a>31.7.2.5. Configuring the <acronym class="acronym">TFTP</acronym> and <acronym class="acronym">NFS</acronym> Servers</h4></div></div></div><a id="idp90968656" class="indexterm"></a><a id="idp90969808" class="indexterm"></a><p>If you are using <acronym class="acronym">PXE</acronym> or
	  <span class="application">Etherboot</span> configured to use
	  <acronym class="acronym">TFTP</acronym>, you need to enable
	  <span class="application">tftpd</span> on the file server:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Create a directory from which <span class="application">tftpd</span>
            will serve the files, e.g. <code class="filename">/tftpboot</code>.</p></li><li class="step"><p>Add this line to your
	      <code class="filename">/etc/inetd.conf</code>:</p><pre class="programlisting">tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">It appears that at least some <acronym class="acronym">PXE</acronym> versions want
		the <acronym class="acronym">TCP</acronym> version of <acronym class="acronym">TFTP</acronym>.  In this case, add a second line,
		replacing <code class="literal">dgram udp</code> with <code class="literal">stream
		tcp</code>.</p></div></li><li class="step"><p>Tell <span class="application">inetd</span> to reread its configuration
	      file.  The <code class="option">inetd_enable="YES"</code> must be in
	      the <code class="filename">/etc/rc.conf</code> file for this
	      command to execute correctly:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/inetd restart</code></strong></pre></li></ol></div><p>You can place the <code class="filename">tftpboot</code>
	  directory anywhere on the server.  Make sure that the
	  location is set in both <code class="filename">inetd.conf</code> and
	  <code class="filename">dhcpd.conf</code>.</p><p>In all cases, you also need to enable <acronym class="acronym">NFS</acronym> and export the
	  appropriate file system on the <acronym class="acronym">NFS</acronym> server.</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Add this to <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">nfs_server_enable="YES"</pre></li><li class="step"><p>Export the file system where the diskless root directory
	      is located by adding the following to
	      <code class="filename">/etc/exports</code> (adjust the volume mount
	      point and replace <em class="replaceable"><code>margaux corbieres</code></em>
	      with the names of the diskless workstations):</p><pre class="programlisting"><em class="replaceable"><code>/data/misc</code></em> -alldirs -ro <em class="replaceable"><code>margaux corbieres</code></em></pre></li><li class="step"><p>Tell <span class="application">mountd</span> to reread its configuration
	      file.  If you actually needed to enable <acronym class="acronym">NFS</acronym> in
	      <code class="filename">/etc/rc.conf</code>
	      at the first step, you probably want to reboot instead.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/mountd restart</code></strong></pre></li></ol></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91000272"></a>31.7.2.6. Building a Diskless Kernel</h4></div></div></div><a id="idp91000912" class="indexterm"></a><p>If using <span class="application">Etherboot</span>, you need to
	  create a kernel configuration file for the diskless client
	  with the following options (in addition to the usual ones):</p><pre class="programlisting">
options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info
	</pre><p>You may also want to use <code class="literal">BOOTP_NFSV3</code>,
	  <code class="literal">BOOT_COMPAT</code> and <code class="literal">BOOTP_WIRED_TO</code>
	  (refer to <code class="filename">NOTES</code>).</p><p>These option names are historical and slightly misleading as
	  they actually enable indifferent use of <acronym class="acronym">DHCP</acronym> and
	  BOOTP inside the kernel (it is also possible to force strict BOOTP
	  or <acronym class="acronym">DHCP</acronym> use).</p><p>Build the kernel (see <a class="xref" href="kernelconfig.html" title="章 9. 設定 FreeBSD Kernel">章 9, <em>設定 FreeBSD Kernel</em></a>),
	  and copy it to the place specified
	  in <code class="filename">dhcpd.conf</code>.</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">When using <acronym class="acronym">PXE</acronym>, building a kernel with the
	  above options is not strictly necessary (though suggested).
	  Enabling them will cause more <acronym class="acronym">DHCP</acronym> requests to be
	  issued during kernel startup, with a small risk of inconsistency
	  between the new values and those retrieved by <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pxeboot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pxeboot</span>(8)</span></a> in some
	  special cases.  The advantage of using them is that the host name
	  will be set as a side effect.  Otherwise you will need to set the
	  host name by another method, for example in a client-specific
	  <code class="filename">rc.conf</code> file.</p></div><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">In order to be loadable with
	    <span class="application">Etherboot</span>, a kernel needs to have
	    the device hints compiled in.  You would typically set the
	    following option in the configuration file (see the
	    <code class="filename">NOTES</code> configuration comments file):</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">hints		"GENERIC.hints"</pre></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91016528"></a>31.7.2.7. Preparing the Root Filesystem</h4></div></div></div><a id="idp91017168" class="indexterm"></a><p>You need to create a root file system for the diskless
	  workstations, in the location listed as
	  <code class="literal">root-path</code> in
	  <code class="filename">dhcpd.conf</code>.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91019600"></a>31.7.2.7.1. Using <code class="command">make world</code> to populate root</h5></div></div></div><p>This method is quick and
	    will install a complete virgin system (not only the root file system)
	    into <code class="envar">DESTDIR</code>.
	    All you have to do is simply execute the following script:</p><pre class="programlisting">#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
cd /usr/src/etc; make distribution</pre><p>Once done, you may need to customize your
	    <code class="filename">/etc/rc.conf</code> and
	    <code class="filename">/etc/fstab</code> placed into
	    <code class="envar">DESTDIR</code> according to your needs.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91023568"></a>31.7.2.8. Configuring Swap</h4></div></div></div><p>If needed, a swap file located on the server can be
	  accessed via <acronym class="acronym">NFS</acronym>.</p><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91024976"></a>31.7.2.8.1. <acronym class="acronym">NFS</acronym> Swap</h5></div></div></div><p>The kernel does not support enabling <acronym class="acronym">NFS</acronym>
	    swap at boot time.  Swap must be enabled by the startup scripts,
	    by mounting a writable file system and creating and enabling a
	    swap file.  To create a swap file of appropriate size, you can do
	    like this:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</code></strong></pre><p>To enable it you have to add the following line to your
	    <code class="filename">rc.conf</code>:</p><pre class="programlisting">swapfile=<em class="replaceable"><code>/path/to/swapfile</code></em></pre></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91029328"></a>31.7.2.9. Miscellaneous Issues</h4></div></div></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91029968"></a>31.7.2.9.1. Running with a Read-only <code class="filename">/usr</code></h5></div></div></div><a id="idp91030864" class="indexterm"></a><p>If the diskless workstation is configured to run X, you
	    will have to adjust the <span class="application">XDM</span> configuration file, which puts
	    the error log on <code class="filename">/usr</code> by default.</p></div><div class="sect4"><div xmlns="" class="titlepage"><div><div><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp91033296"></a>31.7.2.9.2. Using a Non-FreeBSD Server</h5></div></div></div><p>When the server for the root file system is not running FreeBSD,
	    you will have to create the root file system on a
	    FreeBSD machine, then copy it to its destination, using
	    <code class="command">tar</code> or <code class="command">cpio</code>.</p><p>In this situation, there are sometimes
	    problems with the special files in <code class="filename">/dev</code>,
	    due to differing major/minor integer sizes.  A solution to this
	    problem is to export a directory from the non-FreeBSD server,
	    mount this directory onto a FreeBSD machine, and
	    use <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devfs&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">devfs</span>(5)</span></a> to allocate device nodes transparently for
	    the user.</p></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-aggregation.html">前一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">上一層</a></td><td width="40%" align="right"> <a accesskey="n" href="network-isdn.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">31.6. Link Aggregation and Failover </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 31.8. ISDN</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文及其他文件，可由此下載：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>若有 FreeBSD 方面疑問，請先閱讀
    <a href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;。<br></br>
    關於本文件的問題，請洽詢
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;。</small></p></body></html>