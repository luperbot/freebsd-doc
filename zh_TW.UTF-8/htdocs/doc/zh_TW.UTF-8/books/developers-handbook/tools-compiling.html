<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>2.4. 用 cc 來編譯程式</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="tools.html" title="章 2. 程式開發工具" /><link rel="prev" href="tools-programming.html" title="2.3. Programming 概念" /><link rel="next" href="tools-make.html" title="2.5. Make" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.4. 用 <code class="command">cc</code> 來編譯程式</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="tools-programming.html">前一頁</a> </td><th width="60%" align="center">章 2. 程式開發工具</th><td width="20%" align="right"> <a accesskey="n" href="tools-make.html">下一頁</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="tools-compiling"></a>2.4. 用 <code class="command">cc</code> 來編譯程式</h2></div></div></div><p>本章範例只有針對 GNU C compiler 和 GNU C++ compiler 作說明，
        這兩個在 FreeBSD base system 中就有了，
        直接打 <code class="command">cc</code> 或 <code class="command">gcc</code> 就可以執行。
        至於，如何用直譯器產生程式的說明，通常可在直譯器的文件或線上文件找到說明，因此不再贅述。</p><p>當你寫完你的傑作後，接下來便是讓這個程式可以在 FreeBSD 上執行，
        通常這些要一些步驟才能完成，有些步驟則需要不同程式來完成。</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>預先處理(Pre-process)你的程式碼，移除程式內的註解，和其他技巧，
          像是 expanding(擴大) C 的 marco。</p></li><li class="step"><p>確認你的程式語法是否確實遵照 C/C++ 的規定，如果沒有符合的話，編譯器會出現警告。</p></li><li class="step"><p>將原始碼轉成組合語言 —— 它跟機器語言(machine code)非常相近，但仍在人類可理解的範圍內(據說應該是這樣)。
	  <a href="#ftn.idp63843792" class="footnote" id="idp63843792"><sup class="footnote">[2]</sup></a></p></li><li class="step"><p>把組合語言轉成機器語言 —— 是的，這裡說的機器語言就是常提到的 bit 和 byte，也就是 1 和 0。</p></li><li class="step"><p>確認程式中用到的函式呼叫、全域變數是否正確，舉例來說：如若呼叫了不存在的函式，編譯器會顯示警告。</p></li><li class="step"><p>如果程式是由程式碼檔案來編譯，編譯器會整合起來。</p></li><li class="step"><p>編譯器會負責產生東西，讓系統上的 run-time loader 可以把程式載入記憶體內執行。</p></li><li class="step"><p>最後會把編譯完的執行檔存在硬碟上。</p></li></ol></div><p>通常 <em class="firstterm">編譯(compiling)</em> 是指第 1 到第 4 個步驟。
      —— 其他步驟則稱為 <em class="firstterm">連結(linking)</em>，
      有時候步驟 1 也可以是指 <em class="firstterm">預先處理(pre-processing)</em>，
      而步驟 3 到步驟 4 則是 <em class="firstterm">組譯(assembling)</em>。</p><p>幸運的是，你可以不用理會以上細節，編譯器都會自動完成。
      因為 <code class="command">cc</code> 只是是個前端程式(front end)，它會依照正確的參數來呼叫相關程式幫你處理。
      只需打：</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc foobar.c</code></strong></pre><p>上述指令會把 <code class="filename">foobar.c</code> 開始編譯，並完成上述動作。
      如果你有許多檔案需要編譯，那請打類似下列指令即可：</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc foo.c bar.c</code></strong></pre><p>記住語法錯誤檢查就是 —— 純粹檢查語法錯誤與否，
      而不會幫你檢測任何邏輯錯誤，比如：無限迴圈，或是排序方式想用 binary sort 卻弄成 bubble sort。
      <a href="#ftn.idp63878608" class="footnote" id="idp63878608"><sup class="footnote">[3]</sup></a></p><p><code class="command">cc</code> 有非常多的選項，都可透過線上手冊來查。
      下面只提一些必要且重要的選項，以作為例子。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-o <em class="replaceable"><code>檔名</code></em></code></span></dt><dd><p><code class="option">-o</code> 編譯後的執行檔檔名，如果沒有使用這選項的話，
	    編譯好的程式預設檔名將會是 <code class="filename">a.out</code>

	    <a href="#ftn.idp63886800" class="footnote" id="idp63886800"><sup class="footnote">[4]</sup></a></p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc foobar.c</code></strong>               <em class="lineannotation"><span class="lineannotation">執行檔就是 a.out</span></em>
<code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.c</code></strong>     <em class="lineannotation"><span class="lineannotation">執行檔就是 foobar</span></em>
	    </pre></div></dd><dt><span class="term"><code class="option">-c</code></span></dt><dd><p>使用 <code class="option">-c</code> 時，只會編譯原始碼，而不作連結(linking)。
	    當只想確認語法是否正確或使用 Makefile 來編譯程式時，這個選項非常有用。</p><div class="informalexample"><pre class="screen">
        <code class="prompt">%</code> <strong class="userinput"><code>cc -c foobar.c</code></strong>
	    </pre></div><p>這會產生叫做 <code class="filename">foobar</code> 的 <em class="firstterm">object file</em>(非執行檔)。
	    這檔可以與其他的 object file 連結在一起，而成執行檔。</p></dd><dt><span class="term"><code class="option">-g</code></span></dt><dd><p><code class="option">-g</code> 將會把一些給 gdb 用的除錯訊息包進去執行檔裡面，所謂的除錯訊息例如：
	    程式在第幾行出錯、那個程式第幾行做什麼函式呼叫等等。除錯資訊<span class="emphasis"><em>非常</em></span>好用。
	    但缺點就是：對於程式來說，額外的除錯訊息會讓編譯出來的程式比較肥些。
	    <code class="option">-g</code> 的適用時機在於：當程式還在開發時使用就好，
	    而當你要釋出你的 <span class="quote">“<span class="quote">發行版本(release version)</span>”</span>
	    或者確認程式可運作正常的話，就不必用 <code class="option">-g</code> 這選項了。</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -g foobar.c</code></strong>
	    </pre></div><p>這動作會產生有含除錯訊息的執行檔。
	    <a href="#ftn.idp63945424" class="footnote" id="idp63945424"><sup class="footnote">[5]</sup></a></p></dd><dt><span class="term"><code class="option">-O</code></span></dt><dd><p><code class="option">-O</code> 會產生最佳化的執行檔，
	    編譯器會使用一些技巧，來讓程式可以跑的比未經最佳化的程式還快，
	    可以在大寫 O 後面加上數字來指明想要的最佳化層級。
	    但是最佳化還是會有一些錯誤，舉例來說在 FreeBSD 2.10 release 中用 <code class="command">cc</code>
	    且指定 <code class="option">-O2</code> 時，在某些情形下會產生錯誤的執行檔。</p><p>只有當要釋出發行版本、或者加速程式時，才需要使用最佳化選項。</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -O -o foobar foobar.c</code></strong>
	    </pre></div><p>這會產生 <code class="filename">foobar</code> 執行檔的最佳化版本。</p></dd></dl></div><p>以下三個參數將會強迫 <code class="command">cc</code> 確認程式碼是否符合一些國際標準的規範，
      也就是通常說的 <acronym class="acronym">ANSI</acronym> 標準，
      而 <acronym class="acronym">ANSI</acronym> 嚴格來講屬 <acronym class="acronym">ISO</acronym> 標準。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-Wall</code></span></dt><dd><p><code class="option">-Wall</code> 顯示 <code class="command">cc</code>  維護者所認為值得注意的所有警告訊息。
	    不過這名字可能會造成誤解，事實上它並未完全顯示 <code class="command">cc</code> 所能注意到的各項警告訊息。</p></dd><dt><span class="term"><code class="option">-ansi</code></span></dt><dd><p><code class="option">-ansi</code> 關閉 <code class="command">cc</code> 特有的某些特殊非 ANSI C 標準功能。
	    不過這名字可能會造成誤解，事實上它並不保證你的程式會完全符合 ANSI 標準。</p></dd><dt><span class="term"><code class="option">-pedantic</code></span></dt><dd><p>全面關閉 <code class="command">cc</code> 所特有的非 <acronym class="acronym">ANSI</acronym>  C 標準功能。</p></dd></dl></div><p>除了這些參數，<code class="command">cc</code> 還允許你使用一些額外的參數取代標準參數，有些額外參數非常有用，
      但是實際上並不是所有的編譯器都有提供這些參數。
      照標準來寫程式的最主要目的就是，希望你寫出來的程式可以在所有編譯器上編譯、執行無誤，
      當程式可以達成上述目的時，就稱為 <em class="firstterm">portable code(移植性良好的程式碼)</em>。</p><p>一般來說，在撰寫程式時就應要注意『移植性』。
      否則。當想把程式拿到另外一台機器上跑的時候，就可能得需要重寫程式。</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -Wall -ansi -pedantic -o foobar foobar.c</code></strong></pre></div><p>上述指令會確認 <code class="filename">foobar.c</code> 內的語法是否符合標準，
      並且產生名為 <code class="filename">foobar</code> 的執行檔。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-l<em class="replaceable"><code>library</code></em></code></span></dt><dd><p>告訴 gcc 在連結(linking)程式時你需要用到的函式庫名稱。</p><p>最常見的情況就是，當你在程式中使用了 C 數學函式庫，
	    跟其他作業平台不一樣的是，這函示學函式都不在標準函式庫(library)中，
	    因此編譯器並不知道這函式庫名稱，你必須告訴編譯器要加上它才行。</p><p>規則很簡單，如果有個函式庫叫做 <code class="filename">libsomething.a</code>，
	    就必須在編譯時加上參數 <code class="option">-l<em class="replaceable"><code>something</code></em></code> 才行。
	    舉例來說，數學函式庫叫做 <code class="filename">libm.a</code>，
	    所以你必須給 <code class="command">cc</code> 的參數就是 <code class="option">-lm</code>。
	    一般情況下，通常會把這參數必須放在指令的最後。</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.c -lm</code></strong>
	    </pre></div><p>上面這指令會讓 gcc 跟數學函式庫作連結，以便你的程式可以呼叫函式庫內含的數學函式。</p><p>如果你正在編譯的程式是 C++ 程式碼，你還必須額外指定 <code class="option">-lg++</code> 或者是
	    <code class="option">-lstdc++</code>。
	    如果你的 FreeBSD 是 2.2(含)以後版本，
	    你可以用指令 <code class="command">c++</code> 來取代 <code class="command">cc</code>。
	    在 FreeBSD 上 <code class="command">c++</code> 也可以用 <code class="command">g++</code> 取代。</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.cc -lg++</code></strong>     <em class="lineannotation"><span class="lineannotation">適用 FreeBSD 2.1.6 或更早期的版本</span></em>
<code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.cc -lstdc++</code></strong>  <em class="lineannotation"><span class="lineannotation">適用 FreeBSD 2.2 及之後的版本</span></em>
<code class="prompt">%</code> <strong class="userinput"><code>c++ -o foobar foobar.cc</code></strong>
	    </pre></div><p>上述指令都會從原始檔 <code class="filename">foobar.cc</code> 編譯產生名為 <code class="filename">fooboar</code> 的執行檔。
	    這邊要提醒的是在 <span class="trademark">UNIX</span>® 系統中 C++ 程式傳統都以 <code class="filename">.C</code>、
	    <code class="filename">.cxx</code> 或者是 <code class="filename">.cc</code> 作為副檔名，
	    而非 <span class="trademark">MS-DOS</span>® 那種以 <code class="filename">.cpp</code> 作為副檔名的命名方式(不過也越來越普遍了)。
	    <code class="command">gcc</code> 會依副檔名來決定用哪一種編譯器編譯，
	    然而，現在已經不再限制副檔名了，
	    所以可以自由的使用 <code class="filename">.cpp</code> 作為 C++ 程式碼的副檔名！</p></dd></dl></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64077776"></a>2.4.1. 常見的 <code class="command">cc</code> 問題</h3></div></div></div><div class="qandaset"><a id="idp64082000"></a><dl><dt>2.4.1.1. <a href="tools-compiling.html#idp64083024">我用 sin() 函示撰寫我的程式，
	      但是有個錯誤訊息(如下)，這代表著？</a></dt><dt>2.4.1.2. <a href="tools-compiling.html#idp64111184">好吧，我試著寫些簡單的程式，來練習使用 -lm 選項(該程式會運算 2.1 的 6 次方)</a></dt><dt>2.4.1.3. <a href="tools-compiling.html#idp64133456">那如何才可以修正剛所說的問題？</a></dt><dt>2.4.1.4. <a href="tools-compiling.html#idp64157264">已經編譯好 foobar.c，
	      但是編譯後找不到 foobar 執行檔。 該去哪邊找呢？</a></dt><dt>2.4.1.5. <a href="tools-compiling.html#idp64172624">好，有個編譯好的程式叫做 foobar，
	      用 ls 指令時可以看到，
	      但執行時，訊息卻說卻沒有這檔案。為什麼？</a></dt><dt>2.4.1.6. <a href="tools-compiling.html#idp64202960">試著執行 test 執行檔，
	      但是卻沒有任何事發生，到底是哪裡出錯了？</a></dt><dt>2.4.1.7. <a href="tools-compiling.html#idp64217296">當執行我寫的程式時剛開始正常，
	      接下來卻出現 core dumped 錯誤訊息。這錯誤訊息到底代表什麼？</a></dt><dt>2.4.1.8. <a href="tools-compiling.html#idp64234320">真是太神奇了！程式居然發生 core dumped 了，該怎麼辦？</a></dt><dt>2.4.1.9. <a href="tools-compiling.html#idp64242256">當程式已經把 core memory 資料 dump 出來後，
	      同時也出現另一個錯誤 segmentation fault 這意思是？</a></dt><dt>2.4.1.10. <a href="tools-compiling.html#idp64291792">Sometimes when I get a core dump it says
	      bus error.  It says in my UNIX®
	      book that this means a hardware problem, but the
	      computer still seems to be working.  Is this
	      true?</a></dt><dt>2.4.1.11. <a href="tools-compiling.html#idp64298960">This dumping core business sounds as though it could
	      be quite useful, if I can make it happen when I want to.
	      Can I do this, or do I have to wait until there is an
	      error?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp64083024"></a><a id="idp64084048"></a><p><strong>2.4.1.1.</strong></p></td><td align="left" valign="top"><p>我用 <code class="function">sin()</code> 函示撰寫我的程式，
	      但是有個錯誤訊息(如下)，這代表著？</p><div class="informalexample"><pre class="screen">/var/tmp/cc0143941.o: Undefined symbol `_sin' referenced from text segment
	      </pre></div></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>當使用 <code class="function">sin()</code> 這類的數學函示時，
	      你必須告訴 cc 要和數學函式庫作連結(linking)，就像這樣：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.c -lm</code></strong>
	      </pre></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64111184"></a><a id="idp64111696"></a><p><strong>2.4.1.2.</strong></p></td><td align="left" valign="top"><p>好吧，我試著寫些簡單的程式，來練習使用 -lm 選項(該程式會運算 2.1 的 6 次方)</p><div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;

int main() {
	float f;

	f = pow(2.1, 6);
	printf("2.1 ^ 6 = %f\n", f);
	return 0;
}
	      </pre></div><p>然後進行編譯：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc temp.c -lm</code></strong>
	      </pre></div><p>編譯後執行程式，得到下面這結果：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./a.out</code></strong>
2.1 ^ 6 = 1023.000000
	      </pre></div><p>很明顯的，程式結果<span class="emphasis"><em>不是</em></span>正確答案，到底是哪邊出錯？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>當編譯器發現你呼叫一個函示時，它會確認該函示的回傳值類型(prototype)，
	      如果沒有特別指明，則預設的回傳值類型為 <span class="type">int(整數)</span>。
	      很明顯的，你的程式所需要的並不是回傳值類別為 <span class="type">int</span>。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64133456"></a><a id="idp64134352"></a><p><strong>2.4.1.3.</strong></p></td><td align="left" valign="top"><p>那如何才可以修正剛所說的問題？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>數學函示的回傳值類型(prototype)會定義在 <code class="filename">math.h</code>，
	      如果你有 include 這檔，編譯器就會知道該函示的回傳值類型，如此一來該運算就會得到正確的結果！</p><div class="informalexample"><pre class="programlisting">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main() {
...
	      </pre></div><p>加了上述內容之後，再重新編譯，最後執行：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./a.out</code></strong>
2.1 ^ 6 = 85.766121
	      </pre></div><p>如果有用到數學函式，<span class="emphasis"><em>請確定</em></span>要有 include <code class="filename">math.h</code> 這檔，
	      而且記得要和數學函式庫作連結。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64157264"></a><a id="idp64157904"></a><p><strong>2.4.1.4.</strong></p></td><td align="left" valign="top"><p>已經編譯好 <code class="filename">foobar.c</code>，
	      但是編譯後找不到 <code class="filename">foobar</code> 執行檔。 該去哪邊找呢？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>記得，除非有指定編譯結果的執行檔檔名，否則預設的執行檔檔名是 a.out。
	      用 <code class="option">-o <em class="replaceable"><code>filename</code></em></code> 參數，
	      就可以達到所想要的結果，比如：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -o foobar foobar.c</code></strong>
	      </pre></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64172624"></a><a id="idp64173648"></a><p><strong>2.4.1.5.</strong></p></td><td align="left" valign="top"><p>好，有個編譯好的程式叫做 <code class="filename">foobar</code>，
	      用 <code class="command">ls</code> 指令時可以看到，
	      但執行時，訊息卻說卻沒有這檔案。為什麼？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>與 <span class="trademark">MS-DOS</span>® 不同的是，除非有指定執行檔的路徑，
	      否則 <span class="trademark">UNIX</span>® 系統並不會在目前的目錄下尋找你想執行的檔案。
	      在指令列下打 <code class="command">./foobar</code> 代表
	      <span class="quote">“<span class="quote">執行在這個目錄底下名為 <code class="filename">foobar</code> 的程式</span>”</span>，
	      或者也可以更改 <code class="envar">PATH</code> 環境變數設定如下，以達成類似效果：</p><div class="informalexample"><pre class="screen">bin:/usr/bin:/usr/local/bin:.
	      </pre></div><p>上一行最後的 "." 代表<span class="quote">“<span class="quote">如果在前面寫的其他目錄找不到，就找目前的目錄</span>”</span>。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64202960"></a><a id="idp64203216"></a><p><strong>2.4.1.6.</strong></p></td><td align="left" valign="top"><p>試著執行 <code class="filename">test</code> 執行檔，
	      但是卻沒有任何事發生，到底是哪裡出錯了？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>大多數的 <span class="trademark">UNIX</span>® 系統都會在路徑 <code class="filename">/usr/bin</code> 擺放執行檔。
	      除非有指定使用在目前目錄內的 <code class="filename">test</code>，否則 shell 會優先選擇位在
	      <code class="filename">/usr/bin</code> 的 <code class="filename">test</code>，
	      要指定檔名的話，作法類似：</p><div class="informalexample"><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./test</code></strong>
	      </pre></div><p>為了避免上述困擾，請為你的程式取更好的名稱吧！</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64217296"></a><a id="idp64217552"></a><p><strong>2.4.1.7.</strong></p></td><td align="left" valign="top"><p>當執行我寫的程式時剛開始正常，
	      接下來卻出現 <span class="errorname">core dumped</span> 錯誤訊息。這錯誤訊息到底代表什麼？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>關於 <em class="firstterm">core dumped</em> 這個名稱的由來，
	      可以追溯到早期的 <span class="trademark">UNIX</span>® 系統開始使用 core memory 對資料排序時。
	      基本上當程式在很多情況下發生錯誤後，
	      作業系統會把 core memory 中的資訊寫入 <code class="filename">core</code> 這檔案中，
	      以便讓 programmer 知道程式到底是為何出錯。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64234320"></a><a id="idp64235216"></a><p><strong>2.4.1.8.</strong></p></td><td align="left" valign="top"><p>真是太神奇了！程式居然發生 <span class="errorname">core dumped</span> 了，該怎麼辦？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>請用 <code class="command">gdb</code> 來分析 core 結果(詳情請參考 <a class="xref" href="debugging.html" title="2.6. Debugging">節 2.6, “Debugging”</a>)。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64242256"></a><a id="idp64243152"></a><p><strong>2.4.1.9.</strong></p></td><td align="left" valign="top"><p>當程式已經把 core memory 資料 dump 出來後，
	      同時也出現另一個錯誤 <span class="errorname">segmentation fault</span> 這意思是？</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>基本上，這個錯誤表示你的程式在記憶體中試著做一個嚴重的非法運作(illegal operation)，
	      <span class="trademark">UNIX</span>® 就是被設計來保護整個作業系統免於被惡質的程式破壞，所以才會告訴你這個訊息。</p><p>最常造成<span class="quote">“<span class="quote">segmentation fault</span>”</span>的原因通常為：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>試著對一個 <span class="symbol">NULL</span> 的指標(pointer)作寫入的動作，如</p><pre class="programlisting">char *foo = NULL;
strcpy(foo, "bang!");
		</pre></li><li class="listitem"><p>使用一個尚未初始化(initialized)的指標，如：</p><pre class="programlisting">char *foo;
strcpy(foo, "bang!");
		</pre><p>尚未初始化的指標的初始值將會是隨機的，如果你夠幸運的話，
		  這個指標的初始值會指向 kernel 已經用到的記憶體位置，
		  kernel 會結束掉這個程式以確保系統運作正常。如果你不夠幸運，
		  初始指到的記憶體位置是你程式必須要用到的資料結構(data structures)的位置，
		  當這個情形發生時程式將會當的不知其所以然。</p></li><li class="listitem"><p>試著寫入超過陣列(array)元素個數，如：</p><pre class="programlisting">int bar[20];
bar[27] = 6;
		</pre></li><li class="listitem"><p>試著讀寫在唯讀記憶體(read-only memory)中的資料，如：</p><pre class="programlisting">char *foo = "My string";
strcpy(foo, "bang!");
		</pre><p><span class="trademark">UNIX</span>® compilers often put string literals like
		  <code class="literal">"My string"</code> into read-only areas
		  of memory.</p></li><li class="listitem"><p>Doing naughty things with
		  <code class="function">malloc()</code> and
		  <code class="function">free()</code>, eg</p><pre class="programlisting">char bar[80];
free(bar);
		</pre><p>or</p><pre class="programlisting">char *foo = malloc(27);
free(foo);
free(foo);
		</pre></li></ul></div><p>Making one of these mistakes will not always lead to
	      an error, but they are always bad practice.  Some
	      systems and compilers are more tolerant than others,
	      which is why programs that ran well on one system can
	      crash when you try them on an another.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64291792"></a><a id="idp64292688"></a><p><strong>2.4.1.10.</strong></p></td><td align="left" valign="top"><p>Sometimes when I get a core dump it says
	      <span class="errorname">bus error</span>.  It says in my <span class="trademark">UNIX</span>®
	      book that this means a hardware problem, but the
	      computer still seems to be working.  Is this
	      true?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>No, fortunately not (unless of course you really do
	      have a hardware problem…).  This is usually
	      another way of saying that you accessed memory in a way
	      you should not have.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp64298960"></a><a id="idp64308176"></a><p><strong>2.4.1.11.</strong></p></td><td align="left" valign="top"><p>This dumping core business sounds as though it could
	      be quite useful, if I can make it happen when I want to.
	      Can I do this, or do I have to wait until there is an
	      error?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Yes, just go to another console or xterm, do</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ps</code></strong>
	    </pre><p>to find out the process ID of your program, and
	      do</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>kill -ABRT pid</code></strong>
	    </pre><p>where
	      <em class="parameter"><code><em class="replaceable"><code>pid</code></em></code></em> is
	      the process ID you looked up.</p><p>This is useful if your program has got stuck in an
	      infinite loop, for instance.  If your program happens to
	      trap <span class="symbol">SIGABRT</span>, there are several other
	      signals which have a similar effect.</p><p>Alternatively, you can create a core dump from
	      inside your program, by calling the
	      <code class="function">abort()</code> function. See the manual page
	      of <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=abort&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span></a> to learn more.</p><p>If you want to create a core dump from outside your
              program, but do not want the process to terminate, you
              can use the <code class="command">gcore</code> program. See the
              manual page of <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gcore&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gcore</span>(1)</span></a> for more information.</p></td></tr></tbody></table></div></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp63843792" class="footnote"><p><a href="#idp63843792" class="para"><sup class="para">[2] </sup></a>嚴格說起來，在這個階段 <code class="command">cc</code> 並不是真的把原始程式轉成組合語言，
          而是轉為 machine-independent 的 <em class="firstterm">p-code</em>。</p></div><div id="ftn.idp63878608" class="footnote"><p><a href="#idp63878608" class="para"><sup class="para">[3] </sup></a>剛所說的 binary sort 和 bubble sort 問題，
          在已排序好的序列中，binary sort 搜索效率會比 bubble sort 好。</p></div><div id="ftn.idp63886800" class="footnote"><p><a href="#idp63886800" class="para"><sup class="para">[4] </sup></a>至於 <code class="option">-o</code> 的原因，則是一團歷史迷霧了。</p></div><div id="ftn.idp63945424" class="footnote"><p><a href="#idp63945424" class="para"><sup class="para">[5] </sup></a>請注意，因為上例沒用 <code class="option">-o</code> 以指定執行檔名稱，
	        所以執行檔會是 <code class="filename">a.out</code> 這檔。
	        那麼，要如何產生 <code class="filename">foobar</code> 的執行檔並內含除錯訊息，
	        這就留待看倌們練習一下囉。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tools-programming.html">前一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="tools.html">上一層</a></td><td width="40%" align="right"> <a accesskey="n" href="tools-make.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2.3. Programming 概念 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2.5. Make</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文及其他文件，可由此下載：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>若有 FreeBSD 方面疑問，請先閱讀
    <a href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;。<br></br>
    關於本文件的問題，請洽詢
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;。</small></p></body></html>