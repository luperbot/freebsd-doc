<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>3.3. Buffer Overflows</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="secure.html" title="章 3. Secure Programming" /><link rel="prev" href="secure-philosophy.html" title="3.2. Secure Design Methodology" /><link rel="next" href="secure-setuid.html" title="3.4. SetUID issues" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. Buffer Overflows</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="secure-philosophy.html">前一頁</a> </td><th width="60%" align="center">章 3. Secure Programming</th><td width="20%" align="right"> <a accesskey="n" href="secure-setuid.html">下一頁</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="secure-bufferov"></a>3.3. Buffer Overflows</h2></div></div></div><p>Buffer Overflows have been around since the very
      beginnings of the Von-Neuman <a class="xref" href="bi01.html#COD">1</a> architecture.

      <a id="idp67346768" class="indexterm"></a>
      <a id="idp67355600" class="indexterm"></a>

      They first gained widespread notoriety in 1988 with the Morris
      Internet worm.  Unfortunately, the same basic attack remains

      <a id="idp67356112" class="indexterm"></a>

      effective today.  Of the 17 CERT security advisories of 1999, 10

      <a id="idp67356624" class="indexterm"></a>

      of them were directly caused by buffer-overflow software bugs.
      By far the most common type of buffer overflow attack is based
      on corrupting the stack.</p><a id="idp67357776" class="indexterm"></a><a id="idp67358288" class="indexterm"></a><p>Most modern computer systems use a stack to pass arguments
      to procedures and to store local variables.  A stack is a last
      in first out (LIFO) buffer in the high memory area of a process
      image.  When a program invokes a function a new "stack frame" is

      <a id="idp67359056" class="indexterm"></a>
      <a id="idp67359568" class="indexterm"></a>

      created.  This stack frame consists of the arguments passed to
      the function as well as a dynamic amount of local variable
      space.  The "stack pointer" is a register that holds the current

      <a id="idp67360720" class="indexterm"></a>
      <a id="idp67361232" class="indexterm"></a>

      location of the top of the stack.  Since this value is
      constantly changing as new values are pushed onto the top of the
      stack, many implementations also provide a "frame pointer" that
      is located near the beginning of a stack frame so that local
      variables can more easily be addressed relative to this
      value. <a class="xref" href="bi01.html#COD">1</a> The return address for function

      <a id="idp67362128" class="indexterm"></a>
      <a id="idp67362640" class="indexterm"></a>
      <a id="idp67363920" class="indexterm"></a>
      <a id="idp67364432" class="indexterm"></a>

      calls is also stored on the stack, and this is the cause of
      stack-overflow exploits since overflowing a local variable in a
      function can overwrite the return address of that function,
      potentially allowing a malicious user to execute any code he or
      she wants.</p><p>Although stack-based attacks are by far the most common,
      it would also be possible to overrun the stack with a heap-based
      (malloc/free) attack.</p><p>The C programming language does not perform automatic
      bounds checking on arrays or pointers as many other languages
      do.  In addition, the standard C library is filled with a
      handful of very dangerous functions.</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><code class="function">strcpy</code>(char *dest, const char
          *src)</td><td><p>May overflow the dest buffer</p></td></tr><tr><td><code class="function">strcat</code>(char *dest, const char
          *src)</td><td><p>May overflow the dest buffer</p></td></tr><tr><td><code class="function">getwd</code>(char *buf)</td><td><p>May overflow the buf buffer</p></td></tr><tr><td><code class="function">gets</code>(char *s)</td><td><p>May overflow the s buffer</p></td></tr><tr><td><code class="function">[vf]scanf</code>(const char *format,
          ...)</td><td><p>May overflow its arguments.</p></td></tr><tr><td><code class="function">realpath</code>(char *path, char
          resolved_path[])</td><td><p>May overflow the path buffer</p></td></tr><tr><td><code class="function">[v]sprintf</code>(char *str, const char
          *format, ...)</td><td><p>May overflow the str buffer.</p></td></tr></tbody></table></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67381456"></a>3.3.1. Example Buffer Overflow</h3></div></div></div><p>The following example code contains a buffer overflow
      designed to overwrite the return address and skip the
      instruction immediately following the function call.  (Inspired
      by <a class="xref" href="bi01.html#Phrack">4</a>)</p><pre class="programlisting">#include <code class="sgmltag-element">stdio.h</code>

void manipulate(char *buffer) {
  char newbuffer[80];
  strcpy(newbuffer,buffer);
}

int main() {
  char ch,buffer[4096];
  int i=0;

  while ((buffer[i++] = getchar()) != '\n') {};

  i=1;
  manipulate(buffer);
  i=2;
  printf("The value of i is : %d\n",i);
  return 0;
}</pre><p>Let us examine what the memory image of this process would
      look like if we were to input 160 spaces into our little program
      before hitting return.</p><p>[XXX figure here!]</p><p>Obviously more malicious input can be devised to execute
      actual compiled instructions (such as exec(/bin/sh)).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67389136"></a>3.3.2. Avoiding Buffer Overflows</h3></div></div></div><p>The most straightforward solution to the problem of
      stack-overflows is to always use length restricted memory and
      string copy functions.  <code class="function">strncpy</code> and
      <code class="function">strncat</code> are part of the standard C library.

      <a id="idp67390672" class="indexterm"></a>
      <a id="idp67391824" class="indexterm"></a>

      These functions accept a length value as a parameter which
      should be no larger than the size of the destination buffer.
      These functions will then copy up to `length' bytes from the
      source to the destination.  However there are a number of
      problems with these functions.  Neither function guarantees NUL
      termination if the size of the input buffer is as large as the

      <a id="idp67392976" class="indexterm"></a>

      destination.  The length parameter is also used inconsistently
      between strncpy and strncat so it is easy for programmers to get
      confused as to their proper usage.  There is also a significant
      performance loss compared to <code class="function">strcpy</code> when
      copying a short string into a large buffer since
      <code class="function">strncpy</code> NUL fills up the size
      specified.</p><p>In OpenBSD, another memory copy implementation has been

      <a id="idp67394640" class="indexterm"></a>

      created to get around these problem.  The
      <code class="function">strlcpy</code> and <code class="function">strlcat</code>
      functions guarantee that they will always null terminate the
      destination string when given a non-zero length argument.  For
      more information about these functions see <a class="xref" href="bi01.html#OpenBSD">6</a>.  The OpenBSD <code class="function">strlcpy</code> and
      <code class="function">strlcat</code> instructions have been in FreeBSD
      since 3.3.</p><a id="idp67397328" class="indexterm"></a><a id="idp67398480" class="indexterm"></a><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67399632"></a>3.3.2.1. Compiler based run-time bounds checking</h4></div></div></div><a id="idp67400144" class="indexterm"></a><p>Unfortunately there is still a very large assortment of
        code in public use which blindly copies memory around without
        using any of the bounded copy routines we just discussed.
        Fortunately, there is another solution.  Several compiler
        add-ons and libraries exist to do Run-time bounds checking in
        C/C++.</p><a id="idp67401424" class="indexterm"></a><a id="idp67401936" class="indexterm"></a><p>StackGuard is one such add-on that is implemented as a
        small patch to the gcc code generator.  From the <a class="link" href="http://immunix.org/stackguard.html" target="_top">StackGuard
          website</a>:

        </p><div class="blockquote"><blockquote class="blockquote"><p>"StackGuard detects and defeats stack
        smashing attacks by protecting the return address on the stack
        from being altered.  StackGuard places a "canary" word next to
        the return address when a function is called.  If the canary
        word has been altered when the function returns, then a stack
        smashing attack has been attempted, and the program responds
        by emitting an intruder alert into syslog, and then
        halts."</p></blockquote></div><p>

        </p><div class="blockquote"><blockquote class="blockquote"><p>"StackGuard is implemented as a small patch
        to the gcc code generator, specifically the function_prolog()
        and function_epilog() routines.  function_prolog() has been
        enhanced to lay down canaries on the stack when functions
        start, and function_epilog() checks canary integrity when the
        function exits.  Any attempt at corrupting the return address
        is thus detected before the function
        returns."</p></blockquote></div><p>
        </p><a id="idp67404624" class="indexterm"></a><p>Recompiling your application with StackGuard is an
        effective means of stopping most buffer-overflow attacks, but
        it can still be compromised.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67405648"></a>3.3.2.2. Library based run-time bounds checking</h4></div></div></div><a id="idp67406160" class="indexterm"></a><p>Compiler-based mechanisms are completely useless for
        binary-only software for which you cannot recompile.  For
        these situations there are a number of libraries which
        re-implement the unsafe functions of the C-library
        (<code class="function">strcpy</code>, <code class="function">fscanf</code>,
        <code class="function">getwd</code>, etc..) and ensure that these
        functions can never write past the stack pointer.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">libsafe</li><li class="listitem">libverify</li><li class="listitem">libparanoia</li></ul></div><p>Unfortunately these library-based defenses have a number
        of shortcomings.  These libraries only protect against a very
        small set of security related issues and they neglect to fix
        the actual problem.  These defenses may fail if the
        application was compiled with -fomit-frame-pointer.  Also, the
        LD_PRELOAD and LD_LIBRARY_PATH environment variables can be
        overwritten/unset by the user.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="secure-philosophy.html">前一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="secure.html">上一層</a></td><td width="40%" align="right"> <a accesskey="n" href="secure-setuid.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. Secure Design
      Methodology </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 3.4. SetUID issues</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文及其他文件，可由此下載：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>若有 FreeBSD 方面疑問，請先閱讀
    <a href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;。<br></br>
    關於本文件的問題，請洽詢
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;。</small></p></body></html>