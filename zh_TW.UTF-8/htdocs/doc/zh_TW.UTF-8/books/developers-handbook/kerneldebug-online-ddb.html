<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>9.5. On-Line Kernel Debugging Using DDB</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="kerneldebug.html" title="章 9. Kernel Debugging" /><link rel="prev" href="kerneldebug-post-mortem.html" title="9.4. Post-Mortem Analysis of a Dump" /><link rel="next" href="kerneldebug-online-gdb.html" title="9.6. On-Line Kernel Debugging Using Remote GDB" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9.5. On-Line Kernel Debugging Using DDB</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kerneldebug-post-mortem.html">前一頁</a> </td><th width="60%" align="center">章 9. Kernel Debugging</th><td width="20%" align="right"> <a accesskey="n" href="kerneldebug-online-gdb.html">下一頁</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kerneldebug-online-ddb"></a>9.5. On-Line Kernel Debugging Using DDB</h2></div></div></div><p>While <code class="command">gdb -k</code> as an off-line debugger provides a very
      high level of user interface, there are some things it cannot do.  The
      most important ones being breakpointing and single-stepping kernel
      code.</p><p>If you need to do low-level debugging on your kernel, there is an
      on-line debugger available called DDB.  It allows setting of
      breakpoints, single-stepping kernel functions, examining and changing
      kernel variables, etc.  However, it cannot access kernel source files,
      and only has access to the global and static symbols, not to the full
      debug information like <code class="command">gdb</code> does.</p><p>To configure your kernel to include DDB, add the option line

      </p><pre class="programlisting">options DDB</pre><p>

      to your config file, and rebuild.  (See <a class="link" href="../../../../doc/zh_TW.UTF-8/books/handbook/index.html" target="_top">The FreeBSD Handbook</a> for details on
      configuring the FreeBSD kernel).</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">If you have an older version of the boot blocks, your
	debugger symbols might not be loaded at all.  Update the boot blocks;
	the recent ones load the DDB symbols automatically.</p></div><p>Once your DDB kernel is running, there are several ways to enter
      DDB.  The first, and earliest way is to type the boot flag
      <code class="option">-d</code> right at the boot prompt.  The kernel will start up
      in debug mode and enter DDB prior to any device probing.  Hence you can
      even debug the device probe/attach functions.</p><p>The second scenario is to drop to the debugger once the
      system has booted.  There are two simple ways to accomplish
      this.  If you would like to break to the debugger from the
      command prompt, simply type the command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl debug.enter_debugger=ddb</code></strong></pre><p>Alternatively, if you are at the system console, you may use
      a hot-key on the keyboard.  The default break-to-debugger
      sequence is <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>ESC</strong></span>.  For
      syscons, this sequence can be remapped and some of the
      distributed maps out there do this, so check to make sure you
      know the right sequence to use.  There is an option available
      for serial consoles that allows the use of a serial line BREAK on the
      console line to enter DDB (<code class="literal">options BREAK_TO_DEBUGGER</code>
      in the kernel config file).  It is not the default since there are a lot
      of serial adapters around that gratuitously generate a BREAK
      condition, for example when pulling the cable.</p><p>The third way is that any panic condition will branch to DDB if the
      kernel is configured to use it.  For this reason, it is not wise to
      configure a kernel with DDB for a machine running unattended.</p><p>The DDB commands roughly resemble some <code class="command">gdb</code>
      commands.  The first thing you probably need to do is to set a
      breakpoint:</p><pre class="screen"><strong class="userinput"><code>b function-name</code></strong>
<strong class="userinput"><code>b address</code></strong></pre><p>Numbers are taken hexadecimal by default, but to make them distinct
      from symbol names; hexadecimal numbers starting with the letters
      <code class="literal">a-f</code> need to be preceded with <code class="literal">0x</code>
      (this is optional for other numbers).  Simple expressions are allowed,
      for example: <code class="literal">function-name + 0x103</code>.</p><p>To continue the operation of an interrupted kernel, simply
      type:</p><pre class="screen"><strong class="userinput"><code>c</code></strong></pre><p>To get a stack trace, use:</p><pre class="screen"><strong class="userinput"><code>trace</code></strong></pre><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">Note that when entering DDB via a hot-key, the kernel is currently
	servicing an interrupt, so the stack trace might be not of much use
	to you.</p></div><p>If you want to remove a breakpoint, use</p><pre class="screen"><strong class="userinput"><code>del</code></strong>
<strong class="userinput"><code>del address-expression</code></strong></pre><p>The first form will be accepted immediately after a breakpoint hit,
      and deletes the current breakpoint.  The second form can remove any
      breakpoint, but you need to specify the exact address; this can be
      obtained from:</p><pre class="screen"><strong class="userinput"><code>show b</code></strong></pre><p>To single-step the kernel, try:</p><pre class="screen"><strong class="userinput"><code>s</code></strong></pre><p>This will step into functions, but you can make DDB trace them until
      the matching return statement is reached by:</p><pre class="screen"><strong class="userinput"><code>n</code></strong></pre><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">This is different from <code class="command">gdb</code>'s
	<code class="command">next</code> statement; it is like <code class="command">gdb</code>'s
	<code class="command">finish</code>.</p></div><p>To examine data from memory, use (for example):

      </p><pre class="screen"><strong class="userinput"><code>x/wx 0xf0133fe0,40</code></strong>
<strong class="userinput"><code>x/hd db_symtab_space</code></strong>
<strong class="userinput"><code>x/bc termbuf,10</code></strong>
<strong class="userinput"><code>x/s stringbuf</code></strong></pre><p>

      for word/halfword/byte access, and hexadecimal/decimal/character/ string
      display.  The number after the comma is the object count.  To display
      the next 0x10 items, simply use:</p><pre class="screen"><strong class="userinput"><code>x ,10</code></strong></pre><p>Similarly, use

      </p><pre class="screen"><strong class="userinput"><code>x/ia foofunc,10</code></strong></pre><p>

      to disassemble the first 0x10 instructions of
      <code class="function">foofunc</code>, and display them along with their offset
      from the beginning of <code class="function">foofunc</code>.</p><p>To modify memory, use the write command:</p><pre class="screen"><strong class="userinput"><code>w/b termbuf 0xa 0xb 0</code></strong>
<strong class="userinput"><code>w/w 0xf0010030 0 0</code></strong></pre><p>The command modifier
      (<code class="literal">b</code>/<code class="literal">h</code>/<code class="literal">w</code>)
      specifies the size of the data to be written, the first following
      expression is the address to write to and the remainder is interpreted
      as data to write to successive memory locations.</p><p>If you need to know the current registers, use:</p><pre class="screen"><strong class="userinput"><code>show reg</code></strong></pre><p>Alternatively, you can display a single register value by e.g.

      </p><pre class="screen"><strong class="userinput"><code>p $eax</code></strong></pre><p>

      and modify it by:</p><pre class="screen"><strong class="userinput"><code>set $eax new-value</code></strong></pre><p>Should you need to call some kernel functions from DDB, simply
      say:</p><pre class="screen"><strong class="userinput"><code>call func(arg1, arg2, ...)</code></strong></pre><p>The return value will be printed.</p><p>For a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> style summary of all running processes, use:</p><pre class="screen"><strong class="userinput"><code>ps</code></strong></pre><p>Now you have examined why your kernel failed, and you wish to
      reboot.  Remember that, depending on the severity of previous
      malfunctioning, not all parts of the kernel might still be working as
      expected.  Perform one of the following actions to shut down and reboot
      your system:</p><pre class="screen"><strong class="userinput"><code>panic</code></strong></pre><p>This will cause your kernel to dump core and reboot, so you can
      later analyze the core on a higher level with <code class="command">gdb</code>.  This command
      usually must be followed by another <code class="command">continue</code>
      statement.</p><pre class="screen"><strong class="userinput"><code>call boot(0)</code></strong></pre><p>Which might be a good way to cleanly shut down the running system,
      <code class="function">sync()</code> all disks, and finally reboot.  As long as
      the disk and filesystem interfaces of the kernel are not damaged, this
      might be a good way for an almost clean shutdown.</p><pre class="screen"><strong class="userinput"><code>call cpu_reset()</code></strong></pre><p>This is the final way out of disaster and almost the same as hitting the
      Big Red Button.</p><p>If you need a short command summary, simply type:</p><pre class="screen"><strong class="userinput"><code>help</code></strong></pre><p>However, it is highly recommended to have a printed copy of the
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ddb&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ddb</span>(4)</span></a> manual page ready for a debugging
      session.  Remember that it is hard to read the on-line manual while
      single-stepping the kernel.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kerneldebug-post-mortem.html">前一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="kerneldebug.html">上一層</a></td><td width="40%" align="right"> <a accesskey="n" href="kerneldebug-online-gdb.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">9.4. Post-Mortem Analysis of a Dump </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 9.6. On-Line Kernel Debugging Using Remote GDB</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文及其他文件，可由此下載：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>若有 FreeBSD 方面疑問，請先閱讀
    <a href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;。<br></br>
    關於本文件的問題，請洽詢
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;。</small></p></body></html>