<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 18. Tópicos Avançados</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="up" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="prev" href="funnies.html" title="Capítulo 17. As gracinhas do FreeBSD" /><link rel="next" href="acknowledgments.html" title="Capítulo 19. Reconhecimentos" /><link rel="copyright" href="legalnotice.html" title="Nota Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 18. Tópicos Avançados</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="funnies.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="acknowledgments.html">Próxima</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="advanced"></a>Capítulo 18. Tópicos Avançados</h1></div></div></div><div class="qandaset"><a id="idp70852944"></a><dl><dt>18.1. <a href="advanced.html#idp70853328">Como eu posso aprender mais sobre as
	    características internas do FreeBSD?</a></dt><dt>18.2. <a href="advanced.html#idp70856272">Como posso contribuir com o projeto FreeBSD?</a></dt><dt>18.3. <a href="advanced.html#idp70858832">O que são SNAPs e RELEASEs?</a></dt><dt>18.4. <a href="advanced.html#idp70884944">Como faço a minha própria
	    distribuição personalizada?</a></dt><dt>18.5. <a href="advanced.html#idp70887632">Por que o make world sobrescreve os
	    binários já instalados?</a></dt><dt>18.6. <a href="advanced.html#idp70896976">Por que quando meu sistema inicializa, ele diz
	    &#8220;(bus speed defaulted)&#8221;?</a></dt><dt>18.7. <a href="advanced.html#idp70900176">Posso acompanhar a série -CURRENT mesmo tendo
	    acesso limitado à Internet?</a></dt><dt>18.8. <a href="advanced.html#idp70903376">Como o FreeBSD foi dividido em arquivos de
	    240k?</a></dt><dt>18.9. <a href="advanced.html#idp70906960">Eu escrevi uma extensão para o
	    kernel; a quem eu
	    envio?</a></dt><dt>18.10. <a href="advanced.html#idp70910544">Como as placas Plug N Play ISA são detectadas e
	    inicializadas?</a></dt><dt>18.11. <a href="advanced.html#idp70927824">Vocês podem definir um número principal
	    para um driver de dispositivo que eu escrevi?</a></dt><dt>18.12. <a href="advanced.html#idp70931536">E sobre políticas alternativas de layout de
	    diretórios?</a></dt><dt>18.13. <a href="advanced.html#idp70934096">O que fazer com os dados que eu vejo quando tenho um
	    kernel panic?</a></dt><dt>18.14. <a href="advanced.html#idp71000016">Por que a dlsym() não funciona mais nos
	    executáveis ELF?</a></dt><dt>18.15. <a href="advanced.html#idp71005008">Como eu posso aumentar ou reduzir o espaço de
	    endereçamento disponível para o
	    kernel?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp70853328"></a><a id="learn-advanced"></a><p><strong>18.1.</strong></p></td><td align="left" valign="top"><p>Como eu posso aprender mais sobre as
	    características internas do FreeBSD?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> Atualmente não há nenhum livro
	    específico sobre as características internas
	    do Sistema Operacional FreeBSD.  Contudo, a maior parte do
	    conhecimento genérico sobre UNIX pode ser aplicado
	    diretamente a ele.  Além disso existem livros
	    específicos para sistemas BSD cuja leitura é
	    recomendada.</p><p>Para uma lista, verifique a sessão de <a class="link" href="../handbook/bibliography-osinternals.html" target="_top">
	      bibliografia sobre características internas dos
	      sistemas operacionais</a> no
	    Manual do FreeBSD.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70856272"></a><a id="how-to-contribute"></a><p><strong>18.2.</strong></p></td><td align="left" valign="top"><p>Como posso contribuir com o projeto FreeBSD?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por gentileza, consulte o artigo <a class="link" href="../../articles/contributing/article.html" target="_top">Contribuindo
	      com o Projeto FreeBSD</a> para obter algumas dicas
	    sobre o assunto.  Toda ajuda é mais que bem
	    vinda!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70858832"></a><a id="define-snap-release"></a><p><strong>18.3.</strong></p></td><td align="left" valign="top"><p>O que são SNAPs e RELEASEs?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Atualmente existem três séries
	    ativas/semi-ativas no <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">Repositório
	      CVS</a> do projeto FreeBSD (a RELENG_2 que é
	    provavelmente alterada somente duas vezes ao ano, sendo
	    esta a razão de termos somente três
	    séries em desenvolvimento):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">RELENG_2_2</code>   ou
		<span class="emphasis"><em>2.2-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">RELENG_3</code>     ou
		<span class="emphasis"><em>3.X-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">RELENG_4</code>     ou
		<span class="emphasis"><em>4-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">HEAD</code>        ou
		<span class="emphasis"><em>-CURRENT</em></span>    ou
		<span class="emphasis"><em>5.0-CURRENT</em></span></p></li></ul></div><p><code class="literal">HEAD</code> não é um nome de
	    uma tag de série, como os outros dois; é
	    somente uma constante simbólica para
	    <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>o atual desenvolvimento corrente, mas
		não de série</em></span></span>&#8221;</span> a qual
	    nós simplesmente nos referimos como
	    <span class="quote">&#8220;<span class="quote">-CURRENT</span>&#8221;</span>.</p><p>Neste momento, a <span class="quote">&#8220;<span class="quote">-CURRENT</span>&#8221;</span> se refere ao
	    desenvolvimento atual do FreeBSD 5.0.  A série
	    <code class="literal">4-STABLE</code>, <span class="symbol">RELENG_4</span>
	    originou-se da <span class="quote">&#8220;<span class="quote">-CURRENT</span>&#8221;</span> em Março de
	    2000.</p><p>A série <code class="literal">2.2-STABLE</code>,
	    <span class="symbol">RELENG_2_2</span>, originou-se da
	    <span class="quote">&#8220;<span class="quote">-CURRENT</span>&#8221;</span> em Novembro de 1996, e foi
	    praticamente descontinuada.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70884944"></a><a id="custrel"></a><p><strong>18.4.</strong></p></td><td align="left" valign="top"><p>Como faço a minha própria
	    distribuição personalizada?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por gentileza, consulte o artigo sobre a <a class="link" href="../../articles/releng/article.html" target="_top">Engenharia de
	      Releases.</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70887632"></a><a id="makeworld-clobbers"></a><p><strong>18.5.</strong></p></td><td align="left" valign="top"><p>Por que o <code class="command">make world</code> sobrescreve os
	    binários já instalados?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Porque essa é a idéia geral sobre como
	    ele deve funcionar; como seu nome sugere, o <code class="command">make
	      world</code> reconstrói todo o sistema
	    binário a partir do zero, garantindo que o
	    usuário tenha um ambiente limpo e consistente ao
	    final da operação (é por isso que o
	    processo demora tanto).</p><p>Se a variável de ambiente
	    <code class="literal">DESTDIR</code> estiver definida enquanto um
	    <code class="command">make world</code> ou <code class="command">make
	      installworld</code> estiver sendo executado, os
	    binários recém criados serão
	    distribuídos no diretório definido em
	    <code class="literal">${DESTDIR}</code>, criando no mesmo uma
	    réplica do conteúdo do / do sistema.
	    Algumas alterações aleatórias nas
	    bibliotecas compartilhadas podem ocasionar falhas na hora
	    de reconstruir o sistema com o <code class="command">make
	      world</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70896976"></a><a id="bus-speed-defaulted"></a><p><strong>18.6.</strong></p></td><td align="left" valign="top"><p>Por que quando meu sistema inicializa, ele diz
	    <span class="quote">&#8220;<span class="quote">(bus speed defaulted)</span>&#8221;</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Os controladores SCSI Adaptec 1542 permitem que o
	    usuário defina a velocidade de acesso ao barramento
	    por meio de software.  Algumas versões mais antigas
	    deste dispositivo tentavam determinar automaticamente a
	    maior velocidade possível e tentavam ajustar sua
	    velocidade à esse limite máximo.
	    Descobriu-se contudo, que esse comportamento as vezes era
	    prejudicial, e fazia com que algumas máquinas
	    não funcionassem de forma adequada, por este motivo
	    essa característica agora vem desabilitada por
	    default, para ativá-la é necessário
	    definir a opção <span class="symbol">TUNE_1542</span>
	    no <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD.  Essa
	    opção, em sistemas onde ela se aplica,
	    provavelmente assegura que seus discos sejam acessados de
	    forma mais rápida e eficiente; contudo, em sistemas
	    onde o uso desse algoritmo é inviável, pode
	    resultar em perda de dados.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70900176"></a><a id="ctm"></a><p><strong>18.7.</strong></p></td><td align="left" valign="top"><p>Posso acompanhar a série -CURRENT mesmo tendo
	    acesso limitado à Internet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sim, é possível acompanhar a
	    série de desenvolvimento <code class="literal">sem
	      precisar</code> baixar sempre todo o codigo fonte do
	    sistema, basta utilizar o <a class="link" href="../handbook/synching.html#CTM" target="_top">recurso de
	      CTM</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70903376"></a><a id="split-240k"></a><p><strong>18.8.</strong></p></td><td align="left" valign="top"><p>Como o FreeBSD foi dividido em arquivos de
	    240k?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O comando split que acompanha as novas versões
	    dos sistemas BSD têm uma opção
	    <code class="option">-b</code> que permite dividir os arquivos em
	    limites arbitrários de bytes.</p><p>Eis um exemplo tirado do
	    <code class="filename">/usr/src/Makefile</code>.</p><pre class="programlisting">bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70906960"></a><a id="submitting-kernel-extensions"></a><p><strong>18.9.</strong></p></td><td align="left" valign="top"><p>Eu escrevi uma extensão para o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>; a quem eu
	    envio?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por gentileza, consulte o artigo <span class="quote">&#8220;<span class="quote"><a class="link" href="../../articles/contributing/article.html" target="_top">Contribuindo
		com o Projeto FreeBSD</a></span>&#8221;</span> para obter mais
	    informações sobre como enviar código
	    fonte ao projeto.</p><p>E obrigado pelo seu interesse! :)</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70910544"></a><a id="pnp-initialize"></a><p><strong>18.10.</strong></p></td><td align="left" valign="top"><p>Como as placas Plug N Play ISA são detectadas e
	    inicializadas?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por: Frank Durda IV
	    <code class="email">&lt;<a xmlns="" class="email" href="mailto:uhclem@nemesis.lonestar.org">uhclem@nemesis.lonestar.org</a>&gt;</code></p><p>Simplificando, existem poucas portas de E/S que todas
	    as placas PnP respondem quando o sistema indaga se algum
	    dispositivo está usando-a.  Então, quando a
	    rotina de procura do PnP começa, ele pergunta se
	    há alguma placa PnP presente, e todas as placas PnP
	    respondem com seus respectivos números de modelo
	    para uma leitura de E/S da mesma porta.  A rotina de
	    procura recebe então um sinal wired-OR
	    representando um <span class="quote">&#8220;<span class="quote">sim</span>&#8221;</span> à pergunta em
	    questão.  Ao menos um bit positivo constitui essa
	    resposta.  Então o código de procura
	    é capaz de fazer com que as placas com o modelo de
	    identificação (atribuído pela
	    Microsoft/Intel) inferior a X sejam colocados em modo
	    <span class="quote">&#8220;<span class="quote">off-line</span>&#8221;</span>.  Ele então irá
	    verificar se alguma placa respondeu a consulta.  Se a
	    resposta for <code class="literal">0</code> o sistema assume que
	    não há placas com
	    identificação acima de X.  Depois a rotina
	    de busca verifica se há alguma placa cujo ID
	    é inferior a <code class="literal">X</code>.  Se a resposta
	    for positiva, a rotina de busca sabe que ainda existem
	    placas identificadas com um valor menor que X.  Aí
	    a busca tenta identificar placas com ID superior à
	    X (limite / 4) e ordena que entrem em modo off-line.
	    Repete-se o ciclo de pesquisas e
	    identificações nessa forma
	    semi-binária até que um número
	    necessário de interações seja
	    concluído.  Ao final do processo o sistema
	    terá identificado todas as placas PnP presentes na
	    máquina em questão, com o número de
	    interações necessárias sempre menor
	    que 2^64.</p><p>Os IDs (códigos de identificação)
	    são dois campos de 32-bits (portanto, 2^64)
	    acrescidos de 8 bits que é o checksum
	    (verificação de consistência de
	    dados).  Os primeiros 32 bits identificam o fabricante da
	    placa.  Nenhum fabricante assume isso, mas podemos
	    perceber que diferentes tipos de placas do mesmo
	    fabricante costumam ter diferentes
	    identificações de 32-bit.  O motivo correto,
	    não se sabe, mas percebe-se que 32 bits exclusivos
	    para os fabricantes chega a ser um exagero.</p><p>Os últimos 32 bits é um número
	    serial que torna a identificação dessa placa
	    única.  O fabricante não pode nunca produzir
	    uma placa que tenha os 32 bits finais iguais, a não
	    ser que os 32 bits iniciais sejam distintos.  Dessa forma
	    é possível existir várias placas do
	    mesmo tipo e fabricante, e ainda assim todos os 64 bits
	    dessas placas serem únicos.</p><p>Os grupos de 32 bits nunca podem ser todos zero.  Isso
	    permite ao wired-OR identificar bits não nulos
	    durante a procura binária inicial.</p><p>Uma vez que o sistema tenha identificado todas as IDs
	    presentes, ele vai reativar cada placa, uma por vez (pela
	    mesma porta de E/S) e achar os recursos que cada uma
	    necessita, quais opções de
	    interrupções estão
	    disponíveis, etc.  Uma busca é feita em
	    todas as placas para obter estas
	    informações.</p><p>Tal informação é então
	    combinada com as informações encontradas nos
	    arquivos ECU, no sistema, ou então da MLB BIOS.  O
	    suporte da BIOS PnP e da ECU costuma ser sintética,
	    portanto os periféricos não são
	    exatamente PnP como é dito.  Contudo, ao examinar as
	    informações da da BIOS e da ECU, as rotinas
	    de busca podem identificar dispositivos ditos PnP e evitar
	    que eles requeiram recursos também
	    necessários por outros dispositivos, que por sua
	    vez não podem realocar tais valores
	    automaticamente.</p><p>Os dispositivos PnP são visitados mais uma vez
	    e recebem seus endereços de E/S, DMA, IRQ e
	    endereçamentos atribuídos na memória.
	    Os dispositivos permaneceram naquela ordem até a
	    próxima inicialização do sistema,
	    apesar de que nada impede que eles sejam movidos quando se
	    desejar.</p><p>Essa explicação é muito
	    simplista, mas provavelmente você entendeu a
	    idéia geral do comportamento PnP.</p><p>A Microsoft fez um exame sobre algumas das portas
	    primárias de status de impressoras para fazer PnP,
	    dentro da lógica que nenhuma placa poderia
	    decodificar aqueles endereços para os ciclos
	    opostos de E/S.  Eu encontrei uma placa genuína de
	    impressora IBM que enviou dados decodificados da porta de
	    status durante o começo do período da
	    proposta de revisão do PnP, mas a Microsoft
	    <span class="quote">&#8220;<span class="quote">ficou brava</span>&#8221;</span>.  Então eles resolveram
	    fazer um envio para a porta de status da impressora, de
	    forma a justar o endereço usado (naquele instante +
	    <code class="literal">0x800</code>) e uma terceira porta de E/S para
	    a leitura que tecnicamente pode ser localizada em qualquer
	    lugar entre <code class="literal">0x200</code> e
	    <code class="literal">0x3ff</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70927824"></a><a id="major-numbers"></a><p><strong>18.11.</strong></p></td><td align="left" valign="top"><p>Vocês podem definir um número principal
	    para um driver de dispositivo que eu escrevi?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Isso depende se você pretende tornar o driver
	    disponível para o público.  Se sim,
	    então por favor nos mande uma cópia do
	    código-fonte do driver, mais as devidas
	    modificações para o
	    <code class="filename">files.i386</code>, um exemplo do arquivo de
	    configuração, e os devidos códigos do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">MAKEDEV</span>(8)</span></a> para criar qualquer arquivo especial que
	    seu dispositivo precise.  Se você não pode,
	    ou está impedido por causa de
	    restrições de licença, então o
	    character major number 32 e o block major number 8
	    estão reservados especificadamente para este
	    propósito; por favor, use-os.  De qualquer maneira,
	    nós gostaríamos de obter maiores
	    informações sobre seu driver na
	    <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers" target="_top">lista de discussão
  de assuntos técnicos relacionados ao FreeBSD</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70931536"></a><a id="alternate-directory-layout"></a><p><strong>18.12.</strong></p></td><td align="left" valign="top"><p>E sobre políticas alternativas de layout de
	    diretórios?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Em resposta a questão da política de
	    formatos alternativos para diretórios, o esquema
	    que está atualmente em uso está
	    imutável desde quando eu o escrevi em 1983.  Eu
	    escrevi aquela política para o FFS (fast
	    filesystem) original, e nunca o revisei.  Ele funciona bem
	    em evitar que os os grupos de cilindros sejam
	    completamente preenchidos.  Como muitos de vocês
	    notaram, ele funciona mediocremente para procura.  A
	    maioria dos sistemas de arquivos são criados
	    à partir de arquivos que foram criados por uma
	    primeira procura em profundidade (depth first search,
	    também conhecido como ftw).  Estes
	    diretórios acabam sendo distribuídos pelo
	    grupo de cilindros, criando assim um cenário
	    horrível em relação a futuras
	    primeiras buscas de profundidade.  Se pudéssemos
	    saber o número total de diretórios a serem
	    criados, a solução seria criar (total /
	    fs_ncg) por grupo de cilindros antes de movê-los.
	    Evidentemente, seria necessário criar um conjunto
	    de métodos heurísticos para adivinhar esse
	    número.  Mesmo usando um pequeno número
	    fixo, digamos 10, ele produziria um aumento na ordem de
	    magnitude.  Para diferenciar restaurações de
	    operações normais (quando o algoritmo atual
	    é provavelmente mais sensível), você
	    poderia usar o agrupamento acima de 10 se eles fossem
	    finalizados dentro de uma janela de dez segundos.  De
	    qualquer maneira, minha conclusão é que isso
	    é uma área pronta para
	    experimentações. </p><p>Kirk McKusick, Setembro de 1998</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70934096"></a><a id="kernel-panic-troubleshooting"></a><p><strong>18.13.</strong></p></td><td align="left" valign="top"><p>O que fazer com os dados que eu vejo quando tenho um
	    kernel panic?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="emphasis"><em>[Esta seção foi
	      extraída de um e-mail escrito por Bill Paul na
	      <a class="link" href="support.html#mailing" title="2.3.">freebsd-current</a> por
	      Dag-Erling C. Smørgrav, que arrumou alguns problemas de
	      impressão e adicionou os comentários entre
	      chaves]</em></span></p><pre class="programlisting">From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: Ben Rosengart
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org</pre><p><span class="emphasis"><em>Ben Rosengart posted the following panic
	      message]</em></span></p><pre class="programlisting">&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</pre><p>[Quando] você vê uma mensagem como essa,
	    não é suficiente somente reproduzí-la
	    e enviá-la em um e-mail.  O valor do ponteiro de
	    instrução (instruction pointer) que eu
	    destaquei acima é muito importante; infelizmente,
	    ele também depende de configuração.
	    Em outras palavras, os valores variam de acordo com a
	    exata imagem do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> que
	    você estiver usando.  Se você estiver usando
	    uma imagem GENERIC do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> de um dos
	    <span class="foreignphrase"><em class="foreignphrase">snapshots</em></span>, então
	    é possível que alguém acompanhe a
	    função ofensiva, mas se você
	    está rodando um
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> customizado
	    então só <span class="emphasis"><em>você</em></span>
	    pode nos dizer aonde a falha ocorreu.</p><p>O que você deve fazer é isso:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Anote o valor do ponteiro de
		instrução.  Observe que o 0x8: parte do
		começo não é significante.  Nesse
		caso é o <code class="literal">0xf0xxxxxx</code> que
		nós queremos.</p></li><li class="step"><p>Quando o sistema reinicializar, faça o seguinte:

		</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</code></strong></pre><p>

		Onde <code class="literal">f0xxxxxx</code> é o valor do
		ponteiro de instrução.  As chances
		são que você não terá um
		resultado exato visto que os símbolos na tabela
		de símbolos do
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> são para
		os pontos de entrada (entry points) de
		funções e o endereço do ponteiro
		de instrução estarão em algum
		lugar dentro de uma função, não
		no começo.  Se você não receber um
		resultado exato, omita o último dígito
		do valor do ponteiro de instrução e
		tente novamente, ex:

		</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</code></strong></pre><p>

		Se isso não produz nenhum resultado, corte
		outro dígito.  Repita até que você
		tenha algum tipo de retorno.  O resultado será
		uma possível lista de funções que
		causaram o panic.  Isso é menos do que um
		mecanismo exato para rastreamento de um ponto de
		falha, mas é melhor que nada.</p></li></ol></div><p>Eu vejo pessoas constantemente mostrando mensagens de
	    panic como essa, mas eu raramente vejo alguém
	    comparar o ponteiro de instrução com uma
	    função na tabela de símbolos do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.</p><p>A melhor maneira de rastrear a causa de um panic
	    é guardar as mensagens de falha (crash dump), e
	    então usar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> para gerar um stack trace
	    da falha.</p><p>Em qualquer caso, o método que eu normalmente
	    uso é esse:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Definir um arquivo de configuração
		do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>,
		opcionalmente adiconando a <code class="literal">options
		  DDB</code> se você acha que precisa do
		debugger do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para
		algo.  (Eu uso isso principalmente para ajustar
		breakpoints se eu suspeito que há uma
		condição de laço infinito
		(infinite loop ou algo do tipo).</p></li><li class="step"><p>Use <code class="command">config -g
		  KERNELCONFIG</code>
		configurar o diretório da
		construção.</p></li><li class="step"><p><code class="command">cd /sys/compile/
		  KERNELCONFIG; make
		</code></p></li><li class="step"><p>Espere o <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>
		acabar de compilar.</p></li><li class="step"><p><code class="command">make install</code></p></li><li class="step"><p>reboot</p></li></ol></div><p>O processo do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> terá
	    construído dois
	    <span class="foreignphrase"><em class="foreignphrase">kernels</em></span>.
	    <code class="filename">kernel</code> e
	    <code class="filename">kernel.debug</code>.  O
	    <code class="filename">kernel</code> foi instalado como
	    <code class="filename">/kernel</code>, enquanto o
	    <code class="filename">kernel.debug</code> pode ser usado como
	    fonte símbolos de debug para o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>.</p><p>Para ter certeza que você irá capturar o
	    crash dump, você precisa editar o
	    <code class="filename">/etc/rc.conf</code> e ajustar o
	    <code class="literal">dumpdev</code> para apontar para sua
	    partição swap.  Isso fará com que os
	    scripts <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> usem o comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> para
	    habilitar os crash dumps.  Você pode também
	    executar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> manualmente.  Depois de um panic,
	    o crash dump pode ser recuperado usando o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>;
	    se variavel <code class="literal">dumpdev</code> estiver definida no
	    <code class="filename">/etc/rc.conf</code>, os scripts <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>
	    irão executar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> automaticamente e
	    colocar o crash dump em
	    <code class="filename">/var/crash</code>.</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">Os crash dumps do FreeBSD são geralmente do
	      mesmo tamanho da memória RAM física da sua
	      máquina.  Isto é, se você tem 64MB
	      de RAM, você terá um crash dump de 64MB.
	      Então você deve ter certeza que há
	      espaço suficiente em
	      <code class="filename">/var/crash</code> para alocar o dump.
	      Alternativamente, você executa o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
	      manualmente e pode fazê-lo recuperar o crash dump
	      para onde você tenha mais espaço.  É
	      possível limitar o tamanho do crash dump
	      utilizando a opção <code class="literal">options
		MAXMEM=(foo)</code> para ajustar a quantia de
	      memória que o
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> irá usar
	      para algo um pouco mais sensível.  Por exemplo,
	      se você tem 128MB de RAM, você pode limitar
	      o uso de memória do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para 16MB para que
	      o tamanho do seu crash dump tenha somente 16MB ao
	      invés de 128MB.</p></div><p>Uma vez que você recuperou o crash dump,
	    você pode ter um stack trace com o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> como
	    segue:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>where</code></strong></pre><p>Note que há várias telas com
	    informações valiosas; seria ideal o uso do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> para capturar todas elas.  Usando a imagem
	    (unstripped) do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> com
	    todos os símbolos de debug deve mostrar a linha
	    exata do código-fonte do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> onde o panic
	    ocorreu.  Geralmente é mais interessante ler o
	    stack trace de baixo para cima a fim de rastrear a exata
	    seqüência de eventos que levaram ao crash.
	    Você também pode usar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> para
	    exibir os conteúdos de várias
	    variáveis ou estruturas a fim de examinar o estado
	    do sistema no instante do crash.</p><p>Agora, se você é realmente louco e tem um
	    segundo computador, você também pode
	    configurar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> para executar um debug remoto,
	    tanto que você pode usar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> em um sistema
	    para debugar o <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> em
	    outro sistema, incluindo o ajuste de breakpoints,
	    rastreamento passo-a-passo pelo código do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, do mesmo modo que
	    você pode fazer com um programa do modo de
	    usuário normal.  Eu ainda não brinquei com
	    isso pois não tive a chance de configurar duas lado
	    a lado com o único propósito de
	    debugging.</p><p><span class="emphasis"><em>[Adendo de Bill: "Eu esqueci de
	      mencionar uma coisa: se você tem DDB habilitado e
	      o <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> em modo de
	      debug, você pode forçar um panic (e um
	      crash dump) apenas digitando ´panic´ no
	      prompt do ddb.  Ele pode parar no debugger novamente
	      durante a fase de panic.  Se isso acontecer, digite
	      ´continue´ e ele finalizará o crash
	      dump."-ed]</em></span></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp71000016"></a><a id="dlsym-failure"></a><p><strong>18.14.</strong></p></td><td align="left" valign="top"><p>Por que a dlsym() não funciona mais nos
	    executáveis ELF?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A toolchain (cadeia de ferramentas) ELF não
	    faz, por padrão, os símbolos definidos em um
	    executável visível para o linkador
	    dinâmico (dynamic linker).  Conseqüentemente, a
	    procura em nomes obtidos de chamadas com a
	    <code class="function">dlsym()</code> para <code class="function">dlopen(NULL,
	      flags)</code>  irá falhar ao buscar tais
	    símbolos.</p><p>Se a intenção é usar a
	    <code class="function">dlsym()</code> para buscar símbolos
	    que possam existir nos executáveis principais do
	    processo, é necessário linkar o programa com
	    a opção <code class="option">-export-dynamic</code> com
	    o linker ELF (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp71005008"></a><a id="change-kernel-address-space"></a><p><strong>18.15.</strong></p></td><td align="left" valign="top"><p>Como eu posso aumentar ou reduzir o espaço de
	    endereçamento disponível para o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por padrão, o espaço de
	    endereçamento (address space) do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> é 256 MB no
	    FreeBSD 3.x e 1 GB no FreeBSD 4.x.  Em um servidor de rede
	    com tráfego intensivo (por exemplo, um servidor FTP
	    ou HTTP de muito tráfego) pode acontecer de, por
	    exemplo, 256MB de memória não ser o
	    suficiente.</p><p>Mas então, como aumentar esse espaço?
	    Existem duas formas.  Primeiro, é necessário
	    dizer ao <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> que ele
	    deve reservar uma grande quantidade de espaço em
	    memória para ele mesmo.  Segundo, considerando que
	    o <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> é carregado
	    no topo do espaço de endereçamento, é
	    preciso diminuir o endereço de forma que não
	    conflite com as páginas anteriores de
	    memória, e que no lugar disso, ele seja carregado
	    em seu novo local.</p><p>O primeiro objetivo é facilmente atingido
	    aumentando as definições de valores do
	    <code class="literal">NKPDE</code> no arquivo
	    <code class="filename">src/sys/i386/include/pmap.h</code>.  Aqui
	    está o arquivo, como deve ser, para 1GB de
	    endereço de memória:</p><pre class="programlisting">#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</pre><p>Para achar o valor correto de
	    <code class="literal">NKPDE</code>, divida o número desejado
	    (em megabytes) por quatro, então subtraia um para
	    máquinas mono processadas e dois para
	    máquinas com SMP.</p><p>Para atingir o segundo objetivo é
	    necessário descobrir o endereço correto de
	    carregamento.  Para isso basta subtrair o tamanho do
	    espaço de endereçamento desejado (em bytes)
	    de 0x100100000; o resultado é 0xc0100000 para um
	    endereço de espaço de 1 GB.  Ajuste
	    <span class="symbol">LOAD_ADDRESS</span> em
	    <code class="filename">src/sys/i386/conf/Makefile.i386</code> para
	    esse valor, agora ajuste o contador de
	    posiçõo listada no inicio do
	    <code class="filename">src/sys/i386/conf/kernel.script</code> para
	    o mesmo valor, como a seguir:</p><pre class="programlisting">OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</pre><p>Agora recompile e reinstale seu
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.  Provavelmente
	    aparecerão problemas com o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> e com o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>, executar um <code class="command">make world</code> deve
	    solucionar tais problemas (ou então, a
	    recompilação manual da
	    <code class="filename">libkvm</code>, do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> e do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>,
	    depois de incluir o <code class="filename">pmap.h</code> alterado
	    em <code class="filename">/usr/include/vm/</code>.</p><p>OBS: o tamanho do espaço em memória do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> deve ser um
	    múltiplo de quatro megabytes.</p><p><span class="emphasis"><em>[Adendo por David Greenman: Acho que o
	      endereço de espaço do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> precisa ser uma
	      potência de dois, mas eu não estou certo
	      disso.  O código do processo de
	      inicialização antigo costumava mexer com
	      os bits de endereço de alta ordem, o que
	      implicava em uma granularidade de
	      256MB]</em></span></p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="funnies.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="acknowledgments.html">Próxima</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 17. As gracinhas do FreeBSD </td><td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td><td width="40%" align="right" valign="top"> Capítulo 19. Reconhecimentos</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Este, e outros documentos, podem ser obtidos em
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Para perguntas sobre FreeBSD, leia a
    <a href="http://www.FreeBSD.org/docs.html">documentação</a> antes de contatar
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Para perguntas sobre esta documentação, envie e-mail para
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>