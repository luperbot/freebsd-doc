<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 5. Resolução de Problemas</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="up" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="prev" href="hardware.html" title="Capítulo 4. Compatibilidade de Hardware" /><link rel="next" href="commercial.html" title="Capítulo 6. Aplicações Comerciais" /><link rel="copyright" href="legalnotice.html" title="Nota Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 5. Resolução de Problemas</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="hardware.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="commercial.html">Próxima</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="troubleshoot"></a>Capítulo 5. Resolução de Problemas</h1></div></div></div><div class="qandaset"><a id="idp67892560"></a><dl><dt>5.1. <a href="troubleshoot.html#idp67892816">O que fazer quando meu disco rígido tiver bad
	    blocks?
	  </a></dt><dt>5.2. <a href="troubleshoot.html#idp67904720">Por que o FreeBSD não reconhece a minha
	    controladora SCSI EISA Bustek 742a?</a></dt><dt>5.3. <a href="troubleshoot.html#idp67922256">Por que o FreeBSD não detecta a controladora
	    SCSI do Netserver HP??</a></dt><dt>5.4. <a href="troubleshoot.html#idp67936080">O que está havendo com minha controladora IDE
	    CMD640?</a></dt><dt>5.5. <a href="troubleshoot.html#idp67940560">Eu sempre vejo mensagens como ed1:
	      timeout.  O que elas significam?</a></dt><dt>5.6. <a href="troubleshoot.html#idp67947984">Por que minha placa 3COM 3C509 parou de funcionar sem
	    motivo aparente?</a></dt><dt>5.7. <a href="troubleshoot.html#idp67950416">Minha impressora paralela está ridiculamente
	    lenta.  O que devo fazer?</a></dt><dt>5.8. <a href="troubleshoot.html#idp67953616">Por que alguns programas ocasionalmente morrem com
	    erro de Signal 11 ?</a></dt><dt>5.9. <a href="troubleshoot.html#idp68008400">O meu sistema trava com o erro Fatal trap
	      12: page fault in kernel mode, ou
	    panic:, e sai mostrando uma
	    quantidade enorme de informações.  O que eu
	    faço?</a></dt><dt>5.10. <a href="troubleshoot.html#idp68012752">Por que a tela fica preta e perde sincronia quando eu
	    inicio o sistema?</a></dt><dt>5.11. <a href="troubleshoot.html#idp68045392">Por que o FreeBSD só detecta 64MB de
	    memória RAM se eu tenho 128MB instalados?</a></dt><dt>5.12. <a href="troubleshoot.html#idp68050256">Por que o FreeBSD 2.0 entre em pânico com a
	    mensagem kmem_map too
	      small!?</a></dt><dt>5.13. <a href="troubleshoot.html#idp68057680">Por que o erro /kernel: proc: table is
	      fullocorre?</a></dt><dt>5.14. <a href="troubleshoot.html#idp68118224">Por que acontece o erro CMAP
	      busy quando eu reinicio com um novo
	    kernel?</a></dt><dt>5.15. <a href="troubleshoot.html#idp68122832">O que a mensagem ahc0: brkadrint, Illegal
	      Host Access at seqaddr 0x0
	    significa??</a></dt><dt>5.16. <a href="troubleshoot.html#idp68130640">Quando eu inicio o sistema, encontro o erro
	    ahc0: illegal cable configuration,
	    mas o meu cabo está certo.  O que está
	    havendo?</a></dt><dt>5.17. <a href="troubleshoot.html#idp68133200">Por que o Sendmail retorna um erro que diz
	    &#8220;mail loops back to
		myself&#8221;?</a></dt><dt>5.18. <a href="troubleshoot.html#idp68149840">Porque algumas aplicações que usam tela
	    inteira não se comportam muito bem em
	    estações remotas?</a></dt><dt>5.19. <a href="troubleshoot.html#idp68160592">Por que meu computador apresenta a mensagem
	    calcru: negative time...?</a></dt><dt>5.20. <a href="troubleshoot.html#idp68167120">Acontece da pcm não ser encontrada, com a
	    mensagem pcm0 not found ou
	    então minha placa de som é encontrada na
	    pcm1 mas no meu
	    kernel a entrada se refere
	    a device pcm0.  O que está
	    havendo?</a></dt><dt>5.21. <a href="troubleshoot.html#idp68191056">Porque a minha placa PnP não é mais
	    encontrada (ou é encontrada como
	    unknown) desde a
	    atualização para o FreeBSD 4.X?</a></dt><dt>5.22. <a href="troubleshoot.html#idp68220624">Qual a causa do erro nlist
	      failed quando eu executo, por exemplo, o
	    top ou o
	    systat?</a></dt><dt>5.23. <a href="troubleshoot.html#idp68235088">Porque demora tanto para a conexão se
	    estabelecer via ssh ou
	    telnet?</a></dt><dt>5.24. <a href="troubleshoot.html#idp68246608">O que a mensagem stray IRQ quer
	    dizer?</a></dt><dt>5.25. <a href="troubleshoot.html#idp68257360">Por que a mensagem file: table is
	      full aparece repetidas vezes no
	    dmesg?</a></dt><dt>5.26. <a href="troubleshoot.html#idp68265296">Por que o relógio do meu laptop mantem a hora
	    incorreta?</a></dt><dt>5.27. <a href="troubleshoot.html#idp68277584">Por que o meu laptop não funciona muito bem na
	    hora de identificar cartões PCMCIA?</a></dt><dt>5.28. <a href="troubleshoot.html#idp68281424">Por que o bootloader do FreeBSD mostra a mensagem
	    Read error e pára
	    completamente logo após a tela da BIOS?</a></dt><dt>5.29. <a href="troubleshoot.html#idp68287696">Outro sistema operacional destruiu o meu gerenciador
	    de inicialização(Boot Manager).  Como eu o
	    recupero?
	  </a></dt><dt>5.30. <a href="troubleshoot.html#idp68311888">O que o erro swap_pager: indefinite wait
	      buffer: quer dizer?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp67892816"></a><a id="awre"></a><p><strong>5.1.</strong></p></td><td align="left" valign="top"><p>O que fazer quando meu disco rígido tiver bad
	    blocks?
	  </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Com controladoras SCSI, o drive (HD) deveria ser capaz
	    de remapear blocos ruins e corrigí-los
	    automaticamente.  Porém, muitos desses discos
	    mantém essa função desabilitada por
	    alguma razão misteriosa...</p><p>Para habilitar essa função é
	    necessário editar o primeiro modo de página
	    do dispositivo, o qual pode ser feito com o comando abaixo
	    (como <code class="systemitem">root</code>)</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>scsi -f /dev/rsd0c -m 1 -e -P 3</code></strong></pre><p>E mudando os valores de AWRE e ARRE de 0 para
	    1:-</p><pre class="programlisting">AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</pre><p>Os parágrafos seguintes foram enviados por Ted
	    Mittelstaedt <code class="email">&lt;<a xmlns="" class="email" href="mailto:tedm@toybox.placo.com">tedm@toybox.placo.com</a>&gt;</code>:</p><p>Para os discos IDE, qualquer bad block é
	    considerado um sinal de dificuldade em potencial.  Todos
	    os discos IDE modernos já vêm com um
	    remapeador interno que realoca bad blocks por outros
	    blocos em bom estado, automaticamente.  Todos os disco
	    rígido IDE fabricados hoje em dia oferecem
	    garantias extensas.</p><p>Se ainda quiser tentar salvar um drive IDE com bad
	    blocks, pode fazer um download do programa de
	    diagnóstico e correção do
	    próprio fabricante do disco rígido.
	    Às vezes estes programas podem fixar e
	    forçar eletronicamente o disco a marcar estes
	    blocos ruins e desativá-los.</p><p>Em discos ESDI, RLL e MFM, a existência de bad
	    blocks é normal e não representa nenhum
	    sinal de dificuldade,geralmente.  Em um PC, a placa
	    controladora das unidades de disco e, a BIOS se encarregam
	    da tarefa de re-mapear os bad blocks.  Isso funciona em
	    sistemas operacionais como DOS que usa código da
	    BIOS para acessar o disco.  Porém, o driver
	    (software controlador) do FreeBSD não trabalha ou
	    acessa comandos da BIOS para para interagir com o drive
	    (HD), então um mecanismo chamado bad144, existente
	    no FreeBSD, acaba substituindo esta funcionalidade.  O
	    bad144 só trabalha com o drive wd (portanto,
	    não é suportado no FreeBSD 4.0), e
	    não pode ser usado com drive SCSI.  O bad144
	    trabalha marcando e organizando setores ruins encontrados
	    no HD, em um arquivo especial no disco.</p><p>Uma característica do bad144 - o bloco
	    danificado é colocado em um arquivo especial
	    situado na última trilha do disco.  Como este
	    arquivo contém uma lista de setores defeituosos que
	    pode incluir valores perto do início do disco, onde
	    o /kernel pode estar alocado, esse arquivo deverá
	    ser acessível ao bootstrap para que o programa -
	    por meio da BIOS - leia o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>;  isso significa que
	    o disco usado com bad144 não deve exceder 1024
	    cilindros, 16 cabeças, e 63 setores, logo, temos um
	    limite efetivo de 500MB para discos mapeados com o
	    bad144..</p><p>Para ativar o uso do bad144, simplesmente defina a
	    opção de procurar por <span class="quote">&#8220;<span class="quote">Bad
	      Block</span>&#8221;</span> como ON na tela do fdisk do FreeBSD,
	    durante a instalação.  Essas
	    instruções funcionam a partir do FreeBSD
	    2.2.7, e o disco deve ter menos que 1024 cilindros.
	    Geralmente recomenda-se que a unidade de disco esteja em
	    operação durante pelo menos 4 horas antes de
	    executar o bad144, permitindo assim a expansão
	    térmica do HD.</p><p>Se o disco tem mais de 1024 cilindros (como um disco
	    ESDI grande) a controladora ESDI usa um tipo de
	    tradução especial em modo DOS.  A device wd
	    também entende esses mesmos modos de
	    tradução e conversão, isso se o
	    <span class="quote">&#8220;<span class="quote">tradutor</span>&#8221;</span> de geometria for ativado como
	    <span class="quote">&#8220;<span class="quote">geometria fixa</span>&#8221;</span>, quando particionado pelo
	    fdisk.  Você também não deve usar o
	    modo <span class="quote">&#8220;<span class="quote">dangerously dedicated</span>&#8221;</span> para criar
	    partições do FreeBSD, pois isso ignora o
	    tipo de geometria.  Embora o fdisk use a geometria
	    definida pelo usuário, ele continua reconhecendo o
	    tamanho verdadeiro do disco, e tentará criar uma
	    partição maior para o FreeBSD.  Se a
	    geometria de disco for alterada para geometria
	    traduzida(translated geometry), a partição
	    DEVE ser criada manualmente, informando os números
	    de blocos do HD.</p><p>Um truque rápido é usar um disco grande
	    ESDI com uma controladora ESDI, iniciar(booting) o sistema
	    com um disco DOS e formatar uma partição
	    DOS.  Depois reiniciar o sistema com um disco de
	    instalação do FreeBSD, e anotar o
	    número e tamanho dos blocos que serão
	    apresentados na tela do fdisk para a
	    partição DOS.  Redefina a geometria do disco
	    com os valores anotados, apague a partição
	    DOS e crie uma partição FreeBSD
	    <span class="quote">&#8220;<span class="quote">cooperativa</span>&#8221;</span>.  Defina essa
	    partição como bootável e habilite o
	    reconhecimento de bad blocks.  Na
	    instalação, o bad144 é carregado
	    antes que qualquer outro sistema de arquivos seja criado
	    (você pode ver isso com um
	    <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span>).
	    Se houver problemas na criação do arquivo de
	    definições de setor danificado (o arquivo de
	    badsector) é porque a geometria definida é
	    maior do que o seu valor real - reinicie o sistema e
	    comece todos os procedimentos novamente, inclusive o
	    particionamento e formatação da
	    partição DOS.</p><p>Se o remapeamento já estiver habilitado e os
	    problemas com bad block continuarem, considere a
	    substituição imediata do disco, pois os
	    danos e os bad blocks aumentarão consideravelmente
	    com o passar do tempo.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67904720"></a><a id="bustek742a-eisa-scsi"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>Por que o FreeBSD não reconhece a minha
	    controladora SCSI EISA Bustek 742a?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>As informações a seguir são para
	    o modelo 742a, mas provavelmente também servem para
	    as placas Buslogic.  (Bustek = Buslogic).</p><p>Existem duas <span class="quote">&#8220;<span class="quote">versões</span>&#8221;</span>
	    tradicionais da placa 742a.  São os equipamentos de
	    revisão A-G e de revisão H;  as letras de
	    cada revisão são colocadas depois do
	    número de fabricação, ao lado das
	    placas.  A placa 742a possui 2 chips ROM acoplados, o
	    primeiro é o chip da BIOS e o segundo é o do
	    Firmware.  Para o FreeBSD a versão da BIOS é
	    irrelevante, mas a versão do Firmware é uma
	    informação fundamental.  É
	    interessante dizer que, se você fizer uma chamada ao
	    departamento de suporte da Buslogic, eles irão te
	    enviar um upgrade desses ROMs, e é muito bom sempre
	    manter a versão mais recente do ROM do seu Firmware
	    para a versão de revisão do seu
	    equipamento.</p><p>As placas cuja letra de revisão é A-G
	    aceitam apenas atualizações da BIOS/Firmware
	    de versão 2.41/2.21 respectivamente.  A
	    revisão H (REV H) aceita as versões mais
	    recentes da BIOS/Firmware até a versão
	    4.70/3.37.  A principal diferença entre as
	    versões do Firmware é que a versão
	    3.37 tem suporte a<span class="quote">&#8220;<span class="quote">round robin</span>&#8221;</span>.</p><p>As placas Buslogic também tem um número
	    serial.  Caso seu equipamento seja antigo, tente abrir uma
	    chamada no departamento de RMA da Buslogic e informe-os o
	    número de série da sua placa.  Se ela
	    estiver entre os seriais de abrangência, a Buslogic
	    vai aceitar seu equipamento para revisão.</p><p>O FreeBSD 2.1 aceita apenas as revisões de
	    Firmware até o 2.21.  Caso o seu Firmware seja mais
	    antigo do que o 2.21 sua placa não será
	    reconhecida como Buslogic.  Contudo, é
	    possível que o equipamento seja reconhecido como
	    Adaptec 1540, já que os Firmware mais antigos da
	    Buslogic possuem um modo de
	    <span class="quote">&#8220;<span class="quote">emulação</span>&#8221;</span> da AHA1540, o que
	    não é uma boa coisa, para uma placa
	    EISA.</p><p>Caso seu Firmware seja antigo e você conseguiu
	    obter uma revisão para a versão 2.21,
	    não se esqueça que é
	    necessário alterar o jumper W1 da
	    posição A-B (padrão) para
	    posição B-C ao atualizar a placa.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67922256"></a><a id="hpnetserver-scsi-failure"></a><p><strong>5.3.</strong></p></td><td align="left" valign="top"><p>Por que o FreeBSD não detecta a controladora
	    SCSI do Netserver HP??</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Isso já é um problema conhecido.  A
	    controladora SCSI on-board EISA dos servidores HP
	    Netserver estão no slot EISA número 11,
	    portanto todos os <span class="quote">&#8220;<span class="quote">verdadeiros</span>&#8221;</span> slots EISA
	    estão na sua frente.  O endereço definido
	    para os slots EISA &gt;= 10 ocupa um endereço
	    compartilhado com o barramento PCI, e portanto entra em
	    conflito com seus recursos.  Essa é uma
	    situação onde a configuração
	    automática do FreeBSD não se comporta muito
	    bem.</p><p>Portanto o que você deve fazer, é fingir
	    que não existe limitação quanto ao
	    intervalo de endereços, definindo a
	    opção option <code class="literal">EISA_SLOTS</code>
	    do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para o valor 12.
	    Configure e compile um novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, conforme descrito
	    no <a class="link" href="../handbook/kernelconfig.html" target="_top">capítulo de
	      configuração do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> no
	      Manual do FreeBSD</a>.</p><p>Obviamente esse problema é ainda maior quando
	    se trata de uma nova instalação.  Para
	    corrigir esse problema é necessário uma
	    pequena alteração no modo
	    <span class="emphasis"><em>UserConfig</em></span>.  Não use a
	    interface de configuração
	    <span class="quote">&#8220;<span class="quote">visual</span>&#8221;</span> do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, use a Interface de
	    Linha de Comando (CLI), simplesmente digitando:</p><pre class="programlisting">eisa 12
quit</pre><p>na tela do modo CLI, e continue a
	    instalação do FreeBSD como de costume.  De
	    qualquer forma, é recomendável recompilar e
	    instalar um novo <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>
	    depois da instalação do sistema..</p><p>Futuras versões do FreeBSD terão esse
	    problema corrigido automaticamente.</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">Não use discos em modo <code class="literal">dangerously
		dedicated</code> com um HP Netserver.  Veja <a class="link" href="disks.html#dedicate">essa nota</a> para maiores
	      informações.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67936080"></a><a id="cmd640-ide"></a><p><strong>5.4.</strong></p></td><td align="left" valign="top"><p>O que está havendo com minha controladora IDE
	    CMD640?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Está com defeito!  Não suporta mais
	    comandos nos dois canais de forma simultânea.</p><p>Existe uma correção disponível e
	    automaticamente habilitada, se você usa uma
	    controladora com esse chip.  Para maiores detalhes,
	    refira-se a página de manual da controladora de
	    disco (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=wd&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">wd</span>(4)</span></a>).</p><p>Se o FreeBSD em questão é o FreeBSD
	    2.2.1 ou 2.2.2 com essa controladora em questão, e
	    você quer usar o segundo canal, compile um novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> com a
	    opção <code class="literal">options "CMD640"</code>
	    habilitada.  Essa configuração é
	    padrão para o FreeBSD 2.2.5 e posteriores.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67940560"></a><a id="ed1-timeout"></a><p><strong>5.5.</strong></p></td><td align="left" valign="top"><p>Eu sempre vejo mensagens como <span class="errorname">ed1:
	      timeout</span>.  O que elas significam?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Normalmente esse problema é causado por um
	    conflito de interrupções (por exemplo, duas
	    placas usando a mesma IRQ).  O FreeBSD até a
	    versão 2.0.5R costumava ser tolerante quanto a esse
	    problema e a placa de rede continuava funcionando mesmo
	    com IRQ conflitantes.  Contudo desde a versão
	    2.0.5R os conflitos de interrupções
	    não são mais tolerados.  Inicie o sistema
	    com a opção de boot -c e mude as device
	    ed0/de0/...  para o valor correspondente ao da
	    placa.</p><p>Caso esteja usando um conector BNC na sua placa de
	    rede, é provável que existam device timeout
	    por causa de má terminação do
	    barramento.  Pra tirar isso a limpo coloque um terminador
	    direto na placa (sem cabos) e veja se as mensagens de erro
	    param.</p><p>Algumas placas compatíveis NE2000
	    apresentarão esse problema caso a porta UTP
	    não receba sinal de link, ou se o cabo estiver
	    desconectado.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67947984"></a><a id="bad-3c509"></a><p><strong>5.6.</strong></p></td><td align="left" valign="top"><p>Por que minha placa 3COM 3C509 parou de funcionar sem
	    motivo aparente?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esse cartão tem um hábito
	    horrível de perder suas informações
	    de configuração.  Redefina as
	    informações da placa usando o programa de
	    DOS chamado <code class="command">3c5x9.exe</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67950416"></a><a id="printer-slow"></a><p><strong>5.7.</strong></p></td><td align="left" valign="top"><p>Minha impressora paralela está ridiculamente
	    lenta.  O que devo fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Se o único problema é a lerdeza
	    terrível da sua impressora, tente mudar seu <a class="link" href="../handbook/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE" target="_top">modo
	      da porta de impressão</a> conforme discutido
	    na seção de <a class="link" href="../handbook/printing-intro-setup.html" target="_top">Configuração
	      de Impressoras</a> no Manual do FreeBSD.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67953616"></a><a id="signal11"></a><p><strong>5.8.</strong></p></td><td align="left" valign="top"><p>Por que alguns programas ocasionalmente morrem com
	    erro de <span class="errorname">Signal 11</span> ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Erros de sinal 11 são fruto de tentativas de
	    acesso indevido a memória.  Esse acesso normalmente
	    é controlado pelo sistema operacional, e quando o
	    sistema não permite acessar determinados
	    endereços, o processo é morto com signal 11.
	    Se isso estiver acontecendo em intervalos
	    aleatórios de tempo, é preciso investigar as
	    causas com cuidado.</p><p>Esse problema normalmente é atribuído
	    a:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Se o problema ocorre apenas em um programa
		específico que você mesmo esta
		desenvolvendo, se trata de um bug no código do
		seu programa.</p></li><li class="listitem"><p>Se o problema é com algum programa que faz
		parte da base do FreeBSD, é possível que
		também seja um problema de bug no código
		em questão.  Contudo, esses problemas costumam
		ser corrigidos antes que os usuários
		tradicionais percebam sua existência - e
		necessitem ler este <code class="literal">FAQ</code> - afinal,
		é para isso que o -CURRENT existe.</p></li></ol></div><p>Em especial, uma indicação que esse
	    problema <span class="emphasis"><em>não</em></span> é um bug
	    do FreeBSD, é um erro repetitivo no mesmo instante
	    da compilação, mas o problema que o
	    compilador apresenta muda de linha a cada nova
	    compilação.</p><p>Por exemplo, suponha que você esteja executando
	    um <span class="quote">&#8220;<span class="quote">make buildworld</span>&#8221;</span>, e a
	    compilação falha na hora de compilar o
	    <code class="filename">ls.c</code> em <code class="filename">ls.o</code>. Se
	    você rodar o <span class="quote">&#8220;<span class="quote">make buildworld</span>&#8221;</span> de novo
	    e a compilação falha exatamente no mesmo
	    trecho do código, então o problema realmente
	    é com o fonte da aplicação, nesse
	    caso atualize os fontes do FreeBSD e tente novamente.
	    Agora se a compilação falhar em um trecho
	    diferente do código, é quase certo que o
	    problema seja físico, ou seja, com o seu
	    equipamento.</p><p>O que deve ser feito:</p><p>Em primeiro lugar, deve-se usar um debugador, como o
	    gdb, por exemplo, para encontrar o ponto exato do
	    código que está tentando acessar um
	    endereço problemático de memória, e
	    corrigi-lo.</p><p>Em segundo lugar, verifique se a culpa não
	    é do seu equipamento.</p><p>As causas mais comuns para o problema incluem::</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Os seus discos rígidos podem estar
		superaquecidos: Verifique se o sistema de
		ventilação do seu PC está
		funcionando.  Verifique coolers internos (da fonte) e
		externos, e verifique se não existe
		superaquecimento de outros componentes do
		computador.</p></li><li class="listitem"><p>O processador está superaquecido: Pode ser
		porque foi feito um overclock no processador em
		questão, ou no caso mais tradicional, pode ser
		que o cooler tenha parado de funcionar ou que esteja
		sujo e portanto funcionando em rotação
		baixa.  Em ambos os casos, o primeiro passo é
		garantir que o processador esteja rodando sob as
		mesmas condições que ele foi
		construído para funcionar - por exemplo, com a
		velocidade do clock original e com a
		ventilação adequada.</p><p>Caso tenha sido feito overclock no processador,
		lembre-se que é mais barato usar um computador
		um pouco mais lento, do que trocar o processador da
		máquina por causa de um chip fritado ;-)
		Além do que a maioria das pessoas não
		são simpatizantes de overclock, mesmo que
		você considere a ação segura ou
		não.</p></li><li class="listitem"><p>Caso tenha múltiplos pentes de
		memória SIMM/DIMM, tente desligá-los e
		experimente usar cada pente de uma vez,
		indiviualmente.  Com isso é possível
		descobrir se o problema é com algum chip
		DIMM/SIMM ou se o problema é a
		combinação entre os pentes.</p></li><li class="listitem"><p>Configurações super otimistas na
		BIOS da sua placa mãe são outra causa
		provável.  Algumas BIOS tem
		opções que permitem alterar a velocidade
		e frequência de vários recursos.
		Normalmente os valores padrão na BIOS
		são os mais conservadores, e portanto devem ser
		o bastante para controlar corretamente o equipamento;
		contudo algumas opções como por exemplo
		<span class="quote">&#8220;<span class="quote">RAM Speed: Turbo</span>&#8221;</span> ou alguma
		opção parecida coloca o estado de espera
		para o acesso a memória em um valor muito
		baixo, e as vezes, por mais otimista que você
		seja, sua memória pode não ser
		rápida o bastante.  O ideal é definir os
		valores padrão da sua BIOS, mas é
		interessante anotar os valores atuais primeiro!</p></li><li class="listitem"><p>Alimentação insuficiente de energia
		na placa-mãe.  Caso exista alguma placa que
		não esteja sendo utilizada, algum disco
		rígido ou CDROM, é interessante
		desliga-los temporariamente do computador, ou
		simplesmente remover o cabo de energia desses
		equipamentos.  Mesmo em sub utilização,
		essas placas e discos estão sob constante
		alimentação e talvez sua fonte consiga
		suprir uma carga menor.  Ou tente trocar a fonte do
		seu PC, de preferência por uma com maior poder
		de alimentação (por exemplo, se a sua
		fonte é de 250 Watts troque por uma de 300
		Watts).</p></li></ol></div><p>Leia ainda o <code class="literal">FAQ</code> SIG11
	    (disponível a seguir) que tem outras boas
	    explicações sobre esses problemas.  O
	    <code class="literal">FAQ</code> também discute como alguns
	    programas de teste de memória podem pensar que um
	    pente problemático está funcionando
	    corretamente.</p><p>Finalmente, se nenhum dos casos acima ajudou a
	    solucionar seu problema, pode ser que exista um bug no
	    FreeBSD.  Você deve seguir as
	    intruçõoes para enviar um relatório
	    de problemas para o Projeto FreeBSD.</p><p>Existe um <code class="literal">FAQ</code> extenso que cobre
	    esse assunto, disponível <a class="link" href="http://www.bitwizard.nl/sig11/" target="_top"> no
	      <code class="literal">FAQ</code> dos problemas com
	      SIG11.</a></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68008400"></a><a id="trap-12-panic"></a><p><strong>5.9.</strong></p></td><td align="left" valign="top"><p>O meu sistema trava com o erro <span class="errorname">Fatal trap
	      12: page fault in kernel mode</span>, ou
	    <span class="errorname">panic:</span>, e sai mostrando uma
	    quantidade enorme de informações.  O que eu
	    faço?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A equipe de desenvolvimento do FreeBSD tem muito
	    interesse nesse tipo de erro, mas é
	    necessário obter algumas informações
	    suplementares, do que apenas o erro que você
	    está tendo.  Copie sua mensagem de erro inteira,
	    consulte o <code class="literal">FAQ</code> sobre <a class="link" href="advanced.html#kernel-panic-troubleshooting" title="18.13."><span class="foreignphrase"><em class="foreignphrase">kernel</em></span>
	      panics</a>, compile um
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> em modo de
	    debugação e tente analisar o problema.
	    Parece uma tarefa difícil, mas não é
	    necessário conhecimento de
	    programação; basta seguir as
	    instruções.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68012752"></a><a id="screen-loses-sync"></a><p><strong>5.10.</strong></p></td><td align="left" valign="top"><p>Por que a tela fica preta e perde sincronia quando eu
	    inicio o sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esse é um problema conhecido da placa de
	    vídeo ATI Mach 64.  O problema é que essa
	    placa usa o endereço <code class="literal">2e8</code>, o
	    mesmo utilizado pela quarta porta serial dos computadores
	    pessoais.  Devido a um bug (ou uma vantagem?) da
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a> ,essa porta será sempre reconhecida,
	    ainda que não exista a quarta porta serial no seu
	    computador, ou <span class="emphasis"><em>mesmo</em></span> se o sio3 (a
	    quarta porta) estiver desabilitado.</p><p>Até que o bug seja corrigido, você pode
	    usar essa solução:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Entre no modo de configuração do
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> com
		opção <code class="option">-c</code> na tela de
		inicialização(boot).  (Isto colocara o
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> no modo de
		configuração).</p></li><li class="listitem"><p>Desabilite a <code class="filename">sio0</code>,
		<code class="filename">sio1</code>,
		<code class="filename">sio2</code> e
		<code class="filename">sio3</code> (todas elas).  Dessa
		forma será ativada, logo, você não
		terá -&gt; problemas.</p></li><li class="listitem"><p>Digite exit para continuar o boot.</p></li></ol></div><p>Caso queira usar as portas seriais, será
	    necessário construir um
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> customizado, com as
	    seguintes alterações: no fonte
	    <code class="filename">/usr/src/sys/i386/isa/sio.c</code> encontre
	    a ocorrência da expressão
	    <code class="literal">0x2e8</code> e apague essa expressão e
	    a vírgula que a antecede (mantenha a outra).
	    Depois compile o novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> normalmente.</p><p>Mesmo depois dessa correção, é
	    provável que o X Windows ainda não funcione
	    como esperado.  Se for o caso, garanta que a versão
	    do Xfree86 em questão seja ao menos o XFree86 3.3.3
	    ou uma versão superior.   Esse XFree86 e os
	    posteriores tem suporte nativo às placas de
	    vídeo Mach64, e tem inclusive um X Server dedicado
	    para tal equipamento.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68045392"></a><a id="reallybigram"></a><p><strong>5.11.</strong></p></td><td align="left" valign="top"><p>Por que o FreeBSD só detecta 64MB de
	    memória RAM se eu tenho 128MB instalados?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Devido à maneira que o FreeBSD obtém as
	    informações quanto ao tamanho da
	    memória disponível por intermédio da
	    BIOS, pode acontecer de apenas 16 bits válidos
	    serem detectados (65535 Kbytes = 64MB) ou até
	    menos, dependendo da BIOS (em alguns casos, apenas 16MB).
	    Mesmo nessa situação o FreeBSD tenta
	    detectar mais que 64MB de memória, mas esse
	    reconhecimento pode falhar.</p><p>Pra corrigir esse problema pode ser usada a
	    opção do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> descrita a seguir.
	    Existe uma forma de obter informações
	    completas quanto ao tamanho da memória, a partir da
	    BIOS, mas devido a algumas limitações isso
	    nem sempre é possível hoje em dia.
	    Futuramente será.  De qualquer forma, temos ainda a
	    opção do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para
	    situações onde toda a memória
	    não puder ser reconhecida.</p><p><code class="literal">options
	      "MAXMEM=n"</code></p><p>Onde <em class="replaceable"><code>n</code></em> equivale à
	    memória (em Kilobytes) disponível no
	    sistema.  Para 128 MB de memória, use o valor
	    <code class="literal">131072</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68050256"></a><a id="panic-kmemmap-too-small"></a><p><strong>5.12.</strong></p></td><td align="left" valign="top"><p>Por que o FreeBSD 2.0 entre em pânico com a
	    mensagem <span class="errorname">kmem_map too
	      small!</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">A mensagem em questão também pode ser
	      <code class="literal">mb_map too small!</code></p></div><p>Essa mensagem de pânico indica que o sistema
	    ficou sem memória suficiente pros buffers de rede
	    (especificamente, os mbuf clusters).  A quantidade de
	    memória virtual disponível para os clusters
	    mbuf pode ser elevada com a opção::</p><p><code class="literal">options
	      "NMBCLUSTERS=n"</code></p><p>no arquivo de configuração do seu
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, onde
	    <em class="replaceable"><code>n</code></em> equivale ao valor entre
	    512-4096, dependendo do número de conexões
	    TCP simultâneas que você espera poder
	    suportar.  O valor 2048 é recomendável, e
	    provavelmente será o bastante para sanar o problema
	    que causa o pânico em questão O número
	    de clusters mbuf em uso pode ser monitorado com o comando
	    <code class="command">netstat -m</code> (veja <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>).  O
	    valor padrão para a variável NMBCLUSTERS no
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD é
	    <code class="literal">512 + MAXUSERS * 16</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68057680"></a><a id="proc-table-full"></a><p><strong>5.13.</strong></p></td><td align="left" valign="top"><p>Por que o erro <span class="errorname">/kernel: proc: table is
	      full</span>ocorre?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD
	    limita o número máximo de processos
	    simultâneos existentes no sistema.  O número
	    em questão é baseado na opção
	    <code class="literal">MAXUSERS</code>.  do sistema.  A
	    opção <code class="literal">MAXUSERS</code> afeta
	    ainda inúmeros outros limites do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD, como por
	    exemplo os buffers disponíveis para o stack de rede
	    do sistema (veja <a class="link" href="troubleshoot.html#panic-kmemmap-too-small" title="5.12.">esta</a> resposta
	    anterior).  Se o computador estiver sob grande carga,
	    provavelmente será necessário aumentar o
	    <code class="literal">MAXUSERS</code>.  Essa alteração
	    aumentará os limites do sistema em
	    adição ao número de processos
	    permitido.</p><p>Desde a versão 4.4 do FreeBSD, o valor para
	    <code class="literal">MAXUSERS</code> se tornou configurável,
	    não sendo mais necessário recompilar o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para
	    alterá-lo, bastando definir a variável
	    <code class="varname">kern.maxusers</code> no arquivo
	    <code class="filename">/boot/loader.conf</code>.  Em
	    versõoes mais recentes do FreeBSD, deve-se ajustar
	    o <code class="literal">MAXUSERS</code> em sua
	    configuração do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.</p><p>Caso seu sistema não esteja muito carregado,
	    mas o número de processos simultâneos ainda
	    assim é alto basta definir a variável
	    <code class="varname">kern.maxproc</code> com o sysctl.  Em casos
	    especiais, onde esses inúmeros processos
	    estão sendo executados por um único
	    usuário, será preciso alterar ainda alterar
	    o valor da variável
	    <code class="varname">kern.maxprocperuid</code> para um a menos do
	    que o valor de <code class="varname">kern.maxproc</code>.  (deve ser
	    ao menos 1 processo a menos, visto que ao menos o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> do sistema vai estar sempre em
	    execução.)</p><p>Para tornar uma alteração de
	    variável do sysctl permanente, defina-a no arquivo
	    <code class="filename">/etc/sysctl.conf</code> nas versões
	    mais recentes do FreeBSD, ou então no arquivo
	    <code class="filename">/etc/rc.local</code> em versões mais
	    antigas do sistema.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68118224"></a><a id="cmap-busy-panic"></a><p><strong>5.14.</strong></p></td><td align="left" valign="top"><p>Por que acontece o erro <span class="errorname">CMAP
	      busy</span> quando eu reinicio com um novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A lógica que tenta detectar uma data errada nos
	    arquivos <code class="filename">/var/db/kvm_*.db</code> as vezes
	    é falha, o que leva o sistema a entrar em
	    pânico.</p><p>Se for o caso, reinicie seu sistema em modo
	    monousuário e faça:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm /var/db/kvm_*.db</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68122832"></a><a id="brkadrint-illegal-host-access"></a><p><strong>5.15.</strong></p></td><td align="left" valign="top"><p>O que a mensagem <span class="errorname">ahc0: brkadrint, Illegal
	      Host Access at seqaddr 0x0</span>
	    significa??</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Trata-se de um conflito com o Ultrastor SCSI Host
	    Adapter.</p><p>Durante o processo de
	    inicialização(boot), entre no menu de
	    configuração do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> e desabilite a
	    <code class="filename">uha0</code>, que esta causando o
	    problema.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68130640"></a><a id="aci0-illegal-cable"></a><p><strong>5.16.</strong></p></td><td align="left" valign="top"><p>Quando eu inicio o sistema, encontro o erro
	    <span class="errorname">ahc0: illegal cable configuration</span>,
	    mas o meu cabo está certo.  O que está
	    havendo?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A placa-mãe em questão não
	    consegue se dar bem com o suporte a
	    terminação automática do barramento.
	    Altere sua BIOS SCSI para a terminação
	    correta, de acordo com a configuração do
	    equipamento, ao invés de usar
	    terminação automática.  O driver
	    AIC7XXX não consegue descobrir se o reconhecimento
	    externo dos cabos (e conseqüente
	    auto-terminação) está
	    disponível, e portanto ele simplesmente assume que
	    o suporte existe, caso a configuração da
	    EEPROM serial esteja definida como automatic termination.
	    Sem o reconhecimento de cabo externo o driver irá
	    sempre configurar a terminação de forma
	    incorreta, o que compromete a confiabilidade do barramento
	    SCSI.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68133200"></a><a id="mail-loopback"></a><p><strong>5.17.</strong></p></td><td align="left" valign="top"><p>Por que o Sendmail retorna um erro que diz
	    <span class="quote">&#8220;<span class="quote"><span class="errorname">mail loops back to
		myself</span></span>&#8221;</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Essa pergunta é respondida no
	    <code class="literal">FAQ</code> do próprio Sendmail, e
	    diz:-</p><div class="literallayout"><p>        * Eu estou tendo problemas de configurações local "Local configuration error" como essas:<br />
<br />
        553 relay.domain.net config error: mail loops back to myself<br />
        554 &lt;user@domain.net&gt;...  Local configuration error<br />
<br />
	Como posso resolver esse problema?<br />
<br />
	Você definiu que as mensagens enviadas para o domínio<br />
	em questão (domain.net) devem ser repassadas para uma outra<br />
	estação específica (nesse caso para<br />
	relay.domain.net) usando um registro MX, mas essa máquina de<br />
	relay não se reconhece como a estação<br />
	responsável pelas mensagens do domínio domain.net.<br />
	Adicione domain.net no arquivo /etc/mail/local-host-names<br />
	(caso você esteja usando FEATURE(use_cw_file)) ou então<br />
	adicione a linha "Cw domain.net" em /etc/mail/sendmail.cf.<br />
            </p></div><p>Atualmente a versão mais recente do <a class="link" href="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq" target="_top"><code class="literal">FAQ</code>
	      do sendmail</a> é mantida em sincronia com as
	    versões mais atuais do MTA, mas ela ainda é
	    enviada regularmente para os grupos de notícias
	    <a class="link" href="news:comp.mail.sendmail" target="_top">comp.mail.sendmail</a>,
	    <a class="link" href="news:comp.mail.misc" target="_top">comp.mail.misc</a>,
	    <a class="link" href="news:comp.mail.smail" target="_top">comp.mail.smail</a>,
	    <a class="link" href="news:comp.answers" target="_top">comp.answers</a>, e
	    <a class="link" href="news:news.answers" target="_top">news.answers</a>.
	    Ainda é possível receber um cópia por
	    e-mail do <code class="literal">FAQ</code>, enviando uma mensagem
	    para <code class="email">&lt;<a xmlns="" class="email" href="mailto:mail-server@rtfm.mit.edu">mail-server@rtfm.mit.edu</a>&gt;</code> com o comando
	    <code class="literal">send
	      usenet/news.answers/mail/sendmail-faq</code> no corpo
	    da mensagem.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68149840"></a><a id="remote-fullscreen"></a><p><strong>5.18.</strong></p></td><td align="left" valign="top"><p>Porque algumas aplicações que usam tela
	    inteira não se comportam muito bem em
	    estações remotas?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A estação remota deve estar definindo o
	    terminal como algum tipo diferente do
	    <code class="literal">cons25</code> que é o tipo de terminal
	    usado pelo console do FreeBSD.</p><p>Existem inúmeras correções para
	    esse problema:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Depois de logar-se na estação
		remota, defina a variável de ambiente TERM como
		<code class="literal">ansi</code> ou <code class="literal">sco</code> caso
		a máquina em questão tenha
		informações quanto a esse tipo de
		terminal.</p></li><li class="listitem"><p>Use um emulador VT100 como o
		<span class="application">screen</span> no console do
		FreeBSD.  O <span class="application">screen</span> oferece
		a possibilidade de usar múltiplas
		sessões concorrentes em um mesmo terminal, e
		é um grande programa.  Cada janela do
		<span class="application">screen</span>  se comporta como um
		terminal VT100, portanto a variável TERM deve
		ser definida como <code class="literal">vt100</code>.</p></li><li class="listitem"><p>Instale a base do <code class="literal">cons25</code> na
		estação remota.  A maneira correta de
		faze-lo depende do sistema operacional em
		questão na estação remota.
		Consulte os manuais de administração do
		sistema remoto em questão para descobrir como
		faze-lo.</p></li><li class="listitem"><p>Levante um X server do lado FreeBSD da coisa e
		acesse a estação remota usando um
		terminal baseado no ambiente X, como o
		<code class="command">xterm</code> ou o <code class="command">rxvt</code>.
		A variável TERM deve ser definida
		como<code class="literal">xterm</code> ou
		<code class="literal">vt100</code> no lado remoto.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68160592"></a><a id="calcru-negative"></a><p><strong>5.19.</strong></p></td><td align="left" valign="top"><p>Por que meu computador apresenta a mensagem
	    <span class="errorname">calcru: negative time...</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esse comportamento pode ser causado por diversos
	    motivos relacionados a interrupções de
	    <span class="foreignphrase"><em class="foreignphrase">hardware</em></span> e/ou software.
	    Pode ser devido a algum bug, mas também pode
	    acontecer por causa da natureza de alguns devices.  Por
	    exemplo, usar TCP/IP via porta paralela com uma MTU muito
	    grande é uma boa forma de provocar esse
	    comportamento.  Aceleradores gráficos também
	    são eficientes para criar esse tipo de problema,
	    nesse caso, sendo necessário analisar as
	    configurações de interrupções
	    do software.</p><p>Um efeito colateral desse problema são
	    processos que morrem<span class="quote">&#8220;<span class="quote">SIGXCPU exceeded cpu time
	      limit</span>&#8221;</span>.</p><p>No FreeBSD 3.0 e sistemas posteriores a 29 de Novembro
	    de 1998, caso o problema não possa ser solucionado
	    de outra forma, uma correção pode ser
	    definir a seguinte variável do sysctl:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.method=1</code></strong></pre><p>Isso causa um impacto de performance, mas dependendo
	    do problema que causava esse comportamento, é
	    provável que nem consiga-se notar a mudança
	    nessa performance.  Se o problema continuar, mantenha a
	    variável do sysctl habilitada e defina a
	    opção <code class="literal">NTIMECOUNTER</code> no
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> para valores
	    crescentes.  Se chegar a um ponto em que foi
	    necessário definir
	    <code class="literal">NTIMECOUNTER=20</code> e o problema ainda
	    não tiver sido resolvido, as
	    interrupções são serias demais e seu
	    comportamento não é confiável.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68167120"></a><a id="pcm0-not-found"></a><p><strong>5.20.</strong></p></td><td align="left" valign="top"><p>Acontece da pcm não ser encontrada, com a
	    mensagem <span class="errorname">pcm0 not found</span> ou
	    então minha placa de som é encontrada na
	    <code class="filename">pcm1</code> mas no meu
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> a entrada se refere
	    a <code class="literal">device pcm0</code>.  O que está
	    havendo?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Isso acontece no FreeBSD 3.X com placas de som PCI.  A
	    <code class="filename">pcm0</code> é reservada
	    exclusivamente para placas de som ISA e por isso se a
	    placa em questão é PCI, ela será
	    reconhecida como <code class="filename">pcm1</code> e a
	    mensagem em questão pode acontecer.
	  </p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">Não é possível evitar a
	      mensagem de advertência simplesmente alterando o
	      seu <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> e definindo
	      <code class="literal">device pcm1</code> pois isso
	      resultará na <code class="filename">pcm1</code> sendo
	      reservada para placas ISA, e o seu equipamento PCI
	      será reconhecido na <code class="filename">pcm2</code>
	      (e a mensagem de advertência <span class="errorname">pcm1 not
		found</span> continuará).</p></div><p>
	    Caso sua placa de som seja PCI ainda será preciso
	    criar a device <code class="filename">snd1</code> ao
	    invés da <code class="filename">snd0</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV snd1</code></strong></pre><p>Esse comportamento não ocorre na série
	    4.X do FreeBSD, muito trabalho foi feito para tornar o
	    sistema mais <span class="emphasis"><em>PnP-centric</em></span> e a device
	    <code class="filename">pcm0</code> não é mais
	    reservada exclusivamente para placas ISA.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68191056"></a><a id="pnp-not-found"></a><p><strong>5.21.</strong></p></td><td align="left" valign="top"><p>Porque a minha placa PnP não é mais
	    encontrada (ou é encontrada como
	    <code class="literal">unknown</code>) desde a
	    atualização para o FreeBSD 4.X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O FreeBSD 4.X é muito mais
	    <span class="emphasis"><em>PnP-centric</em></span> do que as versões
	    anteriores, e isso causou alguns efeitos distintos em
	    algumas placas PnP (como algumas placas de som e alguns
	    modems interno por exemplo) que não funcionam mais
	    da forma como funcionavam no FreeBSD 3.X.</p><p>O motivo para esse comportamento é explicado no
	    seguinte e-mail, que foi enviada na lista
	    freebsd-questions pelo Reter Wemm, respondendo uma
	    pergunta sobre um modem interno que não era mais
	    reconhecido no FreeBSD depois de atualizar o sistema para
	    versão 4.X (os comentários entre
	    <code class="literal">[]</code>foram adicionados com a
	    intenção de explicar melhor o contexto da
	    mensagem).</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">Os índices dessa citação foram
	      atualizados de seu texto original</p></div><div class="blockquote"><blockquote class="blockquote"><p>A bios PNP configurou ele [o modem] e o deixou
	      conectado na porta em questão, por isso o estilo
	      antigo [no 3.X] <span class="quote">&#8220;<span class="quote">reconhece</span>&#8221;</span> o equipamento
	      ISA.</p><p>No FreeBSD 4 o código ISA é bem mais
	      PnP-centric.  Era possível [no 3.X] encontrar uma
	      placa ISA que funcionava com <span class="quote">&#8220;<span class="quote">determinada</span>&#8221;</span>
	      device e depois, o id PNP da mesma device encontrava a
	      mesma placa novamente, como se fosse uma outra usando os
	      mesmos recursos do sistema, e por isso ele falhava, como
	      se fosse um conflito de recursos.  Portanto, agora ele
	      desabilita o suporta às placas
	      programáveis de forma que essa confusão e
	      dupla detecção de
	      <span class="foreignphrase"><em class="foreignphrase">hardware</em></span> não
	      ocorra.  Essa mudança implica também na
	      necessidade de se saber previamente os ids PnP para cada
	      tipo de equipamento suportado, aumentando um pouco mais
	      a lista de TODO do suporte PnP no sistema.</p></blockquote></div><p>Para fazer o equipamento voltar a funcionar, é
	    necessário encontrar seu PnP id e
	    adicioná-lo a lista de devices ISA reconhecidas
	    como PnP.  Essa informação pode ser obtida
	    usando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> que detecta a
	    configuração dos equipamentos.  Por exemplo,
	    veja a saída do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> de um modem
	    interno:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pnpinfo</code></strong>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</pre><p>[algumas linhas com TAG foram eliminadas]</p><pre class="screen">TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</pre><p>A informação que você quer
	    é a linha <span class="quote">&#8220;<span class="quote">Vendor ID</span>&#8221;</span> no começo
	    da saída do comando.  O valor hexadecimal entre
	    parênteses (0x3024a341 esse caso) é PnP id e
	    o conjunto de caracteres que o antecede (PMC2430) é
	    a identificação ASCII única.</p><p>Alternativamente, se o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> não
	    listou sua placa em questão, o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pciconf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pciconf</span>(8)</span></a> pode
	    ser usado preferivelmente.  Esta é a saída
	    do comando <code class="command">pciconf -vl</code> de uma placa de
	    som onboard:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pciconf -vl</code></strong>
chip1@pci0:31:5:        class=0x040100 card=0x00931028 chip=0x24158086 rev=0x02 hdr=0x00
    vendor   = 'Intel Corporation'
    device   = '82801AA 8xx Chipset AC'97 Audio Controller'
    class    = multimedia
    subclass = audio</pre><p>Aqui deve-se usar o valor do <code class="varname">chip</code>,
	    <span class="quote">&#8220;<span class="quote">0x24158086</span>&#8221;</span>.</p><p>Tais informações (Vendor ID ou valor do
	    chip) precisam ser adicionadas ao arquivo
	    <code class="filename">/usr/src/sys/isa/sio.c</code>.</p><p>Primeiro faça uma cópia de
	    segurança do <code class="filename">sio.c</code> no caso de
	    algo dar errado e também para que você possa
	    fazer um patch para enviar junto com o seu
	    Relatório de Problemas (você vai enviar um
	    PR, não vai?) e depois edite o
	    <code class="filename">sio.c</code> e procure a linha</p><pre class="programlisting">static struct isa_pnp_id sio_ids[] = {</pre><p>Depois analise as linhas logo abaixo para encontrar o
	    lugar apropriado para sua placa.  As entradas na tabela
	    ficam todas parecidas com essa logo abaixo, e são
	    ordenadas de acordo com a identificação
	    ASCII do fabricante do produto a qual deve ser
	    incluída como comentário na coluna do lado
	    do código em questão, e junto com a
	    <span class="emphasis"><em>descrição da placa</em></span> ou
	    parte dela, conforme identificada na saída do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a>:</p><pre class="programlisting">{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</pre><p>Adicione o ID hexadecimal do fabricante da placa no
	    local apropriado, salve o arquivo e recompile o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, depois reinicie o
	    sistema.  Agora a sua placa deve ter sido encontrada como
	    uma device <code class="literal">sio</code> exatamente como era
	    encontrada no FreeBSD 3.X</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68220624"></a><a id="nlist-failed"></a><p><strong>5.22.</strong></p></td><td align="left" valign="top"><p>Qual a causa do erro <span class="errorname">nlist
	      failed</span> quando eu executo, por exemplo, o
	    <code class="command">top</code> ou o
	    <code class="command">systat</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O problema é que o programa que você
	    está tentando executar tenta ler alguma
	    informação específica do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, baseando-se no
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> symbol em
	    questão, mas por algum motivo, essa
	    informação não pode ser encontrada;
	    esse erro é causado por um dos seguintes
	    problemas:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>O <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> e o
		userland do sistema não estão em
		sincronia (por exemplo, você compilou um
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> novo e o
		instalou sem de dar um
		<code class="buildtarget">installworld</code>, ou vice-versa),
		e por isso a tabela de informações dos
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> symbols é
		diferente do que o programa pensa que é.  Se
		esse for o caso basta completar os procedimentos de
		atualização do sistema (veja o arquivo
		<code class="filename">/usr/src/UPDATING</code> para a correta
		seqüência de ações).</p></li><li class="listitem"><p>O <code class="command">/boot/loader</code> não
		está sendo usado para carregar o
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> dessa
		estação, ao invés dele, o boot2
		(veja <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a>) está sendo usado
		diretamente.  Apesar de não ter problema algum
		deixar de usar o <code class="command">/boot/loader</code>, ele
		costuma se comportar melhor na hora de tornar os
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> symbols
		disponíveis para aplicações em
		nível de usuário.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68235088"></a><a id="connection-delay"></a><p><strong>5.23.</strong></p></td><td align="left" valign="top"><p>Porque demora tanto para a conexão se
	    estabelecer via <code class="command">ssh</code> ou
	    <code class="command">telnet</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O sintoma: existe um atraso muito grande entre o
	    estabelecimento da conexão TCP e o momento que o
	    programa cliente pede a senha (ou no caso do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a>, quando a tela de login aparece).</p><p>O problema: o programa servidor dessa
	    transação leva muito tempo tentando resolver
	    o nome da estação cliente que está se
	    conectando.  A maioria dos servidores, incluindo os
	    servidores Telnet e SSH que vem junto com o FreeBSD tentam
	    resolver o número IP do cliente no nome da
	    estação, para, entre outras coisas, gravar
	    essa informação em um arquivo de log para
	    referências futuras por parte do
	    administrador.</p><p>A solução: Se o problema acontece apenas
	    quando você (o cliente) tenta se conectar no
	    servidor, o problema é com o lado cliente da
	    transação; se o problema acontece com
	    qualquer estação que tente se conectar ao
	    computador (servidor) então o problema é do
	    lado servidor.</p><p>Se o problema é com o cliente, a única
	    maneira de corrigir o problema é configurar
	    corretamente o servidor DNS que responde autoritativamente
	    pelo endereço da estação.  Se for uma
	    rede local considere esse comportamento um problema do
	    servidor, e continue lendo;  se a conexão deve ser
	    estabelecida na rede global (internet) , então
	    entre em contato com o seu Provedor de Serviços
	    Internet e solicite que eles corrijam o problema.</p><p>Se o problema é do lado servidor, e a rede em
	    questão, se trata de uma rede local, será
	    necessário configurar o servidor de forma que ele
	    consiga resolver os endereços dos clientes em
	    nomes.  Veja as páginas de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a>
	    e <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a> para obter mais informações.
	    Se a conexão é na Internet, provavelmente o
	    resolvedor (lado cliente do serviço de nomes) do
	    seu servidor não está funcionando
	    corretamente.  Pra fazer o teste, tente descobrir o
	    endereço IP do site <code class="systemitem">www.yahoo.com</code>
	    por exemplo.  Se não funcionar, esta ai o
	    problema.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68246608"></a><a id="stray-irq"></a><p><strong>5.24.</strong></p></td><td align="left" valign="top"><p>O que a mensagem <span class="errorname">stray IRQ</span> quer
	    dizer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Stray IRQs são sintomas de
	    <span class="foreignphrase"><em class="foreignphrase">hardware</em></span> que interrompe o
	    pedido de interrupção no meio de um ciclo de
	    autorização de
	    interrupção.</p><p>Existem três formas de tratar o problema:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Aprenda a conviver com as mensagens de
		advertência.  De qualquer forma, todas as
		mensagens exceto as 5 primeiras para cada IRQ
		são suprimidas pelo sistema mesmo.</p></li><li class="listitem"><p>Evite o inconveniente alterando de 5 para 0 na
		função
		<code class="function">isa_strayintr()</code> o número
		de mensagens antes de suprimir as
		advertências.</p></li><li class="listitem"><p>Evite as advertências instalando algum
		equipamento de porta paralela que use a IRQ 7 e o
		driver PPP (é o usual, na maioria dos sistemas)
		e instale algum driver IDE ou qualquer outro
		dispositivo que use a IRQ 15 e seu respectivo
		suporte.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68257360"></a><a id="file-table-full"></a><p><strong>5.25.</strong></p></td><td align="left" valign="top"><p>Por que a mensagem <span class="errorname">file: table is
	      full</span> aparece repetidas vezes no
	    dmesg?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
	    Esse erro indica que você excedeu o número
	    máximo de descrevedores (descriptors) de arquivos
	    no sistema.  Leia a seção <a class="link" href="../handbook/configtuning-kernel-limits.html#KERN-MAXFILES" target="_top">
	      kern.maxfiles </a>da<a class="link" href="../handbook/configtuning-kernel-limits.html" target="_top">
	      capítulo de Ajuste de Limites do
	      <span class="foreignphrase"><em class="foreignphrase">Kernel</em></span></a> no
	    Manual do FreeBSD do FreeBSD para obter mais
	    informações sobre o problema.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68265296"></a><a id="laptop-clock-skew"></a><p><strong>5.26.</strong></p></td><td align="left" valign="top"><p>Por que o relógio do meu laptop mantem a hora
	    incorreta?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Rode o comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dmesg</span>(8)</span></a>, e procure algumas linhas
	    com a expressão  <code class="literal">Timecounter</code>.  A
	    última linha encontrada será o
	    relógio que o FreeBSD escolheu, e com certeza ele
	    será <code class="literal">TSC</code>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dmesg | grep Timecounter</code></strong>
Timecounter "i8254"  frequency 1193182 Hz
Timecounter "TSC"  frequency 595573479 Hz</pre><p>Essa informação pode ser confirmada ao
	    verificar a variável
	    <code class="varname">kern.timecounter.hardware</code> do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.timecounter.hardware</code></strong>
kern.timecounter.hardware: TSC</pre><p>A BIOS do laptop altera a frequência do
	    relógio TSC de forma a modificar a velocidade do
	    processador quando o computador estiver sendo utilizado
	    com baterias, ou se o mesmo entrar em modo de economia de
	    energia.  O FreeBSD não faz distinção
	    entre frequência do clock e modos especiais de
	    trabalho, e por isso pode atrasar ou adiantar a hora do
	    sistema.</p><p>Esse exemplo, o laptop em questão tem dois
	    relógios; portanto o <code class="literal">i8254</code> pode
	    ser definido como padrão na variável
	    <code class="varname">kern.timecounter.hardware</code> do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.hardware=i8254</code></strong>
kern.timecounter.hardware: TSC -&gt; i8254</pre><p>Agora o seu laptop deve conseguir manter a data e hora
	    de forma mais precisa.</p><p>Pra tornar essa alteração
	    automática, adicione a seguinte linha no arquivo
	    <code class="filename">/etc/sysctl.conf</code>.</p><pre class="programlisting">kern.timecounter.hardware=i8254</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68277584"></a><a id="null-null"></a><p><strong>5.27.</strong></p></td><td align="left" valign="top"><p>Por que o meu laptop não funciona muito bem na
	    hora de identificar cartões PCMCIA?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esse problema é comum em laptops que tem mais
	    de um sistema operacional instalado.  Alguns sistemas
	    não-BSD fazem os cartões PCMCIA ficarem em
	    um estado inconsistente, causando um reconhecimento
	    problemático dos dispositivos por parte do
	    <code class="command">pccardd</code>, como por exemplo, detectando
	    os cartões como
	    <span class="errorname">"(null)""(null)"</span> ao invés da
	    sua marca e modelo verdadeiros.</p><p>É necessário desligar completamente a
	    alimentação de energia do equipamento para
	    garantir que o mesmo seja completamente resetado.
	    Desligue completamente o laptop (não suspenda seu
	    funcionamento, não o deixe entrar em modo de
	    espera, conhecido como standby, a
	    alimentação deve ser completamente
	    interrompida), espere alguns - poucos - minutos e reinicie
	    o laptop.  Tudo deve correr bem.</p><p>Alguns laptops são grandes mentirosos quando
	    afirmam estar desligados.  Se o procedimento acima
	    não funcionar, tire a bateria do laptop, espere
	    alguns minutos e ligue o sistema novamente.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68281424"></a><a id="boot-read-error"></a><p><strong>5.28.</strong></p></td><td align="left" valign="top"><p>Por que o bootloader do FreeBSD mostra a mensagem
	    <span class="errorname">Read error</span> e pára
	    completamente logo após a tela da BIOS?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O inicializador do FreeBSD reconheceu a geometria de
	    disco de forma incorreta e por isso esse valor deve ser
	    definido manualmente com o fdisk(8) ao criar ou modificar
	    uma partição FreeBSD.</p><p>A geometria correta do disco pode ser verificada na
	    BIOS do computador.  Procure pelo número de
	    cilindros, cabeças e de setores do disco em
	    questão.
	  </p><p>No fdisk do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a>, aperte a tecla
	    <span class="keycap"><strong>G</strong></span> para definir a geometria do disco
	    manualmente.
	  </p><p>Irá aparecer uma janela de diálogo
	    perguntando o número de cilindros, cabeças e
	    setores do disco.  Defina esses valores, conforme anotados
	    da BIOS do sistema e separados por barras.</p><p>5000 cilindros, 250 cabeças e 60 setores, por
	    exemplo, seria definido como
	    <strong class="userinput"><code>5000/250/60.</code></strong>
	  </p><p>Aperte ENTER para confirmar os valores e depois aperte
	    a tecla <span class="keycap"><strong>W</strong></span> para escrever as novas
	    informações na tabela de
	    partições do disco.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68287696"></a><a id="bootmanager-restore"></a><p><strong>5.29.</strong></p></td><td align="left" valign="top"><p>Outro sistema operacional destruiu o meu gerenciador
	    de inicialização(Boot Manager).  Como eu o
	    recupero?
	  </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Entre no <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> e escolha o menu
	    Configure, seguido do Fdisk.  Escolha o disco onde o
	    gerenciador de boot costumava ficar e aperte a barra de
	    <span class="keycap"><strong>espaços(space)</strong></span>.  Depois aperte a
	    tecla <span class="keycap"><strong>W</strong></span> para escrever as novas
	    informações no disco.  Vai aparecer uma
	    tela, perguntando o que deve ser instalado na MBR do
	    disco.  Escolha o Gerenciador de
	    inicialização(Boot Manager), e ele
	    será reinstalado.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68311888"></a><a id="indefinite-wait-buffer"></a><p><strong>5.30.</strong></p></td><td align="left" valign="top"><p>O que o erro <span class="errorname">swap_pager: indefinite wait
	      buffer:</span> quer dizer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Quer dizer que existe um processo tentando paginar uma
	    área da memória para o disco, e que esse
	    processo demorou mais de 20 segundos;  portanto falhou.
	    É provável que a causa desse erro sejam
	    blocos defeituosos no disco, falha nos cabos, ou
	    até mesmo algum outro erro de I/O relacionado ao
	    <span class="foreignphrase"><em class="foreignphrase">hardware</em></span>.  Se o disco
	    estiver danificado, serão apresentadas mensagens de
	    erro referentes ao mesmo em
	    <code class="filename">/var/log/messages</code>  e também na
	    saída do <code class="command">dmesg</code>.  Do
	    contrário, verifique seus cabos e
	    conectores.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="hardware.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="commercial.html">Próxima</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 4. Compatibilidade de Hardware </td><td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td><td width="40%" align="right" valign="top"> Capítulo 6. Aplicações Comerciais</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Este, e outros documentos, podem ser obtidos em
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Para perguntas sobre FreeBSD, leia a
    <a href="http://www.FreeBSD.org/docs.html">documentação</a> antes de contatar
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Para perguntas sobre esta documentação, envie e-mail para
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>