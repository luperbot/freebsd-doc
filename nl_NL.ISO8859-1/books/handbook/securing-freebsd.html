<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>15.3. FreeBSD beveiligen</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD handboek" /><link rel="up" href="security.html" title="Hoofdstuk 15. Beveiliging" /><link rel="prev" href="security-intro.html" title="15.2. Introductie" /><link rel="next" href="crypt.html" title="15.4. DES, Blowfish, MD5, SHA256, SHA512 en crypt" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">15.3. FreeBSD beveiligen</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Terug</a> </td><th width="60%" align="center">Hoofdstuk 15. Beveiliging</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Volgende</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>15.3. FreeBSD beveiligen</h2></div></div></div><a id="idp76894160" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Commando versus protocol: </h3><p xmlns="http://www.w3.org/1999/xhtml">In dit hele document gebruiken we
	<span class="application">vette</span> tekst om te verwijzen naar een
	commando of applicatie en een <code class="command">monospaced</code>
	lettertype om te verwijzen naar specifieke commando's.
	Protocollen staan vermeld in een normaal lettertype.  Dit
	typografische onderscheid is zinvol omdat bijvoorbeeld ssh
	zowel een protocol als een commando is.</p></div><p>In de volgende onderdelen behandelen we de methodes uit de
      <a class="link" href="security-intro.html" title="15.2. Introductie">vorige paragraaf</a> om een
      FreeBSD-systeem te beveiligen.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>15.3.1. Beveiligen van <code class="systemitem">root</code> en
	medewerkersaccounts.</h3></div></div></div><a id="idp76899536" class="indexterm"></a><p>Om te beginnen: doe geen moeite om medewerkersaccounts
	te beveiligen als de <code class="systemitem">root</code> account niet
	beveiligd is.  Op de meeste systemen heeft de
	<code class="systemitem">root</code> account een wachtwoord.  Als eerste
	moet aangenomen worden dat dit wachtwoord
	<span class="emphasis"><em>altijd</em></span> gecompromitteerd is.  Dit betekent
	niet dat het wachtwoord verwijderd moet worden.  Het wachtwoord
	is namelijk bijna altijd nodig voor toegang via het console van
	de machine.  Het betekent wel dat het niet mogelijk gemaakt
	moet worden om het wachtwoord te gebruiken buiten het console
	om en mogelijk zelfs niet via het <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> commando.  Pty's
	moeten bijvoorbeeld gemarkeerd staan als onveilig
	(<span class="quote">&#8220;<span class="quote">insecure</span>&#8221;</span>) in het bestand
	<code class="filename">/etc/ttys</code> zodat direct aanmelden met
	<code class="systemitem">root</code> via <code class="command">telnet</code>
	of <code class="command">rlogin</code> niet wordt toegestaan.  Als andere
	aanmelddiensten zoals <span class="application">sshd</span> gebruikt
	worden, dan hoort direct aanmelden via
	<code class="systemitem">root</code> uitgeschakeld staat.  Dit kan door
	het bestand <code class="filename">/etc/ssh/sshd_config</code> te
	bewerken en ervoor te zorgen dat
	<code class="literal">PermitRootLogin</code> op <code class="literal">no</code>
	staat.  Dit moet gebeuren voor iedere methode van toegang
	&#8211; diensten zoals FTP worden vaak over het hoofd gezien.
	Het direct aanmelden van <code class="systemitem">root</code> hoort alleen
	te mogen via het systeemconsole.</p><a id="idp76911568" class="indexterm"></a><p>Natuurlijk moet een systeembeheerder de mogelijkheid hebben
	om <code class="systemitem">root</code> te worden.  Daarvoor kunnen een
	paar gaatjes geprikt worden.  Maar dan moet ervoor gezorgd
	worden dat er voor deze gaatjes extra aanmelden met een
	wachtwoord nodig is.  Eén manier om
	<code class="systemitem">root</code> toegankelijk te maken is door het
	toevoegen van de juiste medewerkersaccounts aan de
	<code class="systemitem">wheel</code> groep (in
	<code class="filename">/etc/group</code>).  De medewerkers die lid zijn
	van de groep <code class="systemitem">wheel</code> mogen
	<code class="command">su</code>&#8211;en naar <code class="systemitem">root</code>.
	Maak medewerkers nooit <span class="quote">&#8220;<span class="quote">native</span>&#8221;</span> lid van de groep
	<code class="systemitem">wheel</code> door ze in de groep
	<code class="systemitem">wheel</code> te plaatsen in
	<code class="filename">/etc/group</code>.  Medewerkersaccounts horen lid
	te zijn van de groep <code class="systemitem">staff</code> en horen dan
	pas toegevoegd te worden aan de groep
	<code class="systemitem">wheel</code> in het bestand
	<code class="filename">/etc/group</code>.  Alleen medewerkers die ook
	echt toegang tot <code class="systemitem">root</code> nodig hebben horen
	in de groep <code class="systemitem">wheel</code> geplaatst te worden.
	Het is ook mogelijk, door een autenticatiemethode als Kerberos
	te gebruiken, om het bestand <code class="filename">.k5login</code> van
	Kerberos in de <code class="systemitem">root</code> account te gebruiken
	om een <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> naar <code class="systemitem">root</code> toe te staan
	zonder ook maar iemand lid te maken van de groep
	<code class="systemitem">wheel</code>.  Dit is misschien wel een
	betere oplossing, omdat het
	<code class="systemitem">wheel</code>-mechanisme het nog steeds mogelijk
	maakt voor een inbreker <code class="systemitem">root</code> te breken als
	de inbreker een wachtwoordbestand te pakken heeft gekregen en
	toegang kan krijgen tot één van de
	medewerkersaccounts.  Hoewel het instellen van het
	<code class="systemitem">wheel</code>-mechanisme beter is dan niets, is
	het niet per se de meest veilige optie.</p><p>Om een account volledig op slot te zetten, dient het
	commando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> gebruikt te worden:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pw lock staff</code></strong></pre><p>Dit voorkomt dat de gebruiker zich aanmeldt via enig
	mechanisme, inclusief <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a>.</p><p>Een andere manier om toegang tot accounts te blokkeren is om
	het versleutelde wachtwoord door een enkel
	<span class="quote">&#8220;<span class="quote"><code class="literal">*</code></span>&#8221;</span>-karakter te vervangen.  Dit
	karakter zal nooit overeenkomen met het versleutelde wachtwoord
	en dus gebruikerstoegang blokkeren.  Het volgende
	medewerkersaccount bijvoorbeeld:</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>zou veranderd moeten worden in:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Dit voorkomt dat de gebruiker <code class="systemitem">foobar</code>
	zich aanmeldt met conventionele methoden.  Deze methode om
	toegang te beperken werkt niet op sites die
	<span class="application">Kerberos</span> gebruiken of in situaties
	waarin de gebruiker met <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> sleutels heeft
	geïnstalleerd.</p><p>Deze beveiligingsmechanismen hebben ook als uitgangspunt dat
	vanaf een zwaarder beveiligde machine wordt aangemeld op een
	minder beveiligd systeem.  Als een hoofdserver bijvoorbeeld
	allerlei servers draait, zou het werkstation er geen moeten
	draaien.  Om een werkstation redelijk veilig te laten zijn,
	dienen er zo min mogelijk servers op te draaien, bij voorkeur
	zelfs geen en er zou een schermbeveiliging met
	wachtwoordbeveiliging op moeten draaien.  Maar als een aanvaller
	fysieke toegang heeft tot een werkstation, dan kan hij elke
	beveiliging die erop is aangebracht omzeilen.  Dit probleem
	dient echt overwogen te worden, net als het feit dat de meeste
	aanvallen van een afstand plaatsvinden, via het netwerk, door
	mensen die geen fysieke toegang hebben tot werkstations of
	servers.</p><p>Het gebruik van iets als Kerberos geeft de mogelijkheid
	om het wachtwoord van de account van een medewerker buiten
	gebruik te stellen of te wijzigen op één plaats,
	waarbij het meteen actief is op alle machines waarop die
	medewerker een account heeft.  Als de account van een
	medewerker gecompromitteerd raakt, moet vooral de mogelijkheid
	om per direct het wachtwoord voor machines te kunnen aanpassen
	niet onderschat worden.  Met afzonderlijke wachtwoorden kan het
	veranderen van wachtwoorden op N systemen een puinhoop worden.
	Met Kerberos kunnen ook wachtwoordrestricties opgelegd worden:
	het is niet alleen mogelijk om een Kerberos
	<span class="quote">&#8220;<span class="quote">ticket</span>&#8221;</span> na een bepaalde tijd te laten verlopen,
	maar het Kerberos systeem kan afdwingen dat de gebruiker na een
	bepaalde tijd een nieuw wachtwoord kiest (na bijvoorbeeld een
	maand).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76945872"></a>15.3.2. Beveiligen van <code class="systemitem">root</code> &#8211; servers
	onder <code class="systemitem">root</code> en suid-/sgid-binaire
	bestanden</h3></div></div></div><a id="idp76947536" class="indexterm"></a><a id="idp76948176" class="indexterm"></a><a id="idp76948816" class="indexterm"></a><a id="idp76949456" class="indexterm"></a><a id="idp76949968" class="indexterm"></a><a id="idp76950608" class="indexterm"></a><a id="idp76951248" class="indexterm"></a><a id="idp76951888" class="indexterm"></a><p>Een voorzichtige systeembeheerder draait alleen die servers
	die nodig zijn, niets meer, niets minder.  Bedenk dat
	servers van derde partijen vaak de meeste neiging hebben tot
	het vertonen van bugs.  Zo staat bijvoorbeeld het draaien van
	een oude versie van <span class="application">imapd</span> of
	<span class="application">popper</span> gelijk aan het weggeven van
	de <code class="systemitem">root</code> account aan de hele wereld.  Draai
	nooit een server die niet zorgvuldig is onderzocht.  Veel
	servers hoeven niet te draaien als <code class="systemitem">root</code>.
	Zo kunnen de <span class="application">ntalk</span>,
	<span class="application">comsat</span> en
	<span class="application">finger</span> daemons bijvoorbeeld draaien
	in speciale gebruikerszandbakken
	(<span class="quote">&#8220;<span class="quote"><em class="firstterm">sandboxes</em></span>&#8221;</span>).  Een zandbak
	is niet perfect, tenzij er heel veel moeite gedaan wordt, maar
	de meerlagenbenadering blijft bestaan: als iemand via een
	server die in een zandbak draait weet in te breken, dan moeten
	ze eerst nog uit de zandbak komen.  Hoe groter het aantal lagen
	is waar een inbreker doorheen moet, hoe kleiner de kans op
	succes is.  <code class="systemitem">root</code> gaten zijn historisch
	gezien aanwezig geweest in vrijwel iedere server die ooit als
	<code class="systemitem">root</code> gedraaid heeft, inclusief de
	basisservers van een systeem.  Op een machine waarop mensen
	alleen aanmelden via <span class="application">sshd</span> en nooit
	via <span class="application">telnetd</span> of
	<span class="application">rshd</span> of
	<span class="application">rlogind</span> dienen die servers
	uitgeschakeld te worden!</p><p>FreeBSD draait <span class="application">ntalkd</span>,
	<span class="application">comsat</span> en
	<span class="application">finger</span> tegenwoordig standaard in een
	zandbak.  Een ander programma dat misschien beter in een
	zandbak kan draaien is <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.  In
	<code class="filename">/etc/defaults/rc.conf</code> staat als commentaar
	welke parameters er nodig zijn om
	<span class="application">named</span> in een zandbak te draaien.
	Afhankelijk van of het een nieuwe systeeminstallatie of het
	bijwerken van een bestaand systeem betreft, worden de speciale
	gebruikersaccounts die bij die zandbakken horen misschien niet
	geïnstalleerd.  Een voorzichtige systeembeheerder
	onderzoekt en implementeert zandbakken voor servers waar dat
	ook maar mogelijk is.</p><a id="idp76970704" class="indexterm"></a><p>Er zijn een aantal diensten die vooral niet in een zandbak
	draaien: <span class="application">sendmail</span>,
	<span class="application">popper</span>,
	<span class="application">imapd</span>,
	<span class="application">ftpd</span> en andere.  Voor sommige
	servers zijn alternatieven, maar dat kost misschien meer tijd
	dan er te besteden is (gemak dient de mens).  Het kan voorkomen
	dat deze servers als <code class="systemitem">root</code> moeten draaien
	en dat er vertrouwd moet worden op andere mechanismen om een
	inbraak via die servers te detecteren.</p><p>De andere grote mogelijkheid voor <code class="systemitem">root</code>
	gaten in een systeem zijn de suid-root en sgid-binaire
	bestanden die geïnstalleerd zijn op een systeem.  Veel van
	die bestanden, zoals <span class="application">rlogin</span>, staan in
	<code class="filename">/bin</code>,
	<code class="filename">/sbin</code>,
	<code class="filename">/usr/bin</code> of
	<code class="filename">/usr/sbin</code>.  Hoewel het niet 100%
	veilig is, mag aangenomen worden dat de suid- en sgid-binaire bestanden
	van een standaardsysteem redelijk veilig zijn.  Toch worden er
	nog wel eens <code class="systemitem">root</code> gaten gevonden in deze
	bestanden.  Zo is er in 1998 een <code class="systemitem">root</code> gat
	gevonden in <code class="literal">Xlib</code> waardoor
	<span class="application">xterm</span> (die normaliter suid is)
	kwetsbaar bleek.  Een voorzichtige systeembeheerder kiest voor
	<span class="quote">&#8220;<span class="quote">better to be safe than sorry</span>&#8221;</span> door de
	suid-bestanden die alleen medewerkers hoeven uit te voeren aan
	een speciale groep toe te wijzen en de suid-bestanden die
	niemand gebruikt te lozen (<code class="command">chmod 000</code>).  Een
	server zonder monitor heeft normaal gezien
	<span class="application">xterm</span> niet nodig.  Sgid-bestanden
	kunnen bijna net zo gevaarlijk zijn.  Als een inbreker een
	sgid-kmem stuk kan krijgen, dan kan hij wellicht
	<code class="filename">/dev/kmem</code> lezen en dus het gecodeerde
	wachtwoordbestand, waardoor mogelijk ieder account met
	een wachtwoord besmet is.  Een inbreker toegang tot de groep
	<code class="literal">kmem</code> kan krijgen, zou bijvoorbeeld mee
	kunnen kijken met de toetsaanslagen die ingegeven worden via de
	pty's, inclusief die pty's die gebruikt worden door gebruikers
	die via beveiligde methodes aanmelden.  Een inbreker die
	toegang krijgt tot de groep <code class="systemitem">tty</code> kan naar
	bijna alle tty's van gebruikers schrijven.  Als een gebruiker
	een terminalprogramma of een terminalemulator met een
	toetsenbordsimulatieoptie draait, dan kan de inbreker in
	potentie een gegevensstroom genereren die ervoor zorgt dat de
	terminal van de gebruiker een commando echot, dat dan wordt
	uitgevoerd door die gebruiker.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>15.3.3. Beveiligen van gebruikersaccounts</h3></div></div></div><p>Gebruikersaccounts zijn gewoonlijk het meest lastig om te
	beveiligen.  Hoewel er allerlei draconische maatregelen genomen
	kunnen worden met betrekking tot de medewerkers en hun
	wachtwoorden <span class="quote">&#8220;<span class="quote">weggesterd</span>&#8221;</span> kunnen worden, gaat dat
	waarschijnlijk niet lukken met de gewone gebruikersaccounts.
	Als er toch voldoende vrijheid is, dan prijst de beheerder zich
	gelukkig en is het misschien toch mogelijk de accounts
	voldoende te beveiligen.  Als die vrijheid er niet is, dan
	moeten die accounts gewoon netter gemonitord worden.  Het
	gebruik van <span class="application">ssh</span> en
	<span class="application">Kerberos</span> voor gebruikersaccounts is
	problematischer vanwege het extra beheer en de ondersteuning,
	maar nog steeds een prima oplossing in vergelijking met een
	versleuteld wachtwoordbestand.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp77004112"></a>15.3.4. Beveiligen van het wachtwoordbestand</h3></div></div></div><p>De enige echte oplossing is zoveel mogelijk wachtwoorden
	wegsterren en <span class="application">ssh</span>
	of <span class="application">Kerberos</span> gebruiken voor toegang
	tot die accounts.  Hoewel een gecodeerd wachtwoordbestand
	(<code class="filename">/etc/spwd.db</code>) alleen gelezen kan worden
	door <code class="systemitem">root</code>, is het wel mogelijk dat een
	inbreker leestoegang krijgt tot dat bestand zonder dat de
	aanvaller root-schrijftoegang krijgt.</p><p>Beveiligingsscripts moeten altijd controleren op en
	rapporteren over wijzigingen in het wachtwoordbestand (zie ook
	<a class="link" href="securing-freebsd.html#security-integrity" title="15.3.6. Bestandsintegriteit controleren: binaire bestanden, instellingenbestanden, enzovoort">Bestandsintegriteit
	  Controleren</a> hieronder).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp77020496"></a>15.3.5. Beveiligen van de kern van de kernel, ruwe apparaten en
	bestandssystemen</h3></div></div></div><p>Als een aanvaller toegang krijgt tot
	<code class="systemitem">root</code> dan kan hij ongeveer alles, maar er
	zijn een paar slimmigheidjes.  Zo hebben bijvoorbeeld de meeste
	moderne kernels een ingebouwd pakketsnuffelstuurprogramma
	(<span class="quote">&#8220;<span class="quote">packet sniffing</span>&#8221;</span>).  Bij FreeBSD is dat het
	<code class="filename">bpf</code> apparaat.  Een inbreker zal in het
	algemeen proberen een pakketsnuffelaar te draaien op een
	gecompromitteerde machine.  De inbreker hoeft deze mogelijkheid
	niet te hebben en bij de meeste systemen is het niet verplicht
	het <code class="filename">bpf</code> apparaat mee te
	compileren.</p><a id="idp77023184" class="indexterm"></a><p>Maar zelfs als het <code class="filename">bpf</code>
	apparaat is uitgeschakeld, dan zijn er nog
	<code class="filename">/dev/mem</code> en
	<code class="filename">/dev/kmem</code>.  De inbreker kan namelijk nog
	schrijven naar ruwe schrijfapparaten.  En er is ook nog een
	optie in de kernel die modulelader (<span class="quote">&#8220;<span class="quote">module
	loader</span>&#8221;</span>) heet, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.  Een ondernemende
	inbreker kan een KLD-module gebruiken om zijn eigen
	<code class="filename">bpf</code>-apparaat of een ander
	snuffelapparaat te installeren in een draaiende kernel.  Om
	deze problemen te voorkomen, moet de kernel op een hoger
	veiligheidsniveau draaien, ten minste securelevel 1.</p><p>Het veiligheidsniveau van de kernel kan op een aantal
	manieren worden ingesteld.  De eenvoudigste manier om het
	veiligheidsniveau van een draaiende kernel te verhogen is met
	<code class="command">sysctl</code> op de kernelvariabele
	<code class="varname">kern.securelevel</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel=1</code></strong></pre><p>Standaard start de kernel van FreeBSD op met een
	veiligheidsniveau van -1.  Het veiligheidsniveau blijft -1
	tenzij het is veranderd, òfwel door de beheerder
	òfwel door <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> vanwege een instelling in de
	opstartscripts.  Het veiligheidsniveau kan tijdens het opstarten
	van het systeem verhoogd worden door de variabele
	<code class="varname">kern_securelevel_enable</code> op
	<code class="literal">YES</code> te zetten in het bestand
	<code class="filename">/etc/rc.conf</code>, en de waarde van de variabele
	<code class="varname">kern_securelevel</code> op het gewenste
	veiligheidsniveau in te stellen.</p><p>Het standaard veiligheidsniveau van een FreeBSD-systeem direct
	nadat de opstartscripts zijn uitgevoerd is -1.  Dit wordt
	<span class="quote">&#8220;<span class="quote">onveilige modus</span>&#8221;</span> genoemd omdat de onveranderlijke
	bestandsvlag uitgezet kan worden, er van/naar alle apparaten mag
	worden gelezen en geschreven, enzovoorts.</p><p>Als eenmaal het veiligheidsniveau op 1 of een hogere waarde
	is ingesteld, worden de alleen-toevoegen en onveranderlijke
	bestanden gehonoreerd, deze kunnen niet worden uitgezet, en
	wordt toegang tot rauwe apparaten ontzegd.  Hogere niveaus
	beperken nog meer bewerkingen.  Lees, voor een volledige
	beschrijving van het effect van de verschillende
	veiligheidsniveaus, de handleidingpagina <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=security&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">security</span>(7)</span></a>.</p><div xmlns="" class="note"><h3 class="admontitle">Opmerking: </h3><p xmlns="http://www.w3.org/1999/xhtml">Het ophogen van het veiligheidsniveau naar 1 of hoger kan
	  enkele problemen met X11 (toegang tot
	  <code class="filename">/dev/io</code> zal worden geblokkeerd), of met
	  de installatie van FreeBSD wanneer die vanaf de broncode is
	  gebouwd (het gedeelte <code class="buildtarget">installword</code> van
	  het proces moet tijdelijk de alleen-toevoegen en
	  onveranderlijke vlaggen van sommige bestanden uitzetten), en
	  met enkele andere gevallen veroorzaken.  Soms, zoals het geval
	  is met X11, is het mogelijk om dit te omzeilen door
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> behoorlijk vroeg in het opstartproces te starten,
	  wanneer het veiligheidsniveau nog laag genoeg is.
	  Omzeilmethoden zoals deze zijn misschien niet voor alle
	  veiligheidsniveaus of voor alle beperkingen die ze opleggen
	  mogelijk.  Wat vooruit plannen is een goed idee.  Het is
	  belangrijk om de beperkingen die door elk veiligheidsniveau
	  worden opgelegd te begrijpen omdat ze het gebruiksgemak van
	  het systeem sterk verminderen.  Het vergemakkelijkt ook het
	  kiezen van eens standaardinstelling en voorkomt allerlei
	  verassingen.</p></div><p>Als het veiligheidsniveau van de kernel naar 1 of hoger
	wordt verhoogd, kan het nuttig zijn om de vlag
	<code class="literal">schg</code> aan te zetten voor kritieke
	opstartprogramma's, mappen, en scriptbestanden (i.e., alles dat
	gedraaid wordt tot het punt waar het veiligheidsniveau wordt
	ingesteld).  Dit kan overdreven zijn, en het bijwerken van het
	systeem is veel moeilijker wanneer het op een hoog
	veiligheidsniveau werkt.  Een minder beperkend compromis is om
	het systeem op een hoger veiligheidsniveau te draaien maar het
	aanzetten van de vlag <code class="literal">schg</code> voor elk
	systeembestand en -map onder de zon over te slaan.  Een andere
	mogelijkheid is om <code class="filename">/</code> en
	<code class="filename">/usr</code> simpelweg als alleen-lezen
	aan te koppelen.  Het dient opgemerkt te worden dat het te draconisch
	zijn over wat is toegestaan het belangrijke detecteren van een
	inbraak kan verhinderen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>15.3.6. Bestandsintegriteit controleren: binaire bestanden,
	instellingenbestanden, enzovoort</h3></div></div></div><p>Als puntje bij paaltje komt kan de kern van een systeem
	maar tot een bepaald punt beveiligd worden zonder dat het
	minder prettig werken wordt.  Zo werk het zetten van de
	<code class="literal">schg</code> bit met <code class="command">chflags</code> op
	de meeste bestanden in <code class="filename">/</code> en
	<code class="filename">/usr</code> waarschijnlijk averechts,
	omdat, hoewel de bestanden beschermd zijn, ook het venster waarin
	detectie plaats kan vinden is gesloten.  De laatste laag van
	beveiliging is waarschijnlijk de meest belangrijke: detectie.
	Alle overige beveiliging is vrijwel waardeloos (of nog erger:
	geeft een vals gevoel van beveiliging) als een mogelijke inbraak
	niet gedetecteerd kan worden.  Een belangrijk doel van het
	meerlagenmodel is het vertragen van een aanvaller, nog meer dan
	hem te stoppen, om hem op heterdaad te kunnen betrappen.</p><p>De beste manier om te zoeken naar een inbraak is zoeken
	naar gewijzigde, ontbrekende of onverwachte bestanden.  De beste
	manier om te zoeken naar gewijzigde bestanden is vanaf een
	ander (vaak gecentraliseerd) systeem met beperkte toegang.
	Met zelfgeschreven scripts op dat extra beveiligde systeem met
	beperkte toegang is een beheerder vrijwel onzichtbaar voor
	mogelijke aanvallers en dat is belangrijk.  Om het nut te
	maximaliseren moeten in het algemeen dat systeem met beperkte
	toegang best veel rechten gegeven worden op de andere machines
	in het netwerk, vaak via een alleen-lezen NFS-export van de
	andere machines naar het systeem met beperkte toegang of door
	<span class="application">ssh</span> sleutelparen in te stellen om
	het systeem met beperkte toegang een
	<span class="application">ssh</span> verbinding te laten maken met de
	andere machines.  Buiten het netwerkverkeer, is NFS de minst
	zichtbare methode.  Hierdoor kunnen de bestandssystemen
	op alle cliëntmachines vrijwel ongezien gemonitord worden.
	Als de server met beperkte toegang verbonden is met de
	cliëntmachines via een switch, dan is de NFS-methode vaak
	de beste keus.  Als de server met beperkte toegang met de andere
	machines is verbonden via een hub of door meerdere routers, dan
	is de NFS-methode wellicht niet veilig genoeg (vanuit een
	netwerk standpunt) en kan beter <span class="application">ssh</span>
	gebruikt worden, ondanks de audit-sporen die
	<span class="application">ssh</span> achterlaat.</p><p>Als de machine met beperkte toegang eenmaal minstens
	leestoegang heeft tot een cliëntsysteem dat het moet gaan
	monitoren, dan moeten scripts gemaakt worden om dat monitoren
	ook echt uit te voeren.  Uitgaande van een NFS-koppeling, kunnen
	de scripts gebruik maken van eenvoudige systeem hulpprogramma's
	als <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> en <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>.  We adviseren minstens
	één keer per dag een md5 te maken van alle
	bestanden op de cliëntmachine en van instellingenbestanden
	als in <code class="filename">/etc</code> en
	<code class="filename">/usr/local/etc</code> zelfs vaker.
	Als er verschillen worden aangetroffen ten opzichte van de basis md5
	informatie op het systeem met beperkte toegang, dan hoort het
	script te gillen om een beheerder die het moet gaan uitzoeken.
	Een goed beveiligingsscript controleert ook op onverwachte
	suid-bestanden en op nieuwe en verwijderde bestanden op
	systeempartities als <code class="filename">/</code> en
	<code class="filename">/usr</code>.</p><p>Als <span class="application">ssh</span> in plaats van NFS wordt
	gebruikt, dan is het schrijven van het script lastiger.  Dan
	moeten de scripts met <code class="command">scp</code> naar de cliënt
	verplaatst worden om ze uit te voeren, waardoor ze zichtbaar
	worden.  Voor de veiligheid dienen ook de binaire bestanden die
	het script gebruikt, zoals <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a>, gekopieerd te
	worden.  De <span class="application">ssh</span>-cliënt op de
	cliënt zou al gecompromitteerd kunnen zijn.  Het is
	misschien noodzakelijk ssh te gebruiken over onveilige
	verbindingen, maar dat maakt alles een stuk lastiger.</p><p>Een goed beveiligingsscript voert ook controles uit op de
	instellingenbestanden van gebruikers en medewerkers:
	<code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
	<code class="filename">.ssh/authorized_keys</code>, enzovoort.
	Dat zijn bestanden die buiten het bereik van de
	<code class="literal">MD5</code>-controle vallen.</p><p>Als gebruikers veel schijfruimte hebben, dan kan het te lang
	duren om alle bestanden op deze partitie te controleren.  In dat
	geval is het verstandig de koppelvlaggen zo in te stellen dat
	suid-binaire bestanden op die partities niet zijn toegestaan.
	Zie daarvoor de optie <code class="literal">nosuid</code> (zie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>).  Die partities moeten wel toch nog minstens eens
	per week doorzocht worden, omdat het doel van deze
	beveiligingslaag het ontdekken van een inbraakpoging is, of die
	nu succesvol is of niet.</p><p>Procesverantwoording (zie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) kost relatief
	gezien weinig en kan bijdragen aan een evaluatie mechanisme
	voor na inbraken.  Het is erg handig om uit te zoeken hoe
	iemand precies heeft ingebroken op het systeem, mits het
	bestand nog onbeschadigd is na de inbraak.</p><p>Tenslotte horen beveiligingsscripts de logboekbestanden te
	verwerken en de logboekbestanden zelf horen zo veilig mogelijk
	tot stand te komen.  <span class="quote">&#8220;<span class="quote">remote syslog</span>&#8221;</span> kan erg
	zinvol zijn.  Een aanvaller zal proberen zijn sporen uit te
	wissen en logboekbestanden zijn van groot belang voor een
	systeembeheerder als het gaat om uitzoeken wanneer en hoe er is
	ingebroken.  Een manier om logboekbestanden veilig te stellen
	is door het systeemconsole via een seriële poort aan te
	sluiten op een veilige machine en zo informatie te
	verzamelen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp77075280"></a>15.3.7. Paranoia</h3></div></div></div><p>Een beetje paranoia is niet verkeerd.  Eigenlijk kan de
	systeembeheerder zoveel beveiligingsopties inschakelen als hij
	wil, als deze maar geen impact hebben op het gebruiksgemak en
	de beveiligingsopties die <span class="emphasis"><em>wel</em></span> impact
	hebben op het gebruiksgemak kunnen ingeschakeld worden als daar
	zorgvuldig mee wordt omgegaan.  Nog belangrijker is misschien
	dat er een juiste combinatie wordt gevonden.  Als de
	aanbevelingen uit dit document woord voor woord worden
	opgevolgd, dan worden daarmee de methodes aan een toekomstige
	aanvaller verraden, die ook toegang heeft tot dit
	document.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp77076816"></a>15.3.8. Ontzeggen van Dienst aanvallen</h3></div></div></div><a id="idp77077456" class="indexterm"></a><p>In deze paragraaf worden Ontzeggen van Dienst aanvallen
	(<span class="quote">&#8220;<span class="quote">Denial of Service</span>&#8221;</span> of DoS) behandeld.  Een
	DoS-aanval wordt meestal uitgevoerd als pakketaanval.  Hoewel er
	weinig gedaan kan worden tegen de huidige aanvallen met
	gefingeerde pakketten die een netwerk kunnen verzadigen, kan
	de schade geminimaliseerd worden door ervoor te zorgen dat
	servers er niet door plat gaan door:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Limiteren van server forks.</p></li><li class="listitem"><p>Limiteren van springplank (<span class="quote">&#8220;<span class="quote">springboard</span>&#8221;</span>)
	    aanvallen (ICMP response aanvallen, ping broadcast, etc.).</p></li><li class="listitem"><p>De Kernel Route Cache overloaden.</p></li></ol></div><p>Een veelvoorkomende DoS-aanval is om een server aan te
	vallen door het zoveel kindprocessen aan te laten maken dat het
	hostsysteem uiteindelijk geen bestandsdescriptors, geheugen
	enzovoort meer heeft en het dan opgeeft.
	<span class="application">inetd</span> (zie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>) kent een
	aantal instellingen om dit type aanval af te zwakken.  Hoewel
	het mogelijk is ervoor te zorgen dat een machine niet plat
	gaat, is het in het algemeen niet mogelijk te voorkomen dat de
	dienstverlening door de aanval wordt verstoord.  Meer is te
	lezen in de handleiding van <span class="application">inetd</span>
	en het advies is in het bijzonder aandacht aan de
	<code class="option">-c</code>, <code class="option">-C</code> en <code class="option">-R</code>
	opties te besteden.  Aanvallen met gefingeerde
	<acronym class="acronym">IP</acronym> adressen omzeilen de <code class="option">-C</code>
	optie naar <span class="application">inetd</span>, dus in het
	algemeen moet een combinatie van opties gebruikt worden.
	Sommige op zichzelf staande servers hebben parameters waarmee
	het aantal forks gelimiteerd kan worden.</p><p><span class="application">Sendmail</span> heeft de optie
	<code class="option">-OMaxDaemonChildren</code> die veel beter blijkt te
	werken dan het gebruik van de opties van
	<span class="application">Sendmail</span> waarmee de werklast
	gelimiteerd kan worden.  De parameter
	<code class="literal">MaxDaemonChildren</code> moet zodanig ingesteld
	worden dat als <span class="application">sendmail</span> start; deze
	hoog genoeg is om de te verwachten belasting aan te kunnen,
	maar niet zo hoog is dat de computer het aantal instanties van
	<span class="application">Sendmail</span>s niet aankan zonder plat te
	gaan.  Het is ook verstandig om
	<span class="application">Sendmail</span> in de wachtrijmodus
	(<code class="option">-ODeliveryMode=queued</code>) te draaien en de
	daemon (<code class="command">sendmail -bd</code>) los te koppelen van de
	verwerking van de wachtrij (<code class="command">sendmail -q15m</code>).
	Als de verwerking van wachtrij real-time moet, kunnen de
	tussenpozen voor verwerking verkort worden door deze
	bijvoorbeeld op <code class="option">-q1m</code> in te stellen, maar dan
	is een redelijke instelling van
	<code class="literal">MaxDaemonChildren</code> van belang om
	<span class="emphasis"><em>die</em></span> <span class="application">Sendmail</span> te
	beschermen tegen trapsgewijze fouten.</p><p><span class="application">Syslogd</span> kan direct aangevallen
	worden en het is sterk aan te raden de <code class="option">-s</code>
	optie te gebruiken waar dat ook maar mogelijk is en anders de
	<code class="option">-a</code> optie.</p><p>Er dient voorzichtig omgesprongen te worden met diensten
	die terugverbinden zoals
	<span class="application">TCP Wrapper</span>'s reverse-identd die
	direct aangevallen kan worden.  In het algemeen is het hierom
	onverstandig gebruik te maken van de reverse-ident optie van
	<span class="application">TCP Wrapper</span>.</p><p>Het is een goed idee om interne diensten af te schermen
	voor toegang van buitenaf door ze te firewallen op de routers
	aan de rand van een netwerk (<span class="quote">&#8220;<span class="quote">border routers</span>&#8221;</span>).
	Dit heeft als achtergrond dat verzadigingsaanvallen voorkomen
	van buiten het LAN voorkomen kunnen worden.  Daarmee wordt geen
	aanval op <code class="systemitem">root</code> via het netwerk en die
	diensten daaraan voorkomen.  Er dient altijd een exclusieve
	firewall te zijn, dat wil zeggen <span class="quote">&#8220;<span class="quote">firewall alles
	<span class="emphasis"><em>behalve</em></span> poorten A, B, C, D en M-Z</span>&#8221;</span>.
	Zo worden alle lage poorten gefirewalled behalve die voor
	specifieke diensten als <span class="application">named</span> (als
	er een primary is voor een zone),
	<span class="application">ntalkd</span>,
	<span class="application">sendmail</span> en andere diensten die
	vanaf Internet toegankelijk moeten zijn.  Als de firewall
	andersom wordt ingesteld, als een inclusieve of tolerante
	firewall, dan is de kans groot dat er wordt vergeten een aantal
	diensten af te <span class="quote">&#8220;<span class="quote">sluiten</span>&#8221;</span> of dat er een nieuwe
	interne dienst wordt toegevoegd en de firewall niet wordt
	bijgewerkt.  Er kan nog steeds voor gekozen worden de hoge
	poorten open te zetten, zodat een tolerante situatie ontstaat,
	zonder de lage poorten open te stellen.  FreeBSD biedt ook de
	mogelijkheid een reeks poortnummers die gebruikt worden voor
	dynamische verbindingen in te stellen via de verscheidene
	<code class="varname">net.inet.ip.portrange</code>
	<code class="command">sysctl</code>s (<code class="command">sysctl -a | fgrep
	portrange</code>), waardoor ook de complexiteit van de
	firewall instellingen kan vereenvoudigen.  Zo kan bijvoorbeeld
	een normaal begin tot eindbereik ingesteld worden van 4000 tot
	5000 en een hoog poortbereik van 49152 tot 65535.  Daarna kan
	alles onder 4000 op de firewall geblokkeerd worden (met
	uitzondering van bepaalde poorten die vanaf Internet bereikbaar
	moeten zijn natuurlijk).</p><p>Een andere veelvoorkomende DoS-aanval is de
	springplankaanval: een server zo aanvallen dat de respons van
	die server de server zelf, het lokale netwerk of een andere
	machine overbelast.  De meest voorkomende aanval van dit type is
	de <span class="emphasis"><em>ICMP ping broadcast aanval</em></span>.  De
	aanvaller fingeert ping-pakketten die naar het broadcast-adres
	van het LAN worden gezonden met als bron het
	<acronym class="acronym">IP</acronym>-adres van de machine die hij eigenlijk aan
	wil vallen.  Als de routers aan de rand van het netwerk niet
	zijn ingesteld om een ping-pakketten aan een broadcast-adres te
	blokkeren, dan kan het LAN genoeg antwoorden produceren om de
	verbinding van het slachtoffer (het gefingeerde bronadres) te
	verzadigen, zeker als de aanvaller hetzelfde doet met tientallen
	andere netwerken.  Broadcastaanvallen met een volume van meer
	dan 120 megabit zijn al voorgekomen.  Een tweede
	springplankaanval is er een tegen het ICMP-foutmeldingssysteem.
	Door een pakket te maken waarop een ICMP-foutmelding komt, kan
	een aanvaller de inkomende verbinding van een server verzadigen
	en de uitgaande verbinding laten verzadigen met
	ICMP-foutmeldingen.  Dit type aanval kan een server ook laten
	crashen door te zorgen dat het geheugen ervan vol zit, zeker als
	de server de ICMP-antwoorden niet zo snel kwijt kan als dat het
	ze genereert.  Gebruik de
	<span class="application">sysctl</span>-variabele
	<code class="literal">net.inet.icmp.icmplim</code> om deze aanvallen te
	beperken.  De laatste belangrijke klasse springplankaanvallen
	hangt samen met een aantal interne diensten van
	<span class="application">inetd</span> zoals de UDP-echodienst.  Een
	aanvaller fingeert eenvoudigweg een UDP-pakket met als
	bronadres de echopoort van Server A en als bestemming de
	echopoort van Server B, waar Server A en B allebei op een LAN
	staan.  Die twee servers gaan dat pakket dan heen en weer
	kaatsen.  Een aanvaller kan beide servers overbelasten door een
	aantal van deze pakketten te injecteren.  Soortgelijke problemen
	kunnen ontstaan met de poort <span class="application">chargen</span>.
	Een competente systeembeheerder zal al deze interne
	<span class="application">inetd</span> testdiensten
	uitschakelen.</p><p>Gefingeerde pakketten kunnen ook gebruikt worden om de
	kernel route cache te overbelasten.  Raadpleeg daarvoor de
	<code class="varname">net.inet.ip.rtexpire</code>,
	<code class="varname">rtminexpire</code> en <code class="varname">rtmaxcache</code>
	<code class="command">sysctl</code> parameters.  Een aanval met
	gefingeerde pakketten met een willekeurig bron-IP zorgt ervoor
	dat de kernel een tijdelijke gecachede route maakt in de
	routetabel, die uitgelezen kan worden met <code class="command">netstat -rna
	| fgrep W3</code>.  Deze routes hebben een levensduur van
	ongeveer 1600 seconden.  Als de kernel merkt dat de gecachede
	routetabel te groot is geworden, dan wordt
	<code class="varname">rtexpire</code> dynamisch verkleind, maar deze
	waarde wordt nooit lager dan <code class="varname">rtminexpire</code>.
	Er zijn twee problemen:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>De kernel reageert niet snel genoeg als een laag
	    belaste server wordt aangevallen.</p></li><li class="listitem"><p><code class="varname">rtminexpire</code> is niet laag genoeg om
	    de kernel de aanval te laten overleven.</p></li></ol></div><p>Als servers verbonden zijn met het Internet via een E3
	of sneller, dan is het verstandig om handmatig
	<code class="varname">rtexpire</code> en <code class="varname">rtminexpire</code>
	aan te passen via <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  Als de een van de parameters
	op nul wordt gezet, dan crasht de machine.  Het instellen van
	beide waarden op 2 seconden is voldoende om de routetabel
	tegen een aanval te beschermen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp77126608"></a>15.3.9. Aandachtspunten voor toegang met
	<span class="application">Kerberos</span> en
	<span class="application">SSH</span></h3></div></div></div><a id="idp77127888" class="indexterm"></a><p>Er zijn een aantal aandachtspunten die in acht genomen
	moeten worden als Kerberos of ssh gebruikt worden.  Kerberos 5
	is een prima autenticatieprotocol, maar er zitten bugs in de
	Kerberos-versies van <span class="application">telnet</span> en
	<span class="application">rlogin</span> waardoor ze niet geschikt
	zijn voor binair verkeer.  Kerberos codeert standaard de sessie
	niet, tenzij de optie <code class="option">-x</code> wordt gebruikt.
	<span class="application">ssh</span> codeert standaard wel
	alles.</p><p>Ssh werkt prima, maar het stuurt coderingssleutels
	standaard door.  Dit betekent dat als gegeven een veilig
	werkstation met sleutels die toegang geven tot de rest van het
	systeem en ssh wordt gebruikt om verbinding te maken met een
	onveilige machine, die sleutels gebruikt kunnen worden.  De
	sleutels zelf zijn niet bekend, maar ssh stelt een
	doorstuurpoort in zolang als een gebruikers aangemeld blijft.
	Als de aanvaller <code class="systemitem">root</code>toegang heeft op de
	onveilige machine, dan kan hij die poort gebruiken om toegang
	te krijgen tot alle machines waar de sleutels van de gebruiker
	toegang toe geven.</p><p>Het advies is ssh in combinatie met Kerberos te gebruiken
	voor het aanmelden door medewerkers wanneer dat ook maar
	mogelijk is.  <span class="application">Ssh</span> kan gecompileerd
	worden met Kerberos-ondersteuning.  Dit vermindert de kans op
	blootstelling van ssh-sleutels en beschermt tegelijkertijd
	de wachtwoorden met Kerberos.  Ssh-sleutels zouden alleen
	gebruikt moeten worden voor geautomatiseerde taken vanaf
	veilige machines (iets waar Kerberos ongeschikt voor is).  Het
	advies is om het doorsturen van sleutels uit te schakelen in de
	ssh-instellingen of om de <code class="literal">from=IP/DOMAIN</code>
	optie te gebruiken die ssh in staat stelt het bestand
	<code class="filename">authorized_keys</code> te gebruiken om de
	sleutel alleen bruikbaar te maken voor entiteiten die zich
	aanmelden vanaf vooraf aangewezen machines.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Terug</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Omhoog</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Volgende</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. Introductie </td><td width="20%" align="center"><a accesskey="h" href="index.html">Begin</a></td><td width="40%" align="right" valign="top"> 15.4. DES, Blowfish, MD5, SHA256, SHA512 en crypt</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>