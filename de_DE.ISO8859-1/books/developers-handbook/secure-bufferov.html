<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>3.3. Puffer-Überläufe</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="secure.html" title="Kapitel 3. Sicheres Programmieren" /><link rel="prev" href="secure-philosophy.html" title="3.2. Methoden des sicheren Entwurfs" /><link rel="next" href="secure-setuid.html" title="3.4. SetUID-Themen" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. Puffer-Überläufe</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="secure-philosophy.html">Zurück</a> </td><th width="60%" align="center">Kapitel 3. Sicheres Programmieren</th><td width="20%" align="right"> <a accesskey="n" href="secure-setuid.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="secure-bufferov"></a>3.3. Puffer-Überläufe</h2></div></div></div><p>Puffer-Überläufe gibt es schon seit den
      Anfängen der Von-Neuman-Architektur <a class="xref" href="bi01.html#COD">1</a>.

      <a id="idp67682128" class="indexterm"></a>
      <a id="idp67682640" class="indexterm"></a>

      Sie erlangten zum ersten Mal durch den Internetwurm Morris im
      Jahre 1988 öffentliche Bekanntheit. Unglücklicherweise

      <a id="idp67683280" class="indexterm"></a>

      funktioniert der gleiche grundlegende Angriff noch heute.  Die bei weitem
      häufigste Form eines Puffer-Überlauf-Angriffs basiert darauf,
      den Stack zu korrumpieren.</p><a id="idp67683920" class="indexterm"></a><a id="idp67684432" class="indexterm"></a><p>Die meisten modernen Computer-Systeme verwenden einen
      Stack, um Argumente an Prozeduren zu übergeben und
      lokale Variablen zu speichern. Ein Stack ist ein
      last-in-first-out-Puffer (LIFO) im hohen Speicherbereich
      eines Prozesses. Wenn ein Programm eine Funktion

      <a id="idp67685200" class="indexterm"></a>
      <a id="idp67685712" class="indexterm"></a>

      aufruft wird ein neuer "Stackframe" erzeugt. Dieser besteht aus
      den Argumenten, die der Funktion übergeben wurden und
      einem variabel grossem Bereich für lokale Variablen. Der
      "Stack-Pointer" ist ein Register, dass die

      <a id="idp67686864" class="indexterm"></a>
      <a id="idp67687376" class="indexterm"></a>

      aktuelle Adresse der Stack-Spitze enthält.
      Da sich dieser Wert oft ändert, wenn neue Werte
      auf dem Stack abgelegt werden, bieten viele Implementierungen
      einen "Frame-Pointer", der nahe am Anfang des Stack-Frames
      liegt und es so leichter macht lokale Variablen relativ zum
      aktuellen Stackframe zu adressieren. <a class="xref" href="bi01.html#COD">1</a>
      Die Rücksprungadresse

      <a id="idp67688272" class="indexterm"></a>
      <a id="idp67688784" class="indexterm"></a>
      <a id="idp67689936" class="indexterm"></a>
      <a id="idp67690448" class="indexterm"></a>

      der Funktionen werden ebenfalls auf dem Stack
      gespeichert und das ist der Grund für
      Stack-Überlauf-Exploits. Denn ein böswilliger Nutzer
      kann die Rücksprungadresse der Funktion überschreiben
      indem er eine lokale Variable in der Funktion
      überlaufen lässt, wodurch es ihm möglich ist
      beliebigen Code auszuführen.</p><p>Obwohl Stack-basierte Angriffe bei weitem die
      Häufigsten sind, ist es auch möglich den Stack mit
      einem Heap-basierten (malloc/free) Angriff zu
      überschreiben.</p><p>Die C-Programmiersprache führt keine automatischen
      Bereichsüberprüfungen bei Feldern oder Zeigern durch, wie
      viele andere Sprachen das tun. Außerdem enthält
      die C-Standardbibliothek eine Handvoll sehr
      gefährlicher Funktionen.</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><code class="function">strcpy</code>(char *dest, const
	      char *src)</td><td><p>Kann den Puffer dest überlaufen
	      lassen</p></td></tr><tr><td><code class="function">strcat</code>(char *dest, const
	      char *src)</td><td><p>Kann den Puffer dest überlaufen
	      lassen</p></td></tr><tr><td><code class="function">getwd</code>(char *buf)</td><td><p>Kann den Puffer buf überlaufen
	      lassen</p></td></tr><tr><td><code class="function">gets</code>(char *s)</td><td><p>Kann den Puffer s überlaufen
	      lassen</p></td></tr><tr><td><code class="function">[vf]scanf</code>(const char
	      *format, ...)</td><td><p>Kann sein Argument überlaufen
	      lassen</p></td></tr><tr><td><code class="function">realpath</code>(char *path,
	      char resolved_path[])</td><td><p>Kann den Puffer path überlaufen
	      lassen</p></td></tr><tr><td><code class="function">[v]sprintf</code>(char *str,
	      const char *format, ...)</td><td><p>Kann den Puffer str überlaufen
	      lassen</p></td></tr></tbody></table></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67712592"></a>3.3.1. Puffer-Überlauf Beispiel</h3></div></div></div><p>Das folgende Quellcode-Beispiel enthält einen
	Puffer-Überlauf, der darauf ausgelegt ist die
	Rücksprungadresse zu überschreiben und die
	Anweisung direkt nach dem Funktionsaufruf zu
	überspringen. (Inspiriert durch
	<a class="xref" href="bi01.html#Phrack">4</a>)</p><pre class="programlisting">#include &lt;stdio.h&gt;

void manipulate(char *buffer) {
char newbuffer[80];
strcpy(newbuffer,buffer);
}

int main() {
char ch,buffer[4096];
int i=0;

while ((buffer[i++] = getchar()) != '\n') {};

i=1;
manipulate(buffer);
i=2;
printf("The value of i is : %d\n",i);
return 0;
}</pre><p>Betrachten wir nun, wie das Speicherabbild dieses
	Prozesses aussehen würde, wenn wir 160 Leerzeichen
	in unser kleines Programm eingeben, bevor wir Enter
	drücken.</p><p>[XXX figure here!]</p><p>Offensichtlich kann man durch böswilligere Eingaben
	bereits kompilierten Programmtext ausführen (wie z.B.
	exec(/bin/sh)).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67715792"></a>3.3.2. Puffer-Überläufe vermeiden</h3></div></div></div><p>Die direkteste Lösung, um
	Stack-Überläufe zu vermeiden, ist immer
	grössenbegrenzten Speicher und String-Copy-Funktionen
	zu verwenden.
	<code class="function">strncpy</code> und <code class="function">strncat</code>
	sind Teil der C-Standardbibliothek.

	<a id="idp67717456" class="indexterm"></a>
	<a id="idp67718608" class="indexterm"></a>

	Diese Funktionen akzeptieren einen Längen-Parameter. Dieser
	Wert sollte nicht größer sein als die Länge
	des Zielpuffers. Die Funktionen kopieren dann bis zu
	`length' Bytes von der Quelle zum Ziel. Allerdings gibt es
	einige Probleme. Keine der Funktionen garantiert, dass
	die Zeichenkette NUL-terminiert ist, wenn die
	Größe

	<a id="idp67719760" class="indexterm"></a>

	des Eingabepuffers so groß ist wie das Ziel.
	Außerdem wird der Parameter length zwischen strncpy
	und strncat inkonsistent definiert, weshalb Programmierer
	leicht bezüglich der korrekten Verwendung durcheinander
	kommen können. Weiterhin gibt es einen spürbaren
	Leistungsverlust im Vergleich zu
	<code class="function">strcpy</code>, wenn eine kurze Zeichenkette in
	einen großen Puffer kopiert wird. Denn
	<code class="function">strncpy</code> fült den Puffer bis zur
	angegebenen Länge mit NUL auf.
      </p><p>In OpenBSD wurde eine weitere Möglichkeit zum

	<a id="idp67721424" class="indexterm"></a>

	kopieren von Speicherbereichen implementiert, die dieses
	Problem umgeht. Die Funktionen <code class="function">strlcpy</code>
	und <code class="function">strlcat</code> garantieren, dass das Ziel
	immer NUL-terminiert wird, wenn das Argument length ungleich
	null ist. Für weitere Informationen über diese
	Funktionen lesen Sie bitte <a class="xref" href="bi01.html#OpenBSD">6</a>. Die
	OpenBSD-Funktionen <code class="function">strlcpy</code> und
	<code class="function">strlcat</code> sind seit Version 3.3 auch in
	FreeBSD verfügbar.</p><a id="idp67732304" class="indexterm"></a><a id="idp67733456" class="indexterm"></a><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67734608"></a>3.3.2.1. Compiler-basierte Laufzeitüberprüfung
	  von Grenzen</h4></div></div></div><a id="idp67735248" class="indexterm"></a><p>Unglücklicherweise gibt es immer noch sehr viel
	  Quelltext, der allgemein verwendet wird und blind Speicher
	  umherkopiert, ohne eine der gerade besprochenen Funktionen,
	  die Begrenzungen unterstützen, zu verwenden.
	  Glücklicherweise gibt es einen Weg, um solche Angriffe zu
	  verhindern -  Überprüfung der Grenzen zur Laufzeit, die in
	  verschiedenen C/C++ Compilern eingebaut ist.</p><a id="idp67736784" class="indexterm"></a><a id="idp67737296" class="indexterm"></a><a id="idp67737808" class="indexterm"></a><p>ProPolice ist eine solche Compiler-Eigenschaft und ist in den
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gcc&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gcc</span>(1)</span></a> Versionen 4.1 und höher integriert.  Es ersetzt und
	  erweitert die <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gcc&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gcc</span>(1)</span></a> StackGuard-Erweiterung von
	  früher.</p><p>ProPolice schützt gegen stackbasierte
	  Pufferüberläufe und andere Angriffe durch das Ablegen von
	  Pseudo-Zufallszahlen in Schlüsselbereichen des Stacks bevor es
	  irgendwelche Funktionen aufruft.  Wenn eine Funktion beendet wird,
	  werden diese <span class="quote">&#8222;<span class="quote">Kanarienvögel</span>&#8220;</span> überprüft
	  und wenn festgestellt wird, dass diese verändert wurden wird das
	  Programm sofort abgebrochen.  Dadurch wird jeglicher Versuch, die
	  Rücksprungadresse oder andere Variablen, die auf dem Stack
	  gespeichert werden, durch die Ausführung von Schadcode zu
	  manipulieren, nicht funktionieren, da der Angreifer auch die
	  Pseudo-Zufallszahlen unberührt lassen müsste.</p><a id="idp67741136" class="indexterm"></a><p>Ihre Anwendungen mit ProPolice neu zu kompilieren ist
	  eine effektive Maßnahme, um sie vor den meisten
	  Puffer-Überlauf-Angriffen zu schützen, aber die
	  Programme können noch immer kompromittiert werden.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67742160"></a>3.3.2.2. Bibliotheks-basierte Laufzeitüberprüfung
	  von Grenzen</h4></div></div></div><a id="idp67742928" class="indexterm"></a><p>Compiler-basierte Mechanismen sind bei Software,
	  die nur im Binärformat vertrieben wird, und die somit
	  nicht neu kompiliert werden kann völlig nutzlos.
	  Für diesen Fall gibt es einige Bibliotheken, welche
	  die unsicheren Funktionen der C-Bibliothek
	  (<code class="function">strcpy</code>, <code class="function">fscanf</code>,
	  <code class="function">getwd</code>, etc..) neu implementieren und
	  sicherstellen, dass nicht hinter den Stack-Pointer
	  geschrieben werden kann.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">libsafe</li><li class="listitem">libverify</li><li class="listitem">libparanoia</li></ul></div><p>Leider haben diese Bibliotheks-basierten
	  Verteidigungen mehrere Schwächen. Diese Bibliotheken
	  schützen nur vor einer kleinen Gruppe von
	  Sicherheitslücken und sie können das
	  eigentliche Problem nicht lösen. Diese
	  Maßnahmen können versagen, wenn die Anwendung
	  mit -fomit-frame-pointer kompiliert wurde.
	  Außerdem kann der Nutzer die Umgebungsvariablen
	  LD_PRELOAD und LD_LIBRARY_PATH überschreiben oder
	  löschen.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="secure-philosophy.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="secure.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="secure-setuid.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. Methoden des sicheren Entwurfs </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 3.4. SetUID-Themen</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>