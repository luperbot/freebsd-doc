<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>12.13. Tuning von Laufwerken</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="config-tuning.html" title="Kapitel 12. Konfiguration und Tuning" /><link rel="prev" href="configtuning-sysctl.html" title="12.12. Einstellungen mit sysctl(8)" /><link rel="next" href="configtuning-kernel-limits.html" title="12.14. Einstellungen von Kernel Limits" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.13. Tuning von Laufwerken</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Zurück</a> </td><th width="60%" align="center">Kapitel 12. Konfiguration und Tuning</th><td width="20%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="configtuning-disk"></a>12.13. Tuning von Laufwerken</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76777552"></a>12.13.1. Sysctl Variablen</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76778192"></a>12.13.1.1. <code class="varname">vfs.vmiodirenable</code></h4></div></div></div><a id="idp76778960" class="indexterm"></a><p>Die Variable <code class="varname">vfs.vmiodirenable</code>
	  besitzt in der Voreinstellung den Wert 1.  Die Variable kann
	  auf den Wert 0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt
	  werden.  Sie steuert, wie Verzeichnisse vom System
	  zwischengespeichert werden.  Die meisten Verzeichnisse sind
	  klein und benutzen nur ein einzelnes Fragment,
	  typischerweise 1 kB, im Dateisystem.  Im Buffer-Cache
	  verbrauchen sie mit 512 Bytes noch weniger Platz.  Ist
	  die Variable ausgeschaltet (auf 0) wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System über sehr viel Speicher verfügt.
	  Ist die Variable aktiviert (auf 1), kann der Buffer-Cache
	  den VM-Page-Cache benutzen, um Verzeichnisse
	  zwischenzuspeichern.  Der ganze Speicher steht damit zum
	  Zwischenspeichern von Verzeichnissen zur Verfügung.  Der
	  Nachteil bei dieser Vorgehensweise ist, dass zum
	  Zwischenspeichern eines Verzeichnisses mindestens eine
	  physikalische Seite im Speicher, die normalerweise 4 kB
	  groß ist, anstelle von 512 Bytes gebraucht wird.  Wir
	  empfehlen, diese Option aktiviert zu lassen, wenn Sie
	  Dienste zur Verfügung stellen, die viele Dateien
	  manipulieren.  Beispiele für solche Dienste sind Web-Caches,
	  große Mail-Systeme oder Netnews.  Die aktivierte
	  Variable vermindert, trotz des verschwendeten Speichers,
	  in aller Regel nicht die Leistung des Systems, obwohl Sie
	  das nachprüfen sollten.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76780880"></a>12.13.1.2. <code class="varname">vfs.write_behind</code></h4></div></div></div><a id="idp76781648" class="indexterm"></a><p>In der Voreinstellung besitzt die Variable
	  <code class="varname">vfs.write_behind</code> den Wert
	  <code class="literal">1</code> (aktiviert).  Mit dieser Einstellung
	  schreibt das Dateisystem anfallende vollständige Cluster,
	  die besonders beim sequentiellen Schreiben großer Dateien
	  auftreten, direkt auf das Medium aus.  Dies verhindert,
	  dass sich im Buffer-Cache veränderte Puffer
	  (<span class="foreignphrase"><em class="foreignphrase">dirty buffers</em></span>) ansammeln,
	  die die I/O-Verarbeitung nicht mehr beschleunigen
	  würden.  Unter bestimmten Umständen blockiert
	  diese Funktion allerdings Prozesse.  Setzen Sie in diesem
	  Fall die Variable <code class="varname">vfs.write_behind</code> auf
	  den Wert <code class="literal">0</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76784976"></a>12.13.1.3. <code class="varname">vfs.hirunningspace</code></h4></div></div></div><a id="idp76785744" class="indexterm"></a><p>Die Variable <code class="varname">vfs.hirunningspace</code>
	  bestimmt systemweit die Menge ausstehender
	  Schreiboperationen, die dem Platten-Controller zu jedem
	  beliebigen Zeitpunkt übergeben werden können.  Normalerweise
	  können Sie den Vorgabewert verwenden.  Auf Systemen mit
	  vielen Platten kann der Wert aber auf 4 bis
	  5 <span class="emphasis"><em>Megabyte</em></span> erhöht werden.
	  Beachten Sie, dass ein zu hoher Wert (größer
	  als der Schreib-Schwellwert des Buffer-Caches) zu
	  Leistungverlusten führen kann.  Setzen Sie den Wert daher
	  nicht zu hoch!  Hohe Werte können auch Leseoperationen
	  verzögern, die gleichzeitig mit Schreiboperationen
	  ausgeführt werden.</p><p>Es gibt weitere Variablen, mit denen Sie den
	  Buffer-Cache und den VM-Page-Cache beeinflussen können.  Wir
	  raten Ihnen allerdings davon ab, diese Variablen zu
	  verändern, da das VM-System den virtuellen Speicher selbst
	  sehr gut verwaltet.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76788432"></a>12.13.1.4. <code class="varname">vm.swap_idle_enabled</code></h4></div></div></div><a id="idp76789200" class="indexterm"></a><p>Die Variable <code class="varname">vm.swap_idle_enabled</code>
	  ist für große Mehrbenutzer-Systeme gedacht, auf
	  denen sich viele Benutzer an- und abmelden und auf denen
	  es viele Prozesse im Leerlauf
	  (<span class="foreignphrase"><em class="foreignphrase">idle</em></span>) gibt.  Solche Systeme
	  fragen kontinuierlich freien Speicher an.  Wenn Sie die
	  Variable <code class="varname">vm.swap_idle_enabled</code> aktivieren,
	  können Sie die Auslagerungs-Hysterese von Seiten mit
	  den Variablen <code class="varname">vm.swap_idle_threshold1</code> und
	  <code class="varname">vm.swap_idle_threshold2</code> einstellen.  Die
	  Schwellwerte beider Variablen geben die Zeit in Sekunden an,
	  in denen sich ein Prozess im Leerlauf befinden muss.  Wenn
	  die Werte so eingestellt sind, dass Seiten früher als nach
	  dem normalen Algorithmus ausgelagert werden, verschafft das
	  dem Auslagerungs-Prozess mehr Luft.  Aktivieren Sie diese
	  Funktion nur, wenn Sie sie wirklich benötigen:  Die
	  Speicherseiten werden eher früher als später ausgelagert.
	  Der Platz im Swap-Bereich wird dadurch schneller verbraucht
	  und die Plattenaktivitäten steigen an.  Auf kleinen
	  Systemen hat diese Funktion spürbare Auswirkungen.  Auf
	  großen Systemen, die sowieso schon Seiten auslagern müssen,
	  können ganze Prozesse leichter in den Speicher geladen oder
	  ausgelagert werden.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76792528"></a>12.13.1.5. <code class="varname">hw.ata.wc</code></h4></div></div></div><a id="idp76793296" class="indexterm"></a><p>In FreeBSD 4.3 wurde versucht, den
	  IDE-Schreib-Zwischenspeicher abzustellen.  Obwohl dies die
	  Bandbreite zum Schreiben auf IDE-Platten verringerte, wurde
	  es aus Gründen der Datenkonsistenz als notwenig angesehen.
	  Der Kern des Problems ist, dass IDE-Platten keine
	  zuverlässige Aussage über das Ende eines Schreibvorgangs
	  treffen.  Wenn der Schreib-Zwischenspeicher aktiviert ist,
	  werden die Daten nicht in der Reihenfolge ihres Eintreffens
	  geschrieben.  Es kann sogar passieren, dass das Schreiben
	  mancher Blöcke im Fall von starker Plattenaktivität auf
	  unbefristete Zeit verzögert wird.  Ein Absturz oder
	  Stromausfall zu dieser Zeit kann die Dateisysteme erheblich
	  beschädigen.  Wir entschieden uns daher für die sichere
	  Variante und stellten den Schreib-Zwischenspeicher ab.
	  Leider war damit auch ein großer Leistungsverlust verbunden,
	  so dass wir die Variable nach dem Release wieder aktiviert
	  haben.  Sie sollten den Wert der Variable
	  <code class="varname">hw.ata.wc</code> auf Ihrem System überprüfen.
	  Wenn der Schreib-Zwischenspeicher abgestellt ist, können Sie
	  ihn aktivieren, indem Sie die Variable auf den Wert 1
	  setzen.  Dies muss zum Zeitpunkt des Systemstarts im
	  Boot-Loader geschehen.  Eine Änderung der Variable, nachdem
	  der Kernel gestartet ist, hat keine Auswirkungen.</p><p>Weitere Informationen finden Sie in <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ata&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ata</span>(4)</span></a>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76796240"></a>12.13.1.6. <code class="literal">SCSI_DELAY</code>
	  (<code class="varname">kern.cam.scsi_delay</code>)</h4></div></div></div><a id="idp76801744" class="indexterm"></a><a id="idp76802640" class="indexterm"></a><p>Mit der Kerneloption <code class="literal">SCSI_DELAY</code> kann
	  die Dauer des Systemstarts verringert werden.  Der
	  Vorgabewert ist recht hoch und er verzögert den Systemstart
	  um 15 oder mehr Sekunden.  Normalerweise kann dieser Wert,
	  insbesondere mit modernen Laufwerken, auf 5 Sekunden
	  heruntergesetzt werden (durch Setzen der
	  <code class="command">sysctl</code>-Variable
	  <code class="varname">kern.cam.scsi_delay</code>).  Die Variable sowie
	  die Kerneloption verwenden für die Zeitangabe Millisekunden
	  und <span class="emphasis"><em>nicht</em></span> Sekunden.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="soft-updates"></a>12.13.2. Soft Updates</h3></div></div></div><a id="idp76806864" class="indexterm"></a><a id="idp76807376" class="indexterm"></a><p>Mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a> lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene
	Optionen, von denen hier nur Soft Updates betrachtet werden.
	Soft Updates werden wie folgt ein- und ausgeschaltet:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>tunefs -n enable /filesystem</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>tunefs -n disable /filesystem</code></strong></pre><p>Ein eingehängtes Dateisystem kann nicht mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a>
	modifiziert werden.  Soft Updates werden am besten im
	Single-User Modus aktiviert, bevor Partitionen eingehangen
	sind.</p><p>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und Löschen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf
	allen Dateisystemen zu aktivieren.  Allerdings sollten Sie
	sich über die zwei Nachteile von Soft Updates bewusst sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, dass
	das Dateisystem über mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umständen mehr Daten als ohne.
	Zweitens verzögern Soft Updates die Freigabe von
	Datenblöcken.  Eine größere Aktualisierung
	eines fast vollen Dateisystems, wie dem Root-Dateisystem,
	z.B. während eines <code class="command">make installworld</code>,
	kann das Dateisystem vollaufen lassen.  Dadurch würde
	die Aktualisierung fehlschlagen.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76821072"></a>12.13.2.1. Details über Soft Updates</h4></div></div></div><a id="idp76821712" class="indexterm"></a><p>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  über Dateien, wie inode Bereiche oder Verzeichniseinträge)
	  aktualisiert auf die Platte zurückschreibt:</p><p>Das historisch übliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine Änderung an
	  einem Verzeichnis nötig war, wurde anschließend
	  gewartet, bis diese Änderung tatsächlich auf die
	  Platte zurückgeschrieben worden war.  Der
	  <span class="emphasis"><em>Inhalt</em></span> der Dateien wurde im
	  <span class="quote">&#8222;<span class="quote">Buffer Cache</span>&#8220;</span> zwischengespeichert und
	  asynchron irgendwann später auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, dass sie
	  sicher funktioniert.  Wenn während eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenblöcke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <span class="quote">&#8222;<span class="quote">Buffer Cache</span>&#8220;</span> auf die Platte gefunden haben,
	  kann <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> das Dateisystem reparieren, indem es die
	  Dateilänge einfach auf 0 setzt.  Außerdem
	  ist die Implementierung einfach und überschaubar.  Der
	  Nachteil ist, dass Änderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <code class="command">rm -r</code>
	  beispielsweise fasst alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser Änderungen am
	  Verzeichnis (Löschen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  großer Hierarchien (<code class="command">tar -x</code>).</p><p>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <code class="command">mount -o async</code> für *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  über den <span class="quote">&#8222;<span class="quote">Buffer Cache</span>&#8220;</span>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, dass man nun nicht mehr auf jeden Update
	  warten muss, Operationen, die zahlreiche Metadaten
	  ändern, werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anfällig für Fehler.  Nachteil ist, dass
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  ändert, ein Ausfall erfolgt (Stromausfall, drücken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschließend in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenblöcke einer Datei können
	  schon auf der Platte stehen, während die inode Tabelle
	  oder das zugehörige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <code class="command">fsck</code>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu nötigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart beschädigt worden ist, kann man es
	  nur neu erzeugen (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">newfs</span>(8)</span></a>) und die Daten
	  vom Backup zurückspielen.
	  </p><p>Der historische Ausweg aus diesem Dilemma war ein
	  <span class="emphasis"><em>dirty region logging</em></span> (auch als
	  <span class="emphasis"><em>Journalling</em></span> bezeichnet, wenngleich
	  dieser Begriff nicht immer gleich benutzt und manchmal auch
	  für andere Formen von Transaktionsprotokollen gebraucht
	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
	  aber nur in einen kleinen Plattenbereich, die
	  <span class="emphasis"><em>logging area</em></span>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <span class="emphasis"><em>logging area</em></span> ein kleines
	  zusammenhängendes Stückchen ist, haben die
	  Schreibköpfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu großen Wege zurückzulegen,
	  so dass alles ein ganzes Stück schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexität
	  der Implementierung hält sich ebenfalls in Grenzen,
	  somit auch die Anfälligkeit für Fehler.  Als
	  Nachteil ergibt sich, dass Metadaten zweimal auf die
	  Platte geschrieben werden müssen (einmal in die
	  <span class="emphasis"><em>logging area</em></span>, einmal an die richtige
	  Stelle), so dass das im Falle regulärer
	  Arbeit (also keine gehäuften Metadatenoperationen) eine
	  <span class="quote">&#8222;<span class="quote">Pessimisierung</span>&#8220;</span> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Dafür hat man
	  als Vorteil, dass im Falle eines Crashes der
	  konsistente Zustand dadurch erzielbar ist, dass die
	  angefangenen Operationen aus dem <span class="emphasis"><em>dirty region
	  log</em></span> entweder zu Ende ausgeführt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verfügung steht.</p><p>Die Lösung von Kirk McKusick, dem Schöpfer von
	  Berkeley FFS, waren <span class="emphasis"><em>Soft Updates</em></span>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<span class="quote">&#8222;<span class="quote">ordered metadata updates</span>&#8220;</span>).  Dadurch hat man
	  den Effekt, dass im Falle massiver
	  Metadaten-Änderungen spätere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <span class="quote">&#8222;<span class="quote">einholen</span>&#8220;</span>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update überhaupt auf
	  die Platte geschrieben wird (die dazugehörigen
	  Datenblöcke werden natürlich auch so sortiert,
	  dass sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites
	  <span class="quote">&#8222;<span class="quote">log rewind</span>&#8220;</span>: alle Operationen, die noch nicht
	  den Weg auf die Platte gefunden haben, sehen danach so aus,
	  als hätten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60 Sekunden früher
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, dass alle tatsächlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, dass Ressourcen noch als
	  <span class="quote">&#8222;<span class="quote">belegt</span>&#8220;</span> markiert sind, die tatsächlich
	  <span class="quote">&#8222;<span class="quote">frei</span>&#8220;</span> sind.  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <code class="command">mount -f</code> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben muss
	  später ein <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> nachgeholt werden.  Das ist
	  dann auch die Idee des <span class="emphasis"><em>background fsck</em></span>:
	  beim Starten des Systems wird lediglich ein
	  <span class="emphasis"><em>Schnappschuss</em></span> des Filesystems
	  gemacht, mit dem <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> dann später arbeiten
	  kann.  Alle Dateisysteme dürfen <span class="quote">&#8222;<span class="quote">unsauber</span>&#8220;</span>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-<code class="command">fsck</code> für die
	  Dateisysteme gestartet, die dies benötigen, um
	  möglicherweise irrtümlich belegte Ressourcen
	  freizugeben.  (Dateisysteme ohne <span class="emphasis"><em>Soft
	  Updates</em></span> benötigen natürlich immer noch
	  den üblichen (Vordergrund-)<code class="command">fsck</code>,
	  bevor sie eingebunden werden können.)</p><p>Der Vorteil ist, dass die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall (also
	  durchaus auch schneller als beim <span class="quote">&#8222;<span class="quote">logging</span>&#8220;</span>, das
	  ja die Metadaten immer zweimal schreiben muss).  Als
	  Nachteil stehen dem die Komplexität des Codes (mit
	  einer erhöhten Fehlerwahrscheinlichkeit in einem
	  bezüglich Datenverlust hoch sensiblen Bereich) und ein
	  erhöhter Speicherverbrauch entgegen.  Außerdem
	  muss man sich an einige Eigenheiten gewöhnen: Nach einem
	  Absturz ist ein etwas älterer Stand auf der
	  Platte &#8211; statt einer leeren, aber bereits angelegten
	  Datei (wie nach einem herkömmlichen
	  <code class="command">fsck</code> Lauf) ist auf einem Dateisystem mit
	  <span class="emphasis"><em>Soft Updates</em></span> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem <code class="command">rm -r</code>
	  nicht sofort wieder als verfügbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn große Datenmengen in einem Dateisystem
	  ersetzt werden, das nicht genügend Platz hat, um alle
	  Dateien zweimal unterzubringen.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="config-tuning.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">12.12. Einstellungen mit sysctl(8) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 12.14. Einstellungen von Kernel Limits</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>