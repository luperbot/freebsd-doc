<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>FreeBSD und Solid State-Geräte</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="Dieser Artikel behandelt die Verwendung von Solid State Festplatten in FreeBSD, um eingebettete Systeme zu erstellen. Eingebettete Systeme haben den Vorteil, dass sie eine höhere Stabilität aufgrund des fehlens von beweglichen Bauteilen (Festplatten) besitzen. Es muss jedoch beachtet werden, dass generell weniger Speicherplatz zur Verfügung steht und die Lebensdauer des Speichermediums geringer ist. Spezielle Themen die behandelt werden beinhalten die Typen und Attribute von Solid State Datenträgern, die in FreeBSD verwendet werden, Kernel-Optionen die in solch einer Umgebung von Interesse sind, der rc.initdiskless-Mechanismus, welcher die Initalisierung solcher Systeme automatisiert, sowie die Notwendigkeit von Nur-Lese-Dateisystemen und das Erstellen von Dateisystemen von Grund auf. Der Artikel schliesst mit ein paar generellen Strategien für kleine und Nur-Lese-FreeBSD Umgebungen. Übersetzt von Benedict Reuschling." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="de" class="article" lang="de"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp60662096"></a>FreeBSD und Solid State-Geräte</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Kozubik</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:john@kozubik.com">john@kozubik.com</a>&gt;</code></p></div></div></div></div></div><div>Version: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2001, 2009 The FreeBSD Documentation Project</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD ist ein eingetragenes
  Warenzeichen der FreeBSD Foundation.</p><p>Viele Produktbezeichnungen von
  Herstellern und Verkäufern sind Warenzeichen.  Soweit dem
  FreeBSD Project das Warenzeichen bekannt ist, werden die in diesem
  Dokument vorkommenden Bezeichnungen mit dem Symbol
  <span class="quote">&#8222;<span class="quote">&#8482;</span>&#8220;</span> oder dem Symbol <span class="quote">&#8222;<span class="quote">®</span>&#8220;</span>
  gekennzeichnet.</p></div></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="legalnotice"></a><p>Redistribution and use in source (SGML DocBook) and 'compiled'
    forms (SGML, HTML, PDF, PostScript, RTF and so forth) with or without
    modification, are permitted provided that the following conditions are
    met:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Redistributions of source code (SGML DocBook) must retain the
        above copyright notice, this list of conditions and the following
        disclaimer as the first lines of this file unmodified.</p></li><li class="listitem"><p>Redistributions in compiled form (transformed to other DTDs,
        converted to PDF, PostScript, RTF and other formats) must
        reproduce the above copyright notice, this list of conditions and
        the following disclaimer in the documentation and/or other
        materials provided with the distribution.</p></li></ol></div><div xmlns="" class="important"><h3 class="admontitle">Wichtig: </h3><p xmlns="http://www.w3.org/1999/xhtml">THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION
      PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
      BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
      THE FREEBSD DOCUMENTATION PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
      OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
      TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
      USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
      DAMAGE.</p></div></div></div><div>Zuletzt bearbeitet am  von .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Zusammenfassung</div><p>Dieser Artikel behandelt die Verwendung von Solid State Festplatten
        in FreeBSD, um eingebettete Systeme zu erstellen.</p><p>Eingebettete Systeme haben den Vorteil, dass sie eine
	höhere Stabilität aufgrund des fehlens von beweglichen
	Bauteilen (Festplatten) besitzen.  Es muss jedoch beachtet
	werden, dass generell weniger Speicherplatz zur Verfügung
	steht und die Lebensdauer des Speichermediums geringer
	ist.</p><p>Spezielle Themen die behandelt werden beinhalten die Typen
	und Attribute von Solid State Datenträgern, die in FreeBSD
	verwendet werden, Kernel-Optionen die in solch einer Umgebung
	von Interesse sind, der
	<code class="filename">rc.initdiskless</code>-Mechanismus, welcher die
	Initalisierung solcher Systeme automatisiert, sowie die
	Notwendigkeit von Nur-Lese-Dateisystemen und das Erstellen von
	Dateisystemen von Grund auf.  Der Artikel schliesst mit ein
	paar generellen Strategien für kleine und Nur-Lese-FreeBSD
	Umgebungen.</p><p><span class="emphasis"><em>Übersetzt von Benedict
	  Reuschling</em></span>.</p></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">einzelne Abschnitte</a>
      /
      
	  komplettes Dokument
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">Inhaltsverzeichnis</div><dl class="toc"><dt><span class="sect1"><a href="#intro">1. Solid State Festplattengeräte</a></span></dt><dt><span class="sect1"><a href="#kernel">2. Kerneloptionen</a></span></dt><dt><span class="sect1"><a href="#ro-fs">3. Die <code class="literal">rc</code>-Subsysteme und nur-Lese
      Dateisysteme</a></span></dt><dt><span class="sect1"><a href="#idp61923024">4. Ein Dateisystem von Grund auf neu erstellen</a></span></dt><dt><span class="sect1"><a href="#strategies">5. Systemstrategien für kleine und Nur-Lese-Umgebungen</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="intro"></a>1. Solid State Festplattengeräte</h2></div></div></div><p>Der Umfang des Artikels ist auf Solid State Geräte
      beschränkt, die auf Flash-Speicher basieren.  Flash-Speicher ist
      ein Solid State Speicher (keine beweglichen Teile), der nicht
      flüchtig ist (der Speicher behält die Daten sogar nachdem alle
      Energiequellen ausgeschaltet wurden).  Flash-Speicher kann
      grossen physischen Schock aushalten und ist vergleichsweise
      schnell (die Flash-Speicher Lösungen, die in diesem Artikel
      behandelt werden, sind nur wenig langsamer als eine
      EIDE-Festplatte in der Schreibgeschwindigkeit und viel schneller
      bei Lese-Operationen).  Ein sehr wichtiger Aspekt von
      Flash-Speichern, dessen Auswirkungen später in diesem Artikel
      diskutiert werden, ist, dass jeder Sektor eine begrenzte
      Kapazität zur Wiederbeschreibung besitzt.  Man kann nur eine
      bestimmte Anzahl von Schreib-, Lösch- und
      Wiederbeschreibungsvorgängen durchführen, bevor der Sektor
      permanent unbrauchbar wird.  Obwohl viele Flash-Speicher
      Produkte automatisch schlechte Blöcke markieren und manche
      Geräte Schreiboperationen gleichmässig verteilen, bleibt
      weiterhin die Anzahl der durchführbaren Schreibvorgänge
      begrenzt.  Verschiedene Geräteeinheiten besitzen zwischen
      1,000,000 und 10,000,000 Schreibzyklen pro Sektor in ihren
      Spezifikationen.  Diese Zahlen variieren aufgrund der
      Umgebungstemperatur.</p><p>Im Speziellen werden wir ATA-kompatible Compact-Flash-Karten
      betrachten, welche als Speichermedien für Digitalkameras
      ziemlich populär sind.  Von besonderem Interesse ist der
      Umstand, dass diese direkt an den IDE-Bus angeschlossen werden
      und kompatibel zu den ATA-Befehlen sind.  Aus diesem Grund
      können diese Geräte mit einem einfachen und billigen Adapter
      direkt an den IDE-Bus eines Computers angeschlossen werden.  Auf
      diese Weise sehen Betriebssysteme wie FreeBSD diese Geräte dann als
      normale (wenn auch sehr kleine) Festplatten an.</p><p>Andere Solid State Plattenlösungen existieren, jedoch
      platzieren deren Kosten, Obskurität und ihre Unhandlichkeit sie
      aussserhalb des Umfangs dieses Artikels.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel"></a>2. Kerneloptionen</h2></div></div></div><p>Ein paar Kerneloptionen sind von besonderem Interesse für
      diejenigen, welche diese eingebetteten FreeBSD-Systeme erstellen
      möchten.</p><p>Alle eingebetteten FreeBSD-Systeme, die Flash-Speicher als
      Systemplatte verwenden, sind interessant für Dateisysteme im
      Hauptspeicher und RAM-Disks.  Wegen der begrenzten Anzahl von
      Schreibzyklen, die auf Flash-Speicher durchgeführt werden
      können, werden die Platte und die Dateisysteme darauf mit
      grosser Wahrscheinlichkeit nur lesend eingehängt werden.  In
      dieser Umgebung werden Dateisysteme wie
      <code class="filename">/tmp</code> und <code class="filename">/var</code> als
      RAM-Disks eingebunden, um dem System zu erlauben, Logdateien
      anzulegen und Zähler sowie temporäre Dateien zu aktualisieren.
      RAM-Disks sind eine kritische Komponente für eine erfolgreiche
      Solid State Umsetzung in FreeBSD.</p><p>Sie sollten dafür sorgen, dass die folgenden Zeilen in Ihrer
      Kernelkonfigurationsdatei vorhanden sind:</p><pre class="programlisting">options         MFS             # Memory Filesystem
options         MD_ROOT         # md device usable as a potential root device
pseudo-device   md              # memory disk</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ro-fs"></a>3. Die <code class="literal">rc</code>-Subsysteme und nur-Lese
      Dateisysteme</h2></div></div></div><p>Die Initialisierung nach dem Bootvorgang eines eingebetteten
      FreeBSD-Systems wird von <code class="filename">/etc/rc.initdiskless</code>
      kontrolliert.</p><p><code class="filename">/etc/rc.d/var</code> hängt
      <code class="filename">/var</code> als RAM-Disk ein, erstellt eine
      konfigurierbare Liste von Verzeichnissen in
      <code class="filename">/var</code> mittels des <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mkdir&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">mkdir</span>(1)</span></a>-Kommandos
      und ändert die Attribute von ein paar dieser Verzeichnisse.  Bei
      der Ausführung von <code class="filename">/etc/rc.d/var</code> kommt eine
      andere <code class="filename">rc.conf</code>-Variable ins Spiel:
      <code class="literal">varsize</code>.  Die Datei <code class="filename">/etc/rc.d/var</code>
      erstellt eine <code class="filename">/var</code>-Partition basierend auf
      dem Wert dieser Variable in <code class="filename">rc.conf</code>:</p><pre class="programlisting">varsize=8192</pre><p>Standardmässig wird dieser Wert in Sektoren
      angegeben.</p><p>Der Fakt, dass es sich bei <code class="filename">/var</code> um ein
      nur-Lese Dateisystem handelt, ist eine wichtige Unterscheidung,
      da die <code class="filename">/</code>-Partition (und jede andere
      Partition, die Sie auf Ihrem Flash-Medium haben) nur lesend
      eingehängt wird.  Erinnern Sie sich, dass in <a class="xref" href="#intro" title="1. Solid State Festplattengeräte">Abschnitt 1, &#8222;Solid State Festplattengeräte&#8220;</a> die Beschränkungen von Flash-Speichern
      erläutert wurden, speziell deren begrenzte Kapazität zum
      Schreiben.  Die Notwendigkeit, Dateisysteme auf Flash-Speichern
      nur lesend einzubinden und keine Swap-Dateien zu verwenden, kann
      nicht oft genug erwähnt werden.  Eine Swap-Datei auf einem
      ausgelasteten System kann in weniger als einem Jahr den gesamten
      Flash-Speicher aufbrauchen. Häufige Protokollierung oder das
      Erstellen und Löschen von temporären Dateien kann das gleiche
      verursachen.  Aus diesem Grund sollten Sie zusätzlich zum
      entfernen des <code class="literal">swap</code>-Eintrags aus ihrer
      <code class="filename">/etc/fstab</code>-Datei auch noch die
      Optionsfelder für jedes Dateisystem auf <code class="literal">ro</code>
      wie folgt stellen:</p><pre class="programlisting"># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1a             /               ufs     ro              1       1</pre><p>Ein paar Anwendungen im normalen System werden sofort nach
      dieser Änderung ausfallen.  Beispielsweise wird Cron nicht
      richtig funktionieren, aufgrund von fehlenden Cron-Tabellen in
      <code class="filename">/var</code> die von
      <code class="filename">/etc/rc.d/var</code> erstellt wurden.  Syslog und
      DHCP werden ebenfalls Probleme durch das nur-Lese Dateisystem
      und fehlende Elemente im Verzeichnis <code class="filename">/var</code>
      verursachen, die <code class="filename">/etc/rc.d/var</code> erstellt
      hat.  Diese Probleme sind jedoch nur vorübergehend und werden
      zusammen mit Lösungen zur Ausführung von anderen gebräuchlichen
      Softwarepaketen in <a class="xref" href="#strategies" title="5. Systemstrategien für kleine und Nur-Lese-Umgebungen">Abschnitt 5, &#8222;Systemstrategien für kleine und Nur-Lese-Umgebungen&#8220;</a>
      angesprochen.</p><p>Eine wichtige Sache, an die man sich erinnern sollte, ist,
      dass ein Dateisystem, welches als nur lesend in
      <code class="filename">/etc/fstab</code> eingebunden wurde, jederzeit als
      schreibend durch das folgende Kommando eingehängt werden
      kann:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/sbin/mount -uw partition</code></strong></pre><p>und auch wieder zurück auf nur lesend durch den Befehl:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/sbin/mount -ur partition</code></strong></pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="idp61923024"></a>4. Ein Dateisystem von Grund auf neu erstellen</h2></div></div></div><p>Wenn ATA-kompatible Compact-Flash-Karten von FreeBSD als
      normale IDE-Festplatten erkannt werden, könnten Sie theoretisch
      FreeBSD aus dem Netzwerk mittels der Kern- und mfsroot-Floppies
      oder einer CD installieren.</p><p>Jedoch kann selbst eine kleine Installation von FreeBSD durch
      die normale Installationsprozedur ein System erzeugen, dass
      grösser als 200 MB ist.  Da die meisten Leute kleinere
      Flash-Speichermedien einsetzen (128 MB wird hier als gross
      angesehen - 32 oder sogar 16 MB sind gebräuchlich) ist eine
      gewöhnliche Installation mit normalen Methoden nicht möglich, da
      es einfach nicht genug freien Plattenplatz gibt, selbst für die
      kleinste Installationsart.</p><p>Der einfachste Weg, diese Speicherlimitierung zu umgehen,
      ist, FreeBSD auf konventionelle Weise auf eine normale Festplatte
      zu installieren.  Nachdem die Installation abgeschlossen wurde,
      kürzen Sie das Betriebssystem auf das nötigste, bis Sie eine
      Grösse erreicht hat, die auf das Flash-Medium passt und benutzen
      Sie dann tar auf dem gesamten Dateisystem.  Die folgenden
      Schritte werden Sie durch den Prozess der Vorbereitung eines
      Flash-Mediums für ihr getartes Dateisystem führen.  Beachten
      Sie, dass Operationen wie Partitionierung, Benennung, Erstellung
      von Dateisystemen, etc. von Hand durchgeführt werden müssen, da
      eine normale Installation nicht möglich ist.  Zusätzlich zu den
      Kern- und mfsroot-Disketten benötigen Sie auch die
      fixit-Floppy.</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p class="title"><strong>Partitionierung Ihrer Flash-Medien</strong></p><p>Wählen Sie nach dem Starten der Kern- und
	  mfsroot-Disketten, <code class="literal">custom</code> aus dem
	  Installationsmenü.  In diesem Menü wählen Sie dann
	  <code class="literal">partition</code> aus.  Dort sollten Sie alle
	  bestehenden Partitionen mit Hilfe der Taste
	  <span class="keycap"><strong>d</strong></span> löschen.  Nachdem alle bestehenden
	  Partitionen gelöscht wurden, erstellen Sie mittels der Taste
	  <span class="keycap"><strong>c</strong></span> eine Partition und akzeptieren Sie den
	  Standardwert für die Grösse der Partition.  Wenn Sie nach
	  dem Typ der Partition gefragt werden, stellen Sie sicher,
	  dass der Wert auf <code class="literal">165</code> eingestellt ist.
	  Schreiben Sie jetzt diese Partitionstabelle auf die Platte
	  durch betätigen der Taste <span class="keycap"><strong>w</strong></span> (dies ist die
	  versteckte Option auf diesem Bildschirm).  Wenn Sie eine
	  ATA-kompatible Compact Flash-Karte verwenden, sollten Sie
	  den FreeBSD Bootmanager auswählen.  Drücken Sie nun die Taste
	  <span class="keycap"><strong>q</strong></span>, um das Partitionsmenü zu verlassen.  Sie
	  werden das Menü des Bootmanagers noch ein weiteres Mal
	  gezeigt bekommt.  In diesem Fall wiederholen Sie die Auswahl
	  von vorher.</p></li><li class="step"><p class="title"><strong>Anlegen von Dateisystemen auf Ihrem
	  Flashspeicher-Gerät</strong></p><p>Verlassen Sie das Installationsmenü und wählen Sie aus
	  dem Hauptinstallationsmenü die Option
	  <code class="literal">fixit</code>.  In der fixit-Umgebung angelangt,
	  geben Sie den folgenden Befehl ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel -e /dev/ad0c</code></strong></pre><p>Zu diesem Zeitpunkt sollten Sie sich im vi-Editor unter
	  der Herrschaft des disklabel-Kommandos befinden.  Als
	  nächstes müssen Sie die eine <code class="literal">a:</code>-Zeile an
	  das Ende der Datei hinzufügen.  Diese
	  <code class="literal">a:</code>-Zeile sollte wie folgt
	  aussehen:</p><pre class="programlisting">a:      <em class="replaceable"><code>123456</code></em>  0       4.2BSD  0       0</pre><p>Wobei <em class="replaceable"><code>123456</code></em> eine Zahl
	  darstellt, die exakt der gleichen Zahl in der bestehenden
	  Zeile mit dem <code class="literal">c:</code>-Eintrag entspricht.  Sie
	  kopieren quasi die bestehende Zeile <code class="literal">c:</code>
	  als eine neue Zeile <code class="literal">a:</code> und stellen
	  sicher, dass fstype <code class="literal">4.2BSD</code> entspricht.
	  Speichern Sie die Datei und verlassen Sie den Editor.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel -B -r /dev/ad0c</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>newfs /dev/ad0a</code></strong></pre></li><li class="step"><p class="title"><strong>Schreiben des Dateisystems auf Ihr Flash-Medium</strong></p><p>Hängen Sie das neu erstellte Flash-Medium ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount /dev/ad0a /flash</code></strong></pre><p>Verbinden Sie diese Maschine mit dem Netzwerk, um die
	  tar-Datei zu übertragen und extrahieren Sie es auf das
	  Dateisystem des Flash-Mediums.  Ein Beispiel dazu wäre
	  folgendes:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ifconfig xl0 192.168.0.10 netmask 255.255.255.0</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>route add default 192.168.0.1</code></strong></pre><p>Jetzt da die Maschine ans Netzwerk angeschlossen ist,
	  kopieren Sie die tar-Datei.  An diesem Punkt werden Sie
	  möglicherweise mit einem Dilemma konfrontiert - sollte Ihr
	  Flash-Speicher beispielsweise 128 MB gross sein und
	  Ihre tar-Datei grösser als 64 MB, können Sie ihre
	  tar-Datei auf dem Flash-Speicher nicht entpacken - Ihnen
	  wird vorher der Speicherplatz ausgehen.  Eine Lösung für
	  dieses Problem, sofern Sie FTP verwenden, ist, dass Sie die
	  Datei entpacken können, während es von FTP übertragen wird.
	  Wenn Sie die Übertragung auf diese Weise durchführen, haben
	  Sie niemals die tar-Datei und deren Inhalt zur gleichen Zeit
	  auf Ihrem Medium:</p><pre class="screen"><code class="prompt">ftp&gt;</code> <strong class="userinput"><code>get tarfile.tar "| tar xvf -"</code></strong></pre><p>Sollte Ihre tar-Datei gezippt sein, können Sie dies
	  ebenso bewerkstelligen:</p><pre class="screen"><code class="prompt">ftp&gt;</code> <strong class="userinput"><code>get tarfile.tar "| zcat | tar xvf -"</code></strong></pre><p>Nachdem der Inhalt Ihrer tar-Datei auf dem Dateisystem
	  des Flash-Mediums abgelegt wurden, können Sie den
	  Flash-Speicher aushängen und neu starten:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>umount /flash</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>exit</code></strong></pre><p>In der Annahme, dass Sie Ihr Dateisystem richtig
	  konfiguriert haben, als es noch auf der gewöhnlichen
	  Festplatte gebaut wurde (mit Ihren Nur-Lese-Dateisystemen
	  und den nötigen Optionen im Kernel), sollten Sie nun
	  erfolgreich von Ihrem FreeBSD Embedded-System starten
	  können.</p></li></ol></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="strategies"></a>5. Systemstrategien für kleine und Nur-Lese-Umgebungen</h2></div></div></div><p>In <a class="xref" href="#ro-fs" title="3. Die rc-Subsysteme und nur-Lese Dateisysteme">Abschnitt 3, &#8222;Die <code class="literal">rc</code>-Subsysteme und nur-Lese
      Dateisysteme&#8220;</a> wurde darauf hingewiesen, dass
      das <code class="filename">/var</code>-Dateisystem von
      <code class="filename">/etc/rc.d/var</code> konstruiert wurde und die
      Präsenz eines Nur-Lese-Wurzeldateisystems Probleme mit vielen in
      FreeBSD gebrächlichen Softwarepaketen verursacht.  In diesem
      Artikel werden Vorschläge für das erfolgreiche Betreiben von
      cron, syslog, Installationen von Ports und dem Apache-Webserver
      unterbreitet.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp62015952"></a>5.1. cron</h3></div></div></div><p>Während des Bootvorgangs wird <code class="filename">/var</code> von
        <code class="filename">/etc/rc.d/var</code> anhand der Liste aus
        <code class="filename">/etc/mtree/BSD.var.dist</code> gefüllt, damit
        <code class="filename">cron</code>, <code class="filename">cron/tabs</code>, <code class="filename">at</code> und ein paar weitere
        Standardverzeichnisse erstellt werden.</p><p>Jedoch löst das noch nicht das Problem, Crontabs über
	Neustarts des Systems hinaus zu erhalten.  Wenn das System neu
	gestartet wird, verschwindet das
	<code class="filename">/var</code>-Dateiystem, welches sich im
	Hauptspeicher befunden hat und jegliche Crontabs, die Sie
	hatten werden ebenfalls verschwinden. Aus diesem Grund besteht
	eine Lösung darin, Crontabs für diejenigen Benutzer zu
	erstellen, die diese auch benötigen.  Dazu sollte das
	<code class="filename">/</code>-Dateisystem lesend und schreibend
	eingehängt und diese Crontabs an einen sicheren Ort kopiert
	werden, wie beispielsweise <code class="filename">/etc/tabs</code>.
	Fügen Sie dann eine Zeile an das Ende der Datei
	<code class="filename">/etc/rc.initdiskless</code> hinzu, die diese
	Crontabs in <code class="filename">/var/cron/tabs</code> kopiert,
	nachdem dieses Verzeichnis während der Systeminitialisierung
	erstellt wurde.  Sie werden auch eine Zeile hinzufügen mössen,
	welche die Besitzer und Berechtigungen auf diesen
	Verzeichnissen, die Sie erstellen und den dazugehörigen
	Dateien, die Sie mittels
	<code class="filename">/etc/rc.initdiskless</code> kopieren,
	setzen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp62045904"></a>5.2. syslog</h3></div></div></div><p>Die Datei <code class="filename">syslog.conf</code> spezifiziert
	den Ort von bestimmten Logdateien, welche in
	<code class="filename">/var/log</code> existieren.  Diese Dateien
	werden nicht von <code class="filename">/etc/rc.d/var</code> während
	der Systeminitialisierung erstellt.  Aus diesem Grund müssen
	Sie irgendwo in <code class="filename">/etc/rc.d/var</code> nach dem
	Abschnitt, der die Verzeichnisse in <code class="filename">/var</code>
	erstellt, eine Zeile ähnlich der folgenden hinzufügen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>touch /var/log/security /var/log/maillog /var/log/cron /var/log/messages</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 0644 /var/log/*</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp62070224"></a>5.3. Installation von Ports</h3></div></div></div><p>Bevor die notwendigen Änderungen erkärt werden, einen
	Ports-Baum zu verwenden, ist es notwendig, Sie an die
	Nur-Lese-Besonderheit Ihres Dateisystems auf dem Flash-Medium
	zu erinnern.  Da dieses nur lesend verfügbar ist, müssen Sie
	es vorübergehend mit Schreibrechten ausstatten, indem Sie die
	mount-Syntax, wie in <a class="xref" href="#ro-fs" title="3. Die rc-Subsysteme und nur-Lese Dateisysteme">Abschnitt 3, &#8222;Die <code class="literal">rc</code>-Subsysteme und nur-Lese
      Dateisysteme&#8220;</a> dargestellt wird,
	verwenden.  Sie sollten immer diese Dateisysteme erneut mit
	nur-Lese-Rechten einhängen wenn Sie damit fertig sind -
	unnötige Schreibvorgänge auf dem Flash-Medium kann dessen
	Lebenszeit erheblich verkürzen.</p><p>Um es zu ermöglichen, in das Ports-Verzeichnis zu wechseln
	und erfolgreich <code class="command">make</code>
	<code class="buildtarget">install</code> auszuführen, müssen wir ein
	Paketverzeichnis auf einem Nicht-Hauptspeicherdateisystem
	erstellen, welches die Pakete über Neustarts hinweg im Auge
	behält.  Weil es sowieso nötig ist, Ihre Dateisysteme mit
	Lese-Schreibrechten für die Installation eines Pakets
	einzuhängen, ist es sinnvoll anzunehmen, dass ein Bereich
	Ihres Flash-Mediums ebenfalls für Paketinformationen, die
	darauf abgespeichert werden, verwendet wird.</p><p>Erstellen Sie zuerst ein Verzeichnis für die
	Paketdatenbank.  Normalerweise ist dies
	<code class="filename">/var/db/pkg</code>, jedoch können wir es dort
	nicht unterbringen, da es jedesmal verschwinden wird, wenn das
	System neu gestartet wird.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mkdir /etc/pkg</code></strong></pre><p>Fügen Sie nun eine Zeile in
	<code class="filename">/etc/rc.d/var</code> hinzu, welche das
	<code class="filename">/etc/pkg</code>-Verzeichnis mit
	<code class="filename">/var/db/pkg</code> verknüpft.  Ein
	Beispiel:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ln -s /etc/pkg /var/db/pkg</code></strong></pre><p>Nun wird jedes Mal, wenn Sie Ihre Dateisysteme mit
	Lese-Schreibrechten einbinden und ein Paket installieren, der
	Befehl <code class="command">make</code>
	<code class="buildtarget">install</code> funktionieren und
	Paketinformationen werden erfolgreich nach
	<code class="filename">/etc/pkg</code> geschrieben (da zu diesem
	Zeitpunkt das Dateisystem mit Lese-Schreibrechten eingebunden
	ist), welche dann stets dem Betriebssystem als
	<code class="filename">/var/db/pkg</code> zur Verfügung stehen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp62095568"></a>5.4. Apache Webserver</h3></div></div></div><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Die Anweisungen in diesem Abschnitt sind nur notwendig,
	  wenn Apache so eingerichtet ist, dass dieser seine PID oder
	  Protokollierungsinformationen ausserhalb von <code class="filename">/var</code> ablegt.  Standardmässig
	  bewahrt Apache seine PID-Datei in <code class="filename">/var/run/httpd.pid</code> und seine
	  Protokolldateien in <code class="filename">/var/log</code> auf.</p></div><p>Es wird nun davon ausgegangen, dass Apache seine
	Protokolldateien in einem Verzeichnis namens <code class="filename">apache_log_dir</code>
	ausserhalb von <code class="filename">/var</code>
	speichert.  Wenn dieses Verzeichnis auf einem
	nur-Lese-Dateisystem existiert, wird Apache nicht in der Lage
	sein, Protokolldateien zu speichern und wird vermutlich nicht
	richtig funktionieren.  Wenn dies der Fall ist, muss ein neues
	Verzeichnis zu der Liste der Verzeichnisse in
	<code class="filename">/etc/rc.d/var</code> hinzugefügt werden, um
	dieses in <code class="filename">/var</code> zu erstellen und um
	<code class="filename">apache_log_dir</code>
	nach <code class="filename">/var/log/apache</code> zu verknüpfen.  Es
	ist auch nötig, Berechtigungen und Besitzer auf diesem neuen
	Verzeichnis zu setzen.</p><p>Fügen Sie zuerst das Verzeichnis
	<code class="literal">log/apache</code> zu der Liste von Verzeichnissen
	hinzu, die in <code class="filename">/etc/rc.d/var</code> angelegt
	werden sollen.</p><p>Danach tragen Sie die folgenden Befehle in
	<code class="filename">/etc/rc.d/var</code> nach dem Abschnitt zum
	Erstellen der Verzeichnisse ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 0774 /var/log/apache</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chown nobody:nobody /var/log/apache</code></strong></pre><p>Schliesslich löschen Sie das bestehende <code class="filename">apache_log_dir</code>
	Verzeichnis und ersetzen es mit einer Verknüpfung:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm -rf apache_log_dir</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ln -s /var/log/apache apache_log_dir</code></strong></pre></div></div></div></body></html>