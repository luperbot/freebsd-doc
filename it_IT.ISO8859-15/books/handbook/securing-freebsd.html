<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>14.3. Rendere sicuro FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manuale di FreeBSD" /><link rel="up" href="security.html" title="Capitolo 14. Sicurezza" /><link rel="prev" href="security-intro.html" title="14.2. Introduzione" /><link rel="next" href="crypt.html" title="14.4. DES, MD5 e Crypt" /><link rel="copyright" href="legalnotice.html" title="Nota Legale" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.3. Rendere sicuro FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Indietro</a> </td><th width="60%" align="center">Capitolo 14. Sicurezza</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Avanti</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>14.3. Rendere sicuro FreeBSD</h2></div></div></div><a id="idp83767888" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Comandi o Protocolli: </h3><p xmlns="http://www.w3.org/1999/xhtml">In questo documento useremo testo
        <span class="application">grassetto</span> per riferirci ad applicazioni e
        testo <code class="command">a spaziatura fissa</code> per riferirci a specifici
        comandi.  I protocolli useranno un font normale.  Questa distinzione
        tipografica è utile per casi come ssh, che è un protocollo
        oltre che un comando.</p></div><p>Le sezioni seguenti descrivono i metodi per rendere sicuro il vostro
      sistema FreeBSD che sono stati menzionati nella <a class="link" href="security-intro.html" title="14.2. Introduzione">sezione precedente</a> di questo
      capitolo.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>14.3.1. Rendere sicuro <code class="systemitem">root</code> e gli account dello
        staff.</h3></div></div></div><a id="idp83773264" class="indexterm"></a><p>Innanzitutto, non preoccuparti di rendere sicuri gli account di
        staff se non hai reso sicuro l'account <code class="systemitem">root</code>.  La
        maggior parte dei sistemi hanno una password assegnata per l'account
        <code class="systemitem">root</code>.  La prima cosa che devi dare per assunta
        è che la password è <span class="emphasis"><em>sempre</em></span>
        compromessa.  Questo non significa che devi togliere la password; la
        password è quasi sempre necessaria per l'accesso dalla console
        della macchina.  Quello che questo significa è che non dovresti
        render possibile l'uso di questa password tranne che da console e
        possibilmente neanche dal comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a>.  Per esempio, assicurati
        che le tue pty siano specificate come <code class="literal">insecure</code> nel
        file <code class="filename">/etc/ttys</code> in modo che accessi diretti
        <code class="systemitem">root</code> tramite <code class="command">telnet</code> o
        <code class="command">rlogin</code> non siano permessi.  Se usi altri servizi di
        login come ad esempio <span class="application">sshd</span>, fai in modo che
        accessi diretti come <code class="systemitem">root</code> siano vietati anche per
        questi.  Puoi farlo modificando il file
        <code class="filename">/etc/ssh/sshd_config</code> e assicurandoti che
        <code class="literal">PermitRootLogin</code> sia impostato a
        <code class="literal">NO</code>.  Tieni conto di tutti i modi di accesso -
        servizi come ad esempio FTP vengono spesso trascurati.  Login
        <code class="systemitem">root</code> diretti dovrebbero essere permessi solo
        tramite la console di sistema.</p><a id="idp83785680" class="indexterm"></a><p>Ovviamente, come sysadmin (amministratore di sistema) hai bisogno
        di accesso a <code class="systemitem">root</code>, quindi apriremo alcuni passaggi;
        ci assicureremo però che questi passaggi richiedano ulteriori
        verifiche di password per funzionare.  Un modo per accedere a
        <code class="systemitem">root</code> è aggiungere gli appropriati account di
        staff al gruppo <code class="systemitem">wheel</code> (in
        <code class="filename">/etc/group</code>).  I membri del gruppo
        <code class="systemitem">wheel</code> possono accedere a
        <code class="systemitem">root</code> tramite <code class="command">su</code>.
        Non dovresti mai dare ai membri dello staff accesso nativo al gruppo
        <code class="systemitem">wheel</code> mettendoli in quel gruppo nel file
        <code class="filename">/etc/passwd</code>; dovresti metterli nel gruppo
        <code class="systemitem">staff</code> e quindi aggiungerli al gruppo
        <code class="systemitem">wheel</code> tramite il file
        <code class="filename">/etc/group</code>.  Solo i membri dello staff che hanno
        effettivo bisogno di accesso a <code class="systemitem">root</code> dovrebbero
        essere nel gruppo <code class="systemitem">wheel</code> group.  Altra
        possibilità, quando si utilizzi Kerberos come  metodo di
        autenticazione, ` quella di utilizzare il file
        <code class="filename">.k5login</code> dell'account <code class="systemitem">root</code> in
        modo da permettere l'accesso a <code class="systemitem">root</code> tramite
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> senza bisogno di mettere nessuno nel gruppo
        <code class="systemitem">wheel</code>.  Questa potrebbe essere la soluzione
        migliore dato che il meccanismo <code class="systemitem">wheel</code> permette
        all'attaccante di diventare <code class="systemitem">root</code> se è
        riuscito ad ottenere accesso ad un account di staff.  Benché il
        meccanismo <code class="systemitem">wheel</code> sia meglio di niente, non
        è necessariamente la soluzione più sicura.</p><p>Un metodo indiretto per rendere sicuri gli account di staff e quindi
        l'accesso a <code class="systemitem">root</code> è quello di eseguire
        l'operazione nota come <span class="quote">«<span class="quote">starring</span>»</span> delle password cifrate.
        password for the staff accounts: utilizzando il comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vipw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">vipw</span>(8)</span></a> si
        può rimpiazzare ogni password cifrata con un singolo carattere
        <span class="quote">«<span class="quote"><code class="literal">*</code></span>»</span> (asterisco, in inglese
        <span class="quote">«<span class="quote">star</span>»</span>).  Questo comando aggiorna il file
        <code class="filename">/etc/master.passwd</code> e il database utenti/password
        in modo da disabilitare i login autenticati da password.</p><p>Un account di staff come il seguente:</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Andrebbe modificato così:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Questo previene i normali login dato che la password cifrata non
        sarà mai <span class="quote">«<span class="quote"><code class="literal">*</code></span>»</span>.  Fatto questo i
        membri dello staff dovranno utilizzare un diverso meccanismo di
        autenticazione come ad esempio <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kerberos&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kerberos</span>(1)</span></a> o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a>
        utilizzando una coppia di chiavi pubblica/privata.  Utilizzando Kerberos
        bisogna generalmente rendere sicure sia le macchine su cui viene
        eseguito il server Kerberos che la propria workstation.  Utilizzando una
        coppia di chiavi bisogna in generale rendere sicura la macchina
        <span class="emphasis"><em>da cui</em></span> ci si sta collegando (in genere la propria
        workstation); si può aggiungere un ulteriore strato di protezione
        proteggendo la coppia di chiavi con una password all'atto della
        creazione con <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh-keygen</span>(1)</span></a>.  Eseguire lo <span class="quote">«<span class="quote">starring</span>»</span>
        degli account dello staff garantisce che questi possano eseguire il
        login solo tramite i metodi di accesso sicuri che sono stati
        configutati.  Quest forze l'intero staff all'uso di connessioni sicure e
        cifrate in tutte le loro sessioni, chiudendo un importante falla di
        sicurezza utilizzata da molti attaccanti: ascoltare il traffico di rete
        da un'altra macchina meno sicura.</p><p>I meccanismi di sicurezza più indiretti assumono anche che ci
        si colleghi da un server più restrittivo a uno che lo è di
        meno; per esempio se il tuo server primario ha in esecuzione una grande
        varietà di servizi, la tua workstation non dovrebbe averne in
        esecuzione nessuno. Per fare in modo che la tua workstation sia
        ragionevolmente sicura dovresti eseguire meno servizi possibile, o
        perfino nessuno del tutto, e dovresti utilizzare uno screen saver
        protetto da password.  Ovviamente, avendo accesso fisico alla
        workstation un attaccante può rompere qualsiasi protezione che tu
        possa aver importato, ma bisogna sempre considerare che la magior parte
        degli attacchi avviene remotamente, tramite una rete, da parte di
        persone che non hanno accesso fisico alle tue workstation o ai tuoi
        server.</p><a id="idp83812176" class="indexterm"></a><p>L'uso di sistemi come Kerberos permette di disabilitare o cambiare
        la pasword ad un account di staff in un solo posto ed avere effeto
        immediato su tutte le macchine in cui il membro dello staff ha un
        account.  Nel caso l'account di un membro dello staff venga compromesso,
        la possibilità di poter cambiare la sua password su tutte le
        macchine non ` cosa di poco conto.  Con password separate,
        cambiare una password su molte macchine può essere un bel
        problema.  Con Kerberos puoi anche imporre restrizioni di cambio
        password:  non solo un ticket Kerberos può essere fatto per
        scadere dopo un tempo predeterminato, ma il sistema Kerberos può
        richiedere all'utente di scegliere una nuova passsword dopo un certo
        periodo di tempo (per esempio, una volta al mese).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83813200"></a>14.3.2. Rendere sicuri i server Root e i binari SUID/SGID</h3></div></div></div><a id="idp83813840" class="indexterm"></a><a id="idp83814736" class="indexterm"></a><a id="idp83815632" class="indexterm"></a><a id="idp83816528" class="indexterm"></a><a id="idp83829712" class="indexterm"></a><a id="idp83830608" class="indexterm"></a><a id="idp83831504" class="indexterm"></a><a id="idp83832400" class="indexterm"></a><p>Il sysadmin prudente esegue soltanto i server che gli sono
        necessari, n' di più né di meno.  Bisogna tenere
        conto del fatto che i server di terze parti sono generalmente i
        più affetti da bug.  Per esempio, utilizzare una versione
        obsoleta di <span class="application">imapd</span> o
        <span class="application">popper</span> è equivalente a dare accesso
        <code class="systemitem">root</code> al mondo intero.  Non eseguire mai un server
        senza controllarlo accuratamente.  Molti server non hanno bisogno di
        essere eseguiti come <code class="systemitem">root</code>.  Per esempio i demoni
        <span class="application">ntalk</span>, <span class="application">comsat</span> e
        <span class="application">finger</span> possono essere eseguiti in speciali
        <em class="firstterm">sandbox</em> utente.  Difficilmente una sandbox
        sarà una soluzione completa del problema, a meno di dedicarci
        parecchio tempo, ma resta valido l'approccio a cipolla alla sicurezza:
        se qualcuno riesce ad irrompere in un server eseguito in una sandbox,
        deve ancora riuscire ad evadere da quest'ultima.  Più strati
        l'attaccante deve superare, minore la sua probabilità di
        successo.  Storicamente sono state trovate falle di accesso a root in
        virtualmente ogni server mai eseguito come <code class="systemitem">root</code>,
        inclusi i server del sistema base.  Se hai una macchina alla quale la
        gente accede solamente tramite <span class="application">sshd</span> e mai
        tramite <span class="application">telnetd</span> o
        <span class="application">rshd</span> o <span class="application">rlogind</span>,
        allora disattiva questi servizi!</p><p>FreeBSD attualmente esegue per default
        <span class="application">ntalkd</span>, <span class="application">comsat</span> e
        <span class="application">finger</span> in una sandbox.  Un altro programma
        candidato ad essere eseguito in una sandbox è <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.
        <code class="filename">/etc/defaults/rc.conf</code> comprende le opzioni
        necessarie per eseguire <span class="application">named</span> in una sandbox
        in forma comentata.  A seconda se state installando un nuovo sistema o
        aggiornando un sistema esistente, gli speciali account utente utilizzati
        da queste sandbox potrebbero non essere presenti.  Il sysadmin prudente
        dovrebbe cercar di utilizzare delle sandbox per i server ogniqualvolta
        possibile.</p><a id="idp83842384" class="indexterm"></a><p>Esiste un certo numero di altri servizi che generalmente non vengono
        eseguiti in una sandbox: <span class="application">sendmail</span>,
        <span class="application">popper</span>, <span class="application">imapd</span>,
        <span class="application">ftpd</span> e altri.  Ci sono software alternativi
        ad alcuni di questi ma installarli potrebbe richiedere più lavoro
        di quello che si intende dedicargli (il fattore convenienza colpisce
        ancora).  Potresti dover eseguire questi servizi come
        <code class="systemitem">root</code> ed affidarti ad altri meccanismi per
        individuare le intrusioni che potrebbero essere fatte attraverso
        questi.</p><p>L'altra grande potenziale fonte di falle per l'accesso a
        <code class="systemitem">root</code> sono i binari suid-root e sgid installati nel
        sistema, come ad esempio <span class="application">rlogin</span>, nelle
        directory <code class="filename">/bin</code>, <code class="filename">/sbin</code>,
        <code class="filename">/usr/bin</code> o <code class="filename">/usr/sbin</code>.
        Benché niente sia sicuro al 100%, i binari suid e sgid presenti
        nel sistema per default possono essere considerati ragionevolmente
        sicuri.  In ogni caso, delle falle da <code class="systemitem">root</code> sono
        occasionalmente trovate anche in questi.  Nel 1998 è stata
        trovata una falla da <code class="systemitem">root</code> in
        <code class="literal">Xlib</code> che rendeva vulnerabile
        <span class="application">xterm</span> (che tipicamente è suid).
        
        It is better to be safe than sorry and the prudent
        sysadmin will restrict suid binaries, that only staff should run,
        to a special group that only staff can access, and get rid of
        (<code class="command">chmod 000</code>) any suid binaries that nobody uses.
        A server with no display generally does not need an
        <span class="application">xterm</span> binary.  Sgid binaries can be
        almost as dangerous.  If an intruder can break an sgid-kmem binary,
        the intruder might be able to read <code class="filename">/dev/kmem</code>
        and thus read the encrypted password file, potentially compromising
        any passworded account.  Alternatively an intruder who breaks
        group <code class="literal">kmem</code> can monitor keystrokes sent through
        ptys, including ptys used by users who login through secure
        methods.  An intruder that breaks the <code class="systemitem">tty</code>
        group can write to
        almost any user's tty.  If a user is running a terminal program or
        emulator with a keyboard-simulation feature, the intruder can
        potentially generate a data stream that causes the user's terminal
        to echo a command, which is then run as that user.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>14.3.3. Rendere sicuri gli account utente</h3></div></div></div><p>Gli account utente sono generalmente i più difficili da
        rendere sicuri.  Bench*eacute; tu possa imporre restrizioni d'accesso
         allo staff ed eseguire lo
        <span class="quote">«<span class="quote">starring</span>»</span> delle loro password, potresti non poter farlo
        con l'account di un generico utente.  Se hai sufficiente controllo
         potesti farcela e rendere gli account utente
        sufficientemente sicuri, altrimenti dovrai essere più vigile nel
        controllo di questi account.  L'uso di ssh e Kerberos per gli account
        utente è più problematico, a causa del maggiore supporto
        amministrativo e tecnico richiesto, ma è sempre un'ottima
        soluzione se confrontata all'uso di un file password cifrato.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83855312"></a>14.3.4. Rendere sicuro il file password</h3></div></div></div><p>L'unica strada sicura è quella di eseguire lo starring so
        più password possibile e utilizzare ssh o Kerberos per accedere a
        quegli account.  Anche se il file di password cifrato
        (<code class="filename">/etc/spwd.db</code>) può essere letto solo da
        <code class="systemitem">root</code>, potrebbe essere possibile per un attaccante
        ottenere accesso in lettura a quel file anche senza aver ottenuto
        accesso in scrittura.</p><p>I tuoi script di sicurezza dovrebbero sempre verificare che il file
        password non venga modificato e in caso riportarlo ad un amministratore
        (cfr. la sezione <a class="link" href="securing-freebsd.html#security-integrity" title="14.3.6. Verifica dell'integrità dei file: binari, file di configurazione, etc.">Verifica dell'integrità dei
          file</a> sottostante).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83858256"></a>14.3.5. Rendere sicuri il kernel, i raw device e i file system</h3></div></div></div><p>Quando un attaccante irrompe nell'account di
        <code class="systemitem">root</code> può fare qualsiasi cosa, ma alcune cose
        sono più comode di altre. 
        Per esempio, la maggior parte dei kernel moderni comprende un device
        per l'ascolto dei pacchetti di rete.  In FreeBSD questo device si chiama
        <code class="filename">bpf</code>.  Un intrusore generalmente cercherà
        di ascoltare i pacchetti delle reti a cui la macchina compromessa
        è collegata.  Non ò obbligatorio dare all'intrusore questa
        possibilità e d'altro canto la maggior parte dei sistemi non ha
        bisogno di avere il device <code class="filename">bpf</code>.</p><a id="idp83860816" class="indexterm"></a><p>Anche nel caso di aver disattivato il device
        <code class="filename">bpf</code>, bisogna comunque preoccuparsi di
        <code class="filename">/dev/mem</code> e <code class="filename">/dev/kmem</code>; tra
        l'altro l'intrusore ha anche la possibilità di scrivere sui
        device disco raw o utilizzare il comando di caricamento moduli del
        kernel, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.  Un intrusore intraprendente può
        utilizzare un proprio modulo del kernel per l'ascolto dei pacchetti e
        caricarlo su un kernel in esecuzione.  Per evitare questi problemi
        bisogna eseguire il kernel ad un livello di sicurezza più alto,
        almeno al livello 1.  Il livello di sicurezza può essere
        impostato con <code class="command">sysctl</code> modificando la variabile
        <code class="varname">kern.securelevel</code>.  Se il livello di sicurezza
        è impostato ad 1, l'accesso in scrittura ai device raw
        sarà negato e alcuni <code class="command">chflags</code> speciali,
        come ad esempio <code class="literal">schg</code>, verranno verificati.
        Devi anche verificare che il flag <code class="literal">schg</code> sia impostato
        sui binari, cartelle e script utilizzati all'avvio prima
        dell'impostazione del livello di sicurezza.  L'uso di un livello di
        sicurezza superiore potrebbe essere una misura eccesiva, dato che rende
        l aggiornamento del sistema molto più complesso.
        You may compromise and run the
        system at a higher secure level but not set the
        <code class="literal">schg</code> flag for every system file and directory
        under the sun.  Another possibility is to simply mount
        <code class="filename">/</code> and <code class="filename">/usr</code> read-only.
        It should be noted that being too draconian in what you attempt to
        protect may prevent the all-important detection of an
        intrusion.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>14.3.6. Verifica dell'integrità dei file: binari, file di
        configurazione, etc.</h3></div></div></div><p>TODO:When it comes right down to it, you can only protect your core
        system configuration and control files so much before the
        convenience factor rears its ugly head.  For example, using
        <code class="command">chflags</code> to set the <code class="literal">schg</code> bit
        on most of the files in <code class="filename">/</code> and
        <code class="filename">/usr</code> is probably counterproductive, because
        while it may protect the files, it also closes a detection window.
        The last layer of your security onion is perhaps the most
        important - detection.  The rest of your security is pretty
        much useless (or, worse, presents you with a false sense of
        security) if you cannot detect potential intrusions.  Half the job
        of the onion is to slow down the attacker, rather than stop him, in
        order to be able to catch him in the act.</p><p>The best way to detect an intrusion is to look for modified,
        missing, or unexpected files.  The best way to look for modified
        files is from another (often centralized) limited-access system.
        Writing your security scripts on the extra-secure limited-access
        system makes them mostly invisible to potential attackers, and this
        is important.  In order to take maximum advantage you generally
        have to give the limited-access box significant access to the
        other machines in the business, usually either by doing a
        read-only NFS export of the other machines to the limited-access
        box, or by setting up ssh key-pairs to
        allow the limited-access box to ssh to
        the other machines.  Except for its network traffic, NFS is the
        least visible method - allowing you to monitor the
        file systems on each client box virtually undetected.  If your
        limited-access server is connected to the client boxes through a
        switch, the NFS method is often the better choice.  If your
        limited-access server is connected to the client boxes through a
        hub, or through several layers of routing, the NFS method may be
        too insecure (network-wise) and using
        ssh may be the better choice even with
        the audit-trail tracks that ssh
        lays.</p><p>Once you have given a limited-access box at least read access to the
        client systems it is supposed to monitor, you must write scripts
        to do the actual monitoring.  Given an NFS mount, you can write
        scripts out of simple system utilities such as <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> and
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>.  It is best to physically md5 the client-box files
        at least once a day, and to test control files such as those
        found in <code class="filename">/etc</code> and
        <code class="filename">/usr/local/etc</code> even more often.  When
        mismatches are found, relative to the base md5 information the
        limited-access machine knows is valid, it should scream at a
        sysadmin to go check it out.  A good security script will also
        check for inappropriate suid binaries and for new or deleted files
        on system partitions such as <code class="filename">/</code> and
        <code class="filename">/usr</code>.</p><p>When using ssh rather than NFS,
        writing the security script is much more difficult.   You
        essentially have to <code class="command">scp</code> the scripts to the client
        box in order to
        run them, making them visible, and for safety you also need to
        <code class="command">scp</code> the binaries (such as find) that those
        scripts use.  The <span class="application">ssh</span> client on the
        client box may already be compromised.  All in all, using
        ssh may be necessary when running over
        insecure links, but it is also a lot harder to deal with.</p><p>A good security script will also check for changes to user and
        staff members access configuration files:
        <code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
        <code class="filename">.ssh/authorized_keys</code> and so forth,
        files that might fall outside the purview of the
        <code class="literal">MD5</code> check.</p><p>If you have a huge amount of user disk space, it may take too
        long to run through every file on those partitions.  In this case,
        setting mount flags to disallow suid binaries and devices on those
        partitions is a good idea.  The <code class="literal">nodev</code> and
        <code class="literal">nosuid</code> options (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>) are what you
        want to look into.  You should probably scan them anyway, at least
        once a week, since the object of this layer is to detect a break-in
        attempt, whether or not the attempt succeeds.</p><p>Process accounting (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) is a relatively
        low-overhead feature of the operating system which might help
        as a post-break-in evaluation mechanism.  It is especially
        useful in tracking down how an intruder has actually broken into
        a system, assuming the file is still intact after the break-in has
        occured.</p><p>Finally, security scripts should process the log files, and the
        logs themselves should be generated in as secure a manner as
        possible - remote syslog can be very useful.  An intruder
        will try to cover his tracks, and log files are critical to the
        sysadmin trying to track down the time and method of the initial
        break-in.  One way to keep a permanent record of the log files is
        to run the system console to a serial port and collect the
        information to a secure machine monitoring the consoles.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83893840"></a>14.3.7. Paranoia</h3></div></div></div><p>Un po' di paranoia non fa mai male.  Come regola, un sysadmin
        può aggiungere qualsiasi feature di sicurezza fintantoché
        non impattano la comodità e può aggiungerne altre
        <span class="emphasis"><em>che la</em></span> impattano, ma solo dopo averci pensato bene.
        
        Even more importantly, a security administrator should mix it up a
        bit - if you use recommendations such as those given by this
        document verbatim, you give away your methodologies to the
        prospective attacker who also has access to this document.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83895632"></a>14.3.8. Attacchi Denial of Service</h3></div></div></div><a id="idp83896272" class="indexterm"></a><p>Questa sezione parla degli attacchi Denial of Service, ovvero quelli
        atti ad interrompere i servizi in esecuzione su una macchina.
        Tipicamente un attacco DoS è un attacco a pacchetto;
        benché non si possa fare molto riguardo ad un attacco moderno
        che satura la vostra rete con pacchetti , si
        può cercare di limitare il danno assicurandosi che l'attacco non
        blocchi i vostri servizi, utilizzando le seguenti tecniche:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Limitare le fork dei server.</p></li><li class="listitem"><p>TODO:Limiting springboard attacks (ICMP response attacks, ping
            broadcast, etc.).</p></li><li class="listitem"><p>Sovraccaricare la Kernel Route Cache. </p></li></ol></div><p>Un comune scenario è l'attacco di un server che fa fork e
        fargli creare così tanti processi figli da esaurire le risorse
        della macchina, come ad esempio la memoria, i file descriptor o altri e
        costringerlo quindi a fermarsi.  <span class="application">inetd</span>
        (cfr. <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>) ha molte opzioni per limitare questo tipo di
        attacchi.  Si deve notare che benché sia possibile evitare che la
        macchina si fermi, non è generalmente possibile evitare che i
        servizi vengano resi non disponibili dall'attacco.  Leggete attentamente
        la pagina del manuale di <span class="application">inetd</span>, con
        particolare attenzione alle opzioni <code class="option">-c</code>,
        <code class="option">-C</code> e <code class="option">-R</code>.  Un attacco con IP
         aggira l'opzione <code class="option">-C</code> quindi
        è bene utilizzare una combinazione di opzioni.  Alcuni server
        indipendenti hanno meccanismi interni per la limitazione delle
        fork.</p><p><span class="application">Sendmail</span> ha l'opzione
        <code class="option">-OMaxDaemonChildren</code> che generalmente funziona molto
        meglio che cercare di utilizzare le funzioni di limitazione basate sul
        carico della macchina, a causa del ritardo di aggiornamento del valore
        di carico.  Quando lanci <span class="application">sendmail</span> dovresti
        specificare un parametro <code class="literal">MaxDaemonChildren</code> abbastanza
        alto da gestire il carico previsto , ma non così alto da non
        essere gestibile dal computer.  È anche prudente eseguire
        <span class="application">Sendmail</span> in modalità queued
        (<code class="option">-ODeliveryMode=queued</code>) ed eseguire il demone
        (<code class="command">sendmail -bd</code>) separatamente dalla gestione code
        (<code class="command">sendmail -q15m</code>).  Se vuoi che i messaggi vengano
        consegnati in tempo reale puoi utilizzare un intervallo molto più
        breve, come ad esempio <code class="option">-q1m</code>, ma assicurati di
        utilizzare un valore <code class="literal">MaxDaemonChildren</code> adatto per
        <span class="emphasis"><em>quel</em></span> <span class="application">Sendmail</span>, in modo
        da prevenire problemi a catena.</p><p><span class="application">Syslogd</span> può essere attaccato
        direttamente ed è fortemente consigliato l'uso dell'opzione
        <code class="option">-s</code> quando possibile, o al limite l'opzione
        <code class="option">-a</code>.</p><p>You should also be fairly careful with connect-back services
        such as <span class="application">TCP Wrapper</span>'s reverse-identd,
        which can be attacked directly.  You generally do not want to use
        the reverse-ident feature of
        <span class="application">TCP Wrapper</span> for this reason.</p><p>È un'ottima idea quella di proteggere i servizi interni
        dall'accesso esterno chiudendoli tramite regole del firewall ai bordi
        della vostra rete.  L'idea è di prevenire gli attacchi a
        saturazione provenienti dall'esterno della vostra rete, non tanto di
        proteggere i servizi da attacchi di rete atti a compromettere
        <code class="systemitem">root</code>.  Utilizza sempre un firewall , ovvero <span class="quote">«<span class="quote">blocca tutto <span class="emphasis"><em>tranne</em></span> le
        porte A, B, C, D e M-Z</span>»</span>; puoi bloccare tutte le porte basse ad
        eccezione di specifici servizi quali <span class="application">named</span>
        (se sei primario per una zona), <span class="application">ntalkd</span>,
        <span class="application">sendmail</span> e altri servizi accessibili da
        Internet.  Se tu cercassi di configurare il firewall in maniera opposta
        (inclusivo o permissivo) c'è una buona probabilità che tu
        ti scordi di <span class="quote">«<span class="quote">chiudere</span>»</span> qualche servizio o che tu aggiunga
        un nuovo servizio interno e dimentichi di aggiornare il firewall.
        Puoi comunque lasciare aperte tutte le porte ,
        permettendo un uso permissivo, senza però compromettere le porte
        .  Nota anche che FreeBSD ti permette di controllare
        l'intervallo di porte utilizzate per il binding dinamico tramite vari
        <code class="command">sysctl</code> <code class="varname">net.inet.ip.portrange</code>
        (<code class="command">sysctl -a | fgrep portrange</code>), che possono
        semplificare la complessità di configurazione del tuo firewall.
        </p><p>Another common DoS attack is called a springboard attack
        - to attack a server in a manner that causes the server to
        generate responses which overloads the server, the local
        network, or some other machine.  The most common attack of this
        nature is the <span class="emphasis"><em>ICMP ping broadcast attack</em></span>.
        The attacker spoofs ping packets sent to your LAN's broadcast
        address with the source IP address set to the actual machine they
        wish to attack.  If your border routers are not configured to
        stomp on ping packets to broadcast addresses, your LAN winds up
        generating sufficient responses to the spoofed source address to
        saturate the victim, especially when the attacker uses the same
        trick on several dozen broadcast addresses over several dozen
        different networks at once.  Broadcast attacks of over a hundred
        and twenty megabits have been measured.  A second common
        springboard attack is against the ICMP error reporting system.
        By constructing packets that generate ICMP error responses, an
        attacker can saturate a server's incoming network and cause the
        server to saturate its outgoing network with ICMP responses.  This
        type of attack can also crash the server by running it out of
        memory, especially if the server cannot drain the ICMP responses
        it generates fast enough.
        Use the <span class="application">sysctl</span>
        variable <code class="literal">net.inet.icmp.icmplim</code> to limit these attacks.
        The last major class of springboard
        attacks is related to certain internal
        <span class="application">inetd</span> services such as the
        udp echo service.  An attacker simply spoofs a UDP packet with the
        source address being server A's echo port, and the destination
        address being server B's echo port, where server A and B are both
        on your LAN.  The two servers then bounce this one packet back and
        forth between each other.  The attacker can overload both servers
        and their LANs simply by injecting a few packets in this manner.
        Similar problems exist with the internal
        <span class="application">chargen</span> port.  A
        competent sysadmin will turn off all of these inetd-internal test
        services.</p><p>Spoofed packet attacks may also be used to overload the kernel
        route cache.  Refer to the <code class="varname">net.inet.ip.rtexpire</code>,
        <code class="varname">rtminexpire</code>, and <code class="varname">rtmaxcache</code>
        <code class="command">sysctl</code> parameters.  A spoofed packet attack
        that uses a random source IP will cause the kernel to generate a
        temporary cached route in the route table, viewable with
        <code class="command">netstat -rna | fgrep W3</code>.  These routes
        typically timeout in 1600 seconds or so.  If the kernel detects
        that the cached route table has gotten too big it will dynamically
        reduce the <code class="varname">rtexpire</code> but will never decrease it
        to less than <code class="varname">rtminexpire</code>.  There are two
        problems:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The kernel does not react quickly enough when a lightly
            loaded server is suddenly attacked.</p></li><li class="listitem"><p>The <code class="varname">rtminexpire</code> is not low enough for
            the kernel to survive a sustained attack.</p></li></ol></div><p>If your servers are connected to the Internet via a T3 or
        better, it may be prudent to manually override both
        <code class="varname">rtexpire</code> and <code class="varname">rtminexpire</code>
        via <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  Never set either parameter to zero (unless
        you want to crash the machine).  Setting both
        parameters to 2 seconds should be sufficient to protect the route
        table from attack.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp83943760"></a>14.3.9. Access Issues with Kerberos and SSH</h3></div></div></div><a id="idp83944400" class="indexterm"></a><a id="idp83945040" class="indexterm"></a><p>There are a few issues with both Kerberos and
        ssh that need to be addressed if
        you intend to use them.  Kerberos 5 is an excellent
        authentication protocol, but there are bugs in the kerberized
        <span class="application">telnet</span> and
        <span class="application">rlogin</span> applications that make them
        unsuitable for dealing with binary streams.  Also, by default
        Kerberos does not encrypt a session unless you use the
        <code class="option">-x</code> option.  <span class="application">ssh</span>
        encrypts everything by default.</p><p>Ssh works quite well in every respect except that it forwards
        encryption keys by default.   What
        this means is that if you have a secure workstation holding keys
        that give you access to the rest of the system, and you
        ssh to an insecure machine, your keys
        are usable.  The actual keys themselves are not exposed, but
        ssh installs a forwarding port for the
        duration of your login, and if an attacker has broken
        <code class="systemitem">root</code> on the
        insecure machine he can utilize that port to use your keys to gain
        access to any other machine that your keys unlock.</p><p>We recommend that you use ssh in
        combination with Kerberos whenever possible for staff logins.
        <span class="application">Ssh</span> can be compiled with Kerberos
        support.  This reduces your reliance on potentially exposed
        ssh keys while at the same time
        protecting passwords via Kerberos.  Ssh
        keys should only be used for automated tasks from secure machines
        (something that Kerberos is unsuited to do).  We also recommend that
        you either turn off key-forwarding in the
        ssh configuration, or that you make use
        of the <code class="literal">from=IP/DOMAIN</code> option that
        ssh allows in its
        <code class="filename">authorized_keys</code> file to make the key only
        usable to entities logging in from specific machines.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Introduzione </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> 14.4. DES, MD5 e Crypt</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Questo, ed altri documenti, possono essere scaricati da
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Per domande su FreeBSD, leggi la
    <a href="http://www.FreeBSD.org/docs.html">documentazione</a> prima di contattare
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Per domande su questa documentazione, invia una e-mail a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>