<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>7.2. Comandi di manipolazione del testo</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Introduzione a Unix" /><link rel="up" href="text-processing.html" title="Capitolo 7. Manipolazione del testo" /><link rel="prev" href="text-processing.html" title="Capitolo 7. Manipolazione del testo" /><link rel="next" href="commands.html" title="Capitolo 8. Altri comandi utili" /><link rel="copyright" href="legalnotice.html" title="Nota Legale" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.2. Comandi di manipolazione del testo</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="text-processing.html">Indietro</a> </td><th width="60%" align="center">Capitolo 7. Manipolazione del testo</th><td width="20%" align="right"> <a accesskey="n" href="commands.html">Avanti</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="text-processing-commands"></a>7.2. Comandi di manipolazione del testo</h2></div></div></div><div class="table"><a id="text-processing-table-commands"></a><div class="table-title">Tabella 7.1. Comandi di manipolazione del testo</div><div class="table-contents"><table summary="Comandi di manipolazione del testo" border="1"><colgroup><col width="4.5in" /><col /></colgroup><thead><tr><th align="center">Comando/Sintassi</th><th align="center">Cosa fa</th></tr></thead><tbody><tr><td><code class="command">awk/nawk [opzioni]
                file</code></td><td>esamina gli schemi (pattern) all'interno di un file ed
              elabora i risultati</td></tr><tr><td><code class="command">grep/egrep/fgrep
                [opzioni]
                'stringa di ricerca'
                file</code></td><td>ricerca nell'argomento (in questo caso probabilmente un
              file) tutte le occorrenze della stringa di ricerca e le
              elenca</td></tr><tr><td><code class="command">sed [opzioni]
                file</code></td><td>editor di flusso per manipolare file da uno script o da
              linea di comando</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="text-processing-commands-grep"></a>7.2.1. grep</h3></div></div></div><p>Questa sezione fornisce un'introduzione all'uso delle
        <span class="emphasis"><em>espressioni regolari</em></span> con <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a>.</p><p>L'utility <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a> viene usata per ricercare espressioni
        regolari comuni che si presentano nei file Unix.  Le espressioni
        regolari, come quelle viste in precedenza, sono meglio specificate
        all'interno di apostrofi (o caratteri di quoting singoli) quando
        usate con l'utility <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a>.  L'utility <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=egrep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">egrep</span>(1)</span></a> fornisce
        una capacità di ricerca attraverso un set esteso di
        meta-caratteri.  La sintassi dell'utility <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a>, alcune delle
        possibili opzioni e alcuni semplici esempi sono mostrati di
        seguito.</p><p><span class="emphasis"><em>Sintassi</em></span></p><p><code class="command">grep [opzioni]
          expreg
          [file]</code></p><p><span class="emphasis"><em>Opzioni generali</em></span></p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><code class="option">-i</code></td><td>ignora la differenza tra caratteri maiuscoli e
                minuscoli</td></tr><tr><td><code class="option">-c</code></td><td>riporta solamente la somma del numero di linee contenenti
                le corrispondenze, non le corrispondenze stesse</td></tr><tr><td><code class="option">-v</code></td><td>inverte la ricerca, visualizzando solo le linee senza
                corrispondenza</td></tr><tr><td><code class="option">-n</code></td><td>mostra un numero di linea insieme alla linea su cui
                è stata trovata una corrispondenza</td></tr><tr><td><code class="option">-s</code></td><td>lavora in silenzio, riportando solo lo stato
                finale:</td></tr><tr><td> </td><td>0, per corrispondenze trovate</td></tr><tr><td> </td><td>1, per nessuna corrispondenza</td></tr><tr><td> </td><td>2, per errori</td></tr><tr><td><code class="option">-l</code></td><td>elenca i nomi dei file, ma non le linee, nei quali sono
                state trovate corrispondenze</td></tr></tbody></table></div><p><span class="emphasis"><em>Esempi:</em></span></p><p>Si consideri il seguente file:</p><pre class="screen">{Unix prompt 5} <strong class="userinput"><code>cat num.list</code></strong>
 1      15 fifteen
 2      14 fourteen
 3      13 thirteen
 4      12 twelve
 5      11 eleven
 6      10 ten
 7       9 nine
 8       8 eight
 9       7 seven
10       6 six
11       5 five
12       4 four
13       3 three
14       2 two
15       1 one</pre><p>Ecco alcuni esempi di <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a> usando tale file.
        Nel primo si ricerca il numero <span class="emphasis"><em>15</em></span>:</p><pre class="screen">{Unix prompt 6} <strong class="userinput"><code>grep '15' num.list</code></strong>
 1      15 fifteen
15       1 one</pre><p>Ora si usa l'opzione <code class="option">-c</code> per contare il numero di
        linee che corrispondono al precedente criterio di ricerca:</p><pre class="screen">{Unix prompt 7} <strong class="userinput"><code>grep -c '15' num.list</code></strong>
2</pre><p>Qui la ricerca è più generale: si selezionano tutte le
        linee che contengono il carattere <span class="emphasis"><em>1</em></span> seguito da un
        <span class="emphasis"><em>1</em></span> o un <span class="emphasis"><em>2</em></span> o un
        <span class="emphasis"><em>5</em></span>:</p><pre class="screen">{Unix prompt 8} <strong class="userinput"><code>grep '1[125]' num.list</code></strong>
 1      15 fifteen
 4      12 twelve
 5      11 eleven
11       5 five
12       4 four
15       1 one</pre><p>Ora si ricercano tutte le linee che <span class="emphasis"><em>iniziano</em></span>
        con uno <span class="emphasis"><em>spazio</em></span>:</p><pre class="screen">{Unix prompt 9} <strong class="userinput"><code>grep '^ ' num.list</code></strong>
 1      15 fifteen
 2      14 fourteen
 3      13 thirteen
 4      12 twelve
 5      11 eleven
 6      10 ten
 7       9 nine
 8       8 eight
 9       7 seven</pre><p>Ora tutte le linee che <span class="emphasis"><em>non iniziano</em></span> con uno
        <span class="emphasis"><em>spazio</em></span>:</p><pre class="screen">{Unix prompt 10} <strong class="userinput"><code>grep '^[^ ]' num.list</code></strong>
10       6 six
11       5 five
12       4 four
13       3 three
14       2 two
15       1 one</pre><p>L'ultimo esempio può anche essere realizzato usando l'opzione
        <code class="option">-v</code> insieme all stringa di ricerca originale,
        esempio:</p><pre class="screen">{Unix prompt 11} <strong class="userinput"><code>grep -v '^ ' num.list</code></strong>
10       6 six
11       5 five
12       4 four
13       3 three
14       2 two
15       1 one</pre><p>Ora si ricercano tutte le linee che <span class="emphasis"><em>iniziano</em></span>
        con carattere <span class="emphasis"><em>compreso</em></span> tra <span class="emphasis"><em>1</em></span> e
        <span class="emphasis"><em>9</em></span>:</p><pre class="screen">{Unix prompt 12} <strong class="userinput"><code>grep '^[1-9]' num.list</code></strong>
10       6 six
11       5 five
12       4 four
13       3 three
14       2 two
15       1 one</pre><p>In questo esempio si ricercano alcune istanze di
        <span class="emphasis"><em>t</em></span> seguite da <span class="emphasis"><em>zero o alcune</em></span>
        occorrenze di <span class="emphasis"><em>e</em></span>:</p><pre class="screen">{Unix prompt 13} <strong class="userinput"><code>grep 'te*' num.list</code></strong>
 1      15 fifteen
 2      14 fourteen
 3      13 thirteen
 4      12 twelve
 6      10 ten
 8       8 eight
13       3 three
14       2 two</pre><p>In questo esempio si ricercano alcune istanze di
        <span class="emphasis"><em>t</em></span> seguite da <span class="emphasis"><em>una o alcune</em></span>
        occorrenze di e:</p><pre class="screen">{Unix prompt 14} <strong class="userinput"><code>grep 'tee*' num.list</code></strong>
1      15 fifteen
2      14 fourteen
3      13 thirteen
6      10 ten</pre><p>Si può prendere il proprio input da un programma,
        anzichè da un file.  Qui si riportano alcune linee di output del
        comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=who&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">who</span>(1)</span></a> che iniziano con la lettera
        <span class="emphasis"><em>l</em></span>.</p><pre class="screen">{Unix prompt 15} <strong class="userinput"><code>who | grep '^l'</code></strong>
lcondron ttyp0 Dec 1 02:41 (lcondron-pc.acs.)</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="text-processing-commands-sed"></a>7.2.2. sed</h3></div></div></div><p>L'editor di flusso non interattivo <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sed&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sed</span>(1)</span></a> manipola un
        flusso di input, linea per linea, creando specifici cambiamenti e
        mandando il risultato su standard output.</p><p><span class="emphasis"><em>Sintassi</em></span></p><p><code class="command">sed [opzioni]
          comando_di_editing
          [file]</code></p><p>Il formato per i comandi di editing è:</p><p><code class="command">[indirizzo1[,indirizzo2]]
          [funzione]
          [argomenti]</code></p><p>dove gli indirizzi sono facoltativi e possono essere separati dalla
        funzione tramite spazi o tab.  La funzione è obbligatoria.
        L'argomento può essere facoltativo o obbligatorio a seconda della
        funzione usata.</p><p>Gli <span class="emphasis"><em>indirizzi di linea numerati</em></span> sono numeri
        decimali di linea che partono dalla prima linea di input e si
        incrementano di uno per ogni linea.  Se vengono stabiliti più
        file di input il contatore continua cumulativamente attraverso i file.
        L'ultima linea di input può essere specificata con il carattere
        $.</p><p>Gli <span class="emphasis"><em>indirizzi di contesto</em></span> sono schemi di
        espressioni regolari racchiusi tra caratteri di slashe (/).</p><p>I comandi possono avere 0, 1 o 2 indirizzi separati da virgola con i
        seguenti effetti:</p><div class="informaltable"><table border="0"><colgroup><col width="2in" /><col /></colgroup><thead><tr><th># indirizzi</th><th>linee considerate</th></tr></thead><tbody><tr><td>0</td><td>tutte le linee di input</td></tr><tr><td>1</td><td>solamente le linee che corrispondono agli indirizzi
                specificati</td></tr><tr><td>2</td><td>dalla prima linea che corrisponde al primo indirizzo fino
                alla linea che corrisponde al secondo indirizzo, inclusa.  Il
                processo viene ripetuto per le linee interne.</td></tr></tbody></table></div><p>Le <span class="emphasis"><em>funzioni di sostituzione</em></span> permettono di
        ricercare contesti e sono specificate nella forma:</p><p><code class="command">s/schema_espressione_regolare/stringa_di_rimpiazzo/flag</code></p><p>e possono essere quotate con caratteri di quoting singoli (') se
        sono specificate opzioni o funzioni aggiuntive.  Questi schemi sono
        identici agli indirizzi di contesto, eccetto che, mentre questi sono
        normalmente chiusi tra slashe (/), nelle funzioni sono permessi alcuni
        normali caratteri per specificare i delimitatori, oltre a newline e
        spazio.  La stringa di rimpiazzo non è uno schema di
        espressione regolare; qui i caratteri non hanno significati speciali,
        fatta eccezione di:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><span class="emphasis"><em>&amp;</em></span></td><td>che sostituisce tale simbolo con la stringa
                <em class="replaceable"><code>schema_espressione_regolare</code></em></td></tr><tr><td><span class="emphasis"><em>\<em class="replaceable"><code>n</code></em></em></span></td><td>sostituisce tale simbolo con
                l'<em class="replaceable"><code>n-esima</code></em> stringa corrispondente a
                <em class="replaceable"><code>schema_espressione_regolare</code></em> chiusa
                tra una coppia di '\(','\)'</td></tr></tbody></table></div><p>Questi caratteri speciali possono essere messi in escape con il
        carattere backslash (\) per rimuovere il loro significato
        speciale.</p><p><span class="emphasis"><em>Opzioni generali</em></span></p><div class="informaltable"><table border="0"><colgroup><col width="1.5in" /><col /></colgroup><tbody><tr><td><code class="option">-e
                  <em class="replaceable"><code>script</code></em></code></td><td>script di editing</td></tr><tr><td><code class="option">-n</code></td><td>non stampa l'output di default, ma solamente quelle linee
                specificate dalle funzioni <code class="command">p</code> o
                <code class="command">s///p</code></td></tr><tr><td><code class="option">-f
                  <em class="replaceable"><code>script_file</code></em></code></td><td>prende lo script di editing dal file specificato</td></tr></tbody></table></div><p>Alcune valide flag per le funzioni sostitutive sono:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><code class="option">d</code></td><td>cancella lo schema</td></tr><tr><td><code class="option">g</code></td><td>sostituzione globale dello schema</td></tr><tr><td><code class="option">p</code></td><td>stampa le linee</td></tr></tbody></table></div><p><span class="emphasis"><em>Esempi:</em></span></p><p>Questo esempio modifica tutte le accidentali virgole (,) in una
        virgola seguita da uno spazio (, ) quindi crea l'output:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cat filey | sed s/,/,\ /g</code></strong></pre><p>Il seguente esempio rimuove tutte le accidentali
        <span class="emphasis"><em>Jr</em></span> precedute da uno spazio
        (<span class="emphasis"><em>Jr</em></span>) all'interno del file
        <code class="filename">filey</code>:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cat filey | sed s/\ Jr//g</code></strong></pre><p>Per realizzare operazioni multiple sull'input, si precede ogni
        operazione con l'opzione <code class="option">-e</code> (edit) e si quota la
        stringa.  Ad esempio, per filtrare le linee contenenti <span class="quote">«<span class="quote">Date:
        </span>»</span> e <span class="quote">«<span class="quote">From: </span>»</span> e rimpiazzarle senza i due punti
        (:):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sed -e 's/Date: /Date /' -e 's/From: /From /'</code></strong></pre><p>Per visualizzare solamente le linee del file che iniziano con
        <span class="quote">«<span class="quote">Date:</span>»</span> e includerne una che inizia con
        <span class="quote">«<span class="quote">Name:</span>»</span>:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sed -n '/^Date:/,/^Name:/p'</code></strong></pre><p>Per stampare solamente le prime 10 linee dell'input (un rimpiazzo di
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=head&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">head</span>(1)</span></a>):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sed -n 1,10p</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="text-processing-commands-awk-nawk-gawk"></a>7.2.3. awk, nawk, gawk</h3></div></div></div><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a> è un linguaggio di elaborazione e ricerca di
        schemi.  Il suo nome deriva dalle ultime iniziali dei tre autori:
        Alfred. V. Aho, Peter. J.Weinberger e Brian. W. Kernighan.
        <code class="command">nawk</code> è un <span class="emphasis"><em>nuovo</em></span>
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a>, una nuova versione del programma e <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gawk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gawk</span>(1)</span></a> è
        il <span class="emphasis"><em>gnu</em></span> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a>, da parte della Free Software
        Foundation.  Ogni versione è leggermente differente.  Qui ci si
        limiterà ad illustrare semplici esempi che potrebbero andar bene
        per tutte le versioni.  In alcuni sistemi operativi <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a> è
        in realtà <code class="command">nawk</code>.</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a> ricerca schemi nel suo input e realizza le operazioni
        specificate su ogni linea o sui campi di linea che contengono tali
        schemi.  Le espressioni dello schema di confronto per <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=awk&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">awk</span>(1)</span></a>
        possono essere specificate sia attraverso linea di comando, sia
        inserendole in un file e usando l'opzione <code class="option">-f
        <em class="replaceable"><code>file_programma</code></em></code>.</p><p><span class="emphasis"><em>Sintassi</em></span></p><p><code class="command">awk programma
          [file]</code></p><p>dove <em class="replaceable"><code>programma</code></em> è composto da uno o
        più dei seguenti campi:</p><p><em class="replaceable"><code>schema</code></em>
        { <em class="replaceable"><code>azione</code></em> }</p><p>Ogni linea di input viene verificata con lo schema di confronto
        insieme alla specifica azione che bisogna realizzare per ogni
        corrispondenza trovata.  Questo continua attraverso la completa sequenza
        di schemi, quindi la prossima linea di input viene verificata.</p><p>L'<span class="emphasis"><em>input</em></span> è diviso tra
        <span class="emphasis"><em>record</em></span> e <span class="emphasis"><em>campi</em></span>.  Il separatore
        di <span class="emphasis"><em>record</em></span> di default è newline e la
        variabile <code class="literal">NR</code> tiene il conto dei record.  Il
        separatore di <span class="emphasis"><em>campo</em></span> di default è uno spazio
        bianco, <span class="emphasis"><em>spazi</em></span> e <span class="emphasis"><em>tab</em></span>, e la
        variabile <code class="literal">NF</code> tiene il conto dei campi.  I separatori
        di input del campo, <code class="literal">FS</code> e del record,
        <code class="literal">RS</code>, possono essere settati in qualsiasi momento per
        farli corrispondere a singoli caratteri specifici.  I separatori di
        output del campo, <code class="literal">OFS</code> e del record,
        <code class="literal">ORS</code>, possono essere modificati, se si desidera, con
        singoli caratteri specifici.
        <code class="literal">$n</code>, dove
        <em class="replaceable"><code>n</code></em> è un intero, viene usato per
        rappresentare l'<em class="replaceable"><code>n-esimo</code></em> campo di un record
        di input, mentre <code class="literal">$0</code> rappresenta l'intero record
        di input.</p><p><code class="literal">BEGIN</code> e <code class="literal">END</code> sono speciali
        schemi che vengono verificati rispettivamente all'inizio dell'input,
        prima che il primo campo sia letto e alla fine dell'input, dopo che
        l'ultimo campo è stato letto.</p><p>La <span class="emphasis"><em>stampa</em></span> è permessa attraverso
        l'istruzione <code class="command">print</code> e l'istruzione per la stampa
        formattata <code class="command">printf</code>.</p><p>Gli <span class="emphasis"><em>schemi</em></span> (pattern) possono essere
        espressioni regolari, espressioni aritmetiche relazionali, espressioni
        di valutazione di stringhe e combinazioni buleane di alcune di queste.
        In quest'ultimo caso gli schemi possono essere combinati con i seguenti
        operatori buleani, usando le parentesi per definire le
        combinazioni:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><span class="emphasis"><em>||</em></span></td><td>or</td></tr><tr><td><span class="emphasis"><em>&amp;&amp;</em></span></td><td>and</td></tr><tr><td><span class="emphasis"><em>!</em></span></td><td>not</td></tr></tbody></table></div><p>La separazione di schemi con virgole definisce un
        <span class="emphasis"><em>range</em></span> in cui lo schema è applicabile,
        esempio:</p><p><code class="command">/primo/,/ultimo/</code></p><p>seleziona tutte le linee partendo con quella che contiene
        <em class="replaceable"><code>primo</code></em> e continuando inclusivamente fino alla
        linea che contiene <em class="replaceable"><code>ultimo</code></em>.</p><p>Per selezionare le linee da 15 a 20 si usa il seguente
        schema:</p><p>NR==15 , NR==20</p><p>Le <span class="emphasis"><em>espressioni regolari</em></span> devono essere chiuse
        tra slashe (/) e i meta-caratteri possono essere messi in escape con il
        carattere di backslash (\).  Le espressioni regolari possono essere
        raggruppate con gli operatori seguenti:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><span class="emphasis"><em>|</em></span></td><td>per alternative separate</td></tr><tr><td><span class="emphasis"><em>+</em></span></td><td>una o più</td></tr><tr><td><span class="emphasis"><em>?</em></span></td><td>zero o una</td></tr></tbody></table></div><p>Un confronto di espressione regolare può essere specificato
        con:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td><span class="emphasis"><em>~</em></span></td><td>contiene l'espressione</td></tr><tr><td><span class="emphasis"><em>!~</em></span></td><td>non contiene l'espressione</td></tr></tbody></table></div><p>Quindi il programma:</p><pre class="programlisting">$1 ~ /[Ff]rank/</pre><p>è vero se il primo campo, $1, contiene "Frank" o "frank"
        dovunque all'interno del campo.  Per confrontare un campo identico a
        "Frank" o "frank" si usa:</p><pre class="programlisting">$1 ~ /^[Ff]rank$/</pre><p>Le <span class="emphasis"><em>espressioni relazionali</em></span> sono permesse usando
        i seguenti operatori relazionali:</p><div class="informaltable"><table border="0"><colgroup><col width="0.5in" /><col /></colgroup><tbody><tr><td>&lt;</td><td>minore di</td></tr><tr><td>&lt;=</td><td>minore o uguale a</td></tr><tr><td>= =</td><td>uguale a</td></tr><tr><td>&gt;=</td><td>maggiore o uguale a</td></tr><tr><td>!=</td><td>non uguale a</td></tr><tr><td>&gt;</td><td>maggiore di</td></tr></tbody></table></div><p>Non si può conoscere su due piedi se le variabili sono
        stringhe o numeri.  Se nessun operando è riconosciuto per essere
        un numero, sono realizzati confronti di stringhe.  Altrimenti, viene
        realizzata una comparazione numerica.  In mancanza di informazioni per
        il contrario, viene realizzata una comparazione di stringa, così
        questa:</p><p>$1 &gt; $2</p><p>verrà valutata con valori di tipo stringa.  Per assicurarsi
        una valutazione numerica, costruire qualcosa simile a:</p><p>( $1 + 0 ) &gt; $2</p><p>Le <span class="emphasis"><em>funzioni matematiche</em></span> exp, log e sqrt sono di
        tipo built-in.</p><p>Altre funzioni <span class="emphasis"><em>built-in</em></span> sono:</p><div class="informaltable"><table border="0"><colgroup><col width="1.5in" /><col /></colgroup><tbody><tr><td><span class="emphasis"><em>index(<em class="replaceable"><code>s</code></em>,<em class="replaceable"><code>t</code></em>)</em></span></td><td>ritorna la posizione della stringa
                <em class="replaceable"><code>s</code></em> dove si presenta il primo
                <em class="replaceable"><code>t</code></em> o 0 se non esiste</td></tr><tr><td><span class="emphasis"><em>lenght(<em class="replaceable"><code>s</code></em>)</em></span></td><td>ritorna la lunghezza della stringa
                <em class="replaceable"><code>s</code></em></td></tr><tr><td><span class="emphasis"><em>substr(<em class="replaceable"><code>s</code></em>,<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>)</em></span></td><td>ritorna l'<em class="replaceable"><code>n-esimo</code></em> carattere della
                sottostringa di <em class="replaceable"><code>s</code></em>, iniziando dalla
                posizione <em class="replaceable"><code>m</code></em></td></tr></tbody></table></div><p>Gli <span class="emphasis"><em>array</em></span> sono dichiarati automaticamente
        quando vengono usati, per esempio:</p><p><code class="literal">arr[i]=$1</code></p><p>assegna il primo campo del corrente record di input all'i-esimo
        elemento dell'array.</p><p>Le espressioni di controllo di flusso <span class="emphasis"><em>if-else</em></span>,
        <span class="emphasis"><em>while</em></span> e <span class="emphasis"><em>for</em></span> sono permesse con
        la sintassi del <span class="emphasis"><em>C</em></span>:</p><p><code class="command">for (i=1; i &lt;= NF; i++) {azioni}</code></p><p><code class="command">while (i&lt;=NF) {azioni}</code></p><p><code class="command">if (i&lt;NF) {azioni}</code></p><p><span class="emphasis"><em>Opzioni generali</em></span></p><div class="informaltable"><table border="0"><colgroup><col width="1.5in" /><col /></colgroup><tbody><tr><td><code class="option">-f
                  <em class="replaceable"><code>file_programma</code></em></code></td><td>legge i comandi dal file specificato</td></tr><tr><td><code class="option">-F<em class="replaceable"><code>c</code></em></code></td><td>usa il carattere <em class="replaceable"><code>c</code></em> come il
                carattere di separatore di campo</td></tr></tbody></table></div><p><span class="emphasis"><em>Esempi:</em></span></p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cat filex | tr a-z A-Z | awk -F: '{printf("7R %-6s %-9s %-24s \n",$1,$2,$3)}' &gt; upload.file</code></strong></pre><p>effettua <code class="command">cat</code> su <code class="filename">filex</code>, che
        è formattato in questo modo:</p><pre class="programlisting">nfb791:99999999:smith
7ax791:999999999:jones
8ab792:99999999:chen
8aa791:999999999:mcnulty</pre><p>cambiando tutti i caratteri minuscoli in caratteri maiuscoli con
        l'utility <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tr</span>(1)</span></a> e formattando il file come mostrato di seguito, il
        quale viene scritto nel file <code class="filename">upload.file</code></p><pre class="programlisting">7R NFB791 99999999 SMITH
7R 7AX791 999999999 JONES
7R 8AB792 99999999 CHEN
7R 8AA791 999999999 MCNULTY</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="text-processing.html">Indietro</a> </td><td width="20%" align="center"><a accesskey="u" href="text-processing.html">Risali</a></td><td width="40%" align="right"> <a accesskey="n" href="commands.html">Avanti</a></td></tr><tr><td width="40%" align="left" valign="top">Capitolo 7. Manipolazione del testo </td><td width="20%" align="center"><a accesskey="h" href="index.html">Partenza</a></td><td width="40%" align="right" valign="top"> Capitolo 8. Altri comandi utili</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Questo, ed altri documenti, possono essere scaricati da
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Per domande su FreeBSD, leggi la
    <a href="http://www.FreeBSD.org/docs.html">documentazione</a> prima di contattare
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Per domande su questa documentazione, invia una e-mail a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>