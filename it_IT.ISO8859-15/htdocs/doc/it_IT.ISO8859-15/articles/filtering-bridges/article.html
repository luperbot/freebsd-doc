<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Filtering Bridges</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="Spesso è utile dividere una rete fisica (come una Ethernet) in due segmenti separati, senza dover creare sottoreti e usare un router per collegarli assieme. Il dispositivo che collega due reti insieme in questo modo è chiamato bridge. Un sistema FreeBSD con due interfacce di rete è sufficiente per raggiungere lo scopo. Un bridge funziona individuando gli indirizzi del livello MAC (indirizzi Ethernet) dei dispositivi collegati ad ognuna delle sue interfacce di rete e inoltrando il traffico tra le due reti solo se il mittente e il destinatario si trovano su segmenti differenti. Sotto molti punti di vista un brigde è simile a uno switch Ethernet con solo due porte." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="it" class="article" lang="it"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp69732432"></a>Filtering Bridges</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Alex</span> <span class="surname">Dupre</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:ale@FreeBSD.org">ale@FreeBSD.org</a>&gt;</code></p></div></div></div></div></div><div>Revisione: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD è un marchio registrato della
  FreeBSD Foundation.</p><p>3Com e HomeConnect sono marchi registrati
  della 3Com Corporation.</p><p>Intel, Celeron, EtherExpress, i386,
  i486, Itanium, Pentium, e Xeon sono marchi o marchi registrati della
  Intel Corporation o delle sue sussidiarie negli Stati Uniti e in altri
  paesi.</p><p>Molti dei nomi identificativi usati dai
  produttori e dai venditori per distinguere i loro prodotti sono anche dei
  marchi.  Quando questi nomi appaiono nel libro, e il FreeBSD Project
  è al corrente del marchio, vengono fatti seguire dal simbolo
  <span class="quote">«<span class="quote">TM</span>»</span> o <span class="quote">«<span class="quote">®</span>»</span>.</p></div></div><div>   di .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Sommario</div><p>Spesso è utile dividere una rete fisica (come una Ethernet)
        in due segmenti separati, senza dover creare sottoreti e usare un router
        per collegarli assieme.  Il dispositivo che collega due reti insieme in
        questo modo è chiamato bridge.  Un sistema FreeBSD con due
        interfacce di rete è sufficiente per raggiungere lo scopo.</p><p>Un bridge funziona individuando gli indirizzi del livello
        <acronym class="acronym">MAC</acronym> (indirizzi Ethernet) dei dispositivi collegati ad
        ognuna delle sue interfacce di rete e inoltrando il traffico tra le due
        reti solo se il mittente e il destinatario si trovano su segmenti
        differenti.  Sotto molti punti di vista un brigde è simile a uno
        switch Ethernet con solo due porte.</p></div></div></div><hr /></div><div class="toc"><div class="toc-title">Indice</div><dl class="toc"><dt><span class="sect1"><a href="#filtering-bridges-why">1. Perché usare un filtering bridge?</a></span></dt><dt><span class="sect1"><a href="#filtering-bridges-how">2. Metodi d'installazione</a></span></dt><dt><span class="sect1"><a href="#filtering-bridges-finalprep">3. Preparativi finali</a></span></dt><dt><span class="sect1"><a href="#filtering-bridges-enabling">4. Attivazione del Bridge</a></span></dt><dt><span class="sect1"><a href="#filtering-bridges-ipfirewall">5. Configurazione del Firewall</a></span></dt><dt><span class="sect1"><a href="#filtering-bridges-contributors">6. Contributi</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-why"></a>1. Perché usare un filtering bridge?</h2></div></div></div><p>Sempre più frequentemente, grazie all'abbassamento dei costi
      delle connessioni a banda larga (xDSL) e a causa della riduzione del
      numero di indirizzi IPv4 disponibili, molte società si ritrovano
      collegate ad Internet 24 ore su 24 e con un numero esiguo (a volte nemmeno
      una potenza di 2) di indirizzi IP.  In situazioni come queste spesso
      è desiderabile avere un firewall che regoli i permessi di ingresso
      e uscita per il traffico da e verso Internet, ma una soluzione basata
      sulle funzionalità di packet filtering dei router può non
      essere applicabile, vuoi per problemi di suddivisione delle sottoreti,
      vuoi perché il router è di proprietà del fornitore di
      accesso (<acronym class="acronym">ISP</acronym>), vuoi perché il router non
      supporta tali funzionalità.  È in questi casi che l'utilizzo
      di un filtering bridge diventa altamente consigliato.</p><p>Un firewall basato su bridge può essere configurato e inserito
      direttamente tra il router xDSL e il vostro hub/switch Ethernet senza
      alcun problema di assegnazione di indirizzi IP.</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">La traduzione italiana di <span class="quote">«<span class="quote">firewall</span>»</span> è
	<span class="quote">«<span class="quote">muro anti incendio</span>»</span>, <span class="emphasis"><em>non</em></span>
	<span class="quote">«<span class="quote">muro di fuoco</span>»</span> come molti pensano.  Nel corso
        dell'articolo, comunque, manterrò i termini tecnici nella loro
        lingua originale in modo da non creare confusione o
        ambiguità.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-how"></a>2. Metodi d'installazione</h2></div></div></div><p>Aggiungere le funzionalità di bridge a una macchina FreeBSD non
      è difficile.  Dalla release 4.5 è possibile caricare tali
      funzionalità come moduli anziché dover ricompilare il
      kernel, semplificando di gran lunga la procedura.  Nelle prossime
      sottosezioni spiegherò entrambi i metodi di installazione.</p><div xmlns="" class="important"><h3 class="admontitle">Importante: </h3><p xmlns="http://www.w3.org/1999/xhtml"><span class="emphasis"><em>Non</em></span> seguite entrambe le istruzioni: le
        procedure sono <span class="emphasis"><em>a esclusione</em></span>.  Scegliete
        l'alternativa che meglio si adatta alle vostre esigenze e
        capacità.</p></div><p>Prima di continuare è necessario assicurarsi di avere almeno
      due schede di rete Ethernet che supportino la modalità promiscua
      sia in ricezione che in trasmissione, difatti devono essere in grado di
      inviare pacchetti Ethernet con qualunque indirizzo, non solo il loro.
      Inoltre, per avere un buon rendimento, le schede dovrebbero essere di
      tipo PCI bus mastering.  Le scelte migliori sono ancora le Intel
      <span class="trademark">EtherExpress</span>&#8482; Pro seguite dalle <span class="trademark">3Com</span>® 3c9xx subito dopo.  Per
      comodità nella configurazione del firewall può essere
      utile avere due schede di marche differenti (che usino drivers
      differenti) in modo da distinguere chiaramente quale interfaccia sia
      collegata al router e quale alla rete interna.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="filtering-bridges-kernel"></a>2.1. Configurazione del Kernel</h3></div></div></div><p>Così avete deciso di utilizzare il più vecchio e
        collaudato metodo di installazione.  Per prima cosa bisogna
	aggiungere le seguenti righe al file di configurazione del
	kernel:</p><pre class="programlisting">options BRIDGE
options IPFIREWALL
options IPFIREWALL_VERBOSE</pre><p>La prima riga serve a compilare il supporto per il bridge, la
        seconda il firewall e la terza le funzioni di logging del firewall.
      </p><p>Adesso è necessario compilare e installare il nuovo kernel.
        Si possono trovare le istruzioni nella sezione <a class="link" href="../../../../doc/it_IT.ISO8859-15/books/handbook/kernelconfig-building.html" target="_top">
        Building and Installing a Custom Kernel</a> dell'handbook.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="filtering-bridges-modules"></a>2.2. Caricamento dei Moduli</h3></div></div></div><p>Se avete deciso di usare il nuovo e più semplice metodo di
        installazione, l'unica cosa da fare è aggiungere la seguente riga
        al file <code class="filename">/boot/loader.conf</code>:</p><pre class="programlisting">bridge_load="YES"</pre><p>In questo modo all'avvio della macchina verrà caricato
        insieme al kernel anche il modulo <code class="filename">bridge.ko</code>.  Non
        è necessario invece aggiungere una riga per il modulo
        <code class="filename">ipfw.ko</code> in quanto verrà caricato in
        automatico dallo script <code class="filename">/etc/rc.network</code> dopo aver
        seguito i passi della prossima sezione.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-finalprep"></a>3. Preparativi finali</h2></div></div></div><p>Prima di riavviare per caricare il nuovo kernel o i moduli richiesti
      (a seconda del metodo che avete scelto in precedenza), bisogna effettuare
      alcune modifiche al file <code class="filename">/etc/rc.conf</code>.  La regola di
      default del firewall è di rifiutare tutti i pacchetti IP.  Per
      iniziare attiviamo il firewall in modalità <code class="option">open</code>,
      in modo da verificare il suo funzionamento senza alcun problema di
      filtraggio pacchetti (nel caso stiate eseguendo questa procedura da
      remoto, tale accorgimento vi consentirà di non rimanere
      erroneamente tagliati fuori dalla rete).
      Inserite queste linee nel file <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">firewall_enable="YES"
firewall_type="open"
firewall_quiet="YES"
firewall_logging="YES"</pre><p>La prima riga serve ad attivare il firewall (e a caricare il modulo
      <code class="filename">ipfw.ko</code> nel caso non fosse già compilato nel
      kernel), la seconda a impostarlo in modalità
      <code class="option">open</code> (come descritto nel file
      <code class="filename">/etc/rc.firewall</code>), la terza a non
      visualizzare il caricamento delle regole e la quarta ad abilitare il
      supporto per il logging.</p><p>Per quanto riguarda la configurazione delle interfacce di rete, il
      metodo più utilizzato è quello di assegnare un IP a solo una
      delle schede di rete, ma il bridge funziona egualmente anche se entrambe o
      nessuna delle interfacce ha IP settati.  In quest'ultimo caso (IP-less) la
      macchina bridge sarà ancora più nascosta in quanto
      inaccessibile dalla rete: per configurarla occorrerà quindi entrare
      da console o tramite una terza interfaccia di rete separata dal bridge.  A
      volte all'avvio della macchina qualche programma richiede di accedere alla
      rete, per esempio per una risoluzione di dominio: in questo caso è
      necessario assegnare un IP all'interfaccia esterna (quella collegata a
      Internet, dove risiede il server <acronym class="acronym">DNS</acronym>), visto che il
      bridge verrà attivato alla fine della procedura di avvio.  Questo
      vuol dire che l'interfaccia <code class="filename">fxp0</code> (nel nostro
      caso) deve essere menzionata nella sezione ifconfig del file
      <code class="filename">/etc/rc.conf</code>, mentre la <code class="filename">xl0</code>
      no.  Assegnare IP a entrambe le schede di rete non ha molto senso, a meno
      che durante la procedura di avvio non si debba accedere a servizi presenti
      su entrambi i segmenti Ethernet.</p><p>C'è un'altra cosa importante da sapere.  Quando si utilizza IP
      sopra Ethernet ci sono due protocolli Ethernet in uso: uno è IP,
      l'altro è <acronym class="acronym">ARP</acronym>.  <acronym class="acronym">ARP</acronym> permette
      la conversione dell'indirizzo IP di una macchina nel suo indirizzo
      Ethernet (livello <acronym class="acronym">MAC</acronym>).  Affinché due macchine
      separate dal bridge riescano a comunicare tra loro è necessario che
      il bridge lasci passare i pacchetti <acronym class="acronym">ARP</acronym>.  Tale
      protocollo non fa parte del livello IP, visto che è presente solo
      con IP sopra Ethernet.  Il firewall di FreeBSD agisce esclusivamente sul
      livello IP e quindi tutti i pacchetti non IP (compreso
      <acronym class="acronym">ARP</acronym>) verranno inoltrati senza essere filtrati, anche se
      il firewall è configurato per non lasciar passare nulla.</p><p>Ora è arrivato il momento di riavviare la macchina e usarla
      come in precedenza: appariranno dei nuovi messaggi riguardo al bridge e al
      firewall, ma il bridge non sarà attivato e il firewall, essendo in
      modalità <code class="option">open</code>, non impedirà nessuna
      operazione.</p><p>Se ci dovessero essere dei problemi, è il caso di scoprire ora
      da cosa derivino e risolverli prima di continuare.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-enabling"></a>4. Attivazione del Bridge</h2></div></div></div><p>A questo punto, per attivare il bridge, bisogna eseguire i seguenti
      comandi (avendo l'accortezza di sostituire i nomi delle due interfacce di
      rete <code class="filename">fxp0</code> e <code class="filename">xl0</code> con i
      propri):</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl net.link.ether.bridge.config=fxp0:0,xl0:0</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sysctl net.link.ether.bridge.ipfw=1</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sysctl net.link.ether.bridge.enable=1</code></strong></pre><p>La prima riga specifica tra quali interfacce va attivato il bridge,
      la seconda abilita il firewall sul bridge ed infine la terza attiva il
      bridge.</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">Se hai FreeBSD 5.1-RELEASE o precedenti le variabili sysctl
        sono chiamate in modo differente.  Guarda <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bridge&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">bridge</span>(4)</span></a> per i
        dettagli.</p></div><p>A questo punto dovrebbe essere possibile inserire la macchina tra
      due gruppi di host senza che venga compromessa qualsiasi
      possibilità di comunicazione tra di loro.  Se è così,
      il prossimo passo è quello di aggiungere le parti
      <code class="literal">net.link.ether.bridge.[blah]=[blah]</code>
      di queste righe al file <code class="filename">/etc/sysctl.conf</code>, in modo che
      vengano eseguite all'avvio della macchina.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-ipfirewall"></a>5. Configurazione del Firewall</h2></div></div></div><p>Ora è arrivato il momento di creare il proprio file con le
      regole per il firewall, in modo da rendere sicura la rete interna.
      Ci sono delle complicazioni nel fare questo, perché non tutte le
      funzionalità del firewall sono disponibili sui pacchetti inoltrati
      dal bridge.  Inoltre, c'è una differenza tra i pacchetti che stanno
      per essere inoltrati dal bridge e quelli indirizzati alla macchina locale.
      In generale, i pacchetti che entrano nel bridge vengono processati dal
      firewall solo una volta, non due come al solito; infatti vengono filtrati
      solo in ingresso, quindi qualsiasi regola che usi <code class="option">out</code>
      oppure <code class="option">xmit</code> non verrà mai eseguita.  Personalmente
      uso <code class="option">in via</code> che è una sintassi più antica,
      ma che ha un senso quando la si legge.
      Un'altra limitazione è che si possono usare solo i comandi
      <code class="option">pass</code> e <code class="option">drop</code> per i pacchetti filtrati
      dal bridge.  Cose avanzate come <code class="option">divert</code>,
      <code class="option">forward</code> o <code class="option">reject</code> non sono disponibili.
      Queste opzioni possono ancora essere usate, ma solo per il traffico da
      e verso la macchina bridge stessa (sempre che le sia stato assegnato
      un IP).</p><p>Nuovo in FreeBSD 4.0 è il concetto di stateful filtering.
      Questo è un grande miglioramento per il traffico
      <acronym class="acronym">UDP</acronym>, che consiste tipicamente di una richiesta in
      uscita, seguita a breve termine da una risposta con la stessa coppia di
      indirizzi IP e numeri di porta (ma con mittente e destinatario invertiti,
      ovviamente).  Per i firewall che non supportano il mantenimento di stato,
      non c'è modo di gestire questo breve scambio di dati come una
      sessione unica.  Ma con un firewall che può
      <span class="quote">«<span class="quote">ricordarsi</span>»</span> di un pacchetto <acronym class="acronym">UDP</acronym> in
      uscita e permette una risposta nei minuti successivi, gestire i
      servizi <acronym class="acronym">UDP</acronym> è semplice.
      L'esempio seguente mostra come fare.  La stessa cosa è
      possibile farla con i pacchetti <acronym class="acronym">TCP</acronym>.  Questo
      permette di evitare qualche tipo di attacco denial of service e altri
      sporchi trucchi, ma tipicamente fa anche crescere velocemente la
      tabella di stato.</p><p>Vediamo un esempio di configurazione.  Bisogna notare che all'inizio
      del file <code class="filename">/etc/rc.firewall</code> ci sono già delle
      regole standard per l'interfaccia di loopback
      <code class="filename">lo0</code>, quindi non ce ne occuperemo più ora.
      Le regole personalizzate andrebbero messe in un file a parte (per esempio
      <code class="filename">/etc/rc.firewall.local</code>) e caricate all'avvio
      modificando la riga del file <code class="filename">/etc/rc.conf</code> dove era
      stata definita la modalità <code class="option">open</code> con:</p><pre class="programlisting">firewall_type="/etc/rc.firewall.local"</pre><div xmlns="" class="important"><h3 class="admontitle">Importante: </h3><p xmlns="http://www.w3.org/1999/xhtml">Bisogna specificare il path <span class="emphasis"><em>completo</em></span>
        del file, altrimenti non verrà caricato con il rischio di
        rimanere tagliati fuori dalla rete.</p></div><p>Per il nostro esempio immaginiamo di avere l'interfaccia
      <code class="filename">fxp0</code> collegata all'esterno (Internet) e la
      <code class="filename">xl0</code> verso l'interno (<acronym class="acronym">LAN</acronym>).
      La macchina bridge ha assegnato l'IP
      <code class="systemitem">1.2.3.4</code>
      (è impossibile che il vostro <acronym class="acronym">ISP</acronym> vi assegni un
      indirizzo simile a questo, ma per l'esempio va bene).</p><pre class="programlisting"># Le connessioni di cui abbiamo mantenuto lo stato vengono fatte passare subito
add check-state

# Esclude le reti locali definite nell'RFC 1918
add drop all from 10.0.0.0/8 to any in via fxp0
add drop all from 172.16.0.0/12 to any in via fxp0
add drop all from 192.168.0.0/16 to any in via fxp0

# Permette alla macchina bridge di connettersi con chi vuole
# (se la macchina è IP-less non includere questi comandi)
add pass tcp from 1.2.3.4 to any setup keep-state
add pass udp from 1.2.3.4 to any keep-state
add pass ip from 1.2.3.4 to any

# Permette agli host della rete interna di connettersi con chi vogliono
add pass tcp from any to any in via xl0 setup keep-state
add pass udp from any to any in via xl0 keep-state
add pass ip from any to any in via xl0

# Sezione TCP
# Permette SSH
add pass tcp from any to any 22 in via fxp0 setup keep-state
# Permette SMTP solo verso il mail server
add pass tcp from any to relay 25 in via fxp0 setup keep-state
# Permette i trasferimenti di zona solo dal name server secondario [dns2.nic.it]
add pass tcp from 193.205.245.8 to ns 53 in via fxp0 setup keep-state
# Lascia passare i controlli ident:
# è meglio che aspettare che vadano in timeout
add pass tcp from any to any 113 in via fxp0 setup keep-state
# Permette connessioni nel range di "quarantena".
add pass tcp from any to any 49152-65535 in via fxp0 setup keep-state

# Sezione UDP
# Permette DNS solo verso il name server
add pass udp from any to ns 53 in via fxp0 keep-state
# Permette connessioni nel range di "quarantena".
add pass udp from any to any 49152-65535 in via fxp0 keep-state

# Sezione ICMP
# Abilita le funzioni di 'ping'
add pass icmp from any to any icmptypes 8 keep-state
# Permette il passaggio dei messaggi di errori del comando 'traceroute'
add pass icmp from any to any icmptypes 3
add pass icmp from any to any icmptypes 11

# Tutto il resto è sospetto
add drop log all from any to any</pre><p>Coloro che hanno configurato un firewall in precedenza potrebbero aver
      notato che manca qualcosa.  In particolare, non ci sono regole contro lo
      spoofing, difatti <span class="emphasis"><em>non</em></span> abbiamo aggiunto:</p><pre class="programlisting">add deny all from 1.2.3.4/8 to any in via fxp0</pre><p>Ovvero, non far entrare dall'esterno pacchetti che affermano di venire
      dalla rete interna.  Questa è una cosa che solitamente viene fatta
      per essere sicuri che qualcuno non provi a eludere il packet filter,
      generando falsi pacchetti che sembrano venire dall'interno.  Il problema
      è che c'è <span class="emphasis"><em>almeno</em></span> un host
      sull'interfaccia esterna che non si può ignorare: il router.
      Solitamente, però, gli <acronym class="acronym">ISP</acronym> eseguono il controllo
      anti-spoof sui loro router e quindi non ce ne dobbiamo preoccupare.</p><p>L'ultima riga sembra un duplicato della regola di default, ovvero non
      far passare nulla che non sia stato specificatamente permesso.  In
      verità c'è una differenza: tutto il traffico sospetto
      verrà loggato.</p><p>Ci sono due regole per permettere il traffico <acronym class="acronym">SMTP</acronym>
      e <acronym class="acronym">DNS</acronym> verso il mail server e il name server, se ne
      avete.  Ovviamente l'intero set di regole deve essere personalizzato
      per le proprie esigenze, questo non è altro che uno specifico
      esempio (il formato delle regole è spiegato dettagliatamente nella
      man page <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a>).  Bisogna notare che, affinché
      <span class="quote">«<span class="quote">relay</span>»</span> e <span class="quote">«<span class="quote">ns</span>»</span>
      siano interpretati correttamente, la risoluzione dei nomi deve funzionare
      <span class="emphasis"><em>prima</em></span> che il bridge sia attivato.  Questo è un
      chiaro esempio che dimostra l'importanza di settare l'IP sulla corretta
      scheda di rete.  In alternativa è possibile specificare
      direttamente l'indirizzo IP anziché il nome host (cosa necessaria
      se la macchina è IP-less).</p><p>Le persone che sono solite configurare un firewall probabilmente
      avranno sempre usato una regola <code class="option">reset</code> o
      <code class="option">forward</code> per i pacchetti
      ident (porta 113 <acronym class="acronym">TCP</acronym>).  Sfortunatamente, questa non
      è una scelta applicabile con il bridge, quindi la cosa migliore
      è lasciarli passare fino alla destinazione.  Finché la
      macchina di destinazione non ha un demone ident attivo, questa tecnica
      è relativamente sicura.  L'alternativa è proibire le
      connessioni sulla porta 113, creando qualche problema con servizi tipo
      <acronym class="acronym">IRC</acronym> (le richieste ident devono andare in
      timeout).</p><p>L'unica altra cosa un po' particolare che potete aver notato è
      che c'è una regola per lasciar comunicare la macchina bridge e
      un'altra per gli host della rete interna.  Ricordate che questo è
      dovuto al fatto che i due tipi di traffico prendono percorsi differenti
      attraverso il kernel e di conseguenza anche dentro il packet filter.  La
      rete interna passerà attraverso il bridge, mentre la macchina
      locale userà il normale stack IP per le connessioni.  Perciò
      due regole per gestire due casi differenti.  Le regole <code class="literal">in via
      fxp0</code> funzionano in entrambi i casi.
      In generale, se usate regole <code class="option">in via</code> attraverso il
      packet filter, dovrete fare un'eccezione per i pacchetti generati
      localmente, in quanto non entrano tramite nessuna interfaccia.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="filtering-bridges-contributors"></a>6. Contributi</h2></div></div></div><p>Alcune parti di questo articolo sono state prese, tradotte e
      adattate da testi sui bridge, appartenenti alla documentazione di FreeBSD
      in lingua inglese, a cura di Nick Sayer e Steve Peterson.</p><p>Un grosso ringraziamento va a Luigi Rizzo per l'implementazione
      delle funzionalità di bridging in FreeBSD e per il tempo che mi ha
      dedicato rispondendo ad alcune mie domande a riguardo.</p></div></div></body></html>