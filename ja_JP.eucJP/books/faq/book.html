<?xml version="1.0" encoding="euc-jp"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="この文書は FreeBSD システム・バージョン 2.X、3.X、4.X についての FAQ です。 特に断わりがない限り、どの項目も FreeBSD 2.0.5 以降のものを想定しています。 &lt;XXX&gt; のついている項目はまだ作業中のものです。 この FreeBSD ドキュメンテーションプロジェクトに協力したいと思われる方は、 FreeBSD documentation project メーリングリスト まで (英語で) 電子メールを送ってください。 この文書の最新バージョンは、いつでも 日本国内版 FreeBSD World Wide Web サーバや FreeBSD World Wide Web サーバで 見ることができます。 また、ひとつの巨大な HTML ファイルとして HTTP でダウンロードすることもできます。 プレーンテキスト、PostScript、PDF、およびその他の形式のものは FreeBSD FTP サーバに置かれています。 また、FAQ の検索も可能です。 2005 年 6 月現在、HTML 版以外の日本語 FAQ は用意されていません。 日本語版の作成は FreeBSD 日本語ドキュメンテーションプロジェクトが オリジナルの英語版をもとにして行なっています。 FreeBSD FAQ 日本語訳および、 FreeBSD FAQ 日本語版のみに関連することは、 日本語ドキュメンテーションプロジェクト doc-jp@jp.FreeBSD.org において日本語で議論されています。 必要に応じて日本語ドキュメンテーションプロジェクトから、 FreeBSD Documentation Project に対してフィードバックを行ないますので、 英語が得意でない方は 日本語ドキュメンテーションプロジェクト doc-jp@jp.FreeBSD.org まで日本語でコメントをお寄せください。 また、この FreeBSD FAQ とは別に、日本の FreeBSD ユーザ有志によって FreeBSD users-jp メーリングリスト FreeBSD-users-jp@jp.FreeBSD.org やニュースグループ fj.os.bsd.freebsd などへの投稿をもとに作成された QandA が公開されています。 特に日本語環境など日本固有の話題が充実していますので、 こちらも合わせてご覧ください。" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="ja" class="book" lang="ja"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp74134608"></a>FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="orgname">FreeBSD ドキュメンテーションプロジェクト</span></h3></div></div><div>改訂: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 1995-2001 FreeBSD ドキュメンテーションプロジェクト</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="legalnotice"></a><p class="legalnotice-title"><strong>Copyright</strong></p><p>Redistribution and use in source (XML DocBook) and 'compiled'
    forms (XML, HTML, PDF, PostScript, RTF and so forth) with or without
    modification, are permitted provided that the following conditions are
    met:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Redistributions of source code (XML DocBook) must retain the
        above copyright notice, this list of conditions and the following
        disclaimer as the first lines of this file unmodified.</p></li><li class="listitem"><p>Redistributions in compiled form (transformed to other DTDs,
        converted to PDF, PostScript, RTF and other formats) must
        reproduce the above copyright notice, this list of conditions and
        the following disclaimer in the documentation and/or other
        materials provided with the distribution.</p></li></ol></div><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION
      PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
      BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
      THE FREEBSD DOCUMENTATION PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
      OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
      TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
      USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
      DAMAGE.</p></div></div></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">概要</div><p>
        この文書は FreeBSD システム・バージョン 2.X、3.X、4.X についての FAQ です。
        特に断わりがない限り、どの項目も FreeBSD 2.0.5 以降のものを想定しています。
        &lt;XXX&gt; のついている項目はまだ作業中のものです。
        この FreeBSD ドキュメンテーションプロジェクトに協力したいと思われる方は、
        <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc" target="_top">FreeBSD documentation project メーリングリスト</a>
        まで (英語で) 電子メールを送ってください。
        この文書の最新バージョンは、いつでも
        <a class="link" href="http://www.jp.FreeBSD.org/" target="_top">日本国内版 FreeBSD World Wide Web サーバ</a>や
        <a class="link" href="http://www.FreeBSD.org/" target="_top">FreeBSD World Wide Web サーバ</a>で
        見ることができます。
        また、ひとつの巨大な <a class="link" href="book.html" target="_top">HTML</a>
        ファイルとして HTTP でダウンロードすることもできます。
        プレーンテキスト、PostScript、PDF、およびその他の形式のものは
        <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/" target="_top">FreeBSD
          FTP サーバ</a>に置かれています。
        また、<a class="link" href="http://www.FreeBSD.org/search/search.html" target="_top">FAQ
          の検索</a>も可能です。</p><p>
        </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">2005 年 6 月現在、HTML 版以外の日本語 FAQ は用意されていません。</p></div><p>
      </p><p>
        日本語版の作成は FreeBSD 日本語ドキュメンテーションプロジェクトが
        オリジナルの英語版をもとにして行なっています。
        FreeBSD FAQ 日本語訳および、 FreeBSD FAQ 日本語版のみに関連することは、
        日本語ドキュメンテーションプロジェクト <code class="email">&lt;<a xmlns="" class="email" href="mailto:doc-jp@jp.FreeBSD.org">doc-jp@jp.FreeBSD.org</a>&gt;</code> において日本語で議論されています。
        必要に応じて日本語ドキュメンテーションプロジェクトから、
        FreeBSD Documentation Project に対してフィードバックを行ないますので、
        英語が得意でない方は
        日本語ドキュメンテーションプロジェクト <code class="email">&lt;<a xmlns="" class="email" href="mailto:doc-jp@jp.FreeBSD.org">doc-jp@jp.FreeBSD.org</a>&gt;</code> まで日本語でコメントをお寄せください。</p><p>また、この FreeBSD FAQ とは別に、日本の FreeBSD ユーザ有志によって
        FreeBSD users-jp メーリングリスト <code class="email">&lt;<a xmlns="" class="email" href="mailto:FreeBSD-users-jp@jp.FreeBSD.org">FreeBSD-users-jp@jp.FreeBSD.org</a>&gt;</code>
        やニュースグループ
        <a class="link" href="news:fj.os.bsd.freebsd" target="_top">fj.os.bsd.freebsd</a>
        などへの投稿をもとに作成された
        <a class="link" href="http://www.jp.FreeBSD.org/QandA/" target="_top">QandA</a>
        が公開されています。
        特に日本語環境など日本固有の話題が充実していますので、
        こちらも合わせてご覧ください。</p></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">分割版</a>
      /
      
	  単一版
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">目次</div><dl class="toc"><dt><span class="preface"><a href="#preface">まえがき</a></span></dt><dt><span class="chapter"><a href="#install">1. インストール</a></span></dt><dt><span class="chapter"><a href="#hardware">2. ハードウェアコンパチビリティ</a></span></dt><dt><span class="chapter"><a href="#troubleshoot">3. トラブルシューティング</a></span></dt><dt><span class="chapter"><a href="#commercial">4. 商用アプリケーション</a></span></dt><dt><span class="chapter"><a href="#applications">5. ユーザアプリケーション</a></span></dt><dt><span class="chapter"><a href="#kernelconfig">6. カーネルコンフィグレーション</a></span></dt><dt><span class="chapter"><a href="#admin">7. システム管理</a></span></dt><dt><span class="chapter"><a href="#x">8. X Window System と仮想コンソール</a></span></dt><dt><span class="chapter"><a href="#networking">9. ネットワーキング</a></span></dt><dt><span class="chapter"><a href="#ppp">10. PPP</a></span></dt><dt><span class="chapter"><a href="#serial">11. シリアル接続</a></span></dt><dt><span class="chapter"><a href="#misc">12. その他の質問</a></span></dt><dt><span class="chapter"><a href="#hackers">13. まじめな FreeBSD ハッカーだけの話題</a></span></dt><dt><span class="chapter"><a href="#acknowledgments">14. 謝辞</a></span></dt><dt><span class="chapter"><a href="#jcontrib">15. FreeBSD FAQ 日本語化について</a></span></dt><dt><span class="bibliography"><a href="#bibliography">有用な書籍</a></span></dt></dl></div><div class="list-of-tables"><div class="toc-title">表の一覧</div><dl><dt>1.1. <a href="#idp75325264">ネットワーク接続用のパラレルケーブルの結線</a></dt><dt>1.2. <a href="#idp75566800">最大ファイルサイズ</a></dt><dt>1.3. <a href="#idp78099408">指定できるセキュリティプロファイル</a></dt></dl></div><div class="list-of-examples"><div class="toc-title">例の一覧</div><dl><dt>8.1. <a href="#idp79879248">moused による変換を利用してホイールマウスを
                      使用するための XFree86 3.3.x 系列の XF86Config の
                      <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</a></dt><dt>8.2. <a href="#idp79880912">自動的なプロトコル認識機能およびボタン配置変換機能を
                      利用し、ホイールマウスを使用するための XFree86 4.x 系列の
                      XF86Config の <span class="quote">「<span class="quote">InputDevice</span>」</span> セクションの設定例</a></dt><dt>8.3. <a href="#idp79882448">ホイールマウスで Emacs 上でのページスクロールを
                      行うための <span class="quote">「<span class="quote">.emacs</span>」</span> の設定例</a></dt><dt>8.4. <a href="#idp79891280">
                      X サーバによる変換を利用してホイールマウスを使用するための
                      XF86Config の <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</a></dt><dt>8.5. <a href="#idp79911376"><span class="application">Imwheel</span> を利用するための
                  <span class="application">Emacs</span> の設定例</a></dt><dt>8.6. <a href="#idp79914448"><span class="application">Imwheel</span> を利用するための
                  <span class="application">XEmacs</span> の設定例</a></dt></dl></div><div class="preface"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="preface"></a>まえがき</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        栗山 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:kuriyama@FreeBSD.org">kuriyama@FreeBSD.org</a>&gt;</code>、
        花井 浩之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:hanai@FreeBSD.org">hanai@FreeBSD.org</a>&gt;</code>、
        中井 幸博 <code class="email">&lt;<a xmlns="" class="email" href="mailto:nakai@mlab.t.u-tokyo.ac.jp">nakai@mlab.t.u-tokyo.ac.jp</a>&gt;</code>、
        今野 元之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:motoyuki@FreeBSD.org">motoyuki@FreeBSD.org</a>&gt;</code>、
        杉村 貴士 <code class="email">&lt;<a xmlns="" class="email" href="mailto:sugimura@jp.FreeBSD.org">sugimura@jp.FreeBSD.org</a>&gt;</code>、
        1997 年 11 月 5 日
      </em></span>
    </p><p>
      FreeBSD 2.X-4.X FAQ へようこそ!
    </p><p>
      Usenet の FAQ がそうであるように、
      この文書も FreeBSD オペレーティングシステムに関して
      頻繁に尋ねられる質問を網羅することを目的としています
      (もちろんそれに対する答えも!)。
      FAQ は本来バンド幅を減らし、
      同じ質問が何度も繰り返されるのを避けるために作られたものですが、
      最近は有用な情報源と見なされるようになってきました。
    </p><p>
      この FAQ をできる限り有用なものにしようと、
      あらゆる努力がはらわれています。
      もし何かしらの改善案が浮かんだら、ぜひ
      FAQ 保守担当者 <code class="email">&lt;<a xmlns="" class="email" href="mailto:faq@FreeBSD.org">faq@FreeBSD.org</a>&gt;</code> までメールを送ってください。
    </p><div class="qandaset"><a id="idp74220496"></a><dl><dt>1. <a href="#idp74221008">FreeBSD って何?</a></dt><dt>2. <a href="#idp74235344">FreeBSD が目指しているもの</a></dt><dt>3. <a href="#idp74252752">どうして FreeBSD と呼ばれているのですか?</a></dt><dt>4. <a href="#idp74267600">FreeBSD の最新バージョンは?</a></dt><dt>5. <a href="#idp74300240">FreeBSD-CURRENTって何?</a></dt><dt>6. <a href="#idp74335568">FreeBSD-STABLE のコンセプトは何ですか?</a></dt><dt>7. <a href="#idp74346576">FreeBSD のリリースはいつ作られるのですか?</a></dt><dt>8. <a href="#idp74354000">FreeBSD は PC 用だけしかないの?</a></dt><dt>9. <a href="#idp74379344">FreeBSD の責任者はいったい誰?</a></dt><dt>10. <a href="#idp74397136">どこから FreeBSD を入手できますか?</a></dt><dt>11. <a href="#idp74476240">FreeBSD のメーリングリストについて知りたいのですが?</a></dt><dt>12. <a href="#idp74483024">FreeBSD のニュースグループは何がありますか?</a></dt><dt>13. <a href="#idp74488656">FreeBSD の IRC
            (Internet Relay Chat) について何か情報はありますか?</a></dt><dt>14. <a href="#idp74527184">FreeBSD の本</a></dt><dt>15. <a href="#idp74574032">障害報告 (PR; Problem Report)
            データベースにアクセスする方法は?</a></dt><dt>16. <a href="#idp74587344">プレインテキスト (ASCII) 版 や
            PostScript 版の FreeBSD 文書はないのでしょうか?</a></dt><dt>17. <a href="#idp74831824">FreeBSD のウェブサイトのミラーサイトになりたいです!</a></dt><dt>18. <a href="#idp74846928">この文書を他の言語に翻訳したいのですが?</a></dt><dt>19. <a href="#idp74865360">その他の情報</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp74221008"></a><a id="what-is-FreeBSD"></a><p><strong>1.</strong></p></td><td align="left" valign="top"><p>FreeBSD って何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD とは一言で言えば、カリフォルニア大学バークレイ校から
            リリースされた <span class="quote">「<span class="quote">4.4BSD-Lite</span>」</span> と <span class="quote">「<span class="quote">4.4BSD-Lite2</span>」</span> による
            強化の一部に由来する、
            i386 および Alpha/AXP 系のプラットフォーム向けの
            UN*X ライクなオペレーティングシステムです。
            間接的には同じバークレイ校の <span class="quote">「<span class="quote">Net/2</span>」</span> を William Jolitz が
            i386 系に移植した <span class="quote">「<span class="quote">386BSD</span>」</span> も基にしていますが、
            386BSD のコードはほとんど残っていません。
            FreeBSD についての詳細と、何ができるかについては
            <a class="link" href="http://www.FreeBSD.org/" target="_top">FreeBSD のホームページ</a>
            を参照してください。
          </p><p>
            FreeBSD は企業やインターネットサービスプロバイダ、研究者、
            コンピュータ専門家、学生、家庭のユーザなどにより、業務や教育、
            娯楽に用いられています。これらに関しては
            <a class="link" href="http://www.FreeBSD.org/gallery/gallery.html" target="_top">FreeBSD ギャラリー</a>をご覧ください。
          </p><p>
            FreeBSD に関するより詳しい情報は
            <a class="link" href="../handbook/index.html" target="_top">FreeBSD
            ハンドブック</a>を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74235344"></a><a id="FreeBSD-goals"></a><p><strong>2.</strong></p></td><td align="left" valign="top"><p>FreeBSD が目指しているもの</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD プロジェクトの目的は、
            いかなる用途にも使用でき、
            何ら制限のないソフトウェアを供給することです。
            私たちの多くは、
            コード (そしてプロジェクト) に対してかなりの投資をしてきており、
            これからも多少の代償はあっても投資を続けて行くつもりです。
            ただ、他の人達にも同じような負担をするように主張しているわけではありません。
            FreeBSD に興味を持っている一人残らずすべての人々に、
            目的を限定しないでコードを提供すること。
            これが、
            私たちの最初のそして最大の「任務」であると信じています。
            そうすれば、コードは可能な限り広く使われ、
            最大の恩恵をもたらすことができるでしょう。
            これが、私たちが熱烈に支持しているフリーソフトウェアの最も基本的な目的であると、
            私は信じています。
          </p><p>
            私たちのソースツリーに含まれるソースのうち、GNU
            一般公有使用許諾 (GPL) または GNU ライブラリ
            一般公有使用許諾 (LGPL) に従っているものについては、
            多少制限が科されています。ただし、
            ソースコードへのアクセスの保証という、
            一般の制限とはいわば逆の制限です。
            ただし GPL ソフトウェアを商用で利用する場合、
            さらに複雑になるのは避けられません。
            そのため、それらのソフトウェアを、より制限の少ない
            BSD 著作権に従ったソフトウェアで置き換える努力を、
            可能な限り日々続けています。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                GPL では、「ソースコードを実際に受け取るか、
                あるいは希望しさえすればそれを入手することが可能であること」を求めています。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74252752"></a><a id="why-called-FreeBSD"></a><p><strong>3.</strong></p></td><td align="left" valign="top"><p>どうして FreeBSD と呼ばれているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>無料 (free) で使うことができる (商利用も含む)。
                </p></li><li class="listitem"><p>オペレーティングシステムの完全なソースコードが自由 (freely) に手に入り、
                  商利用・非商利用にかかわらず、最低限の制限で他の仕事への利用、配布、導入が可能。
                </p></li><li class="listitem"><p>改良やバグフィックスがある場合、
                  誰でも (free) そのコードを提出でき、
                  ソースツリーに加えることができます
                  (いくつかの簡単な条件には従ってもらいます)。</p></li></ul></div><p>
          </p><p>
            母国語が英語でない読者のために、ここでは <span class="quote">「<span class="quote">free</span>」</span>
            という単語が二つの意味で用いられていることを指摘しておくと分かりやすいかも知れません。
            ひとつは「無料である」ということ、
            もうひとつは「自分のやりたいようにできる」ということです。
            FreeBSD のコードで<span class="emphasis"><em>できない</em></span>いくつかのこと
            (自分が書いたものだと偽るなど) を除けば、
            あなたは自分のやりたいことをやることが可能なのです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74267600"></a><a id="latest-version"></a><p><strong>4.</strong></p></td><td align="left" valign="top"><p>FreeBSD の最新バージョンは?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.3-RELEASE/" target="_top">4.3</a>
            が最新の <span class="emphasis"><em>STABLE</em></span> バージョンで、
            2001 年 4 月にリリースされました。
            また、これは最新の <span class="emphasis"><em>RELEASE</em></span>
            バージョンでもあります。
          </p><p>
            簡単に言ってしまうと、<span class="emphasis"><em>-STABLE</em></span>
            は最新の <span class="emphasis"><em>-CURRENT</em></span>
            のスナップショットのすばらしい新機能の数々よりも、
            安定性と変更回数の少なさを好む ISP や、
            他の企業のユーザをターゲットにしています。
            リリースはこの二種類のブランチで行なわれますが、
            (<span class="emphasis"><em>-STABLE</em></span> と比較すると多少)
            不安定な動作があるということを許容できるなら、
            必要となるのは <span class="emphasis"><em>-CURRENT</em></span> の方だけでしょう。
          </p><p>
            各リリースは<a class="link" href="#release-freq" title="7.">
              数カ月毎</a>にしか行なわれません。
            多くの人々が FreeBSD のソースをそのリリースよりも
            最新の状態に維持している
            (<a class="link" href="#current" title="5.">FreeBSD-current</a> と
            <a class="link" href="#stable" title="6.">FreeBSD-stable</a>
            に関する質問も参照してください) のですが、
            ソースというのは常に改変され続けているため、
            そうすることは一種の慣例になっています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74300240"></a><a id="current"></a><p><strong>5.</strong></p></td><td align="left" valign="top"><p>FreeBSD-CURRENTって何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="../handbook/cutting-edge.html#CURRENT" target="_top">FreeBSD-CURRENT</a>
            はオペレーティングシステムの開発バージョンで、
            やがて 5.0-RELEASE となります。よってこれは、そこに携わっている開発者や、
            どんな障害をも乗り越えていけるタフな愛好家たちにとってのみ興味の対象となるものです。
            -CURRENT の使用に際しての詳細は
            <a class="link" href="../handbook/index.html" target="_top">FreeBSD ハンドブック</a>
            の
            <a class="link" href="../handbook/cutting-edge.html#CURRENT" target="_top">関連するセクション</a>
            を参照してください。
          </p><p>
            オペレーティングシステムに馴染みがない場合や、
            それが一時的に発生している問題なのか、
            それとも本質的な問題かを見極める能力がない場合は、
            FreeBSD-CURRENT を使うべきではありません。
            このブランチは時々急激に拡張されたり、
            システムが構築できない状態になることもしょっちゅうあります。
            FreeBSD-CURRENT を使う人は問題を分析し、
            「小さな欠陥」ではなく、
            明らかに間違いであると思われるものだけを報告できるものと想定されています。
            「make world したら group 関係でエラーがでました」のような質問は、
            -CURRENT メーリングリストでは軽蔑の眼差しであしらわれることもあります。
          </p><p>毎日、その時点の -CURRENT と -STABLE のコードを元に
            <a class="link" href="http://www.FreeBSD.org/releases/snapshots.html" target="_top">snapshot</a>
            が作成されています。
            現在は、その snapshot の配布も利用可能です。
            それぞれの snapshot には以下のような目的があります。
          </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>インストールプログラムの最新版のテスト。
                </p></li><li class="listitem"><p>
                  試してみたいけれど、
                  基礎的な所から毎日変わるようなものを追いかける時間もバンド幅も無い、
                  という人にも -CURRENT や -STABLE を使えるようにする。
                  また、そのような人たちのシステム移行のための手っ取り早い方法を提供する。
                </p></li><li class="listitem"><p>
                  あとでとんでもないことをしてしまった時のために、
                  問題となるコードの特定の参照基準点を保存しておく。
                  (通常は CVS がこういうハプニングのような恐ろしい事態を防止して
                  いるんですけどね :)
                </p></li><li class="listitem"><p>
                  テストが必要な新しい機能を、
                  できる限り多くの隠れテスターに試してもらう。</p></li></ul></div><p>
          </p><p>
            どんな目的であれ、-CURRENT snapshot が
            <span class="quote">「<span class="quote">製品レベルの品質</span>」</span>
            であるとの考えに基づく要求は行わないでください。
            安定性やテスト十分性にこだわる人は、
            完全なリリース、あるいは -STABLE snapshot から離れてはいけません。
          </p><p>
            スナップショットリリースは、5.0-CURRENT が
            <a class="link" href="ftp://current.FreeBSD.org/pub/FreeBSD/" target="_top">ftp://current.FreeBSD.org/pub/FreeBSD/</a>
            から、4-STABLE が
            <a class="link" href="ftp://releng4.FreeBSD.org/pub/FreeBSD" target="_top">releng4.FreeBSD.org</a>
            から直接入手可能です。
            また、3-STABLE スナップショットは、
            この文章の執筆時点 (2000 年 5 月)
            で作成されていません。</p><p>スナップショットリリースは、
            現在、開発や保守作業が行なわれているすべてのブランチにおいて、
            平均して一日一回作成されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74335568"></a><a id="stable"></a><p><strong>6.</strong></p></td><td align="left" valign="top"><p>FreeBSD-STABLE のコンセプトは何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.0.5 がリリースされた後、私たちは FreeBSD の開発を
            2 系統に分割することにしました。
            一つは <a class="link" href="../handbook/stable.html" target="_top">-STABLE</a>
            というブランチで、バグの修正はしっかりテストされ、
            機能の強化は少しずつしか行われません
            (急な変更や実験的機能を望まない、
            インターネットサービスプロバイダや営利企業向け)。
            もう一方のブランチは
            <a class="link" href="../handbook/cutting-edge.html#CURRENT" target="_top">-CURRENT</a>
            で、2.0 がリリースされて以来
            5.0-RELEASE (そしてその後も) へ向けて脈々と続いているものです。
            ASCII で描いた簡単な図がわかりやすいかは自信がありませんが、
            こんな感じになります。
          </p><pre class="programlisting">                 2.0
                  |
                  |
                  |  [2.1-STABLE]
 *BRANCH*       2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [2.1-STABLE 終了]
                  |                         (1997/03)
                  |
                  |
                  |  [2.2-STABLE]
 *BRANCH*       2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [終了]
                  |         (1997/03)     (1997/10)   (1998/04)   (1998/07)   (1998/12)
                  |
                  |
               3.0-SNAPs  (1997 年第一四半期開始)
                  |
                  |
               3.0-RELEASE (1998/10)
                  |
                  |  [3.0-STABLE]
 *BRANCH*      3.1-RELEASE  (1999/02) -&gt; 3.2 -&gt; 3.3 -&gt; 3.4 -&gt; 3.5 -&gt; 3.5.1
                  |                   (1999/05) (1999/09) (1999/12) (2000/06) (2000/07)
                  |  [4.0-STABLE]
 *BRANCH*        4.0  (2000/03) -&gt;4.1 -&gt; 4.1.1 -&gt; 4.2 -&gt; 4.3 -&gt; ... 将来の 4.x リリース ...
                  |
                  |             (2000/07)   (2000/09)   (2000/11)
                  |
                 \|/
                  +
          [5.0-CURRENT として継続中]</pre><p>
            -CURRENT ブランチは
            5.0 とその先へ向けてゆっくりと進化を続けています。
            従来あった 2.2-STABLE ブランチは 2.2.8 のリリースをもって終了しました。
            3-STABLE がそれに代わり、2000 年 7 月に
            3.5.1-RELEASE (最後の 3.X リリース)
            がリリースされました。
            2000 年 3 月 (3.5 の公開前になりますが) には、
            3-STABLE ブランチはほぼ、4-STABLE ブランチによって置き換えられました。
            4.3-RELEASE は 2001 年 4 月にリリースされました。
            4-STABLE は現在 -STABLE ブランチで活発に開発が続けられていますが、
            3-STABLE へのバグの修正 (ほとんどがセキュリティ関連のもの)
            もまだ行なわれています。
            3.X ブランチは 2000 年の夏には公式に開発が終了する予定です。
            現在の <span class="quote">「<span class="quote">current branch</span>」</span> は 5.0-CURRENT であり、
            最初の 5.0 系列のリリース予定はまだ決定していません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74346576"></a><a id="release-freq"></a><p><strong>7.</strong></p></td><td align="left" valign="top"><p>FreeBSD のリリースはいつ作られるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD コアチームは原則的に、
            新しい機能やバグフィックスが充分集まり、
            リリースの安定性を損なうことが無いよう、
            さまざまな変更が十分に安定しているという条件を満たしている場合にのみ、
            新しいバージョンの FreeBSD をリリースします。
            たとえこの用心深さが新しい機能が使えるようになることを
            待ち望んでいるユーザを欲求不満にさせるとしても、
            多くのユーザはこのことを FreeBSD
            の最も良い所の一つだと考えています。
          </p><p>リリースの作成は、平均的に言っておよそ 4 ヶ月ごとに行なわれます。</p><p>もう少し刺激が欲しい (あるいは待ち遠しい) 方々向けには、
            毎日バイナリスナップショットが作成されています。
            上記を参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74354000"></a><a id="available-platforms"></a><p><strong>8.</strong></p></td><td align="left" valign="top"><p>FreeBSD は PC 用だけしかないの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 3.x 以降は x86 アーキテクチャと同様、
            <a class="link" href="http://www.FreeBSD.org/alpha/alpha.html" target="_top">DEC Alpha</a> でも動作します。
            また、SPARC、PowerPC、IA64 への移植という興味深い話もあります。
          </p><p>
            異なるアーキテクチャのマシンを
            持っていて、ゆっくり待てないという場合には次の URL を
            参照してください。
          </p><p>
            <a class="link" href="http://www.netbsd.org/" target="_top">NetBSD</a>
            または
            <a class="link" href="http://www.openbsd.org/" target="_top">OpenBSD</a>。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74379344"></a><a id="responsible"></a><p><strong>9.</strong></p></td><td align="left" valign="top"><p>FreeBSD の責任者はいったい誰?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            プロジェクトの全体的な方向性や、
            誰にソースツリーにコードの書き込み権限を与えるか、
            などといった FreeBSD プロジェクトに関する重要な意思決定は、
            9 名からなる<a class="link" href="../handbook/staff.html#STAFF-CORE" target="_top">コアチーム
              (core team)</a> によってなされます。
            ソースツリーを直接変更できる人はもっと多く、
            200 名以上の<a class="link" href="../handbook/staff:committers.html" target="_top">ソースツリー管理者
              (committer)</a> がいます。
          </p><p>
            しかし、<a class="link" href="#mailing" title="11.">メーリングリスト</a>で先行して議論される、
            通常の変更ではないものの議論への参加には、一切制限はありません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74397136"></a><a id="where-get"></a><p><strong>10.</strong></p></td><td align="left" valign="top"><p>どこから FreeBSD を入手できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD のすべての主要なリリースは anonymous FTP 経由で
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/" target="_top">FreeBSD FTP サイト</a>
            から入手できます。
          </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  現在の 3.X-STABLE リリース、3.5.1-RELEASE は
                  <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.5.1-RELEASE/" target="_top">3.5.1-RELEASE のディレクトリ</a>にあります。
                </p></li><li class="listitem"><p>現在の 4-STABLE リリース、4.3-RELEASE は
                  <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.3-RELEASE/" target="_top">4.3-RELEASE のディレクトリ</a>にあります。</p></li><li class="listitem"><p>
                  <a class="link" href="ftp://releng4.FreeBSD.org/pub/FreeBSD/" target="_top">4.X
                    Snapshot</a> は、ほぼ一日に一回作成されています。
                </p></li><li class="listitem"><p><a class="link" href="ftp://current.FreeBSD.org/pub/FreeBSD/" target="_top">5.0 Snapshot</a>
                  リリースは <a class="link" href="#current" title="5.">-CURRENT</a>
                  ブランチ用に一日に一回作成されており、
                  これらは純粋に最先端の開発者およびテスターのために提供されています。
                </p></li></ul></div><p>
          </p><p>また、FreeBSD は CD-ROM でも入手でき、次のところで注文できます。</p><div class="address"><p>BSDi<br />
〓〓〓〓〓〓〓〓〓〓<span class="street">4041〓Pike〓Lane,〓Suite〓F</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="city">Concord</span>,〓<span class="state">CA</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="postcode">94520</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="country">USA</span><br />
<br />
〓〓〓〓〓〓〓〓〓〓<span class="phone">Orders:〓〓〓〓〓〓〓+1〓800〓786-9907</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="phone">Questions:〓〓〓〓+1〓925〓674-0783</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="fax">FAX:〓〓〓〓〓〓〓〓〓〓〓〓+1〓925〓674-0821</span><br />
〓〓〓〓〓〓〓〓〓〓email:〓〓〓〓<a class="link" href="mailto:orders@osd.bsdi.com" target="_top">BSDi〓Orders〓address</a><br />
〓〓〓〓〓〓〓〓〓〓WWW:〓〓〓〓〓〓<a class="link" href="http://www.osd.bsdi.com/" target="_top">BSDi〓Home〓page</a><span class="phone">Orders:〓〓+1〓800〓786-9907</span></p></div><p>オーストラリアでは、次のところに問い合わせてください。</p><div class="address"><p>Advanced〓Multimedia〓Distributors<br />
〓〓〓〓〓〓〓〓〓〓<span class="street">Factory〓1/1〓Ovata〓Drive</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="city">Tullamarine,〓Melbourne</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="state">Victoria</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="country">Australia</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="phone">Voice:〓〓〓〓〓〓〓〓+61〓3〓9338〓6777</span><br />
<br />
〓〓〓〓〓〓〓〓〓〓CDROM〓Support〓BBS<br />
〓〓〓〓〓〓〓〓〓〓<span class="street">17〓Irvine〓St</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="city">Peppermint〓Grove</span>,〓<span class="state">WA</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="postcode">6011</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="phone">Voice:〓〓〓〓〓〓〓〓+61〓9〓385-3793</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="fax">Fax:〓〓〓〓〓〓〓〓〓〓〓〓+61〓9〓385-2360</span></p></div><p>イギリスの場合は次のところです。</p><div class="address"><p>The〓Public〓Domain〓&amp;〓Shareware〓Library<br />
〓〓〓〓〓〓〓〓〓〓<span class="street">Winscombe〓House,〓Beacon〓Rd</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="city">Crowborough</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="state">Sussex.〓TN6〓1UL</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="phone">Voice:〓〓〓〓〓〓〓〓+44〓1892〓663-298</span><br />
〓〓〓〓〓〓〓〓〓〓<span class="fax">Fax:〓〓〓〓〓〓〓〓〓〓〓〓+44〓1892〓667-473</span></p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74476240"></a><a id="mailing"></a><p><strong>11.</strong></p></td><td align="left" valign="top"><p>FreeBSD のメーリングリストについて知りたいのですが?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            完全な情報が
            <a class="link" href="../handbook/eresources.html#ERESOURCES-MAIL" target="_top">FreeBSD
              ハンドブックのメーリングリストの節</a>
            にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74483024"></a><a id="newsgroups"></a><p><strong>12.</strong></p></td><td align="left" valign="top"><p>FreeBSD のニュースグループは何がありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>完全な情報が
            <a class="link" href="../handbook/eresources-news.html" target="_top">FreeBSD
              ハンドブックのニュースグループの節</a>にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74488656"></a><a id="irc"></a><p><strong>13.</strong></p></td><td align="left" valign="top"><p>FreeBSD の IRC
            (Internet Relay Chat) について何か情報はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            あります。
            以下のように、ほとんどの有名な IRC ネットワークには
            FreeBSD のチャットチャンネルがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>EFNet の Channel <code class="literal">#FreeBSD</code> は
                FreeBSD 関係のフォーラムですが、
                そこで技術的サポートを期待してはいけません。
                そこにいる人たちはあなたをマニュアルページを読むとか、
                研究をするとかといった苦労から遠ざけようとします。
                まず第一に、これはチャットチャンネルであり、
                そこにあるトピックスは恋人募集、スポーツ、
                核兵器といったようなものであり、
                FreeBSD も同列に扱われています。
                一応注意しましたからね! これは
                <code class="systemitem">irc.chat.org</code> のサーバー上にあります。
              </p></li><li class="listitem"><p>EFNet の Channel <span class="emphasis"><em>#FreeBSDhelp</em></span> は
                FreeBSD ユーザのヘルプ専用チャネルです。
                参加者は <span class="emphasis"><em>#FreeBSD</em></span>
                チャネルよりも親切に質問に答えてくれます。</p></li><li class="listitem"><p>DALNET の Channel <code class="literal">#FreeBSD</code>
                はアメリカでは
                <code class="systemitem">irc.dal.net</code>、
                ヨーロッパでは
                <code class="systemitem">irc.eu.dal.net</code>
                にあります。
              </p></li><li class="listitem"><p>UNDERNET の Channel <code class="literal">#FreeBSD</code>
                はアメリカでは
                <code class="systemitem">us.undernet.org</code>、
                ヨーロッパでは <code class="systemitem">eu.undernet.org</code>
                にあります。
                ここはヘルプチャンネルです。
                ドキュメントを読める準備をしてから利用してください。
              </p></li><li class="listitem"><p><a class="link" href="http://www.hybnet.net/" target="_top">HybNet</a> の
                Channel <code class="literal">#FreeBSD</code>。
                このチャンネルはへルプチャンネル<span class="emphasis"><em>です</em></span>。
                サーバーのリストは <a class="link" href="http://www.hybnet.net/" target="_top">HybNet のウェブサイト</a>
                にあります。
              </p></li></ul></div><p>それぞれのチャンネルは別個のもので、
            互いに接続されていません。
            チャットのスタイルも違っていますので、
            自分のチャットのスタイルにあったものを見つけるために一つ一つ試すのもいいでしょう。
            あらゆる種類の IRC トラフィックのため、失礼なことをいう若者たち
            (年輩の方は少数です) のために機嫌を損ねたり、
            手に負えなくなっても気にしてはいけません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74527184"></a><a id="books"></a><p><strong>14.</strong></p></td><td align="left" valign="top"><p>FreeBSD の本</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc" target="_top">FreeBSD documentation project メーリングリスト</a> にコンタクトしてみてください
            (さらに参加すればもっとよいでしょう)。
            このメーリングリストは FreeBSD 関連の文書に関する議論のためのものです。
            FreeBSD に関する質問に対しては、
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions" target="_top">FreeBSD general questions メーリングリスト</a>
            というメーリングリストがあります。
          </p><p><a class="link" href="../handbook/index.html" target="_top">FreeBSD
              ハンドブック</a>もあります。
            これは現在作業中で、
            不完全だったり最新情報でないものが含まれていることに注意してください。</p><p>
            FreeBSD のガイド本の決定版は、
            Greg Lehey 氏による <span class="quote">「<span class="quote">The Complete FreeBSD</span>」</span> です。
            これは BSDi (以前の Walnut Creek CDROM) Books
            から出版されています。
            現在は第三版になっていて、
            インストール、システム管理ガイド、プログラム設定のヘルプ、
            マニュアルページまでの内容が 773
            ページにわたって書かれています。
            この本は (そして現在の FreeBSD リリースは)
            <a class="link" href="http://www.osd.bsdi.com/" target="_top">BSDi</a>、
            <a class="link" href="http://www.cheapbytes.com/" target="_top">CheapBytes</a>、
            または最寄りの書店で注文することができます。
            ISBN コードは 1-57176-246-9 です
            (これ以外のコードの場合もあるかもしれません)。</p><p>
            また、FreeBSD は Berkeley 4.4BSD-Lite
            ベースなので、多くの 4.4BSD のマニュアルが
            FreeBSD にも応用できます。
            O'Reilly and Associates
            が以下のマニュアルを出版しています。
          </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="#biblio-44sysman">[biblio-44sysman]</a></p></li><li class="listitem"><p><a class="xref" href="#biblio-44userman">[biblio-44userman]</a></p></li><li class="listitem"><p><a class="xref" href="#biblio-44suppman">[biblio-44suppman]</a></p></li><li class="listitem"><p><a class="xref" href="#biblio-44progman">[biblio-44progman]</a></p></li><li class="listitem"><p><a class="xref" href="#biblio-44progsupp">[biblio-44progsupp]</a></p></li></ul></div><p>
          </p><p>
            これらの詳細な説明が WWW 経由で
            <a class="link" href="http://gnn.com/gnn/bus/ora/category/bsd.html" target="_top">4.4BSD
              books description</a>
            から読むことができます。
            販売数が少ないためこれらのマニュアルは入手しにくいかもしれません。
          </p><p>
            4.4BSD のカーネル構成についてより徹底的に知りたいのなら、
            <a class="xref" href="#biblio-44kernel">[biblio-44kernel]</a> なら間違いないでしょう。</p><p>システム管理についての良書が <a class="xref" href="#biblio-nemeth3rd">[biblio-nemeth3rd]</a> です。</p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">初版ではなく、紫色のカバーの第三版であるか確認してくだ
            さい。</p></div><p>
            この本は TCP/IP だけでなく DNS、NFS、SLIP/PPP、sendmail、
            INN/NNTP、印刷などの基礎を扱っています。
            高価ですが、買う価値はあります。
            第三版では、Solaris, HP/UX, FreeBSD および Linux を取り扱っています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74574032"></a><a id="access-pr"></a><p><strong>15.</strong></p></td><td align="left" valign="top"><p>障害報告 (PR; Problem Report)
            データベースにアクセスする方法は?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ユーザからの変更要求がまとめられている
            Problem Report データベースは、
            障害報告の web ベースのインタフェースを通して、
            <a class="link" href="http://www.FreeBSD.org/ja/send-pr.html" target="_top">提出</a>と<a class="link" href="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query" target="_top">問い合わせ</a>を行なうことができます。
            また、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=send-pr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">send-pr</span>(1)</span></a> コマンドを使用して、
            電子メール経由で障害報告や変更要求を提出することもできます。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74587344"></a><a id="doc-formats"></a><p><strong>16.</strong></p></td><td align="left" valign="top"><p>プレインテキスト (ASCII) 版 や
            PostScript 版の FreeBSD 文書はないのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>はい、もちろんあります。
            数多くの異なるフォーマット、圧縮形式の文書が FreeBSD FTP サイトの
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/" target="_top">/pub/FreeBSD/doc/</a>
            というディレクトリから入手可能です。</p><p>文書は、次のようなさまざまな観点から分類されています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">faq</code> や <code class="literal">handbook</code>
                といった文書名による分類。</p></li><li class="listitem"><p>文書の言語とエンコーディングによる分類。これは
                FreeBSD システムの <code class="filename">/usr/share/locale</code>
                にある locale 名に基づいています。
                現在利用可能な言語、エンコーディングは以下のとおりです。</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>名前</th><th>意味</th></tr></thead><tbody><tr><td><code class="literal">en_US.ISO8859-1</code></td><td>英語 (米国)</td></tr><tr><td><code class="literal">de_DE.ISO_8859-1</code></td><td>ドイツ語</td></tr><tr><td><code class="literal">es_ES.ISO8859-1</code></td><td>スペイン語</td></tr><tr><td><code class="literal">fr_FR.ISO8859-1</code></td><td>フランス語</td></tr><tr><td><code class="literal">ja_JP.eucJP</code></td><td>日本語 (EUC エンコーディング)</td></tr><tr><td><code class="literal">ru_RU.KOI8-R</code></td><td>ロシア語 (KOI8-R エンコーディング)</td></tr><tr><td><code class="literal">zh_TW.Big5</code></td><td>中国語 (Big5 エンコーディング)</td></tr></tbody></table></div><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">言語によっては準備されていない文書も存在します。</p></div></li><li class="listitem"><p>文書の形式による分類。
                文書は数多くの異なる出力形式を用意し、
                可能な限り柔軟な対応ができるようにしています。
                現在、利用可能な文書形式は以下のとおりです。</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>文書形式</th><th>意味</th></tr></thead><tbody><tr><td><code class="literal">html-split</code></td><td>サイズの小さい、
                        リンクされた複数の HTML ファイル</td></tr><tr><td><code class="literal">html</code></td><td>文書全体を含んだ、単一の大きなファイル</td></tr><tr><td><code class="literal">pdb</code></td><td><a class="link" href="http://www.iSilo.com/" target="_top">iSilo</a> で利用可能な
                        Palm Pilot データベース形式
                      </td></tr><tr><td><code class="literal">pdf</code></td><td>Adobe 社の PDF (Portable Document Format) 形式</td></tr><tr><td><code class="literal">ps</code></td><td>Postscript 形式</td></tr><tr><td><code class="literal">rtf</code></td><td>Microsoft 社のリッチテキスト形式<a href="#ftn.idp74698192" class="footnote" id="idp74698192"><sup class="footnote">[a]</sup></a>
                      </td></tr><tr><td><code class="literal">txt</code></td><td>プレインテキスト形式</td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idp74698192" class="footnote"><p><a href="#idp74698192" class="para"><sup class="para">[a] </sup></a>この形式を Word で読み込んだ場合、
                            ページ番号は自動的に更新されません。
                            ページ番号を更新するには文書を読み込んでから
                            <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>A</strong></span>、
                            <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>END</strong></span>、
                            <span class="keycap"><strong>F9</strong></span> を押してください。</p></div></td></tr></tbody></table></div></li><li class="listitem"><p>圧縮と package 形式による分類。
                現在利用されているのは次の 3 種類です。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="literal">html-split</code> 形式の場合、
                    ファイルはまず、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> を使ってまとめられ、
                    まとめられた <code class="filename">.tar</code>
                    ファイルは次に解説する方式で圧縮されます。</p></li><li class="listitem"><p>その他の形式の場合、ファイルは
                    <code class="filename">book.format</code>
                    (たとえば <code class="filename">book.pdb</code>、
                    <code class="filename">book.html</code> など)
                    という単一のファイルです。</p><p>上にあげたファイルは
                    3 種類の方式のいずれかで圧縮されます。</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>方式</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">zip</code></td><td>Zip 形式。
                            FreeBSD で圧縮を元に戻すには、まず
                            <code class="filename">archivers/unzip</code> の port
                            をインストールする必要があります。</td></tr><tr><td><code class="literal">gz</code></td><td>GNU Zip 形式。圧縮を元に戻すには、
                            FreeBSD に含まれる <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gunzip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gunzip</span>(1)</span></a> を使います。</td></tr><tr><td><code class="literal">bz2</code></td><td>BZip2 形式。
                            他の形式に比べて普及していませんが、
                            一般的にファイルサイズが小さくなります。
                            圧縮を元に戻すには、
                            <code class="filename">archivers/bzip2</code> port
                            をインストールしてください。</td></tr></tbody></table></div><p>Postscript 版のハンドブックが BZip2
                    形式で圧縮されている場合、ファイル名は
                    <code class="filename">handbook/</code> ディレクトリの中の
                    <code class="filename">book.xml.bz2</code> になります。</p></li><li class="listitem"><p>さまざまな形式に整形された文書は、以下に述べるように
                    FreeBSD の package としても提供されています。</p></li></ol></div></li></ul></div><p>ダウンロードする文書と圧縮形式を選択したら、
            文書を FreeBSD <span class="emphasis"><em>package</em></span>
            としてダウンロードするかどうか決めなければなりません。</p><p>package としてダウンロードしてインストールする場合には、
            文書を <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pkg_add&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pkg_add</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pkg_delete</span>(1)</span></a>
            といった、普通の FreeBSD package
            管理システムを用いた管理が可能であるという利点があります。</p><p>文書の package をダウンロードしてインストールすることに決めたら、
            まずはダウンロードするファイル名を知る必要があります。
            文書の package は、<code class="filename">packages</code>
            というディレクトリに置かれています。
            そしてそれぞれの package ファイルは、
            <code class="filename">文書名.言語.エンコーディング.形式.tgz</code>
            というような名前になっています。</p><p>たとえば、FAQ の英語版で PDF 形式のものは、
            <code class="filename">faq.en_US.ISO8859-1.pdf.tgz</code>
            というファイル名です。</p><p>ファイル名がわかったら、
            次のようなコマンドで英語版の PDF 形式 FAQ の package
            をインストールすることができます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pkg_add ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/packages/faq.en_US.ISO8859-1.pdf.tgz</code></strong></pre><p>インストールの終了後は
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pkg_info&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pkg_info</span>(1)</span></a> を使い、
            ファイルがどこにインストールされたかを調べることができます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pkg_info -f faq.en_US.ISO8859-1.pdf</code></strong>
Information for faq.en_US.ISO8859-1.pdf:

Packing list:
        Package name: faq.en_US.ISO8859-1.pdf
        CWD to /usr/share/doc/en_US.ISO8859-1/books/faq
File: book.pdf
        CWD to .
File: +COMMENT (ignored)
File: +DESC (ignored)</pre><p>ご覧になるとわかるとおり、<code class="filename">book.pdf</code> は
            <code class="filename">/usr/share/doc/en_US.ISO8859-1/books/faq</code>
            にインストールされます。</p><p>package を利用しない場合は、
            自分で圧縮されたファイルをダウンロードして元に戻し、
            適切な場所にそれをコピーする必要があります。
          </p><p>たとえば、分割された HTML 版の FAQ で、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gzip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gzip</span>(1)</span></a> で圧縮されているものは
            <code class="filename">en_US.ISO8859-1/books/faq/book.html-split.tar.gz</code>
            というファイルです。
            これをダウンロードして圧縮を元に戻すには、次のようにする必要があるでしょう。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>fetch ftp://ftp.freebsd.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.gz</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>gzip -d book.html-split.tar.gz</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>tar xvf book.html-split.tar</code></strong></pre><p>こうすると、複数の <code class="filename">.html</code>
            ファイルが作成されます。 中心となっているのは
            <code class="filename">index.html</code> という名前のファイルで、
            目次や前書き、文書の他の部分へのリンクが含まれています。
            これらのファイルは、必要に応じて他の場所にコピーしても構いません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74831824"></a><a id="become-web-mirror"></a><p><strong>17.</strong></p></td><td align="left" valign="top"><p>FreeBSD のウェブサイトのミラーサイトになりたいです!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>承知しました!
            ウェブページをミラーするにはいくつかの手段があります。</p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="application">CVSup</span> を使います。
                  <span class="application">CVSup</span> を使って
                  <span class="application">CVSup</span> サーバに接続することで、
                  整形されたファイルを取ってくることができます。</p><p>ウェブページを取得する場合は、
                <code class="filename">/usr/share/examples/cvsup/www-supfile</code>
                にある supfile の例を参考にしてください。</p></li><li class="listitem"><p>
                  FTP を使ってミラーリングします。
                  あなたの好きな FTP ミラーリングツールを使って、
                  FTP サーバに置いてある web
                  サイトのコピーをダウンロードすることができます。
                  タウンロードは単純に ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-CURRENT/www
                  から始めてください。</p></li></ul></div><p>
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74846928"></a><a id="translation"></a><p><strong>18.</strong></p></td><td align="left" valign="top"><p>この文書を他の言語に翻訳したいのですが?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            報酬は支払えませんが、
            文書の翻訳を提出してくださる方には、
            フリーの CD、T シャツの手配や、
            ハンドブックにある貢献者一覧への登録を行ないたいと思います。
            翻訳作業をはじめる前に、
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc" target="_top">FreeBSD documentation project メーリングリスト</a>
            へ連絡するようにお願いします。
            翻訳作業を手伝うという人が現われるかも知れませんし。
            既に翻訳チームがあって、あなたの参加を歓迎してくれるかも知れません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74865360"></a><a id="other-info-sources"></a><p><strong>19.</strong></p></td><td align="left" valign="top"><p>その他の情報</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            以下のニュースグループには FreeBSD
            ユーザに直接関係のある議論が行われてます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="news:comp.unix.bsd.freebsd.announce" target="_top">comp.unix.bsd.freebsd.announce</a> (moderated)</p></li><li class="listitem"><p><a class="link" href="news:comp.unix.bsd.freebsd.misc" target="_top">comp.unix.bsd.freebsd.misc</a></p></li><li class="listitem"><p><a class="link" href="news:comp.unix.bsd.misc" target="_top">comp.unix.bsd.misc</a></p></li></ul></div><p>Web 上のリソース:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.FreeBSD.org/" target="_top">FreeBSD のホームページ</a></p></li><li class="listitem"><p><a id="pao"></a>
                ラップトップ PC を持っている方は、
                迷うことなく日本の<a class="link" href="http://www.jp.FreeBSD.org/PAO/" target="_top">細川 達己氏の
                  Mobile Computing のページ</a> を見ましょう。
              </p></li><li class="listitem"><p><a id="smp"></a>
                SMP (Symmetric MultiProcessing) に関する情報は、
                <a class="link" href="http://people.FreeBSD.org/~fsmp/SMP/SMP.html" target="_top">SMP
                  サポートページ</a>をご覧ください。
              </p></li><li class="listitem"><p><a id="multimedia"></a>
                FreeBSD のマルチメディアアプリケーションに関する情報は、
                <a class="link" href="http://people.FreeBSD.org/~faulkner/multimedia/mm.html" target="_top">マルチメディア</a>のページをご覧ください。
                特に
                <a class="link" href="http://people.FreeBSD.org/~ahasty/Bt848.html" target="_top">Bt848</a>
                ビデオキャプチャチップに興味のある方は、
                リンクをたどってみてください。
              </p></li></ul></div><p>FreeBSD ハンドブックには、
            実に完成された<a class="link" href="../handbook/bibliography.html" target="_top">参考図書</a>の一覧があり、
            買うべき本をさがしている方は読む価値があります。
          </p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="install"></a>第1章 インストール</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@FreeBSD.org">iwasaki@FreeBSD.org</a>&gt;</code>、
        むらたしゅういちろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:mrt@mickey.ai.kyutech.ac.jp">mrt@mickey.ai.kyutech.ac.jp</a>&gt;</code>、
        1997 年 11 月 8 日</em></span>
    </p><div class="qandaset"><a id="idp74918352"></a><dl><dt>1.1. <a href="#idp74919120">FreeBSD を入手するには、どのファイルをダウンロードすれば良いのでしょうか?</a></dt><dt>1.2. <a href="#idp74956240">ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい!</a></dt><dt>1.3. <a href="#idp74997200">FreeBSD のインストールについての説明書はどこにありますか?</a></dt><dt>1.4. <a href="#idp75003856">FreeBSD を動作させるには何が必要ですか?</a></dt><dt>1.5. <a href="#idp75009616">4MB しかメモリがないのですが、インストールできますか?</a></dt><dt>1.6. <a href="#idp75031376">自分用のインストールフロッピーを作るには?</a></dt><dt>1.7. <a href="#idp75038800">同じマシンで Windows 95/98 と共存できますか?</a></dt><dt>1.8. <a href="#idp75044304">Windows 95/98 がブートマネージャを潰しちゃった! どうやって戻すの?</a></dt><dt>1.9. <a href="#idp75086800">
            IBM Thinkpad の A、T、X シリーズのいずれかを持っています。
            FreeBSD をインストールしたら起動しなくなってしまいました。
            どうすればいいですか?
          </a></dt><dt>1.10. <a href="#idp75199952">不良ブロックのあるディスクにインストールできますか?</a></dt><dt>1.11. <a href="#idp75212496">インストーラから起動したら変なことになりました!</a></dt><dt>1.12. <a href="#idp75237584">ATAPI CD-ROM から起動したのですが、
            インストールプログラムは CD-ROM が見つかりませんと言ってきます。
            CD-ROM はどこに行ってしまったのでしょうか?</a></dt><dt>1.13. <a href="#idp75246800">あれれ? テープからインストールできません!</a></dt><dt>1.14. <a href="#idp75251664">PLIP 経由で二つ FreeBSD box を接続したいのですが</a></dt><dt>1.15. <a href="#idp75320656">ラップトップ PC に PLIP 経由でインストールできますか?</a></dt><dt>1.16. <a href="#idp75409616">ハードディスクドライブには、
            どのジオメトリを使うべきでしょうか?</a></dt><dt>1.17. <a href="#idp75426384">ディスクの分割の仕方で何か制限はありますか?</a></dt><dt>1.18. <a href="#idp75432016">大容量ディスクを持っていますが、ディスクマネージャは使えますか?</a></dt><dt>1.19. <a href="#idp75446992">FreeBSD の起動時に
            Missing Operating System
            と表示されます</a></dt><dt>1.20. <a href="#idp75454672">ブートマネージャの F? プロンプトが表示されません。</a></dt><dt>1.21. <a href="#idp75461200">ソースを全部インストールする必要はありますか?</a></dt><dt>1.22. <a href="#idp75473104">カーネルは必ず作り直さなくちゃならないんですか?</a></dt><dt>1.23. <a href="#idp75491664">DES と MD5、どちらのパスワードを使うべきなのでしょうか?
            また、ユーザがどちらを使うことになるか指定する方法はありますか?</a></dt><dt>1.24. <a href="#idp75504976">ブートフロッピーで起動すると、
            Probing Devices...
            の画面でハングアップします。</a></dt><dt>1.25. <a href="#idp75510992">インストール終了後にシステムを再起動すると、
            panic: cant mount root
            のエラーとなります。</a></dt><dt>1.26. <a href="#idp75555408">メモリの大きさの制限は?</a></dt><dt>1.27. <a href="#idp75561296">ffs ファイルシステムの大きさの制限は?</a></dt><dt>1.28. <a href="#idp75614800">フロッピーに 1 TB のファイルを格納するには?</a></dt><dt>1.29. <a href="#idp78074832">新しいカーネルをコンパイルしたら、起動時に
            archsw.readin.failed
            というエラーメッセージが表示されるようになってしまいました。</a></dt><dt>1.30. <a href="#idp78077648">3.X から 4.X にアップグレードするにはどうしたら良いのですか?</a></dt><dt>1.31. <a href="#idp78082256">「セキュリティプロファイル」
            (「security profiles」) とは何ですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp74919120"></a><a id="floppy-download"></a><p><strong>1.1.</strong></p></td><td align="left" valign="top"><p>FreeBSD を入手するには、どのファイルをダウンロードすれば良いのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 3.1-RELEASE 以前では、
            インストールの際に必要なのは
            <code class="filename">floppies/boot.flp</code> と名前のついた
            一つのフロッピーディスクイメージだけでした。
            しかし FreeBSD 3.1-RELEASE 以降、
            幅広い種類のハードウェアサポートが基本システムに追加され、
            そのサポートが必要とする容量を補うため、
            3.X と 4.X の系列では新たに、
            <code class="filename">floppies/kernel.flp</code>
            および
            <code class="filename">floppies/mfsroot.flp</code>
            という、二つのフロッピーディスクイメージを使うようになりました。
            これらのイメージをフロッピーディスクに書き込むには、
            <code class="command">fdimage</code> や
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">dd</span>(1)</span></a> といったツールが必要となります。
          </p><p>
            (DOS ファイルシステムからのインストールなどで)
            あなた自身が手動で配布ファイルをダウンロードする場合には、
            以下の配布ファイルをダウンロードすることをおすすめします。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">bin/</code></p></li><li class="listitem"><p><code class="filename">manpages/</code></p></li><li class="listitem"><p><code class="filename">compat*/</code></p></li><li class="listitem"><p><code class="filename">doc/</code></p></li><li class="listitem"><p><code class="filename">src/ssys.*</code></p></li></ul></div><p>
            この手順の完全な説明と、一般的なインストール時の問題については
            <a class="link" href="../handbook/install.html" target="_top">FreeBSD
              ハンドブックのインストールの節</a>
            を参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74956240"></a><a id="floppy-image-too-large"></a><p><strong>1.2.</strong></p></td><td align="left" valign="top"><p>ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            3.5 インチ (1.44MB) のフロッピーディスクには、
            1474560 バイトのデータを格納できます。
            ブートイメージはちょうど 1474560 バイトの大きさです。
          </p><p>ブートフロッピーディスクを準備する際のよくある間違いには、
            以下のものがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><acronym class="acronym">FTP</acronym>
                によってフロッピーイメージをダウンロードする際に、
                <span class="emphasis"><em>バイナリ (binary)</em></span> モードにしていなかった。
              </p><p>FTP クライアントの中には、
                転送モードのデフォルトを<span class="emphasis"><em>アスキー (ascii)</em></span> モードにして、
                クライアント側システムの慣習にあうよう、
                すべての行末の文字を変更するものがあります。
                この場合は常に、ブートイメージが壊れたものになります。
                ダウンロードしたブートイメージのサイズをチェックしてください。
                サーバ上のものと<span class="emphasis"><em>正確に</em></span>一致しなければ、
                ダウンロードの処理を疑いましょう。
              </p><p>これを回避するには、
                サーバに接続してイメージのダウンロードを開始する前に
                FTP のコマンドプロンプトで
                <code class="command">binary</code> とタイプします。
              </p></li><li class="listitem"><p>ブートイメージを
                DOS の <code class="command">copy</code> コマンド
                (または GUI の同等のツール) でフロッピーディスクへ転送した。
              </p><p><code class="command">copy</code>
                のようなプログラムは、
                直接起動するように作成されたブートイメージをうまく処理できません。
                イメージにはフロッピーディスクの完全な中身がトラック単位で格納されており、
                フロッピーディスク上に通常のファイルとして
                格納されるように想定されているわけではありません。
                <a class="link" href="../handbook/install.html" target="_top">FreeBSD
                  のインストール</a>に記述されているように、
                低レベルのツール (たとえば
                <code class="command">fdimage</code> や
                <code class="command">rawrite</code>) を使用して
                <span class="quote">「<span class="quote">そのままの (raw)</span>」</span> の状態でフロッピーディスクに
                転送する必要があります。
              </p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp74997200"></a><a id="install-instructions-location"></a><p><strong>1.3.</strong></p></td><td align="left" valign="top"><p>FreeBSD のインストールについての説明書はどこにありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            インストールの説明書は<a class="link" href="../handbook/install.html" target="_top">FreeBSD
              ハンドブックのインストールの章</a>にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75003856"></a><a id="need-to-run"></a><p><strong>1.4.</strong></p></td><td align="left" valign="top"><p>FreeBSD を動作させるには何が必要ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            386 以上の PC、5MB 以上の RAM、
            そして最低 60MB のハードディスク容量が必要となります。
            ローエンドの MDA カードでも動作しますが、
            X11R6 を使うには VGA かそれ以上のビデオカードが必要となります。
          </p><p>
            <a class="xref" href="#hardware" title="第2章 ハードウェアコンパチビリティ">2章<em>ハードウェアコンパチビリティ</em></a>
              もご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75009616"></a><a id="four-meg-ram-install"></a><p><strong>1.5.</strong></p></td><td align="left" valign="top"><p>4MB しかメモリがないのですが、インストールできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            4MB のシステムにインストールできた最後の FreeBSD は
            FreeBSD 2.1.7 でした。2.2 を含むより新しいバージョンの
            FreeBSD は新規のインストールに最低 5MB は必要になります。
          </p><p>
            ただし、インストールプログラムが 4MB では動作しないだけで、
            3.0 を含む FreeBSD のすべてのバージョンは 4MB の RAM
            で<span class="emphasis"><em>動作可能</em></span>です。
            インストールする時だけさらに 4MB 追加しておき、
            システムがセットアップされて動作するようになった後、
            また 4MB を取り出して元に戻すこともできます。
            あるいは 4MB より多くメモリを搭載したシステムにディスクを持っていき、
            そのマシンでインストールした後にディスクを戻すこともできます。
          </p><p>
            また、FreeBSD 2.1.7 であっても、4MB
            ではインストールできない場合があります。
            正確には、640KB のベースメモリ + 3MB の拡張メモリでは、
            インストールはできません。もしマシンのマザーボードが
            640KB から 1MB
            の領域で「失われた」メモリを再マップできる場合は、
            FreeBSD 2.1.7 をインストールできるかもしれません。
          </p><p>
            BIOS のセットアップ画面で、<span class="quote">「<span class="quote">remap</span>」</span>
            のオプションを探して有効 (enable) にしてみてください。
            また、ROM shadowing
            を無効 (disable) にする必要もあります。
          </p><p>
            簡単なやり方としては、インストールする時だけあと
            4MB 追加しておく方法があります。
            必要なオプションだけを選択してカスタムカーネルを構築し、
            また 4MB を取り出してもとに戻せばいいのです。
          </p><p>
            また、2.0.5 をインストールして、
            それから 2.1.7 のインストーラの
            <span class="quote">「<span class="quote">upgrade</span>」</span>
            オプションでシステムを 2.1.7 へアップグレード
            するというやり方もあります。
          </p><p>
            インストールしたあとでカスタムカーネルの構築をした場合には、
            4MB でも動作します。
            2MB で起動に成功した人もいます (でもそのシステムは、
            ほとんど使いものになりませんでした :-))。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75031376"></a><a id="custom-boot-floppy"></a><p><strong>1.6.</strong></p></td><td align="left" valign="top"><p>自分用のインストールフロッピーを作るには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在はカスタムインストールフロッピーディスク「だけ」を作る方法はありません。
            カスタムインストールフロッピーディスクイメージを含む、
            release 環境全体を新たに作る必要があります。
          </p><p>
            カスタムの release 環境をつくるには、
            <a class="link" href="#custrel" title="13.2.">ここの指示</a>にしたがってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75038800"></a><a id="windows-coexist"></a><p><strong>1.7.</strong></p></td><td align="left" valign="top"><p>同じマシンで Windows 95/98 と共存できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず Windows 95/98 をインストールしてから、そのあとで FreeBSD
            をインストールしてください。FreeBSD のブートマネージャが Win95
            と FreeBSD のブート管理をしてくれるようになります。
            Windows 95/98 を後にインストールした場合はひどいことに、
            問い合わせることもなくブートマネージャを上書きしてしまいます。
            そうなってしまった場合は次の節をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75044304"></a><a id="win95-damaged-boot-manager"></a><p><strong>1.8.</strong></p></td><td align="left" valign="top"><p>Windows 95/98 がブートマネージャを潰しちゃった! どうやって戻すの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ブートマネージャの再インストールの方法として、
            FreeBSD では以下に示す三通りの方法が用意されています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>DOS を起動し、FreeBSD の配布物の中にある
                <code class="filename">tools/</code> ディレクトリへ移動し、
                <code class="filename">bootinst.exe</code> を探してください。
                そして次のように実行します。
                </p><pre class="screen"><code class="prompt">...\TOOLS&gt;</code> <strong class="userinput"><code>bootinst.exe boot.bin</code></strong></pre><p>
                こうすることで、
                ブートマネージャが再インストールされます。
              </p></li><li class="listitem"><p>
                FreeBSD のブートフロッピーディスクから起動し、
                「カスタム」インストールメニューを選択し、
                続いて「パーティション」を選択します。
                ブートマネージャがインストールされていたドライブ
                (多分最初のもの) を選択し、
                パーティションエディタにたどり着いたら、
                (何も変更せず) そのまま (W)rite を指定します。
                確認のメッセージが出ますので「はい(Y)」と答え、
                ブートマネージャ選択の画面で確実に <span class="quote">「<span class="quote">Boot Manager</span>」</span>
                を選択します。
                これでブートマネージャがディスクに再び書き込まれます。
                インストールメニューから抜けて再起動すると、
                ハードディスクは元通りになります。
              </p></li><li class="listitem"><p>FreeBSD 起動フロッピー (もしくは CD-ROM) から起動し、
                <span class="quote">「<span class="quote">Fixit</span>」</span> メニューを選択します。
                Fixit フロッピーか CD-ROM #2 (<span class="quote">「<span class="quote">live</span>」</span>
                ファイルシステムオプション) の好きな方を選択して
                fixit シェルに入ります。
                そして、次のコマンドを実行してください。</p><pre class="screen"><code class="prompt">Fixit#</code> <strong class="userinput"><code>fdisk -B -b /boot/boot0 起動デバイス</code></strong></pre><p><em class="replaceable"><code>起動デバイス</code></em> の部分は、たとえば
                <code class="filename">ad0</code> (一番目の IDE ディスク)、
                <code class="filename">ad4</code> (セカンダリ IDE コントローラの一番目の IDE ディスク)、
                <code class="filename">da0</code> (一番目の SCSI ディスク)
                などといった、実際の起動デバイスを表しています。</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75086800"></a><a id="boot-on-thinkpad"></a><p><strong>1.9.</strong></p></td><td align="left" valign="top"><p>
            IBM Thinkpad の A、T、X シリーズのいずれかを持っています。
            FreeBSD をインストールしたら起動しなくなってしまいました。
            どうすればいいですか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
          これらのマシンに使われている初期のリビジョンの IBM BIOS
          にはバグがあり、FreeBSD のパーティションをディスクサスペンド用の
          FAT 領域だと誤認します。 そのため、BIOS が FreeBSD のパーティションを
          検出したところでシステムがハング (停止) してしまいます。
        </p><p>
          IBM <a href="#ftn.idp75091152" class="footnote" id="idp75091152"><sup class="footnote">[1]</sup></a>
          によれば、以下のモデル/BIOS リリース番号には修正が含まれています。
        </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>モデル</th><th>BIOS リビジョン番号</th></tr></thead><tbody><tr><td>T20</td><td>IYET49WW 以降</td></tr><tr><td>T21</td><td>KZET22WW 以降</td></tr><tr><td>A20p</td><td>IVET62WW 以降</td></tr><tr><td>A20m</td><td>IWET54WW 以降</td></tr><tr><td>A21p</td><td>KYET27WW 以降</td></tr><tr><td>A21m</td><td>KXET24WW 以降</td></tr><tr><td>A21e</td><td>KUET30WW</td></tr></tbody></table></div><p>それより新しいリビジョンの BIOS にまたバグが入り込んだか
          もしれないという報告がありました。Jacques Vidrine は
          <code class="email">&lt;<a xmlns="" class="email" href="mailto:mobile@freebsd.org">mobile@freebsd.org</a>&gt;</code> メーリングリストにあてた <a class="link" href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=200565+208320+/usr/local/www/db/text/2001/freebsd-mobile/20010429.freebsd-mobile" target="_top">メッセージ</a>
          で、これ以降の IBM の laptop で FreeBSD が正常に起動しない
          場合におそらくうまく行く、BIOS をアップグレードまたは
          ダウングレードできる手順を説明しています。</p><p>
          もし問題のある BIOS を使っていてアップグレードが選べない場合、
          FreeBSD をインストールしてから FreeBSD が使っているパーティション ID を変更し、
          変更されたパーティション ID を正しく扱うことのできる
          新しい起動ブロックをインストールすることで解決することができます。
        </p><p>
          それにはまず、
          セルフテスト画面を通過する状態にまでマシンを回復させる必要があります。
          そのためには、マシンがプライマリディスクから FreeBSD
          パーティションを見つけないようにして起動しなければなりません。
          たとえば、一度ハードディスクを外してしまって、そのディスクを古い ThinkPad
          (ThinkPad 600 など) やデスクトップ PC に適切な変換ケーブルで接続します。
          その後 FreeBSD のパーティションを削除し、
          ハードディスクを元の ThinkPad に戻します。
          こうすることで ThinkPad は起動可能な状態に戻るはずです。
        </p><p>
          マシンがちゃんと動くようになったら、
          以下の復旧手順に従って FreeBSD をインストールすることができます。
        </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                <a class="link" href="http://people.freebsd.org/~bmah/ThinkPad/" target="_top">http://people.freebsd.org/~bmah/ThinkPad/</a>
                から
                <code class="filename">boot1</code> と
                <code class="filename">boot2</code>
                をダウンロードします。 これらのファイルは、
                あとで必要になった時、取り出せる場所に置いておきます。
              </p></li><li class="step"><p>ThinkPad に普通に FreeBSD をインストールします。
                ただし、<code class="literal">Dangerously Dedicated</code>
                モードを使っては<span class="emphasis"><em>いけません</em></span>。
                また、インストールが終わっても再起動しては<span class="emphasis"><em>いけません</em></span>。</p></li><li class="step"><p>
                <span class="quote">「<span class="quote">緊急ホログラフィックシェル (Emergency Holographic Shell)</span>」</span>
                (<span class="keycap"><strong>ALT</strong></span>+<span class="keycap"><strong>F4</strong></span>)
                に切り替えるか、<span class="quote">「<span class="quote">fixit</span>」</span> シェルを起動します。
              </p></li><li class="step"><p>
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a> を使って FreeBSD のパーティション ID を
                <code class="literal">165</code> から <code class="literal">166</code> に
                変更します (これは OpenBSD で使われているものです)。
              </p></li><li class="step"><p>
                <code class="filename">boot1</code> と
                <code class="filename">boot2</code>
                のファイルをローカルファイルシステムに持って来ます。
              </p></li><li class="step"><p>
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">disklabel</span>(8)</span></a> を使って
                <code class="filename">boot1</code> と
                <code class="filename">boot2</code> を
                FreeBSD のスライスに書き込みます。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel -B -b boot1 -s boot2 ad0sn</code></strong></pre><p>
                <em class="replaceable"><code>n</code></em> は、
                あなたが FreeBSD をインストールしたスライスの番号です。
              </p></li><li class="step"><p>
                再起動します。起動プロンプトは <code class="literal">OpenBSD</code>
                と示しますが、実際には、それで FreeBSD が起動します。
              </p></li></ol></div><p>
            この方法で FreeBSD と OpenBSD
            をデュアルブートする方法は、読者への練習問題としましょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75199952"></a><a id="install-bad-blocks"></a><p><strong>1.10.</strong></p></td><td align="left" valign="top"><p>不良ブロックのあるディスクにインストールできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD 3.0 以前のシステムでは、
            不良ブロックを自動的に再マッピングする
            <code class="command">bad144</code> というユーティリティが含まれていましたが、
            現在の IDE ドライブはドライブ自身がこの機能を備えているため、
            <code class="command">bad144</code> は FreeBSD ソースツリーから削除されました。
            FreeBSD 3.0 かそれ以降をインストールしたいと思っているなら、
            比較的新しいディスクドライブを購入することを強くおすすめします。
            新しいドライブを購入する気がなければ、FreeBSD 2.x を利用するべきです。</p><p>現在の IDE ドライブで不良ブロックによるエラーが発生した場合、
            まもなくドライブが故障する可能性があります
            (それはそのドライブ内蔵の再マッピング機能では
            不良ブロックが修正できなくなったということであり、
            ディスクがひどく壊れていることを意味します)。
            新しいハードディスクドライブに交換しましょう。</p><p>不良ブロックのある SCSI ドライブの場合は、
            <a class="link" href="#awre" title="3.1.">この回答</a>を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75212496"></a><a id="boot-floppy-strangeness"></a><p><strong>1.11.</strong></p></td><td align="left" valign="top"><p>インストーラから起動したら変なことになりました!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            インストーラから起動しようとしたときに、マシンが固まってし
            まうとか自然と再起動してしまうといった現象であれば、
            次の三つの項目を確認してください。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>新品の、フォーマットしたての、
                エラーのないフロッピーディスクを使っていますか?
                (三年間もベッドの下に放置されていた雑誌の付録みたいなやつではなくて、
                買ってきたばかりの新品を使ってください)
              </p></li><li class="listitem"><p>フロッピーイメージをバイナリモードでダウンロードしましたか?
                (困った顔をしないでください。私たちの中で一番優秀な人でさえ、
                少なくとも一回はバイナリファイルを
                ASCII モードで思いがけずダウンロードしたことがあるのです!)
              </p></li><li class="listitem"><p>Windows95 あるいは Windows98 を使用しているなら、
                ありのままの本物の DOS で
                <code class="command">fdimage</code> か
                <code class="command">rawrite</code> を実行しましたか?
                これらの OS はディスク作成プログラムのような、
                ハードウェアに直接書き込みを行なうプログラムに干渉する可能性があります。
                GUI の中の DOS シェル内部で動作している場合でも、
                この問題は発生します。</p></li></ol></div><p>また、Netscape
            でブートイメージをダウンロードする場合も問題があることが報告されていますので、
            できれば別の FTP クライアントを使うのがよいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75237584"></a><a id="no-install-cdrom"></a><p><strong>1.12.</strong></p></td><td align="left" valign="top"><p>ATAPI CD-ROM から起動したのですが、
            インストールプログラムは CD-ROM が見つかりませんと言ってきます。
            CD-ROM はどこに行ってしまったのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>この問題は通常、CD-ROM ドライブの設定ミスによって発生します。
            大部分の PC の CD-ROM ドライブは、
            セカンダリ側の IDE
            コントローラのスレーブデバイスとして接続され、
            マスタデバイスがない状態で出荷されています。
            この接続方法は ATAPI 規格違反なので、
            Windows は規格どおりに動いたり、動かなかったりしますが、
            BIOS は起動時に規格違反を無視します。
            そのため BIOS は起動時に CD-ROM を見つけられますが、
            FreeBSD は CD-ROM を見つけられず、
            インストールを完了できないのです。</p><p>CD-ROM が 接続されている
            IDE コントローラのマスタデバイスとなるように設定するか、
            もしくはマスタ、
            スレーブの両方にデバイスが接続されているようにシステムを再構成してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75246800"></a><a id="cannot-install-tape"></a><p><strong>1.13.</strong></p></td><td align="left" valign="top"><p>あれれ? テープからインストールできません!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.1.7R をテープからインストールする場合、
            tar ブロックサイズを 10 (5120 バイト)
            にしたテープを作る必要があります。
            デフォルト の tar ブロックサイズは 20 (10240 バイト) で、
            このデフォルトサイズで作られたテープでは FreeBSD 2.1.7R
            をインストールすることはできません。
            もしこうしたテープを使うと、
            レコードサイズが大きすぎるというエラーが起きることになります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75251664"></a><a id="parallel-connect"></a><p><strong>1.14.</strong></p></td><td align="left" valign="top"><p>PLIP 経由で二つ FreeBSD box を接続したいのですが</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Laplink パラレルケーブルを用意して、
            両方の PC のカーネルに <code class="filename">lpt</code>
            ドライバが組み込まれていることを確認してください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>dmesg | grep lp</code></strong>
lpt0 at 0x378-0x37f irq 7 on isa
lpt0: Interrupt-driven port
lp0: TCP/IP capable interface</pre><p>
            パラレルインタフェースに Laplink
            パラレルケーブルを接続します。
          </p><p>
            <code class="systemitem">root</code>
            になって、両方で <code class="filename">lp0</code>
            のネットワークインタフェースパラメータを設定します。
            たとえば、ホスト <code class="systemitem">max</code> と <code class="systemitem">moritz</code> を接続したい場合、
          </p><pre class="programlisting">                max &lt;-----&gt; moritz
IP Address      10.0.0.1        10.0.0.2</pre><p>max 側で次のようにして、</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ifconfig lp0 10.0.0.1 10.0.0.2</code></strong></pre><p>moritz 側で同様に次のようにします。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ifconfig lp0 10.0.0.2 10.0.0.1</code></strong></pre><p>以上です!
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=lp&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">lp</span>(4)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=lpt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">lpt</span>(4)</span></a>
            のマニュアルページも参照してください。
          </p><p>また、
            <code class="filename">/etc/hosts</code> にホストの追加もしましょう。
          </p><pre class="programlisting">127.0.0.1               localhost.my.domain localhost
10.0.0.1                max.my.domain max
10.0.0.2                moritz.my.domain moritz</pre><p>
            動作確認は次のようにします。
          </p><p><code class="systemitem">max</code> 側:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ifconfig lp0</code></strong>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000</pre><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -r</code></strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use     Netif Expire
moritz              max              UH          4   127592       lp0</pre><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ping -c 4 moritz</code></strong>
PING moritz (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- moritz ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75320656"></a><a id="install-PLIP"></a><p><strong>1.15.</strong></p></td><td align="left" valign="top"><p>ラップトップ PC に PLIP 経由でインストールできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            次のようにして、二つのコンピュータを Laplink
            パラレルケーブルで接続してください。
          </p><div class="table"><a id="idp75325264"></a><div class="table-title">表1.1 ネットワーク接続用のパラレルケーブルの結線</div><div class="table-contents"><table summary="ネットワーク接続用のパラレルケーブルの結線" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>A-name</th><th>A 側</th><th>B 側</th><th>説明</th><th>ポート / ビット</th></tr></thead><tbody><tr><td><div class="literallayout"><p>DATA0<br />
-ERROR</p></div></td><td><div class="literallayout"><p>2<br />
15</p></div></td><td><div class="literallayout"><p>15<br />
2</p></div></td><td>Data</td><td><div class="literallayout"><p>0/0x01<br />
1/0x08</p></div></td></tr><tr><td><div class="literallayout"><p>DATA1<br />
+SLCT</p></div></td><td><div class="literallayout"><p>3<br />
13</p></div></td><td><div class="literallayout"><p>13<br />
3</p></div></td><td>Data</td><td><div class="literallayout"><p>0/0x02<br />
1/0x10</p></div></td></tr><tr><td><div class="literallayout"><p>DATA2<br />
+PE</p></div></td><td><div class="literallayout"><p>4<br />
12</p></div></td><td><div class="literallayout"><p>12<br />
4</p></div></td><td>Data</td><td><div class="literallayout"><p>0/0x04<br />
1/0x20</p></div></td></tr><tr><td><div class="literallayout"><p>DATA3<br />
-ACK</p></div></td><td><div class="literallayout"><p>5<br />
10</p></div></td><td><div class="literallayout"><p>10<br />
5</p></div></td><td>Strobe</td><td><div class="literallayout"><p>0/0x08<br />
1/0x40</p></div></td></tr><tr><td><div class="literallayout"><p>DATA4<br />
BUSY</p></div></td><td><div class="literallayout"><p>6<br />
11</p></div></td><td><div class="literallayout"><p>11<br />
6</p></div></td><td>Data</td><td><div class="literallayout"><p>0/0x10<br />
1/0x80</p></div></td></tr><tr><td>GND</td><td>18-25</td><td>18-25</td><td>GND</td><td>-</td></tr></tbody></table></div></div><br class="table-break" /><p>また、
            <a class="link" href="#pao">Mobile Computing
              についてのページ</a>もご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75409616"></a><a id="geometry"></a><p><strong>1.16.</strong></p></td><td align="left" valign="top"><p>ハードディスクドライブには、
            どのジオメトリを使うべきでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">ここでディスクの「ジオメトリ」とは、ディスクのシリンダ、ヘッダ、
                トラック当りのセクタの数を意味しています - 便宜上、
                C/H/S とすることにします。これはディスクのどの領域で読み書きを
                行なうかを PC の BIOS が決定する手段となります。</p></div><p>
            これについてはある理由のために、誤解されている点が多いようです。
            まず最初に、FreeBSD はディスクブロックで動作しているため、
            SCSI ドライブの <span class="quote">「<span class="quote">物理的</span>」</span> なジオメトリという言い方は、
            まったく見当違いのものです。事実、
            セクタの密度はディスクによってまちまちであるため、
            物理的なジオメトリというものは存在しません。
            製造者が <span class="quote">「<span class="quote">本当の</span>」</span> 物理的なジオメトリと公表しているものは通常、
            彼らが検査して得た最小の使用不可容量の結果のジオメトリのことです。
            IDE の場合、FreeBSD は C/H/S で動作しますが、
            最近のドライブはすべて、これを内部で参照するブロックに変換しています。
          </p><p>
            問題はとなるのは<span class="emphasis"><em>論理的な</em></span>ジオメトリです。
            これは BIOS がそのディスクのジオメトリについて調べた際に取得されるものであり、
            その後のディスクへのアクセスに使用します。
            FreeBSD は起動時に BIOS を使用するため、
            これを正しく取得することは非常に重要なことなのです。
            実際に、ディスク上に複数のオペレーティングシステムがある場合は、
            ジオメトリはどこからでも同じように解釈される必要があります。
            そうしないと、起動時に深刻な問題が発生します。
          </p><p>
            SCSI ディスクでは、
            使用するジオメトリはコントローラの拡張 BIOS
            トランスレーション (<span class="quote">「<span class="quote">&gt;1GB の
            DOS ディスクドライブのサポート</span>」</span>
            とも呼ばれます) が有効になっているかどうかによります。
            無効になっている場合、N シリンダ、64 ヘッド、
            32 セクタ/トラックを使用しますが、
            ここで `N' は MB 単位のディスク容量です。
            たとえば、2GB ディスクは見かけ上 2048 シリンダ、64 ヘッド、
            32 セクタ/トラックとなります。
          </p><p>
            それが「有効」になっており (MS-DOS
            ではこの方法で、ある制限を回避する場合もあります)、
            ディスク容量が 1GB を越える場合は、M シリンダ、
            63 セクタ/トラック (64 「ではなく」)、
            255 ヘッドを使用します。
            `M' は MB 単位のディスク容量を 7.844238(!)
            で割った値となります。
            ということで、2GB ディスクの例では、
            261 シリンダ、63 セクタ/トラック、255 ヘッドとなります。
            (訳注: 以上は Adaptec 社と NCR 社製の SCSI アダプタの場合です。
            SCSI アダプタによって変換の数値が変わってくるのでマニュアルを
            参照してください)。
          </p><p>
            これについてよく分からない場合や
            FreeBSD がインストール中に正しくジオメトリを取得できない場合、
            これを回避するもっとも簡単な方法は、
            ディスクに小さな DOS パーティションを作ることです。
            そうすると正しいジオメトリが取得されるはずです (そして、
            残しておきたくないとか、
            ネットワークカードのプログラミング用に使いたい場合などには、
            いつでもパーティションエディタで DOS
            パーティションを削除することができます)。
          </p><p>
            もう一つの方法として、FreeBSD
            と一緒に配布されているフリーで使えるユーティリティに
            <code class="filename">pfdisk.exe</code>
            (FreeBSD CD-ROM の <code class="filename">tools</code>
            ディレクトリや、他のさまざまな FTP
            サイトにあります)と呼ばれるものがあり、
            ディスク上の他のオペレーティングシステムが使用している
            ジオメトリを調べるのに役立ちます。
            このジオメトリ情報は、
            パーティションエディタに入力することができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75426384"></a><a id="disk-divide-restrictions"></a><p><strong>1.17.</strong></p></td><td align="left" valign="top"><p>ディスクの分割の仕方で何か制限はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい。
            BIOS がカーネルを起動できるようにルートパーティションが
            1024 シリンダ以内にあることを確認する必要があります (これは
            FreeBSD ではなく PC の BIOS の制限です)。
          </p><p>
            SCSI ドライブでは、通常はルートパーティションが最初の 1024MB
            に収まっていることが前提となります (または拡張 BIOS
            トランスレーションが有効になっている場合は最初の 4096MB -
            他の質問をご覧ください)。IDE でそれに相当する値は 504MB
            となります (訳注: E-IDE
            対応の BIOS 搭載マシンの場合は
            IDE の 504MB という制限はありません)。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75432016"></a><a id="disk-manager"></a><p><strong>1.18.</strong></p></td><td align="left" valign="top"><p>大容量ディスクを持っていますが、ディスクマネージャは使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は Ontrack Disk Manager を認識し、これを考慮にいれます。
            他のディスクマネージャはサポートしません。
          </p><p>
            ディスク全体を FreeBSD で使いたい場合、
            ディスクマネージャは必要ありません。
            BIOS が扱える容量 (通常 504MB) いっぱいでディスクの設定を行なうと、
            FreeBSD は実際の容量を算出するはずです。
            MFM コントローラ付きの古いディスクを使っている場合は、
            FreeBSD に使用するシリンダ数を詳細に指定する必要があります。
          </p><p>
            FreeBSD
            と他のオペレーティングシステムが入っているディスクを使用したい場合は、
            ディスクマネージャなしでもできるでしょう。
            FreeBSD
            の起動パーティションと他のオペレーティングシステム用のスライスが、
            最初の 1024 シリンダ内に収まっている事を確認するだけです。
            気になる方は、起動パーティションを 20
            メガバイトぐらいにして大きめにするとよいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75446992"></a><a id="missing-os"></a><p><strong>1.19.</strong></p></td><td align="left" valign="top"><p>FreeBSD の起動時に
            <code class="literal">Missing Operating System</code>
            と表示されます</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは FreeBSD や DOS、
            そのほかの OS がディスク領域<a class="link" href="#geometry" title="1.16.">ジオメトリ</a>
            のとらえ方で衝突しあっていることから起こる典型的な例です。
            こうなったら FreeBSD
            をインストールし直す以外にはありませんが、
            他のところで説明した手順にしたがってやれば、
            ほぼ間違いなくうまくいくはずです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75454672"></a><a id="stop-at-boot-manager"></a><p><strong>1.20.</strong></p></td><td align="left" valign="top"><p>ブートマネージャの <code class="literal">F?</code> プロンプトが表示されません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これはすでに前に質問されている問題のもう一つの症状です。
            BIOS のジオメトリと FreeBSD のジオメトリ設定が一致していないのです!
            コントローラや BIOS がシリンダの変換 (<code class="literal">&gt;1GB ドライブの
            サポート</code>とも呼ばれます) をサポートしていたら、
            その設定を無効化して FreeBSD をインストールし直してみてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75461200"></a><a id="need-complete-sources"></a><p><strong>1.21.</strong></p></td><td align="left" valign="top"><p>ソースを全部インストールする必要はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            一般的には「いいえ」です。
            しかし最低でも、<code class="literal">base</code>
            ソースキット (これにはこの FAQ
            で述べられているファイルのいくつかが含まれています) と、
            <code class="literal">sys</code> (kernel)
            ソースキット (これにはカーネルのソースが含まれています)
            をインストールする事を強くおすすめします。
            通常、何かの実行にソースが必要になる事はありません。
            しかし、カーネルをコンフィグレーションするためのプログラム <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=config&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">config</span>(8)</span></a>
            を実行する時は例外です。
            カーネルのソースをインストールしなくてもよい例として、
            どこか別の場所からカーネルのソースを読み込み専用で NFS
            マウントすることができます。また、
            そこから新しいバイナリを作成できるようにもなっています
            (カーネルソースの制限があるので、直接 <code class="filename">/usr/src</code>
            をマウントする事はおすすめできません。
            それよりもどこか別のディレクトリにマウントして、
            ソースツリーの複製ができるように適切にシンボリックリンクを張ってください)。
          </p><p>
            ソースをネットワーク上に持ち、
            そこからシステムをビルドするようにしておけば、
            FreeBSD の将来のリリースへのアップグレードがずっと簡単になります。
          </p><p>
            実際にソースのサブセットを選択するには、
            システムインストールツールの「配布ファイル」メニューにある、
            「カスタム」メニューを使用します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75473104"></a><a id="need-kernel"></a><p><strong>1.22.</strong></p></td><td align="left" valign="top"><p>カーネルは必ず作り直さなくちゃならないんですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            カーネルを新しく作り直すのは元々、
            FreeBSD のインストール時に必須の作業でした。
            でも最近のリリースでは、
            とてもユーザフレンドリなカーネル設定ツールの恩恵を受けています。
            FreeBSD の起動プロンプト (boot:) で <code class="option">-c</code>
            とタイプすればビジュアルな設定画面になり、
            ほとんどの一般的な ISA
            カードについてのカーネルの設定をすることができるのです。
          </p><p>
            今でも、
            必要なデバイスドライバだけを組み込んだカーネルを作ることはよい事とされています。
            ほんのちょっとだけメモリを節約できますからね。
            でもほとんどのシステムでは、
            もはやどうしてもやらなくちゃならないことではないのです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75491664"></a><a id="password-encryption"></a><p><strong>1.23.</strong></p></td><td align="left" valign="top"><p>DES と MD5、どちらのパスワードを使うべきなのでしょうか?
            また、ユーザがどちらを使うことになるか指定する方法はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD の標準のパスワードフォーマットは
            <span class="emphasis"><em>MD5</em></span> を使ったものです。 これは
            <span class="emphasis"><em>DES</em></span> アルゴリズムに基づいた手法を用いる
            UNIX の伝統的なパスワードフォーマットより安全 (secure) だと
            信じられているものです。 DES パスワードは
            あなたが FreeBSD のパスワードファイルを、
            安全性に劣るパスワードフォーマットを利用している古い OS
            と共有しなければならなくなったときのために
            利用可能になっています (これは利用するためには、
            sysinstall から <span class="quote">「<span class="quote">crypto</span>」</span> 配布物のインストール
            選ぶか、ソースから build しているなら、
            crypto のソースがインストールされている必要があります)。
            新しいパスワードにどちらのパスワードフォーマットを使うかは
            <code class="filename">/etc/login.conf</code> の中の
            <span class="quote">「<span class="quote">passwd_format</span>」</span> という login
            ケーパビリティで制御されます。このケーパビリティは
            <span class="quote">「<span class="quote">des</span>」</span> (利用できるなら) か
            <span class="quote">「<span class="quote">md5</span>」</span> のどちらかの値を取ります。
            login ケーパビリティの詳細については <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=login.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">login.conf</span>(5)</span></a> を
            参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75504976"></a><a id="boot-floppy-hangs"></a><p><strong>1.24.</strong></p></td><td align="left" valign="top"><p>ブートフロッピーで起動すると、
            <code class="literal">Probing Devices...</code>
            の画面でハングアップします。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            IDE Zip か Jaz ドライブが接続されていたら、
            それを取り外してもう一度試してみましょう。
            ブートフロッピーはこの種のドライブを誤認してしまうのです。
            システムがインストールされた後は、そのドライブを再度接続することができます。
            うまくいけばこの問題は将来のリリースで解決されるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75510992"></a><a id="panic-on-install-reboot"></a><p><strong>1.25.</strong></p></td><td align="left" valign="top"><p>インストール終了後にシステムを再起動すると、
            <code class="literal">panic: cant mount root</code>
            のエラーとなります。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            このエラーはディスクデバイスについて、
            起動ブロックとカーネルの認識が混乱しているために起こります。
            このエラーは通常、
            2 台の IDE ディスクがそれぞれ別の IDE
            コントローラのマスターに一つずつ接続されているシステムにおいて、
            FreeBSD がセカンダリ IDE
            コントローラに接続されたディスクにインストールされている場合に発生します。
            起動ブロックは FreeBSD が
            wd1 (2 台目の BIOS
            ディスク) にインストール
            されていると認識するのに対し、
            カーネルはセカンダリ IDE の 1 台目のハードディスクである
            wd2
            にインストールされていると認識するのです。
            デバイス検出後で、
            カーネルは起動ブロックが起動ディスクだと認識したディスクである
            wd1 をマウントしようとします。
            しかし、実際には起動ディスクは
            wd2 なので失敗してしまうのです。
          </p><p>
            この問題を解決するには、以下のどれか一つを行ってください。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>FreeBSD 3.3 以降を利用している場合には、
                システムを再起動して、<code class="literal">Booting kernel in 10 seconds; hit
                  [Enter] to interrupt</code>
                が表示されている間に <code class="literal">Enter</code> キーを押します。
                すると、ブートローダに移行します。
              </p><p>そうしたら、<code class="literal">set
                  root_disk_unit="disk_number"</code>
                と入力します。 FreeBSD が最初の IDE
                コントローラのマスターに接続されたドライブにインストールされていれば、
                <em class="replaceable"><code>disk_number</code></em> は
                <code class="literal">0</code> です。
                また、
                最初の IDE コントローラのスレーブなら <code class="literal">1</code>、
                二番目の IDE コントローラのマスターなら <code class="literal">2</code>、
                二番目の IDE コントローラのスレーブなら <code class="literal">3</code> になります。
              </p><p>その後、<code class="literal">boot</code> と入力します。
                システムはきちんと再起動するはずです。</p><p>この変更を恒久的なものにする (つまり、
                再起動や電源を入れる度にこの操作をする必要がないようにする) には、
                <code class="filename">/boot/loader.conf.local</code> に
                <code class="literal">root_disk_unit="disk_number"</code>
                という行を追加してください。</p></li><li class="listitem"><p>
                FreeBSD 3.2 以前を利用している場合は、
                Boot: プロンプトで
                <code class="literal">1:wd(2,a)kernel</code>
                と入力してエンターキーを押します。
                システムが起動したら、

                <code class="command">echo "1:wd(2,a)kernel" &gt; /boot.config</code>

                というコマンドを実行してこれをデフォルトのブート文字列とします。
              </p></li><li class="listitem"><p>FreeBSD のディスクをプライマリ IDE コントローラに接続して、
                ハードディスクが連続したドライブ番号で認識されるようにします。
              </p></li><li class="listitem"><p>カーネルのコンフィグレーションファイルで wd
                の行を以下のように変更し、
                <a class="link" href="../handbook/kernelconfig.html" target="_top">カーネルの再構築</a>を行って、
                新しいカーネルをインストールします。</p><pre class="programlisting">controller      wdc0    at isa? port "IO_WD1" bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk            wd1     at wdc0 drive 1 # この行をコメントアウト

controller      wdc1    at isa? port "IO_WD2" bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # wd2 から wd1 へ変更
disk            wd2     at wdc1 drive 1 # wd3 から wd2 へ変更</pre><p>ディスクの接続を変更して元の設定に戻したい場合は、ディスクを
                お望みの設定の通りの接続に戻してから再起動します。
                システムは正常に起動するはずです。</p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75555408"></a><a id="memory-limits"></a><p><strong>1.26.</strong></p></td><td align="left" valign="top"><p>メモリの大きさの制限は?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            認識できるメモリの上限は、4GB です。
            この構成は試験済みで、
            詳細は <a class="link" href="ftp://ftp.cdrom.com/archive-info/configuration" target="_top">wcarchive's
              configuration</a> をご覧ください。
            このようにたくさんのメモリをマシンに導入しようという場合には、
            注意が必要です。ECC 機能をサポートし、なおかつ
            容量性負荷 (訳注: 多くのメモリ素子は容量性負荷として働きますが、
            メモリバス上に容量性負荷が増えると信号の伝達が遅れ、誤動作の原因となります) を
            低減させるため、18 チップ構成のメモリモジュールより
            9 チップ構成のメモリモジュールを選択することが、おそらく望ましいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75561296"></a><a id="ffs-limits"></a><p><strong>1.27.</strong></p></td><td align="left" valign="top"><p>ffs ファイルシステムの大きさの制限は?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ffs ファイルシステムの場合、
            論理的な最大の上限は 8 TB (2G ブロック)、
            デフォルトのブロックサイズを 8K とすると 16 TBとなります。
            実際問題として、1 TB のソフトウェアの限界がありますが、
            修正すれば 4 TB のファイルシステムが可能です (実際に存在します)。
          </p><p>一つの ffs のファイルの最大のサイズは、ブロックサイズが 4K の場合で
            約 1G ブロック (4 TB)です。</p><div class="table"><a id="idp75566800"></a><div class="table-title">表1.2 最大ファイルサイズ</div><div class="table-contents"><table summary="最大ファイルサイズ" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>fs ブロックサイズ</th><th>2.2.7-stable</th><th>3.0-current</th><th>動作確認済みのサイズ</th><th>動作するはずのサイズ</th></tr></thead><tbody><tr><td>4K</td><td>4T-1</td><td>4T-1</td><td>4T-1</td><td>&gt;4T</td></tr><tr><td>8K</td><td>&gt;32G</td><td>8T-1</td><td>&gt;32G</td><td>32T-1</td></tr><tr><td>16K</td><td>&gt;128G</td><td>16T-1</td><td>&gt;128G</td><td>32T-1</td></tr><tr><td>32K</td><td>&gt;512G</td><td>32T-1</td><td>&gt;512G</td><td>64T-1</td></tr><tr><td>64K</td><td>&gt;2048G</td><td>64T-1</td><td>&gt;2048G</td><td>128T-1</td></tr></tbody></table></div></div><br class="table-break" /><p>
            fs ブロックサイズが 4K の場合は三重間接ブロックが使用され、
            いずれの場合でも三重間接ブロックを使用して表現できる最大の
            fs ブロック番号 (およそ 1K^3 + 1K^2 + 1K) に制限されるはずなのですが、
            実際は fs ブロック番号の (間違った) 上限 1G-1 で制限されます。
            fs ブロック番号の制限は 2G-1 となるはずです。2G-1 付近に
            fs ブロック番号のバグが多少ありますが、fs ブロックサイズが
            4K の場合は、ここまでのブロック番号には到達しません。
          </p><p>
            ブロックサイズが 8K 以上の場合、いずれの場合も
            fs ブロック番号の上限 2G-1 で制限されるはずですが、
            実際は fs ブロック番号の上限
            1G-1 で制限されます。
            例外的に -STABLE では三重間接ブロックまでは到達しないため、
            制限は二重間接ブロックで表現できる最大の
            fs ブロック番号 (およそ (blocksize/4)^2 + (blocksize/4)) となります。
            -CURRENT ではこの制限を超えると問題を引き起こすかもしれません。
            正しい制限値である 2G-1 ブロックを使用すると明らかに問題が出ます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp75614800"></a><a id="tb-on-floppy"></a><p><strong>1.28.</strong></p></td><td align="left" valign="top"><p>フロッピーに 1 TB のファイルを格納するには?</p><p><span class="emphasis"><em>寄稿: Bruce Evans、1998 年 9 月</em></span></p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            わたしのところでは、
            フロッピーにいくつかの実際のファイルを保存しています :-)。
            最大のファイルサイズは最大のディスクサイズとはあまり関係はありません。
            最大のディスクサイズは 1 TB です。
            ファイルサイズがディスクサイズより大きくなりうるというのは仕様です。
          </p><p>
            以下の例は、32K のディスク容量 (3
            つの間接ブロックと 1 つのデータブロック) を使って、
            小さなルートパーティションに
            8T-1 の大きさのファイルを作成します。
            ここでの dd コマンドは大きなファイルが扱えるものが必要です。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cat foo</code></strong>
df .
dd if=/dev/zero of=z bs=1 seek=`echo 2^43 - 2 | bc` count=1
ls -l z
du z
df .
<code class="prompt">%</code> <strong class="userinput"><code>sh foo</code></strong>
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27702    31619    47%    /
1+0 records in
1+0 records out
1 bytes transferred in 0.000187 secs (5346 bytes/sec)
-rw-r--r--  1 bde  bin  8796093022207 Sep  7 16:04 z
32      z
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27734    31587    47%    /</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78074832"></a><a id="archsw-readin-failed-error"></a><p><strong>1.29.</strong></p></td><td align="left" valign="top"><p>新しいカーネルをコンパイルしたら、起動時に
            <code class="literal">archsw.readin.failed</code>
            というエラーメッセージが表示されるようになってしまいました。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ローダがスタートする前の | が表示されているときに何かキーを押すことで、
            起動のセカンドステージから直接、起動するカーネルを指定して起動することができます。
            特に、カーネルのソースを更新し、<span class="emphasis"><em>make world
              しないで</em></span>新しいカーネルだけインストールした場合にこの症状が現われます。
            こういう操作は動作が保証されません。きちんと make world してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78077648"></a><a id="upgrade-3x-4x"></a><p><strong>1.30.</strong></p></td><td align="left" valign="top"><p>3.X から 4.X にアップグレードするにはどうしたら良いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>アップグレードには、
            バイナリスナップショットを使うことを<span class="emphasis"><em>強く</em></span>おすすめします。
            4-STABLE スナップショットは
            <a class="link" href="ftp://releng4.FreeBSD.org/" target="_top">releng4.FreeBSD.org</a>
            から入手可能です。</p><p>ソースを使ってアップグレードする場合は、詳細について
            <a class="link" href="http://www.FreeBSD.org/handbook/cutting-edge.html" target="_top">FreeBSD
              ハンドブック</a>を参照するようにしてください。</p><div xmlns="" class="caution"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">ソースを使ったアップグレードは、
            慣れていないユーザにはまったくおすすめできません。
            3.X から 4.X への場合は特にそうです。
            ソースを使ったアップグレードを試す前に、
            手順を注意深く読むように心がけてください。</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78082256"></a><a id="security-profiles"></a><p><strong>1.31.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">セキュリティプロファイル</span>」</span>
            (<span class="quote">「<span class="quote">security profiles</span>」</span>) とは何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">セキュリティプロファイル</span>」</span>とは、特定の
            プログラムやその他の設定を有効にしたり無効にすることで、求める
            比率で安全と便利さを実現しようとする構成の選択肢の集まりの
            ことです。セキュリティプロファイルが厳しいほど、デフォルトで
            有効になるプログラムが減ります。これは、動かさなければならない
            もの以外は、何も動かしてはいけないというセキュリティの
            基本的原則の一つです。</p><p>セキュリティプロファイルは、単にデフォルトの設定である
            ということに気をつけてください。FreeBSD をインストールした
            あとに <code class="filename">/etc/rc.conf</code> に適切な行を編集したり
            追加すれば、どのプログラムでも有効にしたり無効にしたりできます。
            後者について詳しいことは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> のマニュアルを
            ご覧ください。</p><p>以下に、各セキュリティプロファイルが何を行うかを説明した
            表を掲載します。列はセキュリティプロファイルの選択肢で、行は
            有効または無効になるプログラムや機能です。</p><div class="table"><a id="idp78099408"></a><div class="table-title">表1.3 指定できるセキュリティプロファイル</div><div class="table-contents"><table summary="指定できるセキュリティプロファイル" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>〓</th><th>Extreme</th><th>High</th><th>Moderate</th><th>Low</th></tr></thead><tbody><tr><td><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a></td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendmail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sendmail</span>(8)</span></a></td><td>NO</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sshd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sshd</span>(8)</span></a></td><td>NO</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=portmap&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">portmap</span>(8)</span></a></td><td>NO</td><td>NO</td><td>おそらく (インストール時に、すでにマシンを
                      NFS クライアントまたはサーバとして設定していると、
                      ポートマッパが有効になります。)
                  </td><td>YES</td></tr><tr><td>NFS server</td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=securelevel&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">securelevel</span>(8)</span></a></td><td>YES (2) (securelevel を設定するセキュリティプロファイル
                      (Extreme または High) を選択する場合、その影響を
                      承知していなければなりません。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> のマニュアルを
                      読み、セキュリティレベルの意味について特に注意を
                      払ってください。そうしないと、後で深刻な問題が
                      起きるかもしれません。)
                    </td><td>YES (1)</td><td>NO</td><td>NO</td></tr></tbody></table></div></div><br class="table-break" /><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">セキュリティプロファイルは魔法の薬ではありません。
                High に設定したら、適当な <a class="link" href="../handbook/eresources.html#ERESOURCES-MAIL" target="_top">
                メーリングリスト</a>を読んだり、良質なパスワードや
                パスフレーズを用いたり、セキュリティについてのよい習慣を
                守ったりしなくていいわけではありません。求めるセキュリティと
                便利さの比率を手軽に設定してくれるだけです。</p></div><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">セキュリティプロファイルの機構は、FreeBSD を最初に
                インストールする時に使うことを想定しています。すでに
                FreeBSD がインストールされているなら、単に求める機能を
                有効にしたり無効にしたりする方が、おそらく効率が
                よいでしょう。もし、本当にセキュリティプロファイルを
                使いたいのであれば、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> を再実行すれば
                設定できます。</p></div></td></tr></tbody></table></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp75091152" class="footnote"><p><a href="#idp75091152" class="para"><sup class="para">[1] </sup></a>これは Keith Frechette
          <code class="email">&lt;<a xmlns="" class="email" href="mailto:kfrechet@us.ibm.com">kfrechet@us.ibm.com</a>&gt;</code> からのメールによります。</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="hardware"></a>第2章 ハードウェアコンパチビリティ</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        にしか <code class="email">&lt;<a xmlns="" class="email" href="mailto:nishika@cheerful.com">nishika@cheerful.com</a>&gt;</code>、
        1997 年 11 月 12 日</em></span>
    </p><div class="qandaset"><a id="idp78126544"></a><dl><dt>2.1. <a href="#idp78126800">FreeBSD は、
            どんなハードディスクドライブをサポートしているのですか?</a></dt><dt>2.2. <a href="#idp78133456">どの SCSI コントローラをサポートしているのですか?</a></dt><dt>2.3. <a href="#idp78135888">どんな CD-ROM ドライブをサポートしているのですか?</a></dt><dt>2.4. <a href="#idp78147536">FreeBSD は、どの CD-RW ドライブに対応していますか?</a></dt><dt>2.5. <a href="#idp78151888">ZIP ドライブをサポートしていますか?</a></dt><dt>2.6. <a href="#idp78159312">では、JAZ や EZ、
            それからその他のリムーバブルドライブはサポートしていますか?</a></dt><dt>2.7. <a href="#idp78167120">どのマルチポートシリアルカードをサポートしていますか?</a></dt><dt>2.8. <a href="#idp78171216">USB キーボードを持っているのですが、FreeBSD で使えますか?</a></dt><dt>2.9. <a href="#idp78188112">珍しいバスマウスを持っているのですが、どのように設定すればいいのですか?</a></dt><dt>2.10. <a href="#idp78206032">PS/2 マウス (「マウスポートマウス」、「キーボードマウス」) を
            使うにはどのように設定すればいいのですか?</a></dt><dt>2.11. <a href="#idp78216272">X Window System 以外の環境でマウスを使うことは可能ですか?</a></dt><dt>2.12. <a href="#idp78262864">マウスを使って、
            テキストコンソールでカットアンドペーストするにはどうしたらよいのですか?</a></dt><dt>2.13. <a href="#idp78266704">USB マウスを持っているのですが、FreeBSD で使えますか?</a></dt><dt>2.14. <a href="#idp78298064">わたしのマウスにはホイール機能や便利なボタンがついているのですが、
            これは FreeBSD でも使えるのですか?</a></dt><dt>2.15. <a href="#idp78301136">
            わたしのマウスはきちんと動いてくれないようです。
            マウスカーソルが画面中をとびまわります。
            このマウスにはホイールがついていて、
            接続は PS/2 ポートです。</a></dt><dt>2.16. <a href="#idp78304336">ラップトップ PC のマウス/トラックボール/タッチパッドは使えますか?</a></dt><dt>2.17. <a href="#idp78307408">どんなテープドライブをサポートしていますか?</a></dt><dt>2.18. <a href="#idp78314064">どんなテープチェンジャーをサポートしていますか?</a></dt><dt>2.19. <a href="#idp78319184">どんなサウンドカードをサポートしていますか?</a></dt><dt>2.20. <a href="#idp78322640">pcm
            ドライバで es1370 から音が出ないのはどうにかなりませんか?</a></dt><dt>2.21. <a href="#idp78325712">どんなネットワークカードをサポートしていますか?</a></dt><dt>2.22. <a href="#idp78328400">数値演算コプロセッサを持っていませんが、何かまずいでしょうか?</a></dt><dt>2.23. <a href="#idp78332496">FreeBSD がサポートするデバイスは他にもあるんでしょうか?</a></dt><dt>2.24. <a href="#idp78334928">パワーマネージメント機能付きのラップトップ PC を持っているのですが…。</a></dt><dt>2.25. <a href="#idp78347344">Micron システムが起動時に固まってしまいます。</a></dt><dt>2.26. <a href="#idp78350672">新しい Adaptec コントローラを持っているのですが、
            FreeBSD が検出できないようです。</a></dt><dt>2.27. <a href="#idp78354384">内蔵の Plug &amp; Play
            モデムを持っているのですが、FreeBSD が検出できないようです。</a></dt><dt>2.28. <a href="#idp78359504">シリアルコンソールで boot: プロンプトを表示するにはどうすればいい?</a></dt><dt>2.29. <a href="#idp78411088">なぜ Micron コンピュータで 3Com PCI ネットワークカードが動かないのでしょう?</a></dt><dt>2.30. <a href="#idp78451408">対称型マルチプロセシング (SMP) をサポートしていますか?</a></dt><dt>2.31. <a href="#idp78454224">ASUS K7V マザーボードのシステムでブートフロッピーを使うと、
            システムがハングアップします。
            対応策はありませんか?
          </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78126800"></a><a id="supported-hard-drives"></a><p><strong>2.1.</strong></p></td><td align="left" valign="top"><p>FreeBSD は、
            どんなハードディスクドライブをサポートしているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は、EIDE と SCSI
            ハードディスクドライブをサポートしています (互換コントローラも含みます。
            次の節参照)。
            また独自の <span class="quote">「<span class="quote">Western Digital</span>」</span>
            インタフェースを使用しているすべてのドライブ (MFM、
            RLL、ESDI、もちろん IDE) もサポートしています。
            独自仕様のインタフェースを使用する
            ESDI コントローラでは動作しないものがあり、
            WD1002/3/6/7
            とその互換インタフェースと衝突します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78133456"></a><a id="supported-scsi-controllers"></a><p><strong>2.2.</strong></p></td><td align="left" valign="top"><p>どの SCSI コントローラをサポートしているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a class="link" href="../handbook/install.html#INSTALL-HW" target="_top">FreeBSD
              ハンドブック</a>に記されている完全なリストを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78135888"></a><a id="supported-cdrom-drives"></a><p><strong>2.3.</strong></p></td><td align="left" valign="top"><p>どんな CD-ROM ドライブをサポートしているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            サポートされている SCSI コントローラに接続できる SCSI
            ドライブは、すべてサポートされています。
          </p><p>
            また、以下の専用 CD-ROM
            インタフェースもサポートしています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ミツミ LU002 (8bit)、LU005 (16bit) および FX001D (16bit 2倍速)。</p></li><li class="listitem"><p>ソニー CDU 31/33A</p></li><li class="listitem"><p>Sound Blaster 非 SCSI タイプの CD-ROM</p></li><li class="listitem"><p>松下/Panasonic CD-ROM</p></li><li class="listitem"><p>ATAPI 互換の IDE CD-ROM</p></li></ul></div><p>
            SCSI でないカードはすべて、SCSI ドライブよりも極めて動作速度が
            遅いことが知られており、ATAPI CD-ROM には動作しないものもあるようです。
          </p><p>
            BSDi の FreeBSD 2.2 CD-ROM からは CD からの直接起動が
            サポートされています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78147536"></a><a id="supported-cdrw-drives"></a><p><strong>2.4.</strong></p></td><td align="left" valign="top"><p>FreeBSD は、どの CD-RW ドライブに対応していますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD は ATAPI 互換の IDE CD-R または CD-RW ドライブで
            あれば対応しています。FreeBSD バージョン 4.0 以降については、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=burncd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">burncd</span>(8)</span></a> のマニュアルをご覧ください。それ以前の
            バージョンの FreeBSD では、
            <code class="filename">/usr/share/examples/atapi</code> にある例を
            ご覧ください。</p><p>また、FreeBSD は SCSI の CD-R または CD-RW ドライブにも
            対応しています。ports または packages から
            <code class="command">cdrecord</code> コマンドをインストールして、
            カーネルに <code class="filename">pass</code> デバイスが組み込まれて
            いることを確認してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78151888"></a><a id="zip-support"></a><p><strong>2.5.</strong></p></td><td align="left" valign="top"><p>ZIP ドライブをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もちろん、
            FreeBSD は SCSI ZIP ドライブ (外付け) をサポートしています。
            ZIP ドライブは SCSI ID を 5 か 6 に設定した状態でなら使用できますが、
            もし SCSI ホストアダプタの BIOS がサポートしてさえいれば
            ZIP ドライブから起動させることもできます。
            どのホストアダプタが SCSI ID を 0 や 1 以外に設定したデバイスから
            起動できるのかはわかりません。そうしたい場合は、アダプタの
            ドキュメントを参照しなければなりません。</p><p>
            ATAPI (IDE) ZIP ドライブは、FreeBSD 2.2.6
            以降のバージョンでサポートされています。
          </p><p>
            バージョン 3.0 以降の FreeBSD では、
            パラレルポート接続の ZIP ドライブをサポートしています。
            最近のバージョンの FreeBSD をお使いでしたら、
            カーネルコンフィグレーションファイルに
            <code class="filename">scbus0</code>、
            <code class="filename">da0</code>、
            <code class="filename">ppbus0</code>、
            <code class="filename">vp0</code>
            の各ドライバが記述されていることを確認してください。
            (GENERIC カーネルには <code class="filename">vp0</code>
            を除くすべてのドライバが含まれています)。
            これらすべてのドライバがあれば、
            パラレルポートのドライブは
            <code class="filename">/dev/da0s4</code>
            となります。
            ディスクは
            <code class="command">mount /dev/da0s4 /mnt</code> とするか
            <code class="command">mount_msdos /dev/da0s4 /mnt</code> (DOS ディスクの場合)
            とすることでマウントできます。
          </p><p>
            それから<a class="link" href="#jaz">リムーバブルドライブに関する注意</a>および、
            <a class="link" href="#disklabel">「フォーマット」に関する注意</a>についても
            確認しておいてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78159312"></a><a id="jaz-zip-removable-support"></a><p><strong>2.6.</strong></p></td><td align="left" valign="top"><p>では、JAZ や EZ、
            それからその他のリムーバブルドライブはサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD では、IDE バージョンの EZ
            ドライブを除くすべての SCSI デバイスは、
            SCSI のディスクと同等に扱われます。
            また IDE EZ は IDE ドライブと同等となります。
          </p><p><a id="jaz"></a>
              システム稼働中のメディア交換について
              FreeBSD がどれほどうまく動くか定かではありません。
              もちろんメディアを入れ替える前にそのドライブのマウントを解除しなければいけないでしょうし、
              FreeBSD がそれらを認識するには、
              起動時に外部ユニットにも電源が投入されていることを確認しなければいけないでしょう。
          </p><p><a class="link" href="#disklabel">「フォーマット」に関する注意</a>も参照のこと。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78167120"></a><a id="multiport-serial-support"></a><p><strong>2.7.</strong></p></td><td align="left" valign="top"><p>どのマルチポートシリアルカードをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一覧は
            <a class="link" href="../handbook/install-hw.html#INSTALL-MISC" target="_top">その他のデバイス</a>の節にあります。
          </p><p>
            無名のカードにもうまく動くものがあり、
            特に AST 互換といわれているものに多く見られます。
          </p><p>
            カード設定の詳細な情報は、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>
            のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78171216"></a><a id="usbkbd"></a><p><strong>2.8.</strong></p></td><td align="left" valign="top"><p>USB キーボードを持っているのですが、FreeBSD で使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            USB デバイスは FreeBSD 3.1 からサポートされましたが、
            実装は FreeBSD 3.2 であってもまだ完全ではないため、
            必ずしも安定して動作するとは限りません。
            もし、それでも USB キーボードを使ってみたいという人は、
            以下の手順を試してみてください。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>FreeBSD 3.2 か、それ以降を使います。</p></li><li class="step"><p>
                カーネルコンフィグレーションファイルに以下の行を追加し、
                カーネルを再構築します。
              </p><pre class="programlisting">device  uhci
device  ohci
device  usb
device  ukbd
options KBD_INSTALL_CDEV</pre><p>FreeBSD 4.0 より前のバージョンでは、
                代わりに次のようにします。</p><pre class="programlisting">controller      uhci0
controller      ohci0
controller      usb0
controller      ukbd0
options         KBD_INSTALL_CDEV</pre></li><li class="step"><p><code class="filename">/dev</code> ディレクトリに移動し、
                次のようにしてデバイスノードを作成します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV kbd0 kbd1</code></strong></pre></li><li class="step"><p><code class="filename">/etc/rc.conf</code> を編集し、
                以下の行を追加します。</p><pre class="programlisting">usbd_enable="YES"
usbd_flags=""</pre></li></ol></div><p>
            システムを再起動させた後、
            AT、USB 両方のキーボードが接続されていれば、
            AT キーボードは <code class="filename">/dev/kbd0</code> に、
            USB キーボードは <code class="filename">/dev/kbd1</code>になります。
            一方、USB キーボードだけが接続されているなら、
            <code class="filename">/dev/ukbd0</code> となります。
          </p><p>
            USB キーボードをコンソールで利用するには、
            それをコンソールドライバに対して明示的に指定する必要があります。
            システムの初期化の際に、次に示すようなコマンドを実行してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</code></strong></pre><p>
            ただし、USB キーボードしか接続されていない場合、それは
            <code class="filename">/dev/kbd0</code> としてアクセスされますので、
            コマンドは次のようにしなければなりません。ご注意ください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kbdcontrol -k /dev/kbd0 &lt; /dev/ttyv0 &gt; /dev/null</code></strong></pre><p>
            上のコマンドは、<code class="filename">/etc/rc.i386</code>
            に追加すると良いでしょう。
          </p><p>
            この設定を一度行なっていれば、
            X 環境でも特に他の設定なしに USB キーボードが利用できます。
          </p><p>
            USB キーボードの活線挿抜 (ホットプラグ機能) は、
            まだおそらくきちんと動作しないと思われます。
            トラブルを避けるためにも、キーボードはシステムを起動させる前に接続しておき、
            シャットダウンするまではずさないようにした方が良いでしょう。
          </p><p>
            詳細については、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ukbd&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ukbd</span>(4)</span></a> のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78188112"></a><a id="busmouse"></a><p><strong>2.9.</strong></p></td><td align="left" valign="top"><p>珍しいバスマウスを持っているのですが、どのように設定すればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は Microsoft、Logitech、
            ATI 等のメーカーから出ているバスマウスと InPort
            バスマウスをサポートしています。FreeBSD 2.X の場合、
            バスマウスのデバイスドライバは GENERIC カーネルに標準で含まれますが、
            FreeBSD 3.X 以降では標準で含まれていません。もしバスマウスのデバイス
            ドライバを含むカーネルを自分で構築する場合には、
            カーネルコンフィグレーションファイルに以下の行が含まれていることを確認してください。</p><p>それは FreeBSD 3.0 を含む、それ以前のリリースの場合は次のとおり、</p><pre class="programlisting">device mse0 at isa? port 0x23c tty irq5 vector mseintr</pre><p>FreeBSD 3.X では、次のとおりです。</p><pre class="programlisting">device mse0 at isa? port 0x23c tty irq5</pre><p>そして FreeBSD 4.X とそれ以降では、次のようになります。</p><pre class="programlisting">device mse0 at isa? port 0x23c irq5</pre><p>
            通常バスマウスには専用のインタフェースカードが附属しています。
            インタフェースカードによってはポートアドレスや割り込み番号を上記の
            設定以外に変更できるかもしれません。詳しくはバスマウスのマニュアルと
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mse&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">mse</span>(4)</span></a> のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78206032"></a><a id="ps2mouse"></a><p><strong>2.10.</strong></p></td><td align="left" valign="top"><p>PS/2 マウス (「マウスポートマウス」、「キーボードマウス」) を
            使うにはどのように設定すればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            あなたが 2.2.5 以降のバージョン FreeBSD を使っているのなら、
            必要なドライバ <code class="filename">psm</code>
            はカーネルに含まれていて有効になっています。
            カーネルは起動時に PS/2 マウスを検出するでしょう。
          </p><p>
            あなたの使っている FreeBSD
            が比較的新しいけれど前のバージョン (2.1.x 以降) のものなら、
            インストールの時に、単にカーネルのコンフィグレーションのメニュー上で
            PS/2 マウスを有効化するだけです、あるいは後で
            <code class="prompt">boot:</code> プロンプト上で
            <code class="option">-c</code> を指定することでもメニューは現れます。
            デフォルトでは無効に設定されていますので、
            明示的に有効化してあげないといけません。
          </p><p>
            あなたの使っている FreeBSD が比較的古いものなら、
            カーネルコンフィグレーションファイルに以下の行を加えて
            カーネルを再コンパイルする必要があります。
          </p><p>
            それは FreeBSD 3.0 を含む、それ以前のリリースでは次のとおり、</p><pre class="programlisting">device psm0 at isa? port "IO_KBD" conflicts tty irq 12 vector psmintr</pre><p>FreeBSD 3.1 を含む、それ以降のリリースでは次のとおり、</p><pre class="programlisting">device psm0 at isa? tty irq 12</pre><p>FreeBSD 4.0 とそれ以降のリリースでは次のとおりです。</p><pre class="programlisting">device psm0 at atkbdc? irq 12</pre><p>
            カーネルの再構築についてよく知らないのであれば、
            <a class="link" href="../handbook/kernelconfig.html" target="_top">カーネルのコンフィグレーション</a>を参照してください。
          </p><p>
            起動時にカーネルが <code class="filename">psm0</code> を検出したら、
            <code class="filename">psm0</code> のエントリが <code class="filename">/dev</code>
            の中にあることを確認してください。それには、以下のようにします。

           </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev; sh MAKEDEV psm0</code></strong></pre><p>

            これは <code class="systemitem">root</code> でログインしているときに行なってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78216272"></a><a id="moused"></a><p><strong>2.11.</strong></p></td><td align="left" valign="top"><p>X Window System 以外の環境でマウスを使うことは可能ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もしデフォルトのコンソールドライバである syscons
            を使っているのであれば、
            テキストコンソール上でマウスを使って、
            テキストのカットアンドペーストができます。
            マウスデーモンである moused を起動し、
            仮想コンソールでマウスポインタを有効にしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>moused -p /dev/xxxx -t yyyy</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>vidcontrol -m on</code></strong></pre><p>
            ここで <em class="replaceable"><code>xxxx</code></em>
            はマウスのデバイス名、
            <em class="replaceable"><code>yyyy</code></em>
            はマウスのプロトコルタイプです。
            サポートされているプロトコルタイプについては
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> のマニュアルページを参照してください。
          </p><p>
            システムを起動する時に自動的に
            moused を起動したい場合には、次のようにします。
            FreeBSD 2.2.1 では以下の変数を
            <code class="filename">/etc/sysconfig</code>
            で設定してください。</p><pre class="programlisting">mousedtype="<em class="replaceable"><code>yyyy</code></em>"
mousedport="<em class="replaceable"><code>xxxx</code></em>"
mousedflags=""</pre><p>
            FreeBSD 2.2.2 以降のバージョンでは
            <code class="filename">/etc/rc.conf</code>
            で以下のように設定します。</p><pre class="programlisting">moused_type="<em class="replaceable"><code>yyyy</code></em>"
moused_port="<em class="replaceable"><code>xxxx</code></em>"
moused_flags=""</pre><p>FreeBSD 3.1 とそれ以降で PS/2 マウスを利用する場合は、
              <code class="literal">moused_enable="YES"</code> を
              <code class="filename">/etc/rc.conf</code> に書き加えるだけです。</p><p>
            また、起動時にすべての仮想端末で、
            標準のコンソールに加えマウスデーモンも使えるようにしたい、
            という場合には、以下の行を
            <code class="filename">/etc/rc.conf</code> に加えます。
          </p><pre class="programlisting">allscreens_flags="-m on"</pre><p>
            FreeBSD 2.2.6 以降の場合で
            比較的新しいシリアルマウスを使っているならば、
            マウスデーモンはマウスのプロトコルタイプを自動判別できます。
            自動判別を試みるには、プロトコルタイプとして
            <code class="literal">auto</code>
            を指定します。
          </p><p>
            マウスデーモンを実行中は、マウスデーモンと他のプログラム
            (たとえば X Window System)
            の間でマウスへのアクセスを調整しなければなりません。
            この問題については <a class="link" href="#x-and-moused" title="8.3.">X とマウス</a>をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78262864"></a><a id="text-mode-cut-paste"></a><p><strong>2.12.</strong></p></td><td align="left" valign="top"><p>マウスを使って、
            テキストコンソールでカットアンドペーストするにはどうしたらよいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            マウスデーモンを起動
            (<a class="link" href="#moused" title="2.11.">前の質問に対する答え</a>を参照してください)
            したあと、
            ボタン 1 (左ボタン) を押しながらマウスを動かして範囲を指定します。
            ボタン 2 (中ボタン) またはボタン 3 (右ボタン) をクリックするとテキスト
            カーソルの位置に選択した範囲のテキストがペーストされます。
          </p><p>
            FreeBSD 2.2.6 以降では、ボタン 2
            をクリックするとペーストされ、ボタン 3
            をクリックした場合に既存の選択範囲が現在のマウスポインタの位置まで
            「延長または短縮」されます。もしマウスに中ボタンがないなら、
            moused のオプションを使って中ボタンのエミュレーションをするか、
            他のボタンを中ボタンとして使う事ができます。
            詳しくは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78266704"></a><a id="usbmouse"></a><p><strong>2.13.</strong></p></td><td align="left" valign="top"><p>USB マウスを持っているのですが、FreeBSD で使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            USB デバイスは FreeBSD 3.1 からサポートされましたが、
            実装は FreeBSD 3.2 であってもまだ完全ではないため、
            必ずしも安定して動作するとは限りません。
            もし、それでも USB マウスを使ってみたいという人は、
            以下の手順を試してみてください。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>FreeBSD 3.2 か、それ以降を使います。</p></li><li class="step"><p>
                カーネルコンフィグレーションファイルに以下の行を追加し、
                カーネルを再構築します。
              </p><pre class="programlisting">device  uhci
device  ohci
device  usb
device  ums</pre><p>FreeBSD 4.0 より前のバージョンでは、
                代わりに次のようにします。</p><pre class="programlisting">controller      uhci0
controller      ohci0
controller      usb0
device          ums0</pre></li><li class="step"><p><code class="filename">/dev</code> ディレクトリに移動し、
                次のようにしてデバイスノードを作成します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV ums0</code></strong></pre></li><li class="step"><p><code class="filename">/etc/rc.conf</code> を編集し、
                以下の行を追加します。</p><pre class="programlisting">moused_enable="YES"
moused_type="auto"
moused_port="/dev/ums0"
moused_flags=""
usbd_enable="YES"
usbd_flags=""</pre><p>moused の設定の詳細については、
                <a class="link" href="#moused" title="2.11.">前項</a>も参照してください。
              </p></li><li class="step"><p>
                X のセッションで USB マウスを使うには、
                <code class="filename">XF86Config</code> を編集する必要があります。
                XFree86 3.3.2、もしくはそれ以降を利用している場合は、
                <span class="emphasis"><em>Pointer</em></span>
                セクションが次のようになっていることを確認してください。
              </p><pre class="programlisting">Device          "/dev/sysmouse"
Protocol        "Auto"</pre><p>
                それより前のバージョンの XFree86 を利用している場合は、
                <span class="emphasis"><em>Pointer</em></span>
                セクションが次のようになっていることを確認してください。
              </p><pre class="programlisting">Device          "/dev/sysmouse"
Protocol        "SysMouse"</pre></li></ol></div><p>X 環境でのマウスの利用については、
            <a class="link" href="#x-and-moused" title="8.3.">他の項</a>も参照してください。
          </p><p>
            USB マウスの活線挿抜 (ホットプラグ機能) は、
            まだおそらくきちんと動作しないと思われます。
            トラブルを避けるためにも、マウスはシステムを起動させる前に接続しておき、
            シャットダウンするまではずさないようにした方が良いでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78298064"></a><a id="mouse-wheel-buttons"></a><p><strong>2.14.</strong></p></td><td align="left" valign="top"><p>わたしのマウスにはホイール機能や便利なボタンがついているのですが、
            これは FreeBSD でも使えるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            答えは残念ながら「場合によります」です。
            こうしたマウスの付加的な機能は大抵の場合、特殊なドライバを必要とします。
            マウスのデバイスドライバやユーザのプログラムが
            そのマウスに対する固有のサポートをしていない場合には、
            標準的な 2 ボタン/3 ボタンマウスのように振舞います。
          </p><p>
            X ウィンドウシステムの環境でのホイールの使い方については、
            <a class="link" href="#x-and-wheel" title="8.4.">X とホイール</a>の項をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78301136"></a><a id="psmerr"></a><p><strong>2.15.</strong></p></td><td align="left" valign="top"><p>
            わたしのマウスはきちんと動いてくれないようです。
            マウスカーソルが画面中をとびまわります。
            このマウスにはホイールがついていて、
            接続は PS/2 ポートです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 3.2 およびそれ以前の PS/2 マウスドライバ psm には、
            Logitech モデル M-S48 とその
            OEM のホイールマウスで不具合が発生します。
            以下のパッチを <code class="filename">/sys/i386/isa/psm.c</code>
            に適用して、カーネルを再構築してください。
          </p><pre class="programlisting">Index: psm.c
===================================================================
RCS file: /src/CVS/src/sys/i386/isa/Attic/psm.c,v
retrieving revision 1.60.2.1
retrieving revision 1.60.2.2
diff -u -r1.60.2.1 -r1.60.2.2
--- psm.c	1999/06/03 12:41:13	1.60.2.1
+++ psm.c	1999/07/12 13:40:52	1.60.2.2
@@ -959,14 +959,28 @@
     sc-&gt;mode.packetsize = vendortype[i].packetsize;

     /* set mouse parameters */
+#if 0
+    /*
+     * A version of Logitech FirstMouse+ won't report wheel movement,
+     * if SET_DEFAULTS is sent...  Don't use this command.
+     * This fix was found by Takashi Nishida.
+     */
     i = send_aux_command(sc-&gt;kbdc, PSMC_SET_DEFAULTS);
     if (verbose &gt;= 2)
 	printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
+#endif
     if (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) {
         sc-&gt;mode.resolution
 	    = set_mouse_resolution(sc-&gt;kbdc,
-	        (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) - 1);
+				   (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) - 1);
+    } else if (sc-&gt;mode.resolution &gt;= 0) {
+	sc-&gt;mode.resolution
+	    = set_mouse_resolution(sc-&gt;kbdc, sc-&gt;dflt_mode.resolution);
+    }
+    if (sc-&gt;mode.rate &gt; 0) {
+	sc-&gt;mode.rate = set_mouse_sampling_rate(sc-&gt;kbdc, sc-&gt;dflt_mode.rate);
     }
+    set_mouse_scaling(sc-&gt;kbdc, 1);

     /* request a data packet and extract sync. bits */
     if (get_mouse_status(sc-&gt;kbdc, stat, 1, 3) &lt; 3) {</pre><p>FreeBSD 3.2
            より新しいリリースではきちんと動作するはずです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78304336"></a><a id="laptop-mouse-trackball"></a><p><strong>2.16.</strong></p></td><td align="left" valign="top"><p>ラップトップ PC のマウス/トラックボール/タッチパッドは使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="#ps2mouse" title="2.10.">前の質問に対する答え</a>と、
            <a class="link" href="#pao">モバイルコンピューティングのページ</a>をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78307408"></a><a id="tape-support"></a><p><strong>2.17.</strong></p></td><td align="left" valign="top"><p>どんなテープドライブをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は SCSI と QIC-36 (QIC-02 インタフェース付き)
            をサポートしています。
            これらには 8-mm (Exabyte と呼ばれています) や DAT ドライブも含まれています。
          </p><p>
            初期の 8-mm ドライブの中には SCSI-2
            とまったく互換性を持たないものがあります。
            これらは FreeBSD 上では動作しません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78314064"></a><a id="tape-changer-support"></a><p><strong>2.18.</strong></p></td><td align="left" valign="top"><p>どんなテープチェンジャーをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.2 は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ch&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ch</span>(4)</span></a> デバイスと <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chio</span>(1)</span></a>
            コマンドを使用した SCSI チェンジャーをサポートしています。
            実際のチェンジャーの制御方法の詳細は、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chio</span>(1)</span></a>
            のマニュアルページを参照してください。
          </p><p>使用している製品が <span class="application">AMANDA</span>
            のようにチェンジャーに対応済みのものでない場合は、
            次のことについて留意してください。
            それらの製品は任意のポイント間のテープの移動を制御するだけなので、
            テープがどのスロットに入っているか、現在ドライブにあるテープが
            どのスロットに戻るべきかを把握しておく必要があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78319184"></a><a id="sound-card-support"></a><p><strong>2.19.</strong></p></td><td align="left" valign="top"><p>どんなサウンドカードをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は SoundBlaster、SoundBlaster Pro、SoundBlaster 16、
            Pro Audio Spectrum 16、AdLib それから Gravis UltraSound サウンドカードを
            サポートしています。MPU-401 やその互換カードも機能に制限はあるものの
            サポートされています。マイクロソフトサウンドシステムのスペックに準拠
            したカードも、<code class="filename">pcm</code> ドライバでサポートされています。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                これらはサウンドについてのみの話です! これらのドライバは
                CD-ROM、SCSI、カード上にあるジョイスティックをサポートしていません
                (SoundBlaster は例外です)。SoundBlaster SCSI インタフェースと非 SCSI
                CD-ROM はサポートしていますが、そのデバイスからは起動できません。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78322640"></a><a id="es1370-silent-pcm"></a><p><strong>2.20.</strong></p></td><td align="left" valign="top"><p><code class="filename">pcm</code>
            ドライバで es1370 から音が出ないのはどうにかなりませんか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>マシンを起動するごとに以下のコマンドを実行してください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mixer pcm 100 vol 100 cd 100</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78325712"></a><a id="network-cards"></a><p><strong>2.21.</strong></p></td><td align="left" valign="top"><p>どんなネットワークカードをサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            より完全な一覧については<a class="link" href="../handbook/install-hw.html#INSTALL-NICS" target="_top">イーサネットカード</a>の節を参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78328400"></a><a id="no-math-coprocessor"></a><p><strong>2.22.</strong></p></td><td align="left" valign="top"><p>数値演算コプロセッサを持っていませんが、何かまずいでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                これらは 386/486SX/486SLC を持っている場合に影響します
                - ほかのマシンでは CPU に内蔵されています。
              </p></div><p>
            一般にこれらは問題とはなりません。
            しかし、数値演算エミュレーションコードのパフォーマンスか、
            正確さのいずれかを選択する状況があります
            (詳しくは <a class="link" href="#emul" title="5.5.">FP
              エミュレーション</a> についての節をご覧ください)。
            とくに、X 上で弧を描く際にとても遅くなることでしょう。
            数値演算コプロセッサを購入されることを強くおすすめします。
            とても役立つことでしょう。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                他の数値演算コプロセッサよりも優れたコプロセッサもあります。
                これは言いにくいことなのですが、Intel を買うために躍起になる人もいないでしょう。
                それが FreeBSD 上で動くという確信がないのなら、クローンにご用心を。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78332496"></a><a id="other-device-support"></a><p><strong>2.23.</strong></p></td><td align="left" valign="top"><p>FreeBSD がサポートするデバイスは他にもあるんでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a class="link" href="../handbook/install-hw.html#INSTALL-MISC" target="_top">FreeBSD
              ハンドブック</a>に記されている、
            サポートされている他のデバイスの一覧を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78334928"></a><a id="power-management-support"></a><p><strong>2.24.</strong></p></td><td align="left" valign="top"><p>パワーマネージメント機能付きのラップトップ PC を持っているのですが…。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD は一部のマシンの <acronym class="acronym">APM</acronym> をサポートしています。
            <code class="filename">LINT</code> カーネルコンフィグファイル の
            <acronym class="acronym">APM</acronym> の部分をご覧ください。
            さらに詳しいことは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=apm&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">apm</span>(4)</span></a> に載っています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78347344"></a><a id="micron-hang-boot"></a><p><strong>2.25.</strong></p></td><td align="left" valign="top"><p>Micron システムが起動時に固まってしまいます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            特定の Micron 製のマザーボードの中には、PCI BIOS が規格通りに
            実装されていないために FreeBSD の起動に失敗するものがあります。
            その BIOS は、PCI デバイスをあるアドレスで設定したと報告するにも
            関わらず、実際にはそうしていないのです。
          </p><p>
            この問題を回避するには、BIOS の
            <span class="quote">「<span class="quote">Plug and Play Operating System</span>」</span>
            を無効に設定してください。また、より詳しい情報は
            <a class="link" href="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron" target="_top">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</a>
            を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78350672"></a><a id="newer-adaptec-support"></a><p><strong>2.26.</strong></p></td><td align="left" valign="top"><p>新しい Adaptec コントローラを持っているのですが、
            FreeBSD が検出できないようです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            新しい AIC789x シリーズの Adaptec チップは、3.0 でデビューした CAM SCSI
            フレームワークでサポートされています。 2.2-STABLE のパッチは
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</a> にあります。
            CAM システムが入っている高機能ブートフロッピーは
            <a class="link" href="http://people.FreeBSD.org/~abial/cam-boot/" target="_top">http://people.FreeBSD.org/~abial/cam-boot/</a> にあります。
            どちらの場合にしても、作業を始める前に <code class="filename">README</code>
            をお読みください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78354384"></a><a id="internal-plugnplay-modem"></a><p><strong>2.27.</strong></p></td><td align="left" valign="top"><p>内蔵の Plug &amp; Play
            モデムを持っているのですが、FreeBSD が検出できないようです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            モデムの PnP ID を シリアルドライバの PnP ID
            リストに追加する必要があるでしょう。
            Plug &amp; Play サポートを有効にするには、
            <code class="literal">controller pnp0</code> をコンフィグレーション
            ファイルに付け加え、
            新しいカーネルをコンパイルしてシステムを再起動してください。
            カーネルは、検出したすべてのデバイスの
            PnP ID を表示します。
            モデムの欄にある PnP ID を <code class="filename">/sys/i386/isa/sio.c</code>
            の 2777 行目くらいにあるテーブルに書き入れてください。
            テーブルを見つけるには、構造体
            <code class="literal">siopnp_ids[]</code> の文字列 <code class="literal">SUP1310</code>
            を探します。
            カーネルを作り直したらインストールし、システムを再起動してください。
            そうすれば、モデムが検出されるはずです。
          </p><p>
            起動時のコンフィグレーションの際に、<code class="literal">pnp</code>
            コマンドを使用して PnP の設定をマニュアルで行なわなければならないかもしれません。
            その場合、モデムを検出させるためのコマンドは</p><pre class="programlisting">pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8</pre><p>のようになります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78359504"></a><a id="serial-console-prompt"></a><p><strong>2.28.</strong></p></td><td align="left" valign="top"><p>シリアルコンソールで boot: プロンプトを表示するにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                  <code class="literal">options COMCONSOLE</code>
                  を指定してカーネルを構築してください。
                </p></li><li class="listitem"><p>
                  そして <code class="filename">/boot.config</code>
                  を作成して <code class="option">-P</code> とだけ書き入れてください。
                </p></li><li class="listitem"><p>その後、キーボードをシステムから抜きます。</p></li></ol></div><p>
            <code class="filename">/usr/src/sys/i386/boot/biosboot/README.serial</code> に、
            これに関する情報が書かれています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78411088"></a><a id="micron-3comnic-failure"></a><p><strong>2.29.</strong></p></td><td align="left" valign="top"><p>なぜ Micron コンピュータで 3Com PCI ネットワークカードが動かないのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            特定の Micron 製のマザーボードの中には、PCI BIOS が規格通りに
            実装されていないために FreeBSD の起動に失敗するものがあります。
            その BIOS は、PCI デバイスをあるアドレスで設定したと報告するにも
            関わらず、実際にはそうしていないのです。
          </p><p>
            この問題を回避するには、BIOS の
            <span class="quote">「<span class="quote">Plug and Play Operating System</span>」</span>
            を無効に設定してください。また、より詳しい情報は
            <a class="link" href="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron" target="_top">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</a>
            を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78451408"></a><a id="smp-support"></a><p><strong>2.30.</strong></p></td><td align="left" valign="top"><p>対称型マルチプロセシング (SMP) をサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>SMP は、3.0-STABLE とそれ以降のリリースでのみサポートされています。
            <span class="emphasis"><em>GENERIC</em></span> カーネルでは SMP は有効化されていませんので、
            SMP を有効化するにはカーネルを再構築する必要があります。
            <code class="filename">/sys/i386/conf/LINT</code> を見て、
            カーネルコンフィグファイルにどのオプションを追加すれば良いのか確かめてください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78454224"></a><a id="asusk7v-boot-failure"></a><p><strong>2.31.</strong></p></td><td align="left" valign="top"><p>ASUS K7V マザーボードのシステムでブートフロッピーを使うと、
            システムがハングアップします。
            対応策はありませんか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>BIOS セットアップで
            <span class="quote">「<span class="quote">起動時のウィルス保護機能</span>」</span> を無効化してください。</p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="troubleshoot"></a>第3章 トラブルシューティング</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        内川 喜章 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yoshiaki@kt.rim.or.jp">yoshiaki@kt.rim.or.jp</a>&gt;</code>、
        1997 年 11 月 10 日</em></span>
    </p><div class="qandaset"><a id="idp78458832"></a><dl><dt>3.1. <a href="#idp78459088">ハードディスクに不良ブロックがあります!</a></dt><dt>3.2. <a href="#idp78487888">Bustek 742a EISA SCSI が認識されません。</a></dt><dt>3.3. <a href="#idp78491856">HP Netserver 上のオンボード SCSI コントローラが認識されません。</a></dt><dt>3.4. <a href="#idp78499280">この CMD640 IDE コントローラはどこかおかしいようです。</a></dt><dt>3.5. <a href="#idp78506960">ed1: timeout
            のようなメッセージがいつも出ます。</a></dt><dt>3.6. <a href="#idp78510416">CDROM をマウントしようとすると
            Incorrect super block と言われます。</a></dt><dt>3.7. <a href="#idp78520656">CDROM をマウントしようとすると
            Device not configured
            と言われます。</a></dt><dt>3.8. <a href="#idp78529616">CDROM をマウントすると、ファイル名中の英数字以外の
            文字が、「?」 と表示されてしまいます。</a></dt><dt>3.9. <a href="#idp78539088">私のプリンタはとてつもなく遅いのです。
            どうしたらよいのでしょう?</a></dt><dt>3.10. <a href="#idp78542928">わたしのプログラムは時々
            Signal 11
            のエラーで止まってしまいます。</a></dt><dt>3.11. <a href="#idp78562000">起動の時に画面が真っ暗になって同期も取れません。</a></dt><dt>3.12. <a href="#idp78572624">128MB の RAM があるのですが、64MB しか認識しません。</a></dt><dt>3.13. <a href="#idp78585040">FreeBSD 2.0 が
            kmem_map too small!
            と言ってパニックします。</a></dt><dt>3.14. <a href="#idp78592080">新しいカーネルで再起動すると
            CMAP busy panic
            となってパニックを起こしてしまいます。
          </a></dt><dt>3.15. <a href="#idp78596176">ahc0: brkadrint,  Illegal Host Access at seqaddr 0x0
            というエラーが出ます</a></dt><dt>3.16. <a href="#idp78599504">sendmail が mail loops back to myself
            というメッセージを出すのですが。</a></dt><dt>3.17. <a href="#idp78611024">リモートマシン上のフルスクリーンアプリケーションがうまく動かない</a></dt><dt>3.18. <a href="#idp78626768">私のマシンで calcru: negative time...
            と表示されるのですが</a></dt><dt>3.19. <a href="#idp78632528">pcm0 not found という表示を見たり
            カーネルコンフィグレーションファイルには device pcm0 と
            書いてあるのにサウンドカードが pcm1 として
            発見されたりします。</a></dt><dt>3.20. <a href="#idp78643152">プラグアンドプレイのカードが認識されなくなりました
            (または、unknown と認識されるようになりました)。</a></dt><dt>3.21. <a href="#idp78661456">top や systat の
            実行中に nlist failed という
            エラーがでます。</a></dt><dt>3.22. <a href="#idp78673360">ssh(1) や telnet(1) でコンピュータに接続する
            のに、どうしてこんなに時間がかかるのですか?</a></dt><dt>3.23. <a href="#idp78685264">file: table is full という
            メッセージが繰り返し dmesg にあらわれます。
          </a></dt><dt>3.24. <a href="#idp78706512">laptop の時間が狂って、大きく進んだり遅れたりします。</a></dt><dt>3.25. <a href="#idp78718928">BIOS 画面が出た後、FreeBSD のブートローダが
            Read error と表示して止まって
            しまいます。
          </a></dt><dt>3.26. <a href="#idp78733392">別のオペレーティングシステムが、ブートマネージャを
            壊してしまいました。どうすれば復旧できるでしょうか。
          </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78459088"></a><a id="awre"></a><p><strong>3.1.</strong></p></td><td align="left" valign="top"><p>ハードディスクに不良ブロックがあります!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            SCSI ディスクの場合は自動的に再マップする機能があるはずです。
            しかし、理解し難い理由から多くのドライブがこの機能が無効化
            されて出荷されています…。
          </p><p>
            これを有効化するには、
            最初のデバイスのモードページを変更する必要があります。
            これは次のコマンドを実行することで、FreeBSD
            上で行なうことができます
            (<code class="systemitem">root</code> 権限で行ないます)。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>scsi -f /dev/rsd0c -m 1 -e -P 3</code></strong></pre><p>
            そして、<acronym class="acronym">AWRE</acronym> と <acronym class="acronym">ARRE</acronym>
            の値を 0 から 1 へ変更します
          </p><pre class="screen">AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</pre><p>
            以下は、<a class="link" href="mailto:tedm@toybox.placo.com" target="_top">Ted
              Mittelstaedt 氏</a>から寄せられたものです。
          </p><p>
            IDE ドライブの場合は通常、不良ブロックは潜在的な障害の兆候です。
            最近の IDE ドライブは、内部の不良ブロック再マッピング機能を有効にした状態で
            出荷されています。また、今日の IDE ハードディスクメーカは、
            出荷以降に不良ブロックが発生することに関して保証を提供していて、
            不良ブロックのあるディスクドライブを交換するサービスを行なっています。
          </p><p>
            もし、不良ブロックのある IDE ディスクドライブを復旧しようと思うなら、
            IDE ドライブメーカが提供する IDE 診断プログラムをダウンロードして、
            そのドライブに使ってみてください。この種のプログラムは大抵、
            ドライブの制御部分に対して不良ブロックを再走査し、
            不良ブロックを使用不能にするようにセットすることができます。
          </p><p>
            ESDI、RLL および MFM ドライブの場合、
            不良ブロックはドライブの正常な部分であり、
            一般的に言って障害を表すものではありません。
            PC では、ディスクドライブコントローラカードと
            BIOS が不良ブロックの使用不能化の作業を行ないます。
            DOS など、ディスクアクセスに BIOS
            を経由する OS にとっては有効に働きますが、FreeBSD
            のディスクドライバは BIOS を利用しません。そのため、
            代替として bad144 という機構が存在します。
            bad144 は、wd ドライバでだけ (つまり FreeBSD 4.0
            ではサポートされていない)動作し、SCSI ドライバに利用することは
            <span class="emphasis"><em>できません</em></span>。bad144 は、
            検出された不良セクタをスペシャルファイルに記録するという機能を持っています。
          </p><p>
            bad144 を利用する上で、注意しなければならない点が一つあります。
            それは、不良ブロックスペシャルファイルは、
            ディスクの最終トラックに置かれるということです。
            このファイルには、ディスクの先頭の付近、
            <code class="filename">/kernel</code>
            ファイルが位置しているであろう部分で発生した不良セクタが記録されています。
            したがって、このファイルは BIOS
            コールを使ってカーネルファイルを読み込む起動プログラムが、
            アクセス可能でなければなりません。
            これはつまり、bad144 を利用するディスクは
            1024 シリンダ、16 ヘッド、63 セクタを超えてはならないということを意味し、
            bad144 を利用したディスクが実質 500MB を超えられないことになります。
          </p><p>
            bad144 を使うには、FreeBSD のインストール時に表示される fdisk 画面で
            <span class="quote">「<span class="quote">Bad Block</span>」</span> 走査を ON に設定するだけです。
            これは、FreeBSD 2.2.7 以降で機能します。
            ディスクは、1024 シリンダ以内でなければなりません。
            ディスクドライブは事前に少なくとも 4 時間、
            ディスクが温度によって膨張し、
            トラックに曲がりが出るまで回転させることをお薦めします
            (訳注: 温度変化に対する膨張によって、
            ディスクが微小変形することにより発生する不良セクタを確実に検出するためです)。
          </p><p>
            大容量の ESDI ドライブのように 1024 シリンダを超えるディスクの場合、
            DOS 上でそのディスクが利用できるよう、
            ESDI コントローラは特殊な変換モードを利用します。
            fdisk の <span class="quote">「<span class="quote">set geometry</span>」</span> コマンドを使って
            <span class="quote">「<span class="quote">変換された (translated)</span>」</span>
            ジオメトリに切替えると、wd ドライバはこの変換モードを解釈できます。
            その際、FreeBSD パーティションを作成するのに
            <span class="quote">「<span class="quote">dangerously dedicated</span>」</span>
            モードを利用してはいけません。
            このモードは、そのようなジオメトリを無視するからです。
            たとえ fdisk がオーバーライドされたジオメトリ情報を使ったとしても、
            依然としてディスクの真の大きさを保持しているため、大きすぎる FreeBSD
            パーティションを作成しようとしてしまうでしょう。
            ディスクジオメトリ情報が変換されたジオメトリ情報にかわっている場合は、
            手動でブロック数を入力し、
            パーティションを作成する必要があります。
          </p><p>
            大容量の ESDI ディスクを ESDI コントローラでセットアップするには、
            ちょっとしたトリックを使います。まず、DOS のディスクで起動して
            そのディスクを DOS パーティションとしてフォーマットします。
            そして FreeBSD を起動し、インストーラの fdisk 画面で
            DOS パーティションのブロックサイズとブロック数を読みとり、メモしておきます。
            ジオメトリ情報を DOS が利用しているものと同一に再設定し、
            DOS パーティションを削除して <span class="quote">「<span class="quote">cooperative</span>」</span> FreeBSD パーティションを
            先程記録したブロックサイズを使って作成してください。
            そのパーティションを起動可能パーティションに設定し、不良ブロック走査を
            有効にします。 実際のインストールでは、ファイルシステムが作成される前に
            bad144 が最初に実行されます (Alt-F2 を押すことで状況を確認できます)。
            不良セクタファイルを作成中に何らかの障害が発生したなら、
            システムを再起動して、もう一度最初からやり直しになります。
            おそらくディスクジオメトリ情報の設定を大きくしすぎているのでしょう
            (やり直しは、DOS によるフォーマットとパーティション確保を含みます)。
          </p><p>
            もし、不良ブロックの再マッピングを有効にしていて不良ブロックが見付かったら、
            ドライブの交換を考えてください。不良ブロックは、時間とともに悪化するからです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78487888"></a><a id="bustek742a-eisa-scsi"></a><p><strong>3.2.</strong></p></td><td align="left" valign="top"><p>Bustek 742a EISA SCSI が認識されません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この情報は 742a のためのものですが、他の Buslogic カードについても
            同様のことが言えます。(Bustek = Buslogic)
          </p><p>
            742a カードには大きくわけて 2 つの「バージョン」が存在します。
            ハードウェアリビジョンの A-G と H 以降です。リビジョンの
            文字はカードの隅にあるアセンブリ番号の後ろにあります。
            742a は二つの ROM チップを持っており、一つは BIOS チップで
            もう一つはファームウェアチップです。FreeBSD はあなたの
            持っているものがどの BIOS バージョンかは問題ありませんが、
            ファームウェアバージョンについては問題となります。
            Buslogic の技術サポート部門に連絡すれば、アップグレード版の
            ROM を送ってくれることでしょう。BIOS チップと
            ファームウェアチップはペアで出荷されます。
            アダプタカードのハードウェアリビジョンにあわせた
            最も新しいファームウェア ROM を使用しなければなりません。
          </p><p>
            リビジョン A-G のカードには、2.41/2.21 までの
            BIOS/ファームウェアのセットを使用することができます。
            リビジョン H 以降のカードには、最新のものである
            4.70/3.37 の BIOS/ファームウェアのセットを
            使用することができます。これらのファームウェアの違いは、
            ファームウェア 3.37 が 「ラウンドロビン方式」
            をサポートしているところからきています。
          </p><p>
            Buslogic のカードには、製造番号も刻印されています。古い
            ハードウェアリビジョンのカードを持っている場合は、Buslogic の RMA
            部門に問い合わせて製造番号を伝えると、新しいハードウェアリビジョンの
            カードに交換することもできます。もしカードが十分新しければ、彼らは
            交換に応じてくれるでしょう。
          </p><p>
            FreeBSD 2.1 は ファームウェアリビジョン 2.21
            以降のものをサポートしています。
            これよりも古いファームウェアリビジョンのものは、
            Buslogic カードとして正常に認識されません。
            しかし、Adaptec 1540 として認識されるかもしれません。
            初期の Buslogic のファームウェアは AHA1540 「互換」モードを
            持っています。しかし、EISA カードにとってこれは
            よいことではありません。
          </p><p>
            古いハードウェアリビジョンのカードを持っていてファームウェア
            2.21 を入手するのであれば、ジャンパ W1 の位置をデフォルトの
            A-B から B-C に合わせる必要があるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78491856"></a><a id="hpnetserver-scsi-failure"></a><p><strong>3.3.</strong></p></td><td align="left" valign="top"><p>HP Netserver 上のオンボード SCSI コントローラが認識されません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            基本的にこれは既知の問題です。HP Netserver マシンの
            EISA オンボード SCSI コントローラは EISA のスロット番号 11
            を占有しますが、「本当の」EISA
            スロットはすべてそれよりも前のアドレスに配置されているのです。
            残念ながら、
            10 番以上の EISA スロットは PCI
            に割り当てられたアドレス空間と衝突し、FreeBSD
            の自動コンフィグレーションは、
            現状ではうまくこの状況を処理できていないのです。
          </p><p>
            ですから現時点での最良の方法は、カーネルオプションの
            <code class="literal">EISA_SLOTS</code> を 12 に変え、
            アドレス空間の衝突がないかの
            ようなふりをさせることです :)
            <a class="link" href="../handbook/kernelconfig.html" target="_top">カーネルの再構築</a>に記述されているようにしてカーネルを再構築してください。</p><p>
            もちろん、これはこのようなマシンにインストールする際に
            「卵が先か、
            鶏が先か」といった問題を生み出すことになります。
            この問題を回避するために、
            <span class="emphasis"><em>ユーザコンフィグ (UserConfig)</em></span>
            の中には特別な仕組みが組み込まれています。
            このとき <span class="quote">「<span class="quote">visual</span>」</span> インタフェースは使用せず、
            コマンドラインインタフェースを使用してください。単純に
          </p><pre class="programlisting">eisa 12
quit</pre><p>
            とプロンプト上から打ち込み、
            後は普通にインストールを行なってください。
            とにかくカスタムカーネルのコンパイルとインストールを行なうことを
            おすすめします。
          </p><p>
            うまくいけば、将来のバージョンではこの問題が解決していることでしょう。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">HP Netserver
                では<code class="literal">危険覚悟の専用ディスク</code>は使用できません。
                詳細については <a class="link" href="#dedicate">この注意事項</a>をご覧ください。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78499280"></a><a id="cmd640-ide"></a><p><strong>3.4.</strong></p></td><td align="left" valign="top"><p>この CMD640 IDE コントローラはどこかおかしいようです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            それは壊れているのです。両方のチャンネルを同時に制御できないのです。
          </p><p>
            現在、このチップを使っているシステムを自動的に検出して、
            うまく動かすためのしくみが使えるようになっています。
            くわしくは wd(4) のマニュアルページを参照してください。
          </p><p>
            CMD640 IDE コントローラを使っているシステムで FreeBSD 2.2.1
            あるいは 2.2.2 を使い、
            かつセカンダリのチャネルを使いたいのであれば、
            <code class="literal">options "CMD640"</code>
            を有効にしてカーネルを作り直してください。
            FreeBSD 2.2.5 以降では、デフォルトでそうなっています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78506960"></a><a id="ed1-timeout"></a><p><strong>3.5.</strong></p></td><td align="left" valign="top"><p><code class="literal">ed1: timeout</code>
            のようなメッセージがいつも出ます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            たぶん IRQ の衝突が原因でしょう (二つのボードが同じ IRQ
            を使用しているなど)。FreeBSD 2.0.5R
            以前はこれに関して寛大で、
            IRQ の衝突があってもネットワークドライバは機能していました。
            しかし 2.0.5R 以降はもはや、IRQ の衝突に寛大ではありません。
            <code class="option">-c</code> オプションをつけて起動し、
            ed0/de0/... のエントリをボードの設定に合わせてください。
          </p><p>
            ネットワークカードの BNC
            コネクタ (訳注: 10BASE-2 タイプのインタフェース)
            を使っている場合、
            デバイスのタイムアウトはターミネーションの不良によっても起きます。
            これをチェックするにはケーブルを外してターミネータを直接 NIC
            に接続します。そしてエラーメッセージが消えるかどうか
            確認します。
          </p><p>
            NE2000 コンパチブルカードのなかには、
            UTP ポートのリンクがなかったりケーブルが接続されていない場合に
            このエラーを出すものがあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78510416"></a><a id="mount-cd-superblock"></a><p><strong>3.6.</strong></p></td><td align="left" valign="top"><p>CDROM をマウントしようとすると
            <code class="literal">Incorrect super block</code> と言われます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>
            にマウントしたいデバイスのタイプを指定する必要があります。
            デフォルトでは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>
            はファイルシステムを
            <code class="literal">ufs</code> とみなします。CDROM のファイルシステムを
            マウントしたいのであれば <code class="option">-t cd9660</code>
            と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a> にオプションをつけて明示する必要があります。
            これはもちろん
            CDROM が ISO 9660 ファイルシステムである場合です。ほとんどの
            CDROM はこの形式です。1.1R の FreeBSD では (訳注: 2.1.5R、
            2.2R でも同様です) 自動的に
            Rock Ridge 拡張 (長いファイル名への対応) をうまく解釈します。
          </p><p>
            CDROM のデバイス <code class="filename">/dev/cd0c</code>
            を
            <code class="filename">/mnt</code>
            にマウントしたい場合の例では、次のようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t cd9660 /dev/cd0c /mnt</code></strong></pre><p>デバイスの名前はインタフェースによっては別の名前になっている
            かもしれないので注意してください
            (<code class="filename">/dev/cd0c</code> はこの場合の例です)。
            オプション <code class="option">-t cd9660</code> によって
            <code class="command">mount_cd9660</code>
            コマンドが実行されることに注意してください。
            このため例は次のようにすることもできます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount_cd9660 /dev/cd0c /mnt</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78520656"></a><a id="cdrom-not-configured"></a><p><strong>3.7.</strong></p></td><td align="left" valign="top"><p>CDROM をマウントしようとすると
            <code class="literal">Device not configured</code>
            と言われます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは 一般的に CDROM ドライブの中に CDROM が入っていないか、
            ドライブがバス上に見えないことを意味します。ドライブに CDROM
            を入れるか、IDE (ATAPI) であれば master/slave
            の状態をチェックしてください。
            また、CDROM ドライブに CDROM
            を入れてから認識するまでには数秒かかりますので、
            少し待ってみてください。
          </p><p>
            SCSI CDROM ではバスリセットへの応答時間が遅いために、
            失敗することがあるかもしれません。
            SCSI CDROM を持っている場合は、
            カーネルコンフィグレーションファイルに以下の行を加えて
            再コンパイルして試してみてください。
          </p><pre class="programlisting">options "SCSI_DELAY=15"</pre><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                現在の GENERIC カーネルでは上の設定はデフォルトになっています。
                問題がある場合は <code class="literal">SCSI_DELAY</code>
                の数値を増やしてみてください。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78529616"></a><a id="cdrom-unicode-filenames"></a><p><strong>3.8.</strong></p></td><td align="left" valign="top"><p>CDROM をマウントすると、ファイル名中の英数字以外の
            文字が、<span class="quote">「<span class="quote">?</span>」</span> と表示されてしまいます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>もっともありそうなのは、その CDROM が
            <span class="quote">「<span class="quote">Joliet</span>」</span> 拡張を利用してファイルおよび
            ディレクトリに関する情報を保存しているということです。この拡張は、
            すべてのファイル名を Unicode の 2 バイト文字で保存するように
            規定しています。現在、FreeBSD カーネルに汎用的な Unicode
            インタフェースを導入する作業が行われていますが、
            まだ完了していません。したがって、CD9660
            ドライバはファイル名の文字を解読できません。</p><p>一時的な解決策として、FreeBSD 4.3R 以降では、CD9660
            ドライバに特別な仕掛けを施して、ユーザーがその場で適切な
            変換表を読み込めるようにしました。一般的なエンコーディングに
            対応したいくつかのモジュールが
            <code class="filename">sysutils/cd9660_unicode</code> port
            で提供されています。</p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">この記述は古くなっています。<a class="link" href="../../../en_US.ISO8859-1/books/faq/disks.html#CDROM-UNICODE-FILENAMES" target="_top">
              英語版の記述</a>をご覧ください。</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78539088"></a><a id="printer-slow"></a><p><strong>3.9.</strong></p></td><td align="left" valign="top"><p>私のプリンタはとてつもなく遅いのです。
            どうしたらよいのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            パラレルインタフェースで、問題はとんでもなく遅いだけであるなら、
            プリンタボートを <span class="quote">「<span class="quote">polled</span>」</span>
            モードに設定してみてください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>lptcontrol -p</code></strong></pre><p>
            HP の新しいプリンタには、
            割り込みモードで使えないものがあるようです
            (完全にわかったわけではありませんが)。
            タイミングの問題のように思われます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78542928"></a><a id="signal11"></a><p><strong>3.10.</strong></p></td><td align="left" valign="top"><p>わたしのプログラムは時々
            <code class="literal">Signal 11</code>
            のエラーで止まってしまいます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Signal 11 エラーはオペレーティングシステムが
            許可を与えていないメモリにアクセスしようとしたときに発生します。
            このようなことがランダムな間隔で起っているようなら、
            注意深く調査していった方が良いです。</p><p>この手の問題はたいていの場合、以下のどちらかです。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>その問題が特定の、
                あなたが自分で開発したアプリケーションでのみ起っているなら、
                あなたのコードにバグがあるのでしょう。</p></li><li class="listitem"><p>それが FreeBSD のベースシステムの一部と関連する問題なら、
                コードにバグがあるということになります。
                しかしほとんどの場合、
                普通の FAQ の読者がそのようなコードを使うようになるずっと前に、
                そういった問題は発見され、修正されているはずです
                (それが -current の役目なのですから)。</p></li></ol></div><p>それが FreeBSD のバグでは「ない」という決定的なケースとして、
            その問題の発生がプログラムをコンパイルしているときであり、
            コンパイル毎に毎回、コンパイラの挙動が変るというものがあります。</p><p>たとえば、あなたが <span class="quote">「<span class="quote">make buildworld</span>」</span> を実行していて、
            コンパイラが ls.c から ls.o をコンパイルしようとしたときに
            コンパイルに失敗したとします。もう一度 <span class="quote">「<span class="quote">make buildworld</span>」</span>
            を実行したときに、まったく同じ場所でコンパイルが失敗したのなら、
            それは build が壊れている (訳注: つまりソースにバグがある)
            と言うことです -- ソースを更新してやりなおしてみてください。
            もしコンパイルが別の場所でしくじっていたら、
            それはハードウェアの問題です。</p><p>あなたのやるべき事は:</p><p>前者の場合は、
            そのプログラムの間違ったアドレスへアクセスしようとしている部分を、
            gdb 等のデバッガで見つけて修正します。</p><p>後者の場合は、
            ハードウェアに問題がないことを確かめる必要があります。</p><p>その一般的な原因として :</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ハードディスクが熱を持ちすぎているかも知れません:
                ケースのファンがちゃんと動いていてディスクを冷やしているか
                確かめてください (たぶん、他の部品も過熱しています)。</p></li><li class="listitem"><p>CPU がオーバーヒートしています:
                CPU をオーバークロックしていませんか? さもなければ
                CPU ファンが死んでいるのかもしれません。
                いずれにせよ、少なくとも問題解決の間では
                ハードウェアが動くべく指定された条件で動かしてください。
                クロックはデフォルトの設定に戻してください。</p><p>もしあなたがクロックアップをしているのなら、
                遅いシステムでも、システムが焼き付いて
                買い換えなければならなくなるよりずっとマシだということを
                覚えておいた方が良いでしょう。
                大きいコミュニティでは特に、
                あなたがそれが安全だと思っているかどうかは関係なく、
                オーバークロックしたシステムに発生した問題には同情的ではありません。</p></li><li class="listitem"><p>怪しいメモリ:
                もし複数の SIMM や DIMM を使っているならそれを全部抜いてから
                各 SIMM や DIMM を別個に組み込んだシステムを立ち上げてることで
                どの DIMM/SIMM が怪しいのか、それとも組合わせが悪いのか
                と問題の幅が狭まります。</p></li><li class="listitem"><p>楽観的すぎるマザーボードの設定:
                ほとんどの場合に標準設定で十分なタイミングを、
                BIOS の設定やマザーボード上のジャンパピンを変えることで、
                さまざまに変更することができます。しかし時には RAM の
                アクセスウェイトを低くしすぎたり <span class="quote">「<span class="quote">RAM Speed: Turbo</span>」</span> や
                その手の BIOS の設定でおかしな挙動が起こることがあります。
                BIOS を標準の設定に戻すというのはいいアイディアですが、
                その前にあなたの設定を書き留めておいた方がいいでしょう。</p></li><li class="listitem"><p>マザーボードへの電源が安定していない。
                もし使っていない I/O ボードやハードディスク、
                CDROM 等があるなら、一旦それらから電源ケーブルを抜き、
                電源が小さな負荷ならなんとか動作するか確認しましょう。
                あるいは別の電源を試してみましょう。
                その時はなるべく、少し容量の大きいもので試しましょう
                (たとえば、今の電源容量が 250W だったら 300W
                のものを試します)。</p></li></ol></div><p>SIG11 FAQ (下に示します) にはこれらの問題のすべてが
            詳しく説明されています。Linux の視点に基づくものですが、
            これも読んでおいた方がいいでしょう。そこではまた、
            メモリのテストを行うソフトウェアや、
            ハードウェアがなぜ問題のあるメモリを見逃してしまうかについても
            議論されています。</p><p>最後に、これらがどれも助けにならなかったら、
            FreeBSD のバグを発見した可能性があります。
            以下の説明を読んで障害報告を送ってください。</p><p>詳細な FAQ は、<a class="link" href="http://www.bitwizard.nl/sig11/" target="_top">
              the SIG11 problem FAQ</a> にあります。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78562000"></a><a id="screen-loses-sync"></a><p><strong>3.11.</strong></p></td><td align="left" valign="top"><p>起動の時に画面が真っ暗になって同期も取れません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは ATI Mach 64 ビデオカードの既知の問題です。
            この問題はカードがアドレス <code class="literal">2e8</code> を使い、
            4 番目のシリアルポートもここを使うということにあります。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a> ドライバのバグ (仕様?) のため、
            4 番目のシリアルポートがなくても、
            通常このアドレスを使う sio3 (4 番目のポートにあたります)
            を無効にしても、ドライバはこのアドレスをさわります。
          </p><p>
            バグが修正されるまでは、次のようにして対処してください。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>起動プロンプトが出たら <code class="option">-c</code> と入力します
                  (これによりカーネルはコンフィグレーションモードに入ります)。
                </p></li><li class="listitem"><p>
                  <code class="filename">sio0</code>,
                  <code class="filename">sio1</code>,
                  <code class="filename">sio2</code>,
                  <code class="filename">sio3</code> (これらすべて) を無効にします。
                  これによって <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a> ドライバは動作しなくなりますが、問題はありません。
                </p></li><li class="listitem"><p>exit と入力して起動を続行します。</p></li></ol></div><p>
            もしシリアルポートを有効にしたいのであれば以下の変更を行なって
            新しいカーネルを作る必要があります。
            <code class="filename">/usr/src/sys/i386/isa/sio.c</code> の中で 1 ヵ所ある
            <code class="literal">0x2e8</code> という文字列を探し、
            この文字列とその手前にあるコンマを削除します
            (後ろのコンマは残します)。
            後は通常の手続きにしたがって新しいカーネルを作ります。
          </p><p>
            この対処を行なった後でもまだ
            X ウィンドウシステムはうまく動かないかもしれません。
            その場合は、
            使用している XFree86 がすくなくとも XFree86 3.3.3
            以降であることを確かめてください。
            それ以降のバージョンでは、
            Mach64 カードやそれらのカードのためにつくられた
            X サーバ の組込みをサポートします。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78572624"></a><a id="reallybigram"></a><p><strong>3.12.</strong></p></td><td align="left" valign="top"><p>128MB の RAM があるのですが、64MB しか認識しません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD がメモリのサイズを BIOS から取得する方法の制限により、
            KB 単位で 16 ビット分までしか検出できません (すなわち最大
            65535KB=64MB です。これより少ない場合もあります。
            ある BIOS の場合はメモリサイズが 16MB に制限されます)。
            64MB 以上のメモリを積んでいる場合、
            FreeBSD はそれを検出しようとします。
            しかしその試みは失敗するかもしれません。
          </p><p>
            この問題を回避するには、
            以下に示すカーネルオプションを使用する必要があります。
            完全なメモリ情報を BIOS から取得する方法もありますが、
            起動ブロックに空きが無いため実装できません。
            起動ブロックの問題が解決されれば、
            いつか拡張 BIOS 機能を使用して完全なメモリ情報を取得できるようになるでしょう。
            とりあえず現在は、カーネルオプションを使ってください。
          </p><p><code class="literal">options "MAXMEM=n"</code></p><p>
            <em class="replaceable"><code>n</code></em> には、
            キロバイト単位でメモリの量を指定します。128MB
            の場合は、<code class="literal">131072</code> となります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78585040"></a><a id="panic-kmemmap-too-small"></a><p><strong>3.13.</strong></p></td><td align="left" valign="top"><p>FreeBSD 2.0 が
            <code class="literal">kmem_map too small!</code>
            と言ってパニックします。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">メッセージは、<code class="literal">mb_map too small!</code>
                の場合もあります。
              </p></div><p>
            このパニックは、ネットワークバッファ (特に mbuf
            クラスタ) の仮想メモリが無くなったことを示します。
            以下のオプションをカーネルコンフィグファイルに追加して
            mbuf クラスタに使用できる仮想メモリの量を増やしてください。
          </p><p><code class="literal">options "NMBCLUSTERS=n"</code></p><p>
            <em class="replaceable"><code>n</code></em>
            には、
            同時に使用したい TCP コネクションの数に応じて
            512 から 4096 までの数値を指定できます。
            とりあえず 2048 を試してみるのをおすすめします。
            これでパニックは完全の予防できるはずです。
            mbuf クラスタの割り当て、使用状況については、
            <code class="command">netstat -m</code> で知ることができます
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> をご覧ください)。
            <code class="literal">NMBCLUSTERS</code> のデフォルト値は
            <code class="literal">512 + MAXUSERS * 16</code> です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78592080"></a><a id="cmap-busy-panic"></a><p><strong>3.14.</strong></p></td><td align="left" valign="top"><p>新しいカーネルで再起動すると
            <code class="literal">CMAP busy panic</code>
            となってパニックを起こしてしまいます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ファイル <code class="filename">/var/db/kvm_*.db</code>
            において範囲外のデータを検出するためのロジックは失敗することがあり、
            こうした矛盾のあるファイルを使用することでパニックを引き起こすことがあります。
          </p><p>
            これが起こったなら、シングルユーザで再起動した後に、
            以下のコマンドを実行してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm /var/db/kvm_*.db</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78596176"></a><a id="brkadrint-illegal-host-access"></a><p><strong>3.15.</strong></p></td><td align="left" valign="top"><p><code class="literal">ahc0: brkadrint,  Illegal Host Access at seqaddr 0x0</code>
            というエラーが出ます</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは Ultrastor SCSI Host Adapter と衝突しています。
          </p><p>
            起動時に kernel configuration メニューに入り、
            問題を起こしている
            <code class="filename">uha0</code>
            を disable にしましょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78599504"></a><a id="mail-loopback"></a><p><strong>3.16.</strong></p></td><td align="left" valign="top"><p>sendmail が <code class="literal">mail loops back to myself</code>
            というメッセージを出すのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この事は、sendmail FAQ に次のように書いてあります。
          </p><div class="literallayout"><p>〓〓〓〓〓〓〓〓*〓"Local〓configuration〓error"〓というメッセージが出ます。たとえば:<br />
<br />
〓〓〓〓〓〓〓〓553〓relay.domain.net〓config〓error:〓mail〓loops〓back〓to〓myself<br />
〓〓〓〓〓〓〓〓554〓&lt;user@domain.net&gt;...〓Local〓configuration〓error<br />
<br />
〓〓〓〓〓〓〓〓のような物ですが、どのようにしたらこの問題を解決できますか?<br />
<br />
〓〓〓〓〓〓〓〓これは、たとえば〓domain.net〓のようなドメイン宛てのメールを〓MX〓record〓で<br />
〓〓〓〓〓〓〓〓特定のホスト〓(ここでは〓relay.domain.net)〓に送ろうとしたのに、<br />
〓〓〓〓〓〓〓〓そのホストでは〓domain.net〓宛てのメールを受け取れるような設定に<br />
〓〓〓〓〓〓〓〓なっていない場合です。設定の際に〓FEATURE(use_cw_file)〓を<br />
〓〓〓〓〓〓〓〓指定してある場合には〓/etc/sendmail.cw〓の中に〓domain.net〓を<br />
〓〓〓〓〓〓〓〓追加してください。もしくは、/etc/sendmail.cf〓の中に<br />
〓〓〓〓〓〓〓〓"Cw〓domain.net"〓を追加してください。<br />
〓〓〓〓〓〓〓〓〓〓〓〓</p></div><p>
            もはや現在の
            <a class="link" href="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq" target="_top">sendmail FAQ</a>
            は sendmail release とは一緒には保守されていません。
            しかし次のネットニュースに定期的に投稿されてます。
            <a class="link" href="news:comp.mail.sendmail" target="_top">comp.mail.sendmail</a>、
            <a class="link" href="news:comp.mail.misc" target="_top">comp.mail.misc</a>、
            <a class="link" href="news:comp.mail.smail" target="_top">comp.mail.smail</a>、
            <a class="link" href="news:comp.answers" target="_top">comp.answers</a>、
            <a class="link" href="news:news.answers" target="_top">news.answers</a>。
            また、メール経由でコピーを入手する場合は
            <a class="link" href="mailto:mail-server@rtfm.mit.edu" target="_top">mail-server@rtfm.mit.edu</a>
            宛まで本文に <code class="literal">send usenet/news.answers/mail/sendmail-faq</code>
            と書いて送ります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78611024"></a><a id="remote-fullscreen"></a><p><strong>3.17.</strong></p></td><td align="left" valign="top"><p>リモートマシン上のフルスクリーンアプリケーションがうまく動かない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            リモートマシンのターミナルタイプが FreeBSD
            のコンソールで必要とされている <code class="literal">cons25</code>
            以外のものです。
          </p><p>この問題を解決しうる方法はいろいろあります:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>リモートマシンにログインした後、
                  そのリモートマシンが
                  <code class="literal">ansi</code> か
                  <code class="literal">sco</code>
                  のターミナルタイプを知っているなら、
                  shell 変数の TERM にそれらのいずれかを設定します。
                </p></li><li class="listitem"><p>FreeBSD のコンソール側で
                  <span class="application">screen</span>
                  のような VT100 エミュレータを使用します。
                  <span class="application">screen</span>
                  は一つのターミナルの中で複数のセッションを並列動作させることができますし、
                  本来の機能も優れています。
                  各々の <span class="application">screen</span> のウィンドウは
                  VT100 ターミナルのように振る舞うので、
                  リモート側で設定されるべき TERM 変数は
                  <code class="literal">vt100</code> となります。
                </p></li><li class="listitem"><p>リモートマシンのターミナルデータベースに
                  <code class="literal">cons25</code>
                  のエントリをインストールします。
                  このインストール方法はリモートマシンのオペレーティングシステムに依存します。
                  リモートのシステムのシステム管理マニュアルが役に立つことでしょう。
                </p></li><li class="listitem"><p>FreeBSD 側で X サーバを起動して、
                  リモートマシンに <code class="command">xterm</code>
                  や <code class="command">rxvt</code>
                  のような X ベースのターミナルエミュレータを使ってログインします。
                  (訳注: 日本語が必要な場合は <code class="command">kterm</code> 等を
                  利用します)
                  リモートホストの TERM 変数は
                  <code class="literal">xterm</code> もしくは
                  <code class="literal">vt100</code> (訳注: もしくは <code class="literal">kterm</code>)
                  に設定します。
                </p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78626768"></a><a id="calcru-negative"></a><p><strong>3.18.</strong></p></td><td align="left" valign="top"><p>私のマシンで <code class="literal">calcru: negative time...</code>
            と表示されるのですが</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは、割り込みに関連するさまざまな不具合によって発生します。
            あるいは、あるデバイスが元々持っているバグが表面化したのかも知れません。
            この症状を再現させる一つの方法として、パラレルポート上で、
            TCP/IP を 大きな MTU
            で走らせるというものがあります。
            グラフィックアクセラレータがこの症状を起こすことがありますが、
            その場合はまず、カードの割り込み設定を確認してください。
          </p><p>
            この問題の副作用として、
            プロセスが <span class="quote">「<span class="quote">SIGXCPU exceeded cpu time limit</span>」</span>
            というメッセージとともに終了してしまう、というものがあります。</p><p>
            1998 年 11 月 29 日に公開された FreeBSD 3.0 以降で
            この問題が解決しないなら、次の sysctl 変数をセットしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.method=1</code></strong></pre><p>
            これは、パフォーマンスへ強い影響を与えますが、
            問題の発生に比べればおそらく気にならない程度でしょう。
            もし、これでもまだ問題が残るようなら、
            カーネルオプションの <code class="literal">NTIMECOUNTER</code>
            を大きな値に増やしてください。
            <code class="literal">NTIMECOUNTER=20</code>
            にまで増やしても解決しない場合は、
            計時処理の信頼性が保てない程の割り込みが、
            そのマシン上で起こっていることを意味します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78632528"></a><a id="pcm0-not-found"></a><p><strong>3.19.</strong></p></td><td align="left" valign="top"><p><code class="literal">pcm0 not found</code> という表示を見たり
            カーネルコンフィグレーションファイルには <code class="literal">device pcm0</code> と
            書いてあるのにサウンドカードが <code class="literal">pcm1</code> として
            発見されたりします。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは FreeBSD 3.x で PCI のサウンドカードを使っているときに
            発生します。<code class="literal">pcm0</code> デバイスは ISA
            のカード専用に予約されているものです。このため、
            あなたが PCI カードを持っているときはこのエラーが表示され、
            カードは <code class="literal">pcm1</code> として検出されます。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">この警告を、単にカーネルコンフィグファイルの当該行を
                <code class="literal">device pcm1</code> に変更することで
                抑制することはできません。その時は <code class="literal">pcm1</code>
                が ISA カードのために予約され、PCI のカードは
                <code class="literal">pcm2</code> として
                (<code class="literal">pcm1 not found</code> の警告とともに)
                検出されます。</p></div><p>
            PCI のサウンドカードを持っているのならば、以下のようにして
            <code class="literal">snd0</code> デバイスのかわりに <code class="literal">snd1</code>
            を作る必要があります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV snd1</code></strong></pre><p>この状況は FreeBSD 4.x では生じません。多くの努力の結果より
            <span class="emphasis"><em>PnP 中心</em></span>に作り替えられ、
            現在、<code class="literal">pcm0</code> デバイスは ISA
            カード専用に予約されたものではなくなりました。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78643152"></a><a id="pnp-not-found"></a><p><strong>3.20.</strong></p></td><td align="left" valign="top"><p>プラグアンドプレイのカードが認識されなくなりました
            (または、<code class="literal">unknown</code> と認識されるようになりました)。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>現在の FreeBSD 4.x はより <span class="emphasis"><em>PnP 中心</em></span>に
            なっています。その副作用の影響で、FreeBSD 3.x で動いていた PnP デバイス
            (たとえばサウンドカードや内蔵モデム) の中には、
            動かなくなってしまったものもあります。</p><p>この挙動の原因は Peter Wemm が freebsd-questions
            メーリングリストに書いた、以下の
            「FreeBSD 4.x にアップグレードしたところ内蔵モデムが
            見つからなくなった」というメールで解説されています。
            (わかりやすくするために <code class="literal">[]</code> 内に
            コメントを加えました)。</p><div class="blockquote"><blockquote class="blockquote"><p>PnP BIOS はあらかじめ、[モデムを]
              ポート空間に存在しているかのように設定します。
              そのため [3.x では] 従来の手法に基づく ISA
              デバイスの検索により、モデムの存在を「発見」できます。
            </p><p>4.0 の ISA コードは、より PnP 中心になっています。
              [3.x では] ISA デバイスの検索が「はぐれた」デバイスを発見して、
              次に PNP デバイス ID のマッチが行なわれることでリソースの競合が発生し、
              デバイスの検索に失敗する可能性があります。
              したがって、4.0 の ISA コードでは
              二重に検索しないよう、プログラマブルなカードを
              最初に無効にしています。
              これは、対応している PnP ハードウェアの PnP ID が、
              予めわかっている必要がある、ということを意味します。
              ユーザがこの挙動にもっと手を入れられるようにすることが
              TODO リスト中にあげられています。</p></blockquote></div><p>3.0 で動作していたデバイスを 4.0 でも動作するようにするには、
            それの PnP ID を調べ、ISA デバイスの検索が
            PnP デバイスの識別に使っているリストにそれを追加する必要があります。
            デバイスの検索に使われる <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> を用いて、
            PnP ID を得ることができます。
            たとえば、内蔵モデムに関する <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> の出力は、
            以下のようになります。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pnpinfo</code></strong>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</pre><p>[more TAG lines elided]</p><pre class="screen">
TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</pre><p>必要な情報は、出力の冒頭にある
            <span class="quote">「<span class="quote">Vendor ID</span>」</span> 行にあります。
            かっこの中の 16 進数 (例の中では 0x3024a341) が PnP ID で、
            直前の文字列 (PMC2430) はユニークな ASCII ID です。
            この情報はファイル <code class="filename">/usr/src/sys/isa/sio.c</code> に
            追加する必要があります。</p><p>まず失敗したときに備えて <code class="filename">sio.c</code> の
            バックアップを取るべきです。障害報告を送るために修正パッチを
            作る時にも必要になるでしょう (send-pr しようとしていますよね?)。
            <code class="filename">sio.c</code> を編集して以下の行を探してください。</p><pre class="programlisting">static struct isa_pnp_id sio_ids[] = {</pre><p>そしてあなたのデバイスのエントリを追加する正しい場所を探します。
            エントリは以下のような形をしていて、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> の
            出力にある <span class="emphasis"><em>デバイスの説明</em></span>の全部
            (もし収まれば) か一部とともに行の右の方のコメント領域に書かれている
            ASCII ベンダ ID でソートされています。</p><pre class="programlisting">{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</pre><p>あなたのデバイスの16進数のベンダ ID を正しい場所に
            追加し、ファイルをセーブしてカーネルを作り直して再起動します。
            あなたのデバイスは FreeBSD 3.x の時と同じように
            <code class="literal">sio</code> として見つかるようになっているはずです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78661456"></a><a id="nlist-failed"></a><p><strong>3.21.</strong></p></td><td align="left" valign="top"><p><code class="command">top</code> や <code class="command">systat</code> の
            実行中に <span class="errorname">nlist failed</span> という
            エラーがでます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このエラーは、
            実行しようとしたアプリケーションが
            あるカーネルシンボルを検索した結果、
            何らかの理由でその検索に失敗した、ということを意味しています。
            これは、以下に示すいずれかの理由によるものです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>カーネルとユーザランドが同期していない (つまり
                カーネルは新しいものを構築したが、
                <code class="buildtarget">installworld</code> は行なっていない。
                あるいはその逆) ので、
                シンボルテーブルがユーザアプリケーションの考えているものと異なっている。
                もしこのケースなら、一連のアップグレード手順に従ってアップグレードを行なってください
                (正しいやり方は <code class="filename">/usr/src/UPDATING</code>
                に書いてあります)。</p></li><li class="listitem"><p>カーネルをロードするのに
                <code class="command">/boot/loader</code> を使わず、
                直接 boot2 (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a> 参照) からロードしている。
                もちろん
                <code class="command">/boot/loader</code>
                を使わなくとも問題はないのですが、
                <code class="command">/boot/loader</code> は一般的に、
                ユーザアプリケーションからカーネルシンボルを
                アクセスできるようにするための機能を持っています。</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78673360"></a><a id="connection-delay"></a><p><strong>3.22.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> でコンピュータに接続する
            のに、どうしてこんなに時間がかかるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>症状: TCP コネクションが確立してから、
            クライアントソフトウェアがパスワードを尋ねてくるまで
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> の場合は、ログインプロンプトが表示されるまで)
            に長い時間がかかる、というもの。</p><p>問題: おそらく、サーバソフトウェアがクライアントの
            IP アドレスからホスト名を解決しようとして、遅れが生じている
            のでしょう。FreeBSD に付属する SSH や Telnet を含む多くの
            サーバソフトウェアは、この名前解決をおこないます。これは、
            管理者が後日参照するログファイルに、その他の情報と一緒に
            ホスト名を記録できるようにするのが目的です。</p><p>対処法: もし、あなたのコンピュータ (クライアント)
            からどのサーバに接続する場合にも問題が起こるのであれば、
            クライアントに問題があります。そして、誰かがあなたの
            コンピュータ (サーバ) に接続するときだけ問題が起こるのであれば、
            そのサーバの問題です。</p><p>問題がクライアントにある場合、唯一の対処法は
            サーバがそのクライアントの名前を解決できるように DNS を修正することです。
            症状がローカルネットワークで発生しているなら、サーバの設定に
            原因がありますので、このまま続きを読みましょう。
            そうではなく、グローバルなインターネット環境で発生しているなら、
            ISP に連絡して問題の修正をお願いしなければならない可能性が高いでしょう。</p><p>問題がサーバにあって、症状がローカルネットワークで
            発生しているなら、ローカルのアドレス範囲にあるアドレスを、
            それに対応するホスト名に解決する問合せを処理できるように、
            サーバを設定する必要があります。
            詳しくは、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a> および <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>
            のマニュアルをご覧ください。グローバルなインターネット環境の場合は、
            サーバのリゾルバが正しく動作していないのが原因かもしれません。
            確認するには、他のホスト (たとえば
            <code class="systemitem">www.yahoo.com</code>) を引いてみてください。
            うまくいかなければ、あなたのコンピュータの問題です。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78685264"></a><a id="file-table-full"></a><p><strong>3.23.</strong></p></td><td align="left" valign="top"><p><span class="errorname">file: table is full</span> という
            メッセージが繰り返し dmesg にあらわれます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            このエラーは、システムのファイル記述子を使い果たして
            しまった時に発生します。メモリ中のファイルテーブルが一杯に
            なっているのです。
          </p><p>解決法:</p><p>
            手動で sysctl 変数
            <code class="varname">kern.maxfiles</code> の限界値を調整します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.maxfiles=n</code></strong></pre><p><code class="varname">n</code> は、システム要件に合わせてください。
            オープンされたファイル、ソケットまたは fifo のそれぞれが
            ファイル記述子を消費します。規模の大きなサーバは、
            同時に実行されるサービスに応じて、いともたやすく何万もの
            ファイル記述子を要求します。</p><p>カーネルに設定されたデフォルトのファイル記述子の
            数を決定するのは、次の</p><pre class="programlisting">maxusers        32</pre><p>カーネル設定ファイルの <code class="varname">maxusers</code> 行
            です。<code class="varname">kern.maxfiles</code> はこの値に比例して
            増加します。
          </p><p>現在設定されている <code class="varname">kern.maxfiles</code> の
            値は、次のコマンドで調べることができます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.maxfiles</code></strong>
kern.maxfiles: 1064
          </pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78706512"></a><a id="laptop-clock-skew"></a><p><strong>3.24.</strong></p></td><td align="left" valign="top"><p>laptop の時間が狂って、大きく進んだり遅れたりします。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>laptop には二つ以上の時計が内蔵されていますが、FreeBSD
            が間違った方を選択して使用しています。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dmesg</span>(8)</span></a> を実行して
            <code class="literal">Timecounter</code> を含む行を確認してください。
            最後に出力された行が FreeBSD が選択したもので、まず間違い
            なく <code class="literal">TSC</code> でしょう。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dmesg | grep Timecounter</code></strong>
Timecounter "i8254"  frequency 1193182 Hz
Timecounter "TSC"  frequency 595573479 Hz</pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a> 変数
            <code class="literal">kern.timecounter.hardware</code> を確認すれば
            裏付けがとれます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.timecounter.hardware</code></strong>
kern.timecounter.hardware: TSC</pre><p>バッテリ駆動している時に、BIOS が CPU の速度を変えるために
            TSC クロックを変更したり、電力節約モードに入ることがあります。
            しかし、FreeBSD はそういった調整を関知しないので、
            時間が早まったり遅れたりするようです。</p><p>上記の例では、<code class="literal">i8254</code> クロックも利用できます。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a> 変数 <code class="literal">kern.timecounter.hardware</code>
            にその名称を書き込んで選択できます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.hardware=i8254</code></strong>
kern.timecounter.hardware: TSC -&gt; i8254</pre><p>これで、laptop はより正確な時間を刻むでしょう。</p><p>この変更を起動時に自動で行うには、次の行を
            <code class="filename">/etc/sysctl.conf</code> に追加してください。</p><pre class="programlisting">kern.timecounter.hardware=i8254</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78718928"></a><a id="boot-read-error"></a><p><strong>3.25.</strong></p></td><td align="left" valign="top"><p>BIOS 画面が出た後、FreeBSD のブートローダが
            <span class="errorname">Read error</span> と表示して止まって
            しまいます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD のブートローダがハードディスクのジオメトリを正しく
            認識していないようです。FreeBSD のスライスを
            fdisk によって手動で作成したり変更したりする際に、
            ジオメトリを誤って指定してしまったのでしょう。
          </p><p>ハードディスクのジオメトリの正しい値は、マシンの BIOS から
            得られます。そのハードディスクのシリンダ、ヘッド、セクタの
            数を探してください。
          </p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> の fdisk において、
            <span class="keycap"><strong>G</strong></span> を入力してハードディスクのジオメトリを
            設定してください。
	  </p><p>シリンダ、ヘッド、セクタの数を入力するダイアログが出てきます。
            BIOS から得た値を斜線 (/) で区切って入力してください。
          </p><p>5000 シリンダ、250 ヘッド、60 セクタなら、
            <strong class="userinput"><code>5000/250/60</code></strong>
	    と入力します。
          </p><p>リターンキーを押して値を設定してください。それから
            <span class="keycap"><strong>W</strong></span> を入力してハードディスクに新しいパーティ
            ションテーブルを書き込んでください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78733392"></a><a id="bootmanager-restore"></a><p><strong>3.26.</strong></p></td><td align="left" valign="top"><p>別のオペレーティングシステムが、ブートマネージャを
            壊してしまいました。どうすれば復旧できるでしょうか。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> を立ち上げて Configure (設定)、Fdisk
            の順に選択してください。ブートマネージャが置かれていた
            ディスクを選択して、<span class="keycap"><strong>スペース</strong></span>キーを
            押してください。<span class="keycap"><strong>W</strong></span> を押して変更を
            ディスクに書き込んでください。どのブートローダを
            インストールするか尋ねられます。ここで選択すれば戻せます。
          </p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="commercial"></a>第4章 商用アプリケーション</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        山下 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:junkun@esys.tsukuba.ac.jp">junkun@esys.tsukuba.ac.jp</a>&gt;</code>、
        1997 年 11 月 10 日</em></span></p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
          この章はまだまだ情報が足りません。
          情報を追加してくれるような企業を待ち望んでいます。
          FreeBSD グループはここに載っている企業からの金銭的な支援を期待してはいませんので、
          奉仕作業の一つとして掲載しています (そして
          FreeBSD が係わる宣伝は、長い目で見ると FreeBSD
          に対してよい方向へ働くと思っています)。
          私たちは商用ソフトウェアベンダに、
          ここで製品を宣伝してもらうことを望んでいます。詳しくは、
          <a class="link" href="http://www.FreeBSD.org/commercial/commercial.html" target="_top">商用ソフトウェアベンダ覧のページ</a>をご覧ください。</p></div><div class="qandaset"><a id="idp78740304"></a><dl><dt>4.1. <a href="#idp78740560">FreeBSD 用のオフィススイートはどこで入手できますか?</a></dt><dt>4.2. <a href="#idp78748112">FreeBSD 用の Motif はどうやったら手に入りますか</a></dt><dt>4.3. <a href="#idp78783824">FreeBSD 用の CDE はどうやったら手に入りますか</a></dt><dt>4.4. <a href="#idp78792528">高機能な商用 X サーバってあるんですか?</a></dt><dt>4.5. <a href="#idp78826704">FreeBSD 用のデータベースシステムはありますか?</a></dt><dt>4.6. <a href="#idp78830544">Oracle を FreeBSD 上で動かすことはできますか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78740560"></a><a id="officesuite"></a><p><strong>4.1.</strong></p></td><td align="left" valign="top"><p>FreeBSD 用のオフィススイートはどこで入手できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.wccdrom.com" target="_top">BSDi</a>
                は FreeBSD ネイティブ版の <a class="link" href="http://www.vistasource.com" target="_top">VistaSource</a>
                ApplixWare 5 を提供しています。</p><p>ApplixWare は、豪華で機能満載の FreeBSD 向けの
                商用オフィススイートで、ワードプロセッサ、表計算、
                プレゼンテーションソフトウェア、ベクタ描画ソフトウェア、
                その他のアプリケーションを揃えています。</p><p>FreeBSD 版の ApplixWare の購入は <a class="link" href="http://www.wccdrom.com/titles/freebsd/applix.phtml" target="_top">
                こちら</a>からどうぞ。</p></li><li class="listitem"><p>Linux 版の <a class="link" href="http://www.sun.com/staroffice" target="_top">StarOffice</a>
                は FreeBSD で完璧に動作します。Linux 版の StarOffice
                をインストールするもっとも簡単な方法は、<a class="link" href="../handbook/ports.html" target="_top">FreeBSD Ports
                  コレクション</a>を利用することです。
                また、オープンソースの
                <a class="link" href="http://www.openoffice.org" target="_top">OpenOffice</a>
                も将来のバージョンで動作するでしょう。</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78748112"></a><a id="motif"></a><p><strong>4.2.</strong></p></td><td align="left" valign="top"><p>FreeBSD 用の Motif はどうやったら手に入りますか</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 用の廉価版 ELF Motif 2.1.20 (i386 版、Alpha 版)
            に関する情報は<a class="link" href="#apps2go">Apps2go</a> から
            手に入れることができます。<a id="apps2go"></a>
          </p><p>
            この製品には、「開発者版 (development edition)」 と、
            より安価な「ランタイム版 (runtime edition)」
            の二つの版があります。これらの製品は以下の物が含まれています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>OSF/Motif manager、xmbind、panner、wsm。
                </p></li><li class="listitem"><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake
                  ファイルといった開発者向けキット
                </p></li><li class="listitem"><p>FreeBSD 3.0 以降で利用できる ELF 版スタティックライブラリ、
                  およびダイナミックライブラリ
                </p></li><li class="listitem"><p>デモンストレーションプログラム
                </p></li></ul></div><p>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください (あなたの欲しいアーキテクチャを指定するのも
            忘れないでください!)。NetBSD や OpenBSD 用の Motif もまた、
            <span class="emphasis"><em>Apps2go</em></span>から販売されています。現在、FTP による
            ダウンロードのみ利用可能です。
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">より詳しい情報は</span></dt><dd><p><a class="link" href="http://www.apps2go.com/" target="_top">Apps2go WWW page</a></p></dd><dt><span class="term">問い合わせは</span></dt><dd><p><a class="link" href="mailto:sales@apps2go.com" target="_top">Sales</a> または
                    <a class="link" href="mailto:support@apps2go.com" target="_top">Support</a> 電子メールアドレス。</p></dd><dt><span class="term">もしくは</span></dt><dd><p>phone (817) 431 8775  or +1 817 431-8775</p></dd></dl></div><p>
            他の FreeBSD 用 Motif 2.1 (ELF 版、a.out 版) に関する情報は
            <a class="link" href="#metrox">Metro Link</a> から手に入れることができます。
          </p><p>この製品は以下の物が含まれています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>OSF/Motif manager、xmbind、panner、wsm。
                </p></li><li class="listitem"><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake
                  ファイルといった開発者向けキット
                </p></li><li class="listitem"><p>スタティックライブラリ、およびダイナミックライブラリ。
                  (FreeBSD 3.0 以降で利用できる ELF 版か、
                  FreeBSD 2.2.8 以前で利用できる a.out 版を指定してください)
                </p></li><li class="listitem"><p>デモンストレーションプログラム
                </p></li><li class="listitem"><p>整形済みのマニュアルページ</p></li></ul></div><p>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください。Linux 用の Motif も <span class="emphasis"><em>Metro Link</em></span>
            から販売されています。現在、CDROM および FTP
            によるダウンロードが利用可能です。
          </p><p>
            FreeBSD 用の a.out 版 Motif 2.0 に関する情報は
            <a class="link" href="#xig">Xi Graphics</a> から
            手に入れることができます。
          </p><p>
            この製品には以下の物が含まれています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>OSF/Motif manager、xmbind、panner、wsm。
                </p></li><li class="listitem"><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake
                  ファイルといった開発者向けキット
                </p></li><li class="listitem"><p>FreeBSD 2.2.8 以前のバージョンで利用できるスタティックライブラリ、
                  およびダイナミックライブラリ
                </p></li><li class="listitem"><p>デモンストレーションプログラム
                </p></li><li class="listitem"><p>整形済みのマニュアルページ</p></li></ul></div><p>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください。BSDI や Linux 用の Motif もまた、<span class="emphasis"><em>Xi Graphics</em></span>
            から販売されています。現在フロッピーディスク 4枚組ですが、
            将来的には CDE のように統合された CD に変わるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78783824"></a><a id="cde"></a><p><strong>4.3.</strong></p></td><td align="left" valign="top"><p>FreeBSD 用の CDE はどうやったら手に入りますか</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>以前
            <a class="link" href="#xig">Xi Graphics</a> より FreeBSD 用の CDE が
            販売されていましたが、現在は既に販売が終了しています。
          </p><p><a class="link" href="http://www.kde.org/" target="_top">KDE</a>
            多くの点で CDE と類似しているオープンソースの X11 デスクトップ環境です。
            <a class="link" href="http://www.xfce.org/" target="_top">xfce</a> の
            ルック &amp; フィール (訳注: 外観や操作方法のこと) も気に入るかも知れません。
            KDE、xfce は、いずれも
            <a class="link" href="http://www.FreeBSD.org/ports/" target="_top">FreeBSD Ports Collection</a>
            に含まれています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78792528"></a><a id="commercial-xserver"></a><p><strong>4.4.</strong></p></td><td align="left" valign="top"><p>高機能な商用 X サーバってあるんですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>はい、<a class="link" href="http://www.xig.com/" target="_top">Xi Graphics</a> と
            <a class="link" href="http://www.metrolink.com/" target="_top">Metro Link</a>
            から、FreeBSD ほか Intel ベースのシステムで動作する
            Accelerated-X という製品が販売されています。
          </p><p>
            Metro Link は、FreeBSD のパッケージ操作ツールを利用することで
            容易に設定が行なえるほか、数多くのビデオボードをサポートした
            高機能な X サーバを提供しています。配布はバイナリ形式のみで、
            FTP が利用可能です。もちろん、とても安価 ($39) に手に入れることができます。
            <a id="metrox"></a>
          </p><p>
            また、Metro Link は ELF 版、a.out 版の FreeBSD 用 Motif
            も販売しています (前を参照)。
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">より詳しい情報は</span></dt><dd><p><a class="link" href="http://www.metrolink.com/" target="_top">Metro Link WWW page</a></p></dd><dt><span class="term">問い合わせは</span></dt><dd><p><a class="link" href="mailto:sales@metrolink.com" target="_top">Sales</a>
                    または
                    <a class="link" href="mailto:tech@metrolink.com" target="_top">Support</a> 電子メールアドレス</p></dd><dt><span class="term">もしくは</span></dt><dd><p>phone (954) 938-0283  or +1 954 938-0283</p></dd></dl></div><p>
            Xi Graphics が提供している高性能な X サーバは楽に設定を行なえるほか、
            数多くのビデオボード
            をサポートしています。サーバはバイナリのみが含まれます。
            FreeBSD 用と Linux 用の統合されたフロッピーディスクに入っています。
            Xi Graphics は Laptop サポートに特化した高性能 X サーバも提供しています。
            <a id="xig"></a>
          </p><p>
            バージョン 5.0 の「互換デモ」が無料で入手できます。
          </p><p>
            また Xi Graphics は FreeBSD 用の Motif と CDE も販売しています (前を参照)。
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">より詳しい情報は</span></dt><dd><p><a class="link" href="http://www.xig.com/" target="_top">Xi Graphics WWW page</a></p></dd><dt><span class="term">問い合せは</span></dt><dd><p><a class="link" href="mailto:sales@xig.com" target="_top">Sales</a> または
                    <a class="link" href="mailto:support@xig.com" target="_top">Support</a></p></dd><dt><span class="term">もしくは</span></dt><dd><p>phone (800) 946 7433  or +1 303 298-7478.</p></dd></dl></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78826704"></a><a id="database-systems"></a><p><strong>4.5.</strong></p></td><td align="left" valign="top"><p>FreeBSD 用のデータベースシステムはありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>もちろんです。FreeBSD のウェブサイトにある
            <a class="link" href="http://www.FreeBSD.org/commercial/software_bycat.html#CATEGORY_DATABASE" target="_top">
              商用ベンダー</a> というセクションをご覧ください。
          </p><p>
            また、FreeBSD Ports Collection
            の<a class="link" href="http://www.FreeBSD.org/ports/databases.html" target="_top">データベース</a>のセクションも参考になるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78830544"></a><a id="oracle-support"></a><p><strong>4.6.</strong></p></td><td align="left" valign="top"><p>Oracle を FreeBSD 上で動かすことはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい。Linux 版 Oracle を FreeBSD でセットアップするための方法は、
            次に示すページに詳しく書かれています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.scc.nl/~marcel/howto-oracle.html" target="_top">http://www.scc.nl/~marcel/howto-oracle.html</a></p></li><li class="listitem"><p><a class="link" href="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd" target="_top">http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</a></p></li></ul></div></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="applications"></a>第5章 ユーザアプリケーション</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        山下 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:junkun@esys.tsukuba.ac.jp">junkun@esys.tsukuba.ac.jp</a>&gt;</code>、
        広瀬 昌一 <code class="email">&lt;<a xmlns="" class="email" href="mailto:shou@kt.rim.or.jp">shou@kt.rim.or.jp</a>&gt;</code>、
        1997 年 11 月 8 日</em></span>
    </p><div class="qandaset"><a id="idp78837840"></a><dl><dt>5.1. <a href="#idp78838096">そういうユーザアプリケーションはどこにあるの?</a></dt><dt>5.2. <a href="#idp78862672">なぜ /bin/sh はこんなに低機能なのですか?
            どうして bash や他のシェルを採用しないのでしょう?</a></dt><dt>5.3. <a href="#idp78870224">libc.so.3.0 はどこにありますか?</a></dt><dt>5.4. <a href="#idp78872272">Error: can't find libc.so.4.0
            というメッセージが表示されるのですが。</a></dt><dt>5.5. <a href="#idp78874704">386/486SX のマシンで ghostscript を動かすとエラーがでます。</a></dt><dt>5.6. <a href="#idp78878288">SCO/iBCS2 のアプリケーションを実行すると、
            socksys で落ちてしまいます。
            (FreeBSD 3.0 とそれ以前のみ)</a></dt><dt>5.7. <a href="#idp78889936">INN (インターネットニュース) の設定方法は?</a></dt><dt>5.8. <a href="#idp78892624">どのバージョンの Microsoft FrontPage を手に入れる必要がありますか?</a></dt><dt>5.9. <a href="#idp78898896">FreeBSD は Java をサポートしていますか?</a></dt><dt>5.10. <a href="#idp78901968">3.x-STABLE を載せているマシンで port
            がコンパイルできないことがあります。それはどうしてですか?
          </a></dt><dt>5.11. <a href="#idp78905296">ld.so はどこにありますか?</a></dt><dt>5.12. <a href="#idp78909776">ソースコードを更新しました。さて、インストール済みの
             ports を更新するにはどうすればよいでしょうか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78838096"></a><a id="user-apps"></a><p><strong>5.1.</strong></p></td><td align="left" valign="top"><p>そういうユーザアプリケーションはどこにあるの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSDに移植されたソフトウェアパッケージについては、
            <a class="link" href="http://www.FreeBSD.org/ports/" target="_top">FreeBSD Ports Collection
              のページ</a>をご覧ください。
            このリストには現在 3400 を越える項目があり、
            しかも毎日更新されています。このページをこまめに訪れるか、
            <code class="literal">freebsd-announce</code><a class="link" href="#mailing" title="11.">
              メーリングリスト</a>を購読すると、
            新しく入った ports を定期的にチェックすることができます。
          </p><p>
            大部分の ports は 2.2 と 3.x および 4.x ブランチで利用できるはずです。
            多くは 2.1.x 系のシステムでも同様に動作するでしょう。
            FreeBSD のリリースが出る度に、そのリリースの時点での ports ツリーの
            スナップショットが撮られ、<code class="filename">ports/</code> ディレクトリに
            納められることになっています。
          </p><p>
            また、<span class="quote">「<span class="quote">package</span>」</span>
            という考えも採用されています。これは基本的には
            gzip で圧縮されたバイナリディストリビューションに、
            インストール時に環境に合わせた作業が必要になった場合、
            行う機能を多少付け加えたものです。
            package を使えば、どのようなファイルが配布物として含まれているか、
            と言った細かい事柄にいちいち煩わされることなく、
            簡単にインストールやアンインストールを繰り返すことができます。
          </p><p>
            インストールしたい package があるなら、
            <code class="filename">/stand/sysinstall</code>の、
            「インストール後の FreeBSD の設定を行う」の下にある
            package のインストールメニューを使うか、
            package のファイル名を指定して
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pkg_add&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pkg_add</span>(1)</span></a> を使用してください。
            package のファイル名には、
            通常末尾に <code class="filename">.tgz</code> がついています。
            CDROM をご使用の方は、CD の
            <code class="filename">packages/All</code>
            ディレクトリからそれらのファイルを利用することができます。
            また、以下の場所から、
            FreeBSD の各種バージョンにあわせた package をダウンロードする
            こともできます。
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">2.2.8-RELEASE/2.2.8-STABLE 用</span></dt><dd><p><a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</a></p></dd><dt><span class="term">3.X-RELEASE/3.X-STABLE 用</span></dt><dd><p><a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/</a></p></dd><dt><span class="term"> 4.X-RELEASE/4-STABLE 用</span></dt><dd><p><a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/</a></p></dd><dt><span class="term">5.X-CURRENT 用</span></dt><dd><p><a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current</a></p></dd></dl></div><p>お近くのミラーサイトもご利用ください。</p><p>
            新しい ports が続々と追加されている状態なので、すべての ports に
            対応する package が存在するわけではないことを覚えておいてください。
            定期的に <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/" target="_top">ftp.FreeBSD.org</a>
            マスターサイトを訪れて、どのような
            package が利用できるのかチェックするのも良いでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78862672"></a><a id="minimal-sh"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>なぜ <code class="command">/bin/sh</code> はこんなに低機能なのですか?
            どうして <code class="command">bash</code> や他のシェルを採用しないのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>それは、POSIX がそのようなシェルがあることを規定しているからです。</p><p>
            もっと込み入った回答:
            多くのユーザは、多くのシステムで同じように動作できるシェルスクリプトを書く必要があります。
            これが、POSIX でシェルやユーティリティコマンドが細く規定されている理由です。
            ほとんどすべてのスクリプトは Bourne shell で書かれているのですが、
            それは、数多くの重要なプログラミングインタフェイス (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a>、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=system&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">system</span>(3)</span></a>、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=popen&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">popen</span>(3)</span></a>、や Perl や Tcl 等の類似の
            高水準スクリプト言語) が、コマンドの解釈に Bourne shell を使うからです。
            このように Bourne shell が極めて頻繁にかつ広範囲で使われているため、
            素早く起動できて確実に動作し、メモリを少ししか消費しないということが
            重要になります。</p><p>
            既存の実装は、
            私たちに可能な限りこれらの多くの要求を同時に満足することができる最良のものです。
            <code class="command">/bin/sh</code> を小さいままに保つため、
            私たちは他のシェルが持つ様々な便利な機能を提供していません。
            Ports コレクションが bash や scsh、tcsh、zsh などの
            多機能なシェルを含んでいるからです (これらのシェルすべての
            メモリ使用状況は、<code class="command">ps -u</code> の <span class="quote">「<span class="quote">VSZ</span>」</span> や
            <span class="quote">「<span class="quote">RSS</span>」</span> の行で、あなた自身が確認することができます)。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78870224"></a><a id="missing-libcso30"></a><p><strong>5.3.</strong></p></td><td align="left" valign="top"><p>libc.so.3.0 はどこにありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.1.x のシステムで 2.2 以降用の
            package を動かそうとしていますね?
            前のセクションを読んで、システムに合った正しい
            port/package を入手してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78872272"></a><a id="missing-libcso40"></a><p><strong>5.4.</strong></p></td><td align="left" valign="top"><p><code class="literal">Error: can't find libc.so.4.0</code>
            というメッセージが表示されるのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>何かの手違いで、4.X と 5.X のシステム用 package をダウンロードし、
            FreeBSD 2.X、もしくは 3.X のシステムにインストールしてしまったのでしょう。
            対応する正しいバージョンの package をダウンロードしてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78874704"></a><a id="emul"></a><p><strong>5.5.</strong></p></td><td align="left" valign="top"><p>386/486SX のマシンで ghostscript を動かすとエラーがでます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            あなたのマシンには数値演算プロセッサが搭載されていませんね?
            カーネルにコプロセッサの代わりとなる数値演算エミュレータを追加する必要があります。
            以下のオプションをカーネルのコンフィグレーションファイルに追加して、
            カーネルを再構築してください。
          </p><pre class="programlisting">options GPL_MATH_EMULATE</pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">このオプションを追加する場合、
                <code class="literal">MATH_EMULATE</code>
                の行を削除してください。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78878288"></a><a id="sco-socksys"></a><p><strong>5.6.</strong></p></td><td align="left" valign="top"><p>SCO/iBCS2 のアプリケーションを実行すると、
            <code class="literal">socksys</code> で落ちてしまいます。
            (FreeBSD 3.0 とそれ以前のみ)</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず最初に
            <code class="filename">/etc/sysconfig</code> (または
            <code class="filename">/etc/rc.conf</code>, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 参照)
            の最後のセクションを編集し、
            以下の変数を <code class="literal">YES</code> に直します。
          </p><pre class="programlisting"># Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO</pre><p>
            これでシステムの起動時に
            ibcs2
            カーネルモジュールが読み込まるようになります。
          </p><p>
            次に /compat/ibcs2/dev/
            を以下のように編集します。
          </p><pre class="screen">lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx</pre><p>
            open や close の処理は、
            socksys から
            <code class="filename">/dev/null</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=null&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">null</span>(4)</span></a> 参照)
            へシンボリックリンクを張ることで代用します。
            残りの処理は、-CURRENT に入っているコードが担当しています。
            これは以前のものより ずっとスッキリした方法です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78889936"></a><a id="configure-inn"></a><p><strong>5.7.</strong></p></td><td align="left" valign="top"><p>INN (インターネットニュース) の設定方法は?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>inn の package や port をインストールしたあとに
            <a class="link" href="http://www.cis.ohio-state.edu/~barr/INN.html" target="_top">Dave Barr's
              INN Page</a> を見てみましょう。初心者向けの INN FAQ があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78892624"></a><a id="ms-frontpage"></a><p><strong>5.8.</strong></p></td><td align="left" valign="top"><p>どのバージョンの Microsoft FrontPage を手に入れる必要がありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ルーク、ports を使うのだ!
            パッチ処理済みの Apache が ports ツリーから入手できます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78898896"></a><a id="java"></a><p><strong>5.9.</strong></p></td><td align="left" valign="top"><p>FreeBSD は Java をサポートしていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>はい。
            <a class="link" href="http://www.FreeBSD.org/java/" target="_top">http://www.FreeBSD.org/java/</a>
            をご覧ください。
            <a class="link" href="../java/" target="_top">日本語訳</a>
            もあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78901968"></a><a id="ports-3x"></a><p><strong>5.10.</strong></p></td><td align="left" valign="top"><p>3.x-STABLE を載せているマシンで port
            がコンパイルできないことがあります。それはどうしてですか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もし、その時点の -CURRENT か -STABLE
            に比べてずっと古いバージョンの FreeBSD を利用しているなら、
            <a class="link" href="http://www.FreeBSD.org/ports/" target="_top">http://www.FreeBSD.org/ports/</a>
            にある ports アップグレードキットが必要です。
            最新の FreeBSD を利用しているのに発生する場合はおそらく、
            -CURRENT では正常なのに -STABLE ではうまく動かなくなるような変更がその
            port に対して行なわれ、受理されてしまっているのでしょう。
            ports コレクションは -CURRENT と -STABLE、
            両方のブランチで動かなければならないものですので、
            もしそれを発見したら <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=send-pr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">send-pr</span>(1)</span></a>
            コマンドを使ってバグレポートの提出をお願いします。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78905296"></a><a id="find-ldso"></a><p><strong>5.11.</strong></p></td><td align="left" valign="top"><p>ld.so はどこにありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>3.1-R 以降などの Elf 化されたマシンで Netscape Navigator などの
            aout 形式のアプリケーションを動かすときには、
            <code class="filename">/usr/libexec/ld.so</code> と
            aout ライブラリのファイルが必要です。
            それらは配布物の <code class="literal">compat22</code> に納められています。
            <code class="filename">/stand/sysinstall</code> や
            <code class="filename">compat22</code> サブディレクトリ内の
            <code class="filename">install.sh</code> を使って
            <code class="literal">compat22</code>
            をインストールしてください。
            合わせて 3.1-R と 3.2-R の ERRATA もお読みください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78909776"></a><a id="ports-update"></a><p><strong>5.12.</strong></p></td><td align="left" valign="top"><p>ソースコードを更新しました。さて、インストール済みの
             ports を更新するにはどうすればよいでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>残念ながら、インストール済みの ports を更新する簡単な
            方法はありません。<code class="command">pkg_version</code> コマンドを
            用いて ports ツリー中の新しいバージョンに更新する
            スクリプトを次のように生成することができます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pkg_version -c &gt; /tmp/myscript</code></strong></pre><p>出力されたスクリプトを使う前に、手で
            編集<span class="emphasis"><em>しなければなりません</em></span>。現在のバージョンの
            <code class="command">pkg_version</code> では、スクリプトの先頭に
            <code class="command">exit</code> を挿入して強制しています。</p><p>スクリプトの出力には、更新された packages に依存する
            packages が記載されているので、保存しておきましょう。これらも
            やはり更新する必要があるかもしれません。通常、更新が
            必要となるのは、共有ライブラリのバージョンが変化し、
            そのライブラリを利用している ports が新しいライブラリを用いるために
            再構築する必要がある場合です。</p><p>システムが常時稼動しているならば、
            <code class="filename">/etc/periodic.conf</code> に
            <code class="literal">weekly_status_pkg_enable="YES"</code> を
            設定して、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=periodic&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">periodic</span>(8)</span></a> システムによって毎週更新が必要な ports
            の一覧を生成できます。</p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="kernelconfig"></a>第6章 カーネルコンフィグレーション</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        はらだ きろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:kiroh@jp.FreeBSD.org">kiroh@jp.FreeBSD.org</a>&gt;</code>、
        1997 年 11 月 10 日
      </em></span>
    </p><div class="qandaset"><a id="idp78923472"></a><dl><dt>6.1. <a href="#idp78923728">カーネルをカスタマイズしたいんですが、難しいですか?</a></dt><dt>6.2. <a href="#idp78928080">_hw_float
            が無いので、カーネルのコンパイルがうまくいきません。</a></dt><dt>6.3. <a href="#idp78932688">わたしのカーネルはどうしてこんなに大きい (10MB 以上)
            のでしょうか?</a></dt><dt>6.4. <a href="#idp78938960">
            マルチポートシリアルのコードで割り込みが衝突しています。
          </a></dt><dt>6.5. <a href="#idp78941776">カーネルを構築にいつも失敗します。
            GENERIC カーネルも構築できません。</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78923728"></a><a id="make-kernel"></a><p><strong>6.1.</strong></p></td><td align="left" valign="top"><p>カーネルをカスタマイズしたいんですが、難しいですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            全然難しくありません。
            <a class="link" href="../handbook/kernelconfig.html" target="_top">カーネルの再構築</a>を調べてください。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">うまく動作するカーネルができたら、
                日付入りのカーネルのスナップショットを
                <code class="filename">kernel.YYMMDD</code>
                のように作成することをおすすめします。
                こうしておけば、次にカーネルの構築をやってうまくいかなくなってしまっても、
                <code class="filename">kernel.GENERIC</code> にわざわざ戻る必要がなくなります。
                これは、GENERIC カーネルでサポートされないデバイスから起動している場合は、
                特に重要です。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78928080"></a><a id="missing-hw-float"></a><p><strong>6.2.</strong></p></td><td align="left" valign="top"><p><code class="literal">_hw_float</code>
            が無いので、カーネルのコンパイルがうまくいきません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            推測ですが、数値演算コプロセッサを持ってないからと思って、
            <code class="filename">npx0</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=npx&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">npx</span>(4)</span></a> 参照)
            をカーネルコンフィグファイルから削除してしまったのではないでしょうか?
            <code class="filename">npx0</code> は<span class="emphasis"><em>必須</em></span>です。
            コプロセッサがなくても、<code class="filename">npx0</code>
            デバイスは削除してはいけません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78932688"></a><a id="why-kernel-big"></a><p><strong>6.3.</strong></p></td><td align="left" valign="top"><p>わたしのカーネルはどうしてこんなに大きい (10MB 以上)
            のでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは<span class="emphasis"><em>デバッグモード</em></span>でカーネルを構築していることが原因です。
            デバッグモードで構築されたカーネルは、
            デバッグに用いられる膨大なシンボル情報を含んでいるため、
            カーネルのサイズが非常に大きくなります。
            ただし FreeBSD 3.0 とそれ以降のシステムの場合は
            カーネルのサイズは小さくなりますし、
            デバッグカーネルを実行する時のパフォーマンスの低下もありません。
            また、そのカーネルはシステムがパニックした場合に有用です。</p><p>しかし、容量の小さなディスクでシステムを運用していたり、
            単にデバッグカーネルを実行したくない場合は、
            以下の両方が当てはまっているかどうか確認してください。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>カーネルコンフィグファイルに以下の行が書かれていないこと。</p><pre class="programlisting">makeoptions DEBUG=-g</pre></li><li class="listitem"><p><code class="command">config</code> を実行する際、
                <code class="option">-g</code> オプションを付けていないこと。</p></li></ul></div><p>上に書かれた指定は両方ともカーネルをデバッグモードで構築するためのものです。
            上の手順を従っている限り、カーネルを普通に構築してサイズの小さなカーネルを得ることができます。
            その場合のカーネルサイズは、およそ 1.5MB から 2MB 程度になります。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78938960"></a><a id="multiport-serial-interrupts"></a><p><strong>6.4.</strong></p></td><td align="left" valign="top"><p>
            マルチポートシリアルのコードで割り込みが衝突しています。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            マルチポートシリアルを
            サポートするコードを含んだカーネルをコンパイルしようとすると、
            最初のポートだけ検出され、
            残りのポートは割り込みの競合のためスキップされたと言われます。
            どうやったらいいでしょうか?
          </p><p>
            ここでの問題は、FreeBSD
            にはハードウェアまたはソフトウェアの競合により、
            カーネルがクラッシュするのを防ぐコードが含まれているという点です。
            解決するには、最初のポートにだけ IRQ の設定を書き、
            残りは IRQ の設定を削除します。
            以下に例を示します。
          </p><pre class="programlisting"># Multiport high-speed serial line - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78941776"></a><a id="generic-kernel-build-failure"></a><p><strong>6.5.</strong></p></td><td align="left" valign="top"><p>カーネルを構築にいつも失敗します。
            GENERIC カーネルも構築できません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>さまざまな理由が考えられます。以下、順に列記します。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>あなたは新しい
                <code class="command">make buildkernel</code> や
                <code class="command">make installkernel</code>
                ターゲットを使わず、
                現在走っているシステムを構築した時と異なるソースツリーを
                構築しようとしている (たとえば、4.0-RELEASE のシステム上で
                4.3-RELEASE を構築しようとしている) のではないでしょうか?
                もしシステムをアップグレードしようとしているのなら、
                <code class="filename">/usr/src/UPDATING</code> ファイルを
                <span class="quote">「<span class="quote">共通項目 (COMMON ITEMS)</span>」</span>
                節に注意しながら最後までお読みください。</p></li><li class="listitem"><p>あなたは新しい <code class="command">make buildkernel</code> や
                <code class="command">make installkernel</code> ターゲットを
                使っているのにも関わらず、
                <code class="command">make buildworld</code>
                を行なっていないのではないでしょうか?
                <code class="command">make buildkernel</code> ターゲットは、
                <code class="command">make buildworld</code>
                ターゲットによって作られるファイルに依存しています
                そのため、<code class="command">make buildkernel</code>
                が正常に終了するためには
                <code class="command">make buildworld</code>
                ターゲットが正常に完了している必要があります。</p></li><li class="listitem"><p>構築しようとしているのが
                <a class="link" href="#stable" title="6.">FreeBSD-STABLE</a>
                だったとしても、あなたが入手したソースツリーが何らかの理由で
                書き換わったり、壊れてしまっているのかも知れません。
                <a class="link" href="#stable" title="6.">FreeBSD-STABLE</a>
                はほとんどの場合、きちんと構築できるようになっていますが、
                確実に構築可能であることが保証されているのは
                リリース版だけです。一度ソースツリーを再取得して、
                問題が解決しないかどうか試してみてください。
                また、あるサーバから取得した時に問題が発生したら、
                別のサーバを試すのも効果があるかも知れません。</p></li></ul></div></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="admin"></a>第7章 システム管理</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        にしか <code class="email">&lt;<a xmlns="" class="email" href="mailto:nishika@cheerful.com">nishika@cheerful.com</a>&gt;</code>、
        1997 年 11 月 12 日</em></span>
    </p><div class="qandaset"><a id="idp79060688"></a><dl><dt>7.1. <a href="#idp79060944">システムスタートアップファイルはどこにあるのですか?</a></dt><dt>7.2. <a href="#idp79079120">簡単にユーザを追加するにはどうすればいいのですか?</a></dt><dt>7.3. <a href="#idp79084624">新しいリムーバブルドライブを持っていますが、どうやって使うの?</a></dt><dt>7.4. <a href="#idp79110352">自分の crontab ファイルを編集した後
            root: not found
            のようなメッセージが延々と表示されるのですが、
            これはなぜですか?</a></dt><dt>7.5. <a href="#idp79134032">su(1) コマンドを実行して
            root になろうとすると、
            su が you are not in the correct group to
            su root と警告します。</a></dt><dt>7.6. <a href="#idp79146192">rc.conf やその他の
            スタートアップファイルを書き間違えてしまいました。
            しかもそのためファイルシステムがリードオンリーになってしまっていて
            編集ができません。どうすればいいですか?</a></dt><dt>7.7. <a href="#idp79166544">どのようにしたら DOS の拡張パーティションをマウントできますか?</a></dt><dt>7.8. <a href="#idp79180624">他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</a></dt><dt>7.9. <a href="#idp79186768">どのようにしたら FreeBSD を NT ローダーから起動させることができますか?</a></dt><dt>7.10. <a href="#idp79213392">FreeBSD と Linux を LILO から起動するには?</a></dt><dt>7.11. <a href="#idp79227216">FreeBSD と Linux を BootEasy から起動するには?</a></dt><dt>7.12. <a href="#idp79270864">「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?</a></dt><dt>7.13. <a href="#idp79346768">どのようにしたらスワップ領域を増やせますか?</a></dt><dt>7.14. <a href="#idp79366608">プリンタのセットアップで問題があります</a></dt><dt>7.15. <a href="#idp79372496">私のシステムのキーボードマッピングは間違っています。</a></dt><dt>7.16. <a href="#idp79414224">起動時に、unknown: &lt;PNP0303&gt; can't
              assign resources というメッセージが表示されるのですが?</a></dt><dt>7.17. <a href="#idp79418448">ユーザディスククォータが正常に動作していないようです。</a></dt><dt>7.18. <a href="#idp79429456">わたしの ccd は、
            何が適合していない (Inappropriate) のでしょう?</a></dt><dt>7.19. <a href="#idp79433680">どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</a></dt><dt>7.20. <a href="#idp79444816">FreeBSD は System V の IPC プリミティブをサポートしますか?</a></dt><dt>7.21. <a href="#idp79448912">UUCP でメールを配送するには sendmail をどう使えばよいのですか?</a></dt><dt>7.22. <a href="#idp79485392">ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?</a></dt><dt>7.23. <a href="#idp79512272">この UID が 0 の toor という
            アカウントとは何ですか? 危険にさらされているのでしょうか?</a></dt><dt>7.24. <a href="#idp79530960">しまった! root のパスワードを忘れてしまった!</a></dt><dt>7.25. <a href="#idp79557200">
            Control-Alt-Delete
            でシステムが再起動しないようにするにはどうすればいい?</a></dt><dt>7.26. <a href="#idp79563600">DOS のテキストファイルを UNIX
            のテキストファイルに整形するにはどうすればいい?</a></dt><dt>7.27. <a href="#idp79574864">名前で指定してプロセスにシグナルを送るにはどうすればいい?</a></dt><dt>7.28. <a href="#idp79577680">su が not in root's ACL
            と言って私を悩ませるのはなぜ?</a></dt><dt>7.29. <a href="#idp79581136">Kerberos をアンインストールするにはどうすればいいの?</a></dt><dt>7.30. <a href="#idp79585360">疑似ターミナルを追加するには?</a></dt><dt>7.31. <a href="#idp79598672">
            snd0
            デバイスを作成することができません!</a></dt><dt>7.32. <a href="#idp79604816">再起動せずにもう一度
            /etc/rc.conf
            を読み込んで
            /etc/rc
            を開始させるには?</a></dt><dt>7.33. <a href="#idp79615696">砂場 (sandbox) とは何ですか?</a></dt><dt>7.34. <a href="#idp79625168">セキュアレベル (securelevel) って何ですか?</a></dt><dt>7.35. <a href="#idp79649744">フロッピーや CDROM や他のリムーバブルメディアのマウントを一般ユーザーに許可するには?</a></dt><dt>7.36. <a href="#idp79670096">システムを新しい巨大ディスクへ移すにはどうするのですか?</a></dt><dt>7.37. <a href="#idp79729360">
            システムを最新の -STABLE にアップデートしようとしたのですが
            -RC や -BETA になってしまいました! 何が起こったのですか?
          </a></dt><dt>7.38. <a href="#idp79766480">新しいカーネルを入れようとしたのですが、
            chflags に失敗します。どうすれば良いのでしょう?</a></dt><dt>7.39. <a href="#idp79772496">システムの時刻を 1 秒以上変更することができないのです!
            どうすれば良いのでしょう?</a></dt><dt>7.40. <a href="#idp79786832">rpc.statd(8) にメモリリークを見つけました!
            メモリを 256 メガバイトも使っています。</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp79060944"></a><a id="startup-config-files"></a><p><strong>7.1.</strong></p></td><td align="left" valign="top"><p>システムスタートアップファイルはどこにあるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.0.5R から 2.2.1R までは、
            プライマリコンフィグレーションファイルは
            <code class="filename">/etc/sysconfig</code> にあります。
            オプションはすべてこのファイルで設定され、他の
            <code class="filename">/etc/rc</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 参照) および
            <code class="filename">/etc/netstart</code> といった
            ファイルはこれを読み込むだけです。
          </p><p>
            ファイル <code class="filename">/etc/sysconfig</code>
            を見て、システムに適合するように変更してください。
            このファイルには、
            それぞれの場所に何を書けばいいのかを表すコメントがたくさん書かれています。
          </p><p>
            FreeBSD 2.2.2 から 3.0 までのシステムでは、
            <code class="filename">/etc/sysconfig</code> は、
            より分りやすい名前の
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
            に改名され、それに従って書式もいくぶん改められています。
            <code class="filename">/etc/netstart</code> も
            <code class="filename">/etc/rc.network</code> に改名され、
            全部のファイルを
            <code class="command">cp /usr/src/etc/rc* /etc</code>
            で一度にコピーすることが出来るようになります。
          </p><p>FreeBSD 3.1 とそれ以降では、
            <code class="filename">/etc/rc.conf</code> が
            <code class="filename">/etc/defaults/rc.conf</code> に移動しました。
            <span class="emphasis"><em>このファイルを編集してはいけません!</em></span>
            代わりに、
            <code class="filename">/etc/defaults/rc.conf</code>
            の中で変えたいエントリの行を
            <code class="filename">/etc/rc.conf</code> にコピーし、
            そこで変更するようにしてください。</p><p>たとえば named を起動したいとしましょう。
            FreeBSD 3.1 かそれ以降のシステムで FreeBSD 付属の DNS
            サーバを起動するには、次のようにするだけです。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>echo named_enable="YES" &gt;&gt;
              /etc/rc.conf</code></strong></pre><p>FreeBSD 3.1 かそれ以降でローカルサービスを起動するためには、
            <code class="filename">/usr/local/etc/rc.d</code> ディレクトリにシェルスクリプトを置きます。
            シェルスクリプトは起動可能に設定し、ファイル名が .sh で終わっていなければなりません。
            FreeBSD 3.0 とそれ以前のリリースでは、
            <code class="filename">/etc/rc.local</code> を編集する必要があります。</p><p>ファイル <code class="filename">/etc/rc.serial</code>
            はシリアルポートの初期化
            (たとえばポートの設定を固定したり等々)
            のためにあります。</p><p>ファイル <code class="filename">/etc/rc.i386</code> は iBCS2
            エミュレーションのような
            Intel アーキテクチャ固有の設定や、
            PC システムコンソール設定のためにあります。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79079120"></a><a id="adding-users"></a><p><strong>7.2.</strong></p></td><td align="left" valign="top"><p>簡単にユーザを追加するにはどうすればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=adduser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">adduser</span>(8)</span></a> コマンドを使用してください。
            また、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> コマンドを用いることで、さらに細かい操作が可能です。
          </p><p>
            ユーザを削除するには <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rmuser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rmuser</span>(8)</span></a> コマンドを使用してください。
            繰り返しになりますが、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> でも構いません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79084624"></a><a id="removable-drives"></a><p><strong>7.3.</strong></p></td><td align="left" valign="top"><p>新しいリムーバブルドライブを持っていますが、どうやって使うの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            そのリムーバブルドライブが ZIP であれ EZ drive であれ
            (あるいはもしそういう風に使いたいのなら、フロッピーであれ)、
            またハードディスクであれ、一旦システムにインストールされて認識され、
            カートリッジ、フロッピー等々が挿入されていれば、
            ことはどのデバイスでも全く同じように進みます。
          </p><p><a id="disklabel"></a>
              (このセクションは<a class="link" href="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html" target="_top">Mark Mayo's ZIP FAQ</a> に基づいています)
          </p><p>
            ZIP ドライブやフロッピーで、すでに DOS のファイルシステムで
            フォーマットしてある場合、次のコマンドを使うことができます。
            これはフロッピーの場合です。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/fd0c /floppy</code></strong></pre><p>出荷時の設定の ZIP ディスクではこうです。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/da2s4 /zip</code></strong></pre><p>
            その他のディスクに関しては、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a> や
            <code class="filename">/stand/sysinstall</code> を使って、
            どのようにレイアウトされているか確かめてください。
          </p><p>
            以降は ZIP ドライブが 3 番目の SCSI ディスクで、
            da2 と認識されている場合の例です。
          </p><p>
            他人と共有しなければならないフロッピーやリムーバブルディスク
            でなければ、BSD ファイルシステムを載せてしまうのが良い考えでしょう。
            ロングファイル名もサポートされ、パフォーマンスは少なくとも
            2 倍は向上しますし、おまけにずっと安定しています。
            まず最初に、DOS レベルでのパーティション <code class="filename">/</code>
            ファイルシステムを無効にしておく必要があります。使用するのは
            <code class="command">fdisk</code> でも
            <code class="filename">/stand/sysinstall</code> でも結構です。
            複数のオペレーティングシステムを入れることを考慮する
            必要がないような容量の小さなドライブの場合は、
            次のように <acronym class="acronym">FAT</acronym> パーティションテーブル (スライス)
            全体を飛ばして、BSD
            のパーティション設定を行うだけで良いでしょう。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/dev/rda2 count=2</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -Brw da2 auto</code></strong></pre><p>
            複数の BSD パーティションをつくる場合、
            <code class="command">disklabel</code> か
            <code class="filename">/stand/sysinstall</code> を使います。
            固定ディスク上にスワップ領域を加える場合、
            そういうことをしたいと思うのはもっともですが、
            ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
            でしょう。
          </p><p>
            最後に、新しいファイルシステムをつくります。ディスク全体を使用する
            ZIP ドライブの場合は、以下のようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>newfs /dev/rda2c</code></strong></pre><p>次にマウントします。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount /dev/da2c /zip</code></strong></pre><p>また、次のような行を
            <code class="filename">/etc/fstab</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fstab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fstab</span>(5)</span></a> 参照)
            に入れておくのも良い考えでしょう。
            <code class="command">mount /zip</code>
            と入力するだけでマウントできるようになります。
          </p><pre class="programlisting">/dev/da2c /zip ffs rw,noauto 0 0</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79110352"></a><a id="root-not-found-cron-errors"></a><p><strong>7.4.</strong></p></td><td align="left" valign="top"><p>自分の crontab ファイルを編集した後
            <span class="errorname">root: not found</span>
            のようなメッセージが延々と表示されるのですが、
            これはなぜですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは通常、システム crontab (<code class="filename">/etc/crontab</code>)
            を編集し、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a> を使ってインストールした場合に起こります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab /etc/crontab</code></strong></pre><p>この方法は正しくありません。
            システム crontab のフォーマットは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a>
            が更新する各ユーザの crontab とは異なります
            (フォーマットの相違点の詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">crontab</span>(5)</span></a>
            で説明されています)。</p><p>
            もしこのような操作をしてしまったなら、
            あらたな crontab は誤ったフォーマットの
            <code class="filename">/etc/crontab</code>
            のコピーになってしまっているからです。
            以下のコマンドで削除してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab -r</code></strong></pre><p>
            今度 <code class="filename">/etc/crontab</code> を編集する時は、
            その変更を <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> に伝えるような操作をしてはいけません。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> は、自動的にその変更を認識するからです。</p><p>
            もしあなたが何かを一日一回、あるいは一週間や一ヶ月に一回だけ
            実行させたいなら、シェルスクリプトを
            <code class="filename">/usr/local/etc/periodic</code> に追加し、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=periodic&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">periodic</span>(8)</span></a> コマンドにシステムの cron スケジュールから
            他の定期的なシステムのタスクとともに
            実行させたほうが良いかもしれません。
          </p><p>このエラーの実際の原因は、システム crontab には
            どのユーザ権限でコマンドを実行するかを指定する余分なフィールドがあることによるものです。
            FreeBSD に添付されている標準のシステム crontab には、
            すべてのエントリに <code class="systemitem">root</code> が書かれています。
            この crontab が <code class="systemitem">root</code> ユーザの crontab
            (システム crontab とは <span class="emphasis"><em>異なります</em></span>)
            として使われた場合、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> は <code class="literal">root</code>
            を実行するコマンドの最初の単語だと認識しますが、
            そのようなコマンドは存在しないのです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79134032"></a><a id="su-wheel-group"></a><p><strong>7.5.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> コマンドを実行して
            <code class="systemitem">root</code> になろうとすると、
            su が <span class="errorname">you are not in the correct group to
            su root</span> と警告します。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、セキュリティ上の機能です。su コマンドを実行して
            <code class="systemitem">root</code> (またはスーパーユーザ権限を持つ
            他のアカウント) になるには、<code class="systemitem">wheel</code>
            グループに所属していなければなりません。この機能がないと、
            システムにアカウントがあって <code class="systemitem">root</code> の
            パスワードを見つけさえすれば、誰でもスーパーユーザ権限で
            システムにアクセスできてしまいます。この機能がある場合は、
            必ずしもそうはなりません。<code class="systemitem">wheel</code> グループに
            所属していなければ、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> がパスワードの入力すら
            拒否するからです。</p><p>誰かが <code class="systemitem">root</code> に su できるように
            するには、その人を <code class="systemitem">wheel</code> グループに追加してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79146192"></a><a id="rcconf-readonly"></a><p><strong>7.6.</strong></p></td><td align="left" valign="top"><p><code class="filename">rc.conf</code> やその他の
            スタートアップファイルを書き間違えてしまいました。
            しかもそのためファイルシステムがリードオンリーになってしまっていて
            編集ができません。どうすればいいですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            シェルのパス名を入力するプロンプトが表示されたときに、
            単に <code class="literal">ENTER</code> を押し、<code class="command">mount /</code> を
            実行してそルートファイルシステムを再マウントさせます。
            また、お気に入りのエディタがあるファイルシステムを
            マウントするために <code class="command">mount -a -t ufs</code> を
            する必要があるかも知れません。あなたのお気に入りのエディタが
            ネットワークファイルシステム上にある場合は、
            ネットワークファイルシステムをマウントする前にネットワークを
            手動で設定するか、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ed&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ed</span>(1)</span></a> のようなローカルファイルシステムにある
            エディタを使うかしなければなりません。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vi&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">vi</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=emacs&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">emacs</span>(1)</span></a> の様なフルスクリーンエディタを
            使うつもりなら <code class="command">export TERM=cons25</code> と
            やってエディタが <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=termcap&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">termcap</span>(5)</span></a> データベースから正しい
            データを読み取れるようにしなければなりません。</p><p>これを行ったあとはいつもと同様、
            <code class="filename">/etc/rc.conf</code>
            を編集して間違いを訂正することができるようになります。
            カーネル起動メッセージの直後に表示されたエラーメッセージには、
            問題の起こったファイル内での行番号を表示されているはずです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79166544"></a><a id="mount-dos"></a><p><strong>7.7.</strong></p></td><td align="left" valign="top"><p>どのようにしたら DOS の拡張パーティションをマウントできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            DOS 拡張パーティションは、
            すべての基本パーティションの後に認識されます。
            たとえば、2台目の SCSIドライブの拡張パーティションに
            <span class="quote">「<span class="quote">E</span>」</span>
            パーティションがあるとしますと、
            これは <code class="filename">/dev</code>
            に「スライス 5 」のスペシャルファイルを作る必要があり、
            <code class="filename">/dev/da1s5</code>
            としてマウントされます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV da1s5</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/da1s5 /dos/e</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79180624"></a><a id="mount-foreign-fs"></a><p><strong>7.8.</strong></p></td><td align="left" valign="top"><p>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="literal">Digital UNIX</code>:
            UFS CDROM は直接 FreeBSD でマウントすることができます。
            Digital UNIX やそれ以外のシステムのサポートする
            UFS のディスクパーティションをマウントすることはもっと複雑なことで、
            オペレーティングシステムのディスクパーティションの詳細に依存します。
          </p><p>
            <code class="literal">Linux</code>:
            2.2 以降は <code class="literal">ext2fs</code> パーティションをサポートします。
            詳しくは、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_ext2fs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_ext2fs</span>(8)</span></a> を見てください。
          </p><p>
            <code class="literal">NT</code>:
            FreeBSD 用の読みだしのみ可能な NTFS ドライバがあります。
            詳しくは、Mark Ovens 氏によって書かれたチュートリアル
            <a class="link" href="http://ukug.uk.freebsd.org/~mark/ntfs_install.html" target="_top">http://ukug.uk.freebsd.org/~mark/ntfs_install.html</a>
            をご覧ください。
          </p><p>
            この問題について他の情報があれば、他の人から感謝されるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79186768"></a><a id="nt-bootloader"></a><p><strong>7.9.</strong></p></td><td align="left" valign="top"><p>どのようにしたら FreeBSD を NT ローダーから起動させることができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この手順は 2.2.x と (起動が 3 つのステージに分かれている) 3.x
            のシステムとで多少異なります。
          </p><p>
            FreeBSD のネイティブルートパーティションの最初のセクタをファイルにして
            DOS/NT パーティション上に置くという画期的なアイディアがあります。
            ファイル名を
            <code class="filename">c:\bootsect.bsd</code> (<code class="filename">c:\bootsect.dos</code>
            からの発想です) としたとします。
            <code class="filename">c:\boot.ini</code>ファイルを次のように編集します。
          </p><pre class="programlisting">[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"</pre><p>
            この手順は、利用しているシステムが 2.2.x であり、DOS、NT、FreeBSD
            あるいはその他のオペレーティングシステムがすべて、
            <span class="emphasis"><em>同じ</em></span>ディスクのそれぞれの
            fdisk パーティションにインストールされていることを想定しています。
            この例は、DOS と NT を最初の fdisk パーティションにおき、
            FreeBSD は 2 番目においたシステムで確認しています。
            また、FreeBSD は MBR を使わずに、
            ネイティブパーティションから起動するように設定してあります
            (訳注: FreeBSD のインストールで、ブートマネジャを使わずに標準
            MBR を使う場合に相当します)。
          </p><p>
            (もし NTFS に変換してしまっているなら)DOS
            フォーマットのフロッピーディスクか FAT
            パーティションを <code class="filename">/mnt</code> に DOS
            マウントします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</code></strong></pre><p>
            再起動して DOS か NT に切替えます。NTFS ユーザは
            <code class="filename">bootsect.bsd</code> や
            <code class="filename">bootsect.lnx</code> をフロッピーディスクから
            <code class="filename">C:\</code>
            へコピーします。
            <code class="filename">boot.ini</code>
            のファイル属性 (パーミッション) の変更を以下のように行ないます。
          </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>attrib -s -r c:\boot.ini</code></strong></pre><p>
            上の例の
            <code class="filename">boot.ini</code> で示したような正しいエントリを加え、
            ファイル属性を元に戻します。
          </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>attrib +s +r c:\boot.ini</code></strong></pre><p>
            FreeBSD が MBR から起動するようになっている場合、
            それぞれのネイティブパーティションから起動するように設定した後で、
            DOS から <code class="command">fdisk</code>
            コマンドを実行して元に戻してください。
          </p><p>
            FreeBSD 3.X における手順は、これよりいくぶん簡単です。
          </p><p>
            FreeBSD が NT 起動パーティションとして同じディスクにインストールされている場合には、
            <code class="filename">/boot/boot1</code> を単純に
            <code class="filename">C:\BOOTSECT.BSD</code> へコピーします。
            もし FreeBSD が異なったディスクにインストールされている場合には、
            <code class="filename">/boot/boot1</code> では動作しませんので、
            <code class="filename">/boot/boot0</code> が必要です。

            </p><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">ここで <code class="filename">/boot/boot1</code> の代わりに
                <code class="filename">/boot/boot0</code> をコピーするようなことをしてはいけません!
                そうすると、パーティションテーブルを上書きしてしまい、
                コンピュータが起動できなくなってしまいます。</p></div><p>
          </p><p><code class="filename">/boot/boot0</code> をインストールするには、
            sysinstall のブートマネージャを利用するかどうか尋ねられる画面で
            FreeBSD ブートマネージャを選択する必要があります。
            <code class="filename">/boot/boot0</code>
            のパーティションテーブル部分は NULL 文字で埋められているのですが、
            sysinstall は <code class="filename">/boot/boot0</code> を MBR
            にコピーする前にパーティションテーブルをきちんとコピーしてくれるからです。</p><p>FreeBSD ブートマネージャは最後に起動した OS を記録するために
            パーティションテーブルの最後に起動した OS
            のエントリにあるアクティブフラグをセットし、512 バイト全体を MBR に書き戻します。
            これは <code class="filename">/boot/boot0</code> を
            <code class="filename">C:\BOOTSECT.BSD</code> にコピーし、
            エントリの一つにアクティブフラグをセットして空のパーティションテーブルを MBR
            に書き込むことと同じです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79213392"></a><a id="lilo-bootloader"></a><p><strong>7.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD と Linux を LILO から起動するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD と Linux が同じディスクにインストールされている場合、
            単に Linux 以外の OS を起動するための LILO のインストール手順に
            従えばいいだけです。非常に簡単にではありますが、記してみましょう。
          </p><p>
            Linux を起動し、<code class="filename">/etc/lilo.conf</code>
            に以下の行を加えて
            ください。</p><pre class="programlisting">other=/dev/hda2
        table=/dev/hda
        label=FreeBSD</pre><p>
            (上記の手順は FreeBSD のスライスが Linux から
            <code class="filename">/dev/hda2</code>
            という名前で見えていると仮定しています。
            あなたの設定にあわせてください)
            その後、<code class="command">lilo</code> を
            <code class="systemitem">root</code>
            で実行すれば完了です。
          </p><p>
            FreeBSD が別のディスクにインストールされているのなら、
            LILO のエントリに
            <code class="literal">loader=/boot/chain.b</code>
            を追加してください。たとえば、このようになります。
          </p><pre class="programlisting">other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=FreeBSD</pre><p>
            場合によっては、二つ目のディスクを正しく起動するために FreeBSD
            ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません。
            たとえば、FreeBSD SCSI ディスクが BIOS によって
            BIOS ディスク 1 として認識されるのなら、
            FreeBSD のブートローダのプロンプトで、次のように指定する必要があります。

            </p><pre class="screen"><code class="prompt">Boot:</code> <strong class="userinput"><code>1:da(0,a)/kernel</code></strong></pre><p>
          </p><p>
            FreeBSD 2.2.5 やそれ以降の版では、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a> を設定すれば
            起動時に上記のことが自動的に行えます。
          </p><p>
            <a class="link" href="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html" target="_top">Linux+FreeBSD
              mini-HOWTO</a> が FreeBSD と Linux
            とを相互に使えるようにするためのよい参考資料になるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79227216"></a><a id="booteasy-loader"></a><p><strong>7.11.</strong></p></td><td align="left" valign="top"><p>FreeBSD と Linux を BootEasy から起動するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            LILO をマスターブートレコード (MBR) ではなく
            Linux の起動パーティションにインストールしてください。
            これで BootEasy から
            LILO を起動できるようになります。
          </p><p>
            Windows95 と Linux を使用している場合は、
            いずれにせよ後者の方がおすすめです。
            Windows95 を再インストールする必要にかられたとき、
            Linux を起動可能に戻す手続きが簡単ですむからです
            (Windows95 は偏屈なオペレーティングシステムで、
            マスターブートレコード (MBR) から他のオペレーティングシステムを追い払ってしまうのです)。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79270864"></a><a id="dangerously-dedicated"></a><p><strong>7.12.</strong></p></td><td align="left" valign="top"><p>「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a id="dedicate"></a>
              インストール作業中、
              ハードディスクのパーティションを切る際に
              2 つの方法を選ぶことができます。
              デフォルトの方法では、fdisk のテーブルエントリ (FreeBSD
              ではスライスと呼ばれる) を使って、
              自身のパーティションを使用する FreeBSD のスライスを、
              同じマシンの他のオペレーティングシステムと互換性のある形にします。
              それに付随して、ブートセレクタをインストールすれば、
              ディスク上の使用可能なオペレーティングシステムを切り替えることができます。
              もう一つの方法はディスクすべてを FreeBSD で使うというもので、
              この場合ほかのオペレーティングシステムとの互換性を考慮しないことになります。
          </p><p>
            では、なぜこれが 「危険覚悟の」と言われるのでしょう?
            このモードのディスクが、通常の PC のユーティリティが有効な fdisk
            テーブルと見なす情報を持っていないからです。
            ユーティリティの出来如何によりますが、
            そのようなディスクを発見したとき、
            警告を出すものもあります。また、もっと悪い場合、
            確認も通告もなしに
            BSD のブートストラップにダメージを与えるものもあるでしょう。
            さらには、「危険覚悟の」ディスクレイアウトは多数の BIOS、
            AWARD (たとえば HP Netserver や Micronics システム、
            他多数で使用されていた) や
            Symbios/NCR (人気のあるSCSI コントローラ 53C8xx
            用) などを混乱させることが分かっています。
            これは完全なリストではありません。
            他にもまだまだあります。この混乱の兆候は、
            起動時にシステムがロックするというだけでなく、
            FreeBSD のブートストラップが自分自身を見つけられないために表示する
            <span class="quote">「<span class="quote">read error</span>」</span>
            というメッセージなどにも現れることでしょう。
          </p><p>
            そもそもいったいなぜこのモードがあるのでしょうか?
            これはわずかに数キロバイトのディスク容量を節約するのみであり、
            新規インストールで実際に問題を生ずるのです。
            「危険覚悟の」モードの起源は新しい FreeBSD インストーラでの、
            BIOS から見えるディスクの
            「ジオメトリ」の値とディスク自身との整合性という、
            もっとも一般的な問題のひとつを回避したいという要求が背景にあります。
          </p><p>
            「ジオメトリ」は時代遅れの概念ですが、
            未だに PC BIOS とディスクへの相互作用の中核をなしています。
            FreeBSD のインストーラがスライスを作る時、
            ディスク上のスライスを BIOS が見つけられるように、
            スライス位置をディスク上に記録します。それが誤っていれば、
            起動できなくなってしまうでしょう。
          </p><p>
            「危険覚悟の」モードはこれを、
            問題を単純にすることで回避しようとします。
            状況によってはこれでうまくいきます。
            しかし次善の策として使われているに過ぎません。
            この問題を解決するもっと良い方法はいくらでもあるのです。
          </p><p>
            では、
            インストール時に「危険覚悟の専用」モードが必要になる
            状況を回避するにはどうすればよいのでしょうか?
            まず BIOS が報告するディスクのジオメトリの値を覚えておくことからはじめましょう。
            <span class="quote">「<span class="quote">boot:</span>」</span>
            プロンプトで <span class="quote">「<span class="quote"><code class="option">-v</code></span>」</span>
            を指定するか、ローダで
            <span class="quote">「<span class="quote">boot -v</span>」</span>
            と指定して、
            起動時にカーネルにこの値を表示させることができます。
            インストーラが起動する直前に、
            カーネルがジオメトリ値のリストを表示するでしょう。
            パニックを起こさないでください。
            インストーラが起動するのを待ち、
            逆スクロールでさかのぼって値を確認してください。
            普通は BIOS
            ディスクユニット番号は、
            FreeBSD がディスクを検出する順序と同様であり、
            最初に IDE、次に SCSI となります。
          </p><p>
            ディスクをスライシングする際に、
            FDISK の画面で表示されるディスクのジオメトリが正しいこと (BIOS
            の返す値と一致しているか) を確認してください。
            万一異なっていたら <span class="quote">「<span class="quote"><strong class="userinput"><code>g</code></strong></span>」</span>
            を押して修正してください。
            ディスクにまったくなにもない場合や、
            他のシステムから持ってきたディスクの場合は
            これを行なう必要があるかもしれません。
            これはそのディスクから起動させようとしている場合にのみ、
            問題になることに注意してください。
            FreeBSD はそのディスクをうまい具合いに他のディスクと区別してくれます。
          </p><p>
            ディスクのジオメトリについて BIOS と FreeBSD
            間で一致させることができたら、この問題はほぼ解決したと思ってよいでしょう。
            そしてもはや「危険覚悟の専用」モードは必要ありません。
            しかし、まだ起動時に恐怖の
            <span class="quote">「<span class="quote">read error</span>」</span>
            メッセージが出るようであれば、
            お祈りを捧げて新しいディスクを買いましょう。
            もう失うものは何もありません。
          </p><p>
            「危険覚悟の専用ディスク」を通常の PC
            での使用法に戻すには、
            原則として 2 つ方法があります。1 つは十分な NULL
            バイトを MBR に書き込んで、
            きたるべきインストーラにディスクはまっさらだと思い込ませる方法です。
            たとえば、こんな感じです。

            </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/dev/rda0 count=15</code></strong></pre><p>
          </p><p>
            また、マニュアルには書かれていない DOS の「機能」

            </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>fdisk /mbr</code></strong></pre><p>

              は、BSD ブートストラップを追い払ってくれる上に、
            新しいマスターブートレコードをインストールしてくれます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79346768"></a><a id="add-swap-space"></a><p><strong>7.13.</strong></p></td><td align="left" valign="top"><p>どのようにしたらスワップ領域を増やせますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            スワップパーティションのサイズを増やすのが最良の方法ですが、
            別のディスクを追加しなくて済むという利点のある方法があります。
            経験から得た一般的な方法はメインメモリの 2倍程度のスワップ領域を
            とるというものです。しかしごく小さなメインメモリしかない場合は、
            それ以上のスワップを構成したいと思うでしょう。また、将来のメモリの
            アップグレードに備え、後でスワップの構成を変更する必要がないように
            十分なスワップを構成しておくことは良い考えです。
          </p><p>
            スワップを別のディスク上に追加することは、単純に同じディスク上
            にスワップを追加する場合よりも高速に動作するようになります。
            例に挙げれば、あるディスク上のソースをコンパイルしているとして、
            スワップが別のディスク上に作られていれば、これらが同じディスク上
            にある場合よりも断然速いです。SCSI ディスクの場合は特にそうだと言えます。
          </p><p>
            ディスクが複数ある場合、スワップパーティションを各ディスクに
            作るように構成すると、使用中のディスク上にスワップを置いたとしても、
            通常の場合は有益です。一般的に、システムにある高速なディスクには
            スワップを作るようにすべきでしょう。
            FreeBSD はデフォルトでインターリーブなスワップデバイスを 4つまで
            サポートします。複数のスワップパーティションを構成する際に、
            普通はそれらを大体同じくらいの大きさにして作りたいところですが、
            カーネルのコアダンプを取るのに都合が良いようにメインの
            スワップパーティションを大きめにとる人もいます。
            メインのスワップパーティションはカーネルのコアがとれるように
            最低でも実メモリと同じ大きさにすべきでしょう。
          </p><p>
            IDE ドライブは同時に同じチャネル上の複数のドライブには
            アクセスできません (FreeBSD は mode 4 をサポートしていないので、
            すべての IDE ディスク I/O は <span class="quote">「<span class="quote">programmed</span>」</span> です)。
            IDE の場合であってもやはり、スワップを別のハードディスク上に
            作成することをおすすめします。
            ドライブは実に安いものです、心配するだけ無駄です。
          </p><p>
            NFS 越しにスワッピングさせる方法は、
            スワップ用のローカルディスクが無い場合にのみ推奨されます。
            NFS 越しのスワッピングは遅く、FreeBSD 4.x より前のリリースでは
            効率が悪いのですが、4.0 以降ではそれなりに高速になります。
            そうはいっても、利用できるネットワークの太さに制限されますし、
            NFS サーバに余計な負荷がかかります。
          </p><p>
            これは 64MBの vn-swap を作る例です (ここでは
            <code class="filename">/usr/swap0</code>
            としますが、もちろん好きな名前を使うことができます)。
          </p><p>
            カーネルが次の行を含むコンフィグファイルから構成されているかを
            確認します。GENERIC カーネルには、この行が含まれています。
          </p><pre class="programlisting">pseudo-device   vn 1   #Vnode driver (turns a file into a device)</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>vn デバイスを作ります</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh ./MAKEDEV vn0</code></strong></pre></li><li class="listitem"><p>スワップファイルを作ります
                (<code class="filename">/usr/swap0</code>)</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</code></strong></pre></li><li class="listitem"><p>スワップファイルに適切なパーミッションを設定します</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 0600 /usr/swap0</code></strong></pre></li><li class="listitem"><p><code class="filename">/etc/rc.conf</code>
                でスワップファイルを有効化させます</p><pre class="programlisting">swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</pre></li><li class="listitem"><p>マシンを再起動します</p></li></ol></div><p>
            スワップファイルをすぐに有効化させたいのなら以下のようにタイプします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>vnconfig -e /dev/vn0b /usr/swap0 swap</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79366608"></a><a id="printer-setup"></a><p><strong>7.14.</strong></p></td><td align="left" valign="top"><p>プリンタのセットアップで問題があります</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ハンドブックのプリンタの部分を参照してください。
            探している問題のほとんどが書かれているはずです。
            <a class="link" href="../handbook/printing.html" target="_top">FreeBSD
              ハンドブックの「プリンタの利用」</a>をご覧ください。
          </p><p>プリンタによっては、印刷するのにホスト側にドライバが
            必要です。これら <span class="quote">「<span class="quote">WinPrinters</span>」</span> と呼ばれるものは、
            素の FreeBSD では使えません。DOS や Windows NT 4.0 で動作しない
            なら、そのプリンタはおそらく WinPrinter でしょう。
            ただし、唯一の希望が残されています。
            <code class="filename">ports/print/pnm2ppa</code> の port が
            対応しているかどうか確認してみてください。<a class="link" href="http://www.freebsd.org/cgi/url.cgi?ports/print/pnm2ppa/pkg-descr" target="_top">
            パッケージの説明</a>にはこう書いてあります。</p><div class="blockquote"><blockquote class="blockquote"><p>このソフトウェアは PPA (printer performance
              architecture) プロトコルの出力を行います。このプロトコル
              は HP の "Windows 専用" プリンタの一部に使われています。
              そのなかには、HP Deskjet 820C シリーズ、HP DeskJet 720
              シリーズ、および HP DeskJet 1000 シリーズがあります。(略)</p><p>WWW: <a class="link" href="http://pnm2ppa.sourceforge.net/" target="_top">http://pnm2ppa.sourceforge.net/</a></p></blockquote></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79372496"></a><a id="keyboard-mappings"></a><p><strong>7.15.</strong></p></td><td align="left" valign="top"><p>私のシステムのキーボードマッピングは間違っています。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">kbdcontrol</code> プログラムは、
            キーボードマップファイルを読み込むためのオプションを備えています。
            <code class="filename">/usr/share/syscons/keymaps</code>
            の下にたくさんのマップファイルがあります。
            システムに関連のあるものを一つ選んで、ロードしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kbdcontrol -l uk.iso</code></strong></pre><p>
            <code class="filename">/usr/share/syscons/keymaps</code>
            と拡張子
            <code class="filename">.kbd</code> は、どちらも
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kbdcontrol</span>(1)</span></a>
            によって使用されます。
          </p><p>
            これは <code class="filename">/etc/sysconfig</code> (または
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>)
            中で設定することができます。
            このファイル中にあるそれぞれのコメントを参照してください。
          </p><p>
            FreeBSD 2.0.5R
            やそれ以降の版では、
            テキストフォントやキーボードマッピングに関係のあるものはすべて、
            <code class="filename">/usr/share/examples/syscons</code>
            の中におさめられています。
          </p><p>現在以下のマッピングがサポートされています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Belgian ISO-8859-1</p></li><li class="listitem"><p>Brazilian 275 keyboard Codepage 850</p></li><li class="listitem"><p>Brazilian 275 keyboard ISO-8859-1</p></li><li class="listitem"><p>Danish Codepage 865</p></li><li class="listitem"><p>Danish ISO-8859-1</p></li><li class="listitem"><p>French ISO-8859-1</p></li><li class="listitem"><p>German Codepage 850 </p></li><li class="listitem"><p>German ISO-8859-1</p></li><li class="listitem"><p>Italian ISO-8859-1</p></li><li class="listitem"><p>Japanese 106</p></li><li class="listitem"><p>Japanese 106x</p></li><li class="listitem"><p>Latin American</p></li><li class="listitem"><p>Norwegian ISO-8859-1</p></li><li class="listitem"><p>Polish ISO-8859-2 (programmer's)</p></li><li class="listitem"><p>Russian Codepage 866 (alternative)</p></li><li class="listitem"><p>Russian koi8-r (shift)</p></li><li class="listitem"><p>Russian koi8-r</p></li><li class="listitem"><p>Spanish ISO-8859-1</p></li><li class="listitem"><p>Swedish Codepage 850</p></li><li class="listitem"><p>Swedish ISO-8859-1</p></li><li class="listitem"><p>Swiss-German ISO-8859-1</p></li><li class="listitem"><p>United Kingdom Codepage 850</p></li><li class="listitem"><p>United Kingdom ISO-8859-1</p></li><li class="listitem"><p>United States of America ISO-8859-1</p></li><li class="listitem"><p>United States of America dvorak</p></li><li class="listitem"><p>United States of America dvorakx</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79414224"></a><a id="pnp-resources"></a><p><strong>7.16.</strong></p></td><td align="left" valign="top"><p>起動時に、<span class="errorname">unknown: &lt;PNP0303&gt; can't
              assign resources</span> というメッセージが表示されるのですが?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>以下は、freebsd-current メーリングリストへの投稿からの
            抜粋です。</p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top">〓</td><td width="80%" valign="top"><p><span class="quote">「<span class="quote">can't assign resources</span>」</span> というメッセージは、
              そのデバイスがレガシー ISA デバイスで、PnP を意識していない
              ドライバがカーネルに組み込まれていることを示します。
              これには、キーボードコントローラ、プログラム可能な
              割り込み制御 IC やその他さまざまな標準的なデバイスが
              あります。リソースが割り当てられないのは、既にそのアドレスを
              使っているドライバがあるからです。</p></td><td width="10%" valign="top">〓</td></tr><tr><td width="10%" valign="top">〓</td><td colspan="2" align="right" valign="top">--<span class="attribution">Garrett Wollman, 2001 年 4 月 24 日</span></td></tr></table></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79418448"></a><a id="user-quotas"></a><p><strong>7.17.</strong></p></td><td align="left" valign="top"><p>ユーザディスククォータが正常に動作していないようです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="quote">「<span class="quote"><code class="filename">/</code></span>」</span>
                  にはディスククォータを設定しないでください。</p></li><li class="listitem"><p>
                  クォータファイルが置かれるファイルシステム上に
                  クォータファイルを置くようにしてください。
                </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Filesystem</th><th>Quota file</th></tr></thead><tbody><tr><td><code class="filename">/usr</code></td><td><code class="filename">/usr/admin/quotas</code></td></tr><tr><td><code class="filename">/home</code></td><td><code class="filename">/home/admin/quotas</code></td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79429456"></a><a id="inappropriate-ccd"></a><p><strong>7.18.</strong></p></td><td align="left" valign="top"><p>わたしの ccd は、
            何が適合していない (Inappropriate) のでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>次のような症状が現れます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ccdconfig -C</code></strong>
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format</pre><p>
            通常この現象はタイプを「未使用 (unused)」のまま放っておかれた
            <code class="literal">c</code>
            パーティションをつなげようとした場合に現れます。ccd ドライバは
            FS_BSDFFS
            タイプをベースとするパーティションを要求します。
            つなげようとしているディスクのディスクラベルを編集して、
            パーティションのタイプを <code class="literal">4.2BSD</code>
            に変更してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79433680"></a><a id="ccd-disklabel"></a><p><strong>7.19.</strong></p></td><td align="left" valign="top"><p>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>次のような症状が現れます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel ccd0</code></strong>
(it prints something sensible here, so let's try to edit it)
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -e ccd0</code></strong>
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label</pre><p>
            これは ccd から返されるディスクラベルが、
            実はディスク上にはないまったくの偽の情報だからです。
            これを明示的に書き直すことで問題を解消できます、
            それには、つぎのようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel ccd0 &gt; /tmp/disklabel.tmp</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -Rr ccd0 /tmp/disklabel.tmp</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -e ccd0</code></strong>
(this will work now)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79444816"></a><a id="sysv-ipc"></a><p><strong>7.20.</strong></p></td><td align="left" valign="top"><p>FreeBSD は System V の IPC プリミティブをサポートしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい。
            FreeBSD は System-V スタイルの IPC をサポートします。
            共有メモリ、メッセージ、セマフォが含まれます。
            以下の行をカーネルコンフィグファイルに加えると、
            サポートが有効になります。
          </p><pre class="programlisting">options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD 3.2 とそれ以降では、
                これらのオプションがあらかじめ <span class="emphasis"><em>GENERIC</em></span>
                カーネルに含まれていますので、
                あなたのシステムにはすでに組み込まれています。</p></div><p>カーネルを再構築してインストールしてください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79448912"></a><a id="uucpmail"></a><p><strong>7.21.</strong></p></td><td align="left" valign="top"><p>UUCP でメールを配送するには sendmail をどう使えばよいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD に付属している sendmail は、
            インターネットに直接つながっているサイトにあわせて設定してあります。
            UUCP 経由で mail を交換したい場合には sendmail
            の設定ファイルを改めてインストールしなければなりません。
          </p><p>
            <code class="filename">/etc/sendmail.cf</code>
            を自分の手で改造するのは純粋主義者のやるような事です。
            sendmail の version 8 は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=m4&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">m4</span>(1)</span></a>
            のようなプリプロセッサを通して設定ファイルを生成する新しいアプローチを取っており、
            より抽象化されたレベルの設定ファイルを編集します。
            <code class="filename">/usr/src/usr.sbin/sendmail/cf</code>
            ディレクトリの中にある設定ファイルを使用してください。
          </p><p>
            もしすべてのソースをインストールしていない場合には sendmail
            の設定ツールは、別の tar ファイルにまとめてあります。CD-ROM が
            mount されている場合には、次のようにしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/src</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</code></strong></pre><p>
            これはたった数 100Kbyte ですから心配ないでしょう。
            <code class="filename">cf</code>
            ディレクトリにある <code class="filename">README</code>
            に、m4 での設定の基本的な説明があります。
          </p><p>
            UUCP での配送のためには、<code class="literal">mailertable</code> を使用すれば
            よいでしょう。これによって、sendmail
            が配送方式を決定するデータベースを
            作成することができます。
          </p><p>まずはじめに、
            <code class="filename">.mc</code> ファイルを作成しなければなりません。
            <code class="filename">/usr/src/usr.sbin/sendmail/cf/cf</code> というディレクトリが、
            これらのファイルを作成する場所です。既にいくつか例があると思います。
            これから作成するファイルの名前を <code class="filename">foo.mc</code> とすると、
            <code class="filename">sendmail.cf</code> を求めているような形式に変換するには、
            次のようにしてください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/usr.sbin/sendmail/cf/cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make foo.cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cp foo.cf /etc/sendmail.cf</code></strong></pre><p>
            標準的な
            <code class="filename">.mc</code> ファイルは次のようになります。
          </p><pre class="programlisting">include(`../m4/cf.m4')
VERSIONID(`<em class="replaceable"><code>Your version number</code></em>')
OSTYPE(bsd4.4)

FEATURE(nodns)
FEATURE(nocanonify)
FEATURE(mailertable)

define(`UUCP_RELAY', <em class="replaceable"><code>your.uucp.relay</code></em>)
define(`UUCP_MAX_SIZE', 200000)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <em class="replaceable"><code>your.alias.host.name</code></em>
Cw    <em class="replaceable"><code>youruucpnodename.UUCP</code></em></pre><p>
            <code class="literal">nodns</code> と
            <code class="literal">nocanonify</code> という指定をすることで、
            mail の配送に DNS を使用しなくなります。
            <code class="literal">UUCP_RELAY</code> という
            行に関しては、
            ある理由から必要ですがそれは聞かないでください。
            .UUCP で終わる仮想ドメインを処理することのできるインターネット上での
            ホスト名をここに書いてください。通常は、ISP の mail リレーホストを
            書くことになると思います。
          </p><p>
            これが終了したら、次に
            <code class="filename">/etc/mailertable</code>
            というファイルが必要です。標準的な例は次のとおりです。
          </p><pre class="programlisting">#
# makemap hash /etc/mailertable.db &lt; /etc/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre><p>
            見れば分かるように、これは実在する設定のファイルです。はじめの
            3 行はドメイン名で指定されたメールが default の経路で配送されずに、
            「近道」するために UUCP で隣りのサイトに送るための特別な状況を
            処理するものです。
            次の行は Ethernet でつながっているローカルのドメインに対しては
            SMTP で送るための設定です。
            最後に、UUCP での隣りのサイトが .UUCP で終わる仮想ドメインの書式で
            指定されており、default の rule を
            <code class="literal">uucp-neighbour!
            recipient</code>
            で上書きするためのものです。一番最後の行はいつもドットを一つ書きます。
            これは、ここまでの行でマッチしなかったすべてのホストにマッチし、
            このサイトから世界に向けて出ていくための mail gateway に UUCP
            で配送するためのものです。
            <code class="literal">uucp-dom:</code> に続けて書かれているノード名は、
            <code class="literal">uuname</code> コマンドで指定することによって UUCP
            で直接配送される正しいノード名でなければなりません。
          </p><p>
            最後に、このファイルは使用する前に DBM データベースのファイルに
            変換する必要があります。これを行なうコマンドラインは mailertable
            の最初のコメントに書いてあります。mailertable を変更した時には、
            必ずこのコマンドを実行してください。
          </p><p>
            最後のヒントです: もし特定のメール配送がうまく作動するかどうか
            確かめたい場合には、sendmail の<code class="option">-bt</code> オプションを
            使用してください。このオプションによって sendmail は
            <span class="emphasis"><em>アドレステストモード</em></span>で起動します。
            <code class="literal">0</code>
            の後に配送したいアドレスを書いてください。最後の行に、実際に使用される
            mail agent、この mail agent で送られる送信先のホスト、そして
            (多分変換されている) アドレスが表示されます。このモードを抜けるには
            Control-D を押してください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sendmail -bt</code></strong>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>0 foo@interface-business.de</code></strong>
rewrite: ruleset  0   input: foo @ interface-business . de
...
rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
&lt; @ interface-business . de &gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>^D</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79485392"></a><a id="ispmail"></a><p><strong>7.22.</strong></p></td><td align="left" valign="top"><p>ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            静的に IP アドレスが割り当てられる場合は、
            デフォルトの状態を変更する必要はありません。
            割り当てられた名前をホストネームと
            するだけで、sendmail が後のことを引き受けてくれます。
          </p><p>
            ダイアルアップ <span class="application">ppp</span> を
            インターネット接続に使用し、動的に IP アドレスが割り当てられる場合は、
            インターネットサービスプロバイダ (ISP)
            のメールサーバにメールボックスがあるはずです。
            ISP のドメインが
            <code class="systemitem">myISP.com</code>
            で、あなたのユーザ名が
            <code class="systemitem">user</code> だと仮定します。
            また、あなたが自分のマシンを <code class="systemitem">bsd.home</code>
            と呼んでおり、ISP が
            <code class="systemitem">relay.myISP.com</code>
            をメールリレーとして使用できると言っているとしましょう。
          </p><p>
            メールボックスからメールを取ってくるためには、
            回収 (retrieval) エージェントをインストールする必要があります。
            <span class="application">Fetchmail</span>
            は多種多様なプロトコルをサポートしているのでお勧めです。
            ISP が使用しているのは、大抵 POP3 プロトコルです。
            ユーザ ppp を使用している場合、
            <code class="filename">/etc/ppp/ppp.linkup</code>
            に以下のように記述すると、
            インターネットと接続が完了した時点で自動的にメールを取得するようになります。
          </p><pre class="programlisting">MYADDR:
        !bg su user -c fetchmail</pre><p>
            ローカルでないアカウントにメールを配送するのに
            sendmail を使用している場合 (後述)、
            上に示したエントリの後に
          </p><pre class="programlisting">        !bg su user -c "sendmail -q"</pre><p>
            を記述します。これはネットワーク接続が確立したらすぐに
            <span class="application">sendmail</span> に溜っている
            mailqueue を強制的に処理させるようにします。
          </p><p>
            この例では、<code class="systemitem">user</code> が
            <code class="systemitem">bsd.home</code> にアカウントを持ち、
            <code class="systemitem">bsd.home</code> 上の
            <code class="systemitem">user</code>
            のホームディレクトリに、以下のような
            <code class="filename">.fetchmailrc</code>
            ファイルがつくられていることを想定しています。
          </p><pre class="programlisting">poll myISP.com protocol pop3 fetchall pass MySecret;</pre><p>
            言うまでもなく、このファイルは
            <code class="systemitem">user</code>
            以外のユーザが読むことが出来ないようにしなくてはなりません。
            内容にパスワード <code class="literal">MySecret</code>
            が含まれているからです。
          </p><p>
            正しい
            <code class="literal">from:</code>
            ヘッダをつけてメールを送るためには、
            <span class="application">sendmail</span> に
            <code class="literal">user@bsd.home</code> ではなく
            <code class="literal">user@myISP.com</code>
            を使用するよう教える必要があります。
            メールをより早く転送するために、すべてのメールを
            <code class="systemitem">relay.myISP.com</code>
            へ送るように <span class="application">sendmail</span> に
            指示しておくのも良いでしょう。
          </p><p>
            上の要件を満たすには、以下のような <code class="filename">.mc</code>
            ファイルが適しています。
          </p><pre class="programlisting">VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`myISP.com')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.myISP.com')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE', `deferred')dnl</pre><p>
            <code class="filename">.mc</code> ファイルから
            <code class="filename">sendmail.cf</code> への変換方法については、
            前のセクションを参照してください. sendmail.cf を更新した後に
            <span class="application">sendmail</span> をリスタートするのもお忘れなく。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79512272"></a><a id="toor-account"></a><p><strong>7.23.</strong></p></td><td align="left" valign="top"><p>この UID が 0 の <code class="systemitem">toor</code> という
            アカウントとは何ですか? 危険にさらされているのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>心配無用です。<code class="systemitem">toor</code> は
            <span class="quote">「<span class="quote">代替の</span>」</span> スーパーユーザーアカウントです
            (toor は root を逆に綴ったものです)。
            以前は、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bash&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">bash</span>(1)</span></a> シェルがインストールされた時に
            作成されていましたが、現在は標準で作成されています。
            このユーザーが作成されるのは、
            スーパーユーザが非標準のシェルを使う場合を想定しており、
            <code class="systemitem">root</code>
            の標準のシェルを変更しなくてもよくなっています。
            基本配布に含まれていないシェル
            (たとえば ports や packages からインストールされるシェル)
            は、デフォルトでは別のファイルシステムに存在する
            可能性のある <code class="filename">/usr/local/bin</code> に
            インストールされることが多いので、これは重要です。
            <code class="systemitem">root</code> のシェルが
            <code class="filename">/usr/local/bin</code> にあり、
            <code class="filename">/usr</code>
            (または、<code class="filename">/usr/local/bin</code>
            があるいずれかのファイルシステム)
            が何らかの理由でマウントされていないとすると、
            <code class="systemitem">root</code> は問題を解決するために
            ログインすることができません (シングルユーザーモードで再起動すれば、
            シェルのパスの入力を促されるのですが)。</p><p><code class="systemitem">toor</code> を日々の root の仕事を
            非標準のシェルで行うために使い、<code class="systemitem">root</code> は
            シングルユーザーモードや緊急時のために、標準のシェルのままに
            している人がいます。何もしなければ、パスワードを無効にしてあるので
            <code class="systemitem">toor</code> ではログインできません。
            使いたいなら、<code class="systemitem">root</code> でログインして <code class="systemitem">toor</code> の
            パスワードを設定しましょう。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79530960"></a><a id="forgot-root-pw"></a><p><strong>7.24.</strong></p></td><td align="left" valign="top"><p>しまった! root のパスワードを忘れてしまった!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            慌てないでください! 単にシステムを再起動し、
            シングルユーザモードに移るために <code class="prompt">Boot:</code>
            と表示されるプロンプトで <strong class="userinput"><code>boot -s</code></strong>
            と入力してください
            (FreeBSD の 3.2 より前のリリースでは
            <strong class="userinput"><code>-s</code></strong>となります)。
            どのシェルを使うのかという質問には、ENTER
            キーを押してください。<code class="prompt">#</code>
            に移ることができるでしょう。
            <code class="command">mount -u /</code> と入力して
            ルートファイルシステムの読み書きを再マウントし、
            <code class="command">mount -a</code> と入力して、
            すべてのファイルシステムをマウントし直した後、
            <code class="command">passwd root</code>
            と入力して <code class="systemitem">root</code>
            のパスワードを設定し直してください。
            その後、<code class="command">exit</code>
            と入力すれば、起動が続けられます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79557200"></a><a id="CAD-reboot"></a><p><strong>7.25.</strong></p></td><td align="left" valign="top"><p>
            <span class="keycap"><strong>Control</strong></span>-<span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>Delete</strong></span>
            でシステムが再起動しないようにするにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.2.7-RELEASE 以降で syscons (デフォルトのコンソールドライバ)
            を使用している場合には、次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し、インストールしてください。
          </p><pre class="programlisting">options SC_DISABLE_REBOOT</pre><p>
            FreeBSD 2.2.5-RELEASE 以降で PCVT コンソールドライバを使用している
            場合には、同様に次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し、インストールしてください。
          </p><pre class="programlisting">options PCVT_CTRL_ALT_DEL</pre><p>
            上にあげたものよりも古い FreeBSD の場合、
            現在コンソールが使用しているキーマップを編集し、
            キーワード
            <code class="literal">boot</code> を
            <code class="literal">nop</code> に書き換えてください。
            <code class="filename">/usr/share/syscons/keymaps/us.iso.kbd</code>
            にあります。
            その変更を反映させようとして、
            このキーマップのロードを明示的に行なうために、
            <code class="filename">/etc/rc.conf</code> を実行すべきかもしれません。
            もちろん他の国のキーマップを使っているのであれば、
            代わりにそのキーマップファイルを編集してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79563600"></a><a id="dos-to-unix-txt"></a><p><strong>7.26.</strong></p></td><td align="left" valign="top"><p>DOS のテキストファイルを UNIX
            のテキストファイルに整形するにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            単に次の perl コマンドを実行してください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>perl -i.bak -npe 's/\r\n/\n/g' file ...</code></strong></pre><p>
            file
            の部分には処理するファイルを指定してください。
            整形後のファイルは元のファイル名で作成され、
            整形前のファイルはバックアップとして元の
            ファイル名の末尾に拡張子
            <code class="filename">.bak</code> のつけられた名前で作成されます。
          </p><p>
            あるいは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tr</span>(1)</span></a>
            コマンドを使うこともできます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tr -d '\r' &lt; dos-text-file &gt; unix-file</code></strong></pre><p>
            <em class="replaceable"><code>dos-text-file</code></em> は
            DOS 形式のテストファイル、
            <em class="replaceable"><code>unix-file</code></em>
            には変換された出力が格納されます。
            perl を使うよりほんのちょっぴり速くなります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79574864"></a><a id="kill-by-name"></a><p><strong>7.27.</strong></p></td><td align="left" valign="top"><p>名前で指定してプロセスにシグナルを送るにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=killall&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">killall</span>(1)</span></a>
            を使ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79577680"></a><a id="root-acl"></a><p><strong>7.28.</strong></p></td><td align="left" valign="top"><p>su が not in <code class="systemitem">root</code>'s ACL
            と言って私を悩ませるのはなぜ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Kerberos の認証システムからくるエラーです。
            この問題は致命的なものではなく、
            うっとおしいといったものです。
            <code class="command">su</code> に <code class="option">-K</code>
            オプションをつけて起動するか、
            次の質問で説明されている方法で Kerberos
            をアンインストールしてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79581136"></a><a id="uninstall-kerberos"></a><p><strong>7.29.</strong></p></td><td align="left" valign="top"><p>Kerberos をアンインストールするにはどうすればいいの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            システムから Kerberos を削除するには、
            あなたの動かしているリリースの
            bin ディストリビューションを再インストールしてください。
            もし CDROM を持っているのなら、
            その CDROM をマウント (マウントポイントは
            <code class="filename">/cdrom</code> と仮定) して、
            次のように入力してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/bin</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./install.sh</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79585360"></a><a id="add-pty"></a><p><strong>7.30.</strong></p></td><td align="left" valign="top"><p>疑似ターミナルを追加するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            telnet、ssh、X、screen をたくさん利用されている場合、
            疑似ターミナルが足りなくなっている可能性があります。
            これを増やすには次のようにします。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  次の行をカーネルコンフィグレーションファイルに追加して

                  </p><pre class="programlisting">pseudo-device pty 256</pre><p>

                  新たにカーネルを作りインストールします。
                </p></li><li class="step"><p>
                  次のコマンドを実行して

                  </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV pty{1,2,3,4,5,6,7}</code></strong></pre><p>

                  新たなターミナル用の 256 個のデバイスノードを作ります。
                </p></li><li class="step"><p>
                  <code class="filename">/etc/ttys</code> を編集し
                  256 個のターミナルごとの定義を追加します。
                  既存のエントリーの形式にあわせる必要があるでしょう。
                  たとえばこんな感じです。
                </p><pre class="programlisting">ttyqc none network</pre><p>
                  正規表現を使った指定は
                  <code class="literal">tty[pqrsPQRS][0-9a-v]</code>
                  となります。
                </p></li><li class="step"><p>
                  新しいカーネルでシステムを再起動すると完了です。
                </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79598672"></a><a id="create-snd0"></a><p><strong>7.31.</strong></p></td><td align="left" valign="top"><p>
            <code class="filename">snd0</code>
            デバイスを作成することができません!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="filename">snd</code> というデバイスは存在しません。
            この名前は、FreeBSD
            サウンドドライバによって作成されるさまざまなデバイス、
            <code class="filename">mixer</code> や
            <code class="filename">sequencer</code>、
            <code class="filename">dsp</code>
            などを総称したものです。
          </p><p>これらのデバイスを作成するには、次のようにする必要があります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV snd0</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79604816"></a><a id="reread-rc"></a><p><strong>7.32.</strong></p></td><td align="left" valign="top"><p>再起動せずにもう一度
            <code class="filename">/etc/rc.conf</code>
            を読み込んで
            <code class="filename">/etc/rc</code>
            を開始させるには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            シングルユーザモードに移行して、
            マルチユーザモードに戻ってください。
          </p><p>
            コンソールで次のように実行します。

            </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>shutdown now</code></strong><span class="emphasis"><em>(注: <code class="option">-r</code> や <code class="option">-h</code> は付けません)</em></span>
<code class="prompt">#</code> <strong class="userinput"><code>return</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>exit</code></strong></pre><p>
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79615696"></a><a id="sandbox"></a><p><strong>7.33.</strong></p></td><td align="left" valign="top"><p>砂場 (sandbox) とは何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">砂場 (Sandbox)</span>」</span> とはセキュリティ用語の一つで、
            次の二つの意味があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  一つ目は、「仮想的な『防壁』で囲まれているプロセス」です。
                  その『防壁』は、そのプロセスに侵入した第三者が、
                  さらにシステムの広い範囲に影響を与えることを防ぐように設計されます。
                </p><p>
                  このプロセスの振舞いは、『防壁』の中だけに制限される、と表現できます。
                  つまり、このプロセスにおいて、『防壁』を越えるようなコードの実行は
                  できないという意味です。そのため、コードの実行におけるセキュリティは
                  確かなものであると保証でき、実行の詳細な追跡を行なう必要はなくなります。
                </p><p>
                  その『防壁』とは、たとえばユーザ ID がそれにあたるでしょう。
                  この定義は、security(7) や named(8) のマニュアルページで用いられています。
                </p><p>
                  <code class="literal">ntalk</code>
                  サービス (/etc/inetd.conf
                  参照のこと) を例にとってみます。
                  このサービスはかつて、実行時の ユーザ ID として
                  root
                  を用いていましたが、現在では
                  tty
                  というユーザ ID で動作します。
                  ユーザ
                  tty は、
                  ntalk を経由してシステムの侵入に成功した第三者が
                  そのユーザ ID 以上の権限を得ることを、
                  より一層困難にするために設計された砂場 (sandbox) なのです。
                </p></li><li class="listitem"><p>
                  二つ目は「シミュレートされたマシンの内側で実行されるプロセス」のことで、
                  こちらはより中核的です。
                  普通に考えれば、あるプロセスに侵入することができる第三者は、
                  マシンのより広い範囲にも侵入できると信じるものなのですが、
                  この種のプロセスの場合、それは実際にはシミュレートされたマシンに
                  侵入しただけなので、現実のデータを変更することは何一つできません。
                </p><p>
                  これを実現するための最も広く用いられている方法は、
                  シミュレートされた環境をサブディレクトリに構築し、
                  そのディレクトリに chroot して、そのディレクトリで
                  プロセスを実行すること (つまり、そのプロセスにとって
                  <code class="filename">/</code> は
                  システムの実際のルートディレクトリ
                  <code class="filename">/</code> ではなく、
                  chroot されたサブディレクトリを指す) です。
                </p><p>
                  広く用いられているもう一つの方法があります。
                  それは、既に存在しているファイルシステムを
                  読み込み専用 (read-only) でマウントし、その上に、あるプロセスに対して
                  そのファイルシステムが書き込み可能であるように見せるような、
                  もう一つのファイルシステムの層を用意するものです。すると、
                  そのプロセスはファイルを書き込むことができると認識し、
                  実際に書き込むことができるのもその特定のプロセスだけ
                  - システムにある他のプロセスは書き込めないのに対して -
                  であるという状況を実現することができます。
                </p><p>
                  この種の砂場 (sandbox) は、
                  その非常に透過的な性質を使って、ユーザ (もしくは侵入者) が
                  その事実に気付かないように実現されます。
                </p></li></ul></div><p>
            UNIX は、内部的に二つの砂場 (sandbox) を実装しています。
            一つはプロセスレベルのもの、もう一つはユーザ ID レベルのものです。
          </p><p>
            UNIX プロセスはすべて、他の UNIX プロセスから完全に隔離されています。
            どのプロセスも、他のプロセスのアドレス空間を変更することはできません。
            これは、あるプロセスが他のプロセスのアドレス空間を上書きできるような、
            クラッシュにつながる行為が容易に実現できる Windows とは全く異なるものです。
          </p><p>
            UNIX プロセスは、特定のユーザ ID が所有します。
            もし、実行者のユーザ ID が <code class="systemitem">root</code>
            ユーザのものでなければ、
            ユーザ ID は、他のユーザが所有するプロセスから
            そのプロセスを守る機能を果たすわけです。
            また、そのユーザ ID は、ディスク上にあるデータを
            保護するのにも使われています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79625168"></a><a id="securelevel"></a><p><strong>7.34.</strong></p></td><td align="left" valign="top"><p>セキュアレベル (securelevel) って何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>セキュアレベルとはカーネルに実装されているセキュリティ機構の一つです。
            簡単に言うと、カーネルはセキュアレベルが正の値の時に、
            ある特定の操作を制限します。この制限は、たとえスーパユーザ
            (<code class="systemitem">root</code> のこと) であっても例外ではありません。
            この文を書いている時点では、
            セキュアレベル機構を使って以下のような操作を制限することができます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">schg</code> (system immutable flag)
                のようなファイルフラグの変更</p></li><li class="listitem"><p><code class="filename">/dev/mem</code> および
                <code class="filename">/dev/kmem</code>
                経由でのカーネルメモリへの書き込み</p></li><li class="listitem"><p>カーネルモジュールのロード</p></li><li class="listitem"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfirewall&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ipfirewall</span>(4)</span></a> ルールの変更</p></li></ul></div><p>稼働中のシステムでセキュアレベルの状態をチェックするには、
            次のコマンドを実行します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>出力には、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> 変数 (今の場合は
            <code class="varname">kern.securelevel</code>) と数字が現れます。
            数字が現在のセキュアレベルの値です。
            これがもし正の値なら、
            何らかのセキュアレベルによる制限が有効になっています。</p><p>システム稼働中にセキュアレベルを下げることはできません。
            これは、それを可能にするとセキュアレベルの意味がなくなってしまうからです。
            セキュアレベルが正の値でないことを要求する操作
            (たとえば <code class="buildtarget">installworld</code> や日付の変更など)
            を行なう必要がある場合は、<code class="filename">/etc/rc.conf</code>
            にあるセキュアレベルの設定 (<code class="varname">kern_securelevel</code> と
            <code class="varname">kern_securelevel_enable</code> という変数)
            を変更して再起動する必要があります。</p><p>セキュアレベルに関する詳しい情報や、
            各レベルで実現される機能に関しては
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> のマニュアルページを参照してください。</p><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">セキュアレベルは万能というわけではなく、
                弱点も数多く存在します。また、場合によっては、
                セキュリティを低下させてしまうこともあります。</p><p xmlns="http://www.w3.org/1999/xhtml">最も大きな問題の一つに、
                セキュアレベルの機能を有効にするには、
                起動処理でセキュアレベルが設定されるまでに使われるすべてのファイルを
                保護する必要があるということがあります。
                もし攻撃者が、システムがセキュアレベルを設定する前にコードを実行することができるとしたら、
                セキュアレベルによる保護は無意味になってしまいます
                (起動時には低いセキュアレベルでしか実行できない処理を行なう必要があるため、
                セキュアレベルの設定は、起動処理の最後の方で行なわれます)。
                起動処理で使われるすべてのファイルを保護することは技術的に不可能です。
                もしそうできたとしても、システムの保守はまさに悪夢となるでしょう。
                設定ファイル一つ書き換えるのにも、
                シングルユーザモードに切替えなければならなくなるのですから。
              </p><p xmlns="http://www.w3.org/1999/xhtml">以上で説明した内容やその他の点については、
                メーリングリストでも良く話題にのぼります。
                議論のようすを<a class="link" href="http://www.FreeBSD.org/search/" target="_top">このページ</a>から検索してみてください。
                セキュアレベルは、
                いずれより粒度の細かい機構にとって代わるだろうと考えている人々もいますが、
                その点についてはまだ不透明なままです。
              </p><p xmlns="http://www.w3.org/1999/xhtml">どうか注意するようにしてください。</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79649744"></a><a id="user-floppymount"></a><p><strong>7.35.</strong></p></td><td align="left" valign="top"><p>フロッピーや CDROM や他のリムーバブルメディアのマウントを一般ユーザーに許可するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            一般ユーザーでもデバイスをマウントできるようにすることができます。
            手順は次のとおりです。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p><code class="systemitem">root</code>
                になって、
                sysctl 変数である
                <code class="varname">vfs.usermount</code> を
                <code class="literal">1</code> に設定します。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w vfs.usermount=1</code></strong></pre></li><li class="step"><p><code class="systemitem">root</code>
                になって、
                リムーバブルメディアに関連するブロックデバイスに適切なパーミッションを設定します。
              </p><p>
                例として、最初のフロッピーデバイスをユーザーがマウントできるようにするには、
                次のようにします。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 666 /dev/fd0</code></strong></pre><p>
                <code class="systemitem">operator</code> グループに所属するユーザが
                CDROM ドライブをマウントできるようにするには
                以下のようにします。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chgrp operator /dev/cd0c</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 640 /dev/cd0c</code></strong></pre></li><li class="step"><p>
                最後に <code class="literal">vfs.usermount=1</code> という行を
                <code class="filename">/etc/sysctl.conf</code> ファイルに追加し、
                ブート時にセットされるようにしておきます。
              </p></li></ol></div><p>
            これで、すべてのユーザは
            フロッピー <code class="filename">/dev/fd0</code> を
            自身の所有するディレクトリへマウントすることができます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>mkdir ~/my-mount-point</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>mount -t msdos /dev/fd0 ~/my-mount-point</code></strong></pre><p>
            これで、<code class="systemitem">operator</code> グループに所属するユーザは
            CDROM <code class="filename">/dev/cd0c</code> を
            自身の所有するディレクトリへマウントすることができます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>mkdir ~/my-mount-point</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>mount -t msdos /dev/cd0c ~/my-mount-point</code></strong>
</pre><p>デバイスのアンマウントは簡単です。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>umount ~/my-mount-point</code></strong></pre><p>
            しかし、
            <code class="varname">vfs.usermount</code>
            を有効にすることは、セキュリティ上よいことではありません。
            MSDOS 形式のメディアにアクセスには、Ports コレクションにある
            パッケージ
            <a class="link" href="http://www.freebsd.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name" target="_top">mtools</a>
            を使用した方がよいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79670096"></a><a id="new-huge-disk"></a><p><strong>7.36.</strong></p></td><td align="left" valign="top"><p>システムを新しい巨大ディスクへ移すにはどうするのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一番良いのは新しいディスクに OS を再インストールして、
            それからユーザデータを移すことです。特にあなたが -stable を
            複数のリリースを跨いで追い掛けている場合にはこの方法をおすすめします。
            あなたは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot0cfg</span>(8)</span></a> を使うことで booteasy を両方の
            ディスクにインストールでき、新しい配置で満足している間
            デュアルブートができます。これを行ったあとデータを移す
            方法を探すなら次の段落は読み飛ばしてください。</p><p>何もないディスクへインストールしないことに決めたならば
            <code class="filename">/stand/sysinstall</code>、なり <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a>
            と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">disklabel</span>(8)</span></a> なりを使って新しいディスクに
            パーティションとディスクラベルを作らなければなりません。
            また <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot0cfg</span>(8)</span></a> で booteasy を両方のディスクに
            インストールして、コピーの作業が終わったあとに
            古いシステムからでも新しいディスクからでも起動できるように
            しておく必要があります。この作業の詳細は <a class="link" href="http://www.freebsd.org/tutorials/formatting-media/index.html" target="_top">formatting-media
            tutorial</a> を見てください。</p><p>新しいディスクの立ち上げが終わってデータの移動を
            待つばかりになりました。しかし悲しいかな、無闇やたらと
            コピーすればいいというものではありません。デバイスファイル
            (<code class="filename">/dev</code>) やシンボリックリンクなどは
            失敗の元になります。これらを理解するツール、すなわち
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> 等を使う必要があります。
            データの移転はシングルユーザで行うことをお勧めしますが、
            絶対と言うわけではありません。</p><p>あなたは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=restore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">restore</span>(8)</span></a> 以外のもので
            root ファイルシステムを移行してはなりません。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> コマンドでもたぶんうまく行くでしょうが、
            やらないほうがいいでしょう。パーティション一つを
            もう一つのからのパーティションに移すときは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=restore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">restore</span>(8)</span></a> 使うべきです。
            パーティションのデータを新しいパーティションに移すのに
            dump を使うやり方は以下の通りです。</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>新しいパーティションに newfs をかける。</p></li><li class="step"><p>それを暫定的なマウントポイントにマウントする。</p></li><li class="step"><p>そのディレクトリに cd。</p></li><li class="step"><p>古いパーティションを dump し、
                その出力をパイプで新しい方へ。</p></li></ol></div><p>たとえば root を
            <code class="filename">/dev/ad1s1a</code> へ、暫定的なマウントポイントを
            <code class="filename">/mnt</code> として移そうとすると以下のようになります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>newfs /dev/ad1s1a</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount /dev/ad1s1a</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cd /mnt</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>dump 0uaf - / | restore xf -</code></strong></pre><p>もしパーティションの構成を変えようと思っているなら -
            つまり一つだったものを二つにしたり二つだったものをくっつけたり
            しようとしているなら、自前であるディレクトリ以下のすべてを
            新しい場所へ移す必要が出てくるかも知れません。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> は
            ファイルシステムに働くのでこの目的には使えません。この場合は
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> を使います。一般に <code class="filename">/old</code> から
            <code class="filename">/new</code> への移動は  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> で
            以下のようにします。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>(cd /old; tar cf - .) | (cd /new; tar xpf -)</code></strong></pre><p><code class="filename">/old</code> に他のファイルシステムが
            マウントされていて、そのデータの移動までは考えてないならば
            最初の <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> に 'l' フラグを追加します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>(cd /old; tar clf - .) | (cd /new; tar xpf -).</code></strong></pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> のかわりに <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cpio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cpio</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pax&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pax</span>(1)</span></a>,
            cpdup (ports/sysutils/cpdup) 等を
            使っても構いません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79729360"></a><a id="release-candidate"></a><p><strong>7.37.</strong></p></td><td align="left" valign="top"><p>
            システムを最新の -STABLE にアップデートしようとしたのですが
            -RC や -BETA になってしまいました! 何が起こったのですか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            短い答え: ただの名前です。RC は
            <span class="quote">「<span class="quote">リリース候補 (Release Candidate)</span>」</span> に
            由来するもので、リリースが間近であることを意味します。
            また、FreeBSD における -BETA は通常、
            リリース前のコードフリーズ期間に入っているという意味になります。
          </p><p>
            長い答え: FreeBSD はそのリリースを 2 ヶ所あるうちの
            一方から派生させます。3.0-RELEASE や 4.0-RELEASE の様な
            (0 のマイナー番号を持つ) メジャーリリースは、一般に <a class="link" href="#current" title="5.">-CURRENT</a> と呼ばれる
            開発版の流れから分岐させられてできます。3.1-RELEASE や
            4.2-RELEASE などのマイナーリリースはアクティブな
            <a class="link" href="#stable" title="6.">-STABLE</a> ブランチ (枝) の
            スナップショットでした。
            4.3-RELEASE からは、リリース毎にブランチが作成されるように
            なりました。ものすごく保守的な開発速度 (主にセキュリティ
            勧告のみ) を求めている人は、このブランチを追跡すると
            よいでしょう。</p><p>
            リリースを作る時になるとそれを分岐させるブランチは
            特定のプロセスへ突入します。そのプロセスの一つは
            コードフリーズ (コードの凍結) です。コードフリーズが
            始まると、そのブランチの名前がリリースになろうとしていることを
            反映するものに変えられます。たとえば、4.0-STABLE と
            呼ばれていたブランチは名前が 4.1-BETA へと
            変えられ、コードフリーズとリリース前のテストが
            始まったことを示します。
            バグの修正はリリースの一部としてコミットされます。
            ソースコードがリリースの形を取ったなら名前が 4.1-RC へと
            変えられ、それからリリースが作られることを示します。
            ひとたび RC のステージになってしまうと、発見された
            もっとも致命的なバグの修正しかできなくなります。
            ひとたびリリースが (この例では 4.1-RELEASE) 作られれば、
            そのブランチは 4.1-STABLE と改名されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79766480"></a><a id="kernel-chflag-failure"></a><p><strong>7.38.</strong></p></td><td align="left" valign="top"><p>新しいカーネルを入れようとしたのですが、
            chflags に失敗します。どうすれば良いのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>簡単な回答:
            多分、セキュアレベルが 0 より大きくなっているのでしょう。
            直接シングルユーザモードで再起動して、
            カーネルをインストールしてください。</p><p>詳しい回答:
            FreeBSD では、セキュアレベルが 0 より大きい場合、
            システムフラグの変更が禁止されます。
            現在のセキュアレベルは、次のコマンドを使って調べることができます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>セキュアレベルを下げる操作は、できないようになっています。
            そのため、カーネルをインストールするには、
            シングルユーザモードで起動するか、<code class="filename">/etc/rc.conf</code>
            のセキュリティ設定を変更して再起動する必要があります。
            セキュアレベルの詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> を、
            rc.conf の詳細は <code class="filename">/etc/defaults/rc.conf</code> および、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> のマニュアルページをご覧ください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79772496"></a><a id="kernel-securelevel-time"></a><p><strong>7.39.</strong></p></td><td align="left" valign="top"><p>システムの時刻を 1 秒以上変更することができないのです!
            どうすれば良いのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>簡単な回答:
            多分、セキュアレベルが 1 より大きくなっているのでしょう。
            直接シングルユーザモードで再起動して、
            時刻の変更をしてください。</p><p>詳しい回答:
            FreeBSD では、セキュアレベルが 1 より大きい場合、
            1 秒以上の時刻変更が禁止されます。
            現在のセキュアレベルは、次のコマンドを使って調べることができます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>セキュアレベルを下げる操作は、できないようになっています。
            そのため、システムの時刻を変更するには、
            シングルユーザモードで起動するか、<code class="filename">/etc/rc.conf</code>
            のセキュリティ設定を変更して再起動する必要ばあります。
            セキュアレベルの詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> を、
            rc.conf の詳細は <code class="filename">/etc/defaults/rc.conf</code> および、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> のマニュアルページをご覧ください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79786832"></a><a id="statd-mem-leak"></a><p><strong>7.40.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rpc.statd</span>(8)</span></a> にメモリリークを見つけました!
            メモリを 256 メガバイトも使っています。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>いいえ。それはメモリリークではありませんし、
            256 メガバイトのメモリを使っている、ということでもありません。
            おそらく (ほとんどの場合)、
            処理に都合が良いように非常にたくさんの量のメモリを
            そのプロセスのアドレス空間にマッピングしているのでしょう。
            技術的な見地から考えても、これは大きな害があることではなく、
            単に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> といったツールの表示に影響がある程度です。
          </p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rpc.statd</span>(8)</span></a> は、(<code class="filename">/var</code> にある)
            ステータスファイルを自分のアドレス空間にマッピングします。
            マッピングは、後で大きな空間が必要になった時に再マッピングしないで済むよう、
            非常に大きなサイズを指定して行なわれます。
            これは、ソースコードに含まれる <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mmap&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>
            関数のマッピング長を示す引数に
            <code class="literal">0x10000000</code> が指定されていることからも分かります。
            この数字が IA32 アーキテクチャの持つアドレススペース全体の
            16 分の 1、すなわち、ちょうど 256 メガバイトに相当するのです。</p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x"></a>第8章 X Window System と仮想コンソール</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        今野 元之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:motoyuki@FreeBSD.org">motoyuki@FreeBSD.org</a>&gt;</code>
        1997 年 11 月 13 日</em></span>
    </p><div class="qandaset"><a id="idp79812560"></a><dl><dt>8.1. <a href="#idp79812816">X を動かしたいのですが、どうすればいいのですか?</a></dt><dt>8.2. <a href="#idp79817168">X を実行しようとして
            startx
            と入力したのですが、
            KDENABIO failed (Operation not permitted)
            というエラーが表示されます。
            何かおかしなことをやってしまったんでしょうか?</a></dt><dt>8.3. <a href="#idp79828944">私のマウスはなぜ X で動かないのでしょうか?</a></dt><dt>8.4. <a href="#idp79839440">わたしのマウスにはホイール機能が付いているのですが、X で使うことはできますか?</a></dt><dt>8.5. <a href="#idp79920592">X のメニューやダイアログボックスがうまく動きません。</a></dt><dt>8.6. <a href="#idp79925456">仮想コンソールとは何ですか? どうやったら使えますか?</a></dt><dt>8.7. <a href="#idp79971536">X から仮想コンソールに切替えるにはどうすればよいのですか?</a></dt><dt>8.8. <a href="#idp79987536">XDM を起動時に起動させるにはどうしますか?</a></dt><dt>8.9. <a href="#idp80011856">xconsole を動かそうとすると
            「Couldn't open console」
            とエラーが出ます。</a></dt><dt>8.10. <a href="#idp80021456">わたしはいつも XFree86 を一般ユーザから起動していたのですが、
            最近になって root ユーザでなければな
            らないと言われるようになりました。</a></dt><dt>8.11. <a href="#idp80035920">私の PS/2 マウスは X ウィンドウシステム上でうまく動きません。</a></dt><dt>8.12. <a href="#idp80054992">MouseSystems の PS/2 マウスがうまく動きません。</a></dt><dt>8.13. <a href="#idp80063440">X のアプリケーションを構築する時に、
            imake can't find Imake.tmpl
            となります。どこにあるのでしょうか?
          </a></dt><dt>8.14. <a href="#idp80067408">マウスのボタンを入れ替える方法はありますか?</a></dt><dt>8.15. <a href="#idp80071504">スプラッシュスクリーンのインストールはどうするのですか。
            どこで見つけることができますか?</a></dt><dt>8.16. <a href="#idp80091472">X で Windows(tm) キーを使うことはできるのでしょうか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp79812816"></a><a id="running-X"></a><p><strong>8.1.</strong></p></td><td align="left" valign="top"><p>X を動かしたいのですが、どうすればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もっとも簡単な方法は FreeBSD のインストールの際に
            X を動かすことを指定するだけです。
          </p><p>それから <code class="command">xf86config</code>
            ツールのドキュメントを読んでこれに従ってください。
            このツールはあなたのグラフィックカードやマウスなどに合わせて
            XFree86(tm) の設定を行うのを助けてくれます。
          </p><p>
            Xaccel サーバーについて調べてみるのもいいでしょう。
            詳しくは <a class="link" href="#xig">Xi Graphics について</a> か
            <a class="link" href="#metrox">Metro Link</a> をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79817168"></a><a id="running-X-securelevels"></a><p><strong>8.2.</strong></p></td><td align="left" valign="top"><p>X を<span class="emphasis"><em>実行しようと</em></span>して
            <code class="command">startx</code>
            と入力したのですが、
            <span class="errorname">KDENABIO failed (Operation not permitted)</span>
            というエラーが表示されます。
            何かおかしなことをやってしまったんでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>あなたのシステムは高いセキュアレベルで運用されていますね?
            実は、高いセキュアレベルで X を起動することはできないのです。
            どうしてなのかについては、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>
            のマニュアルページに書かれています。</p><p>では、代わりにどうすれば良いのかお答えしましょう。
            基本的に 2 つの方法があります。
            一つはセキュアレベルを 0 にする (通常、これは
            <code class="filename">/etc/rc.conf</code> で指定します) こと、
            もう一つは起動時 (セキュアレベルを上げる前) に
              <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> を実行するかです。</p><p>起動時に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> を実行する方法の詳細については、
            <a class="xref" href="#xdm-boot" title="8.8.">問：〓8.8</a> を参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79828944"></a><a id="x-and-moused"></a><p><strong>8.3.</strong></p></td><td align="left" valign="top"><p>私のマウスはなぜ X で動かないのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>syscons (デフォルトのコンソールドライバ) を使っているのであれば、
            それぞれの仮想スクリーンでマウスポインターをサポートするように
            FreeBSD を設定できます。X でのマウスの衝突を避けるために、syscons は
            <code class="filename">/dev/sysmouse</code>
            という仮想デバイスをサポートしています。
            本物のマウスデバイスから入力されたすべてのマウスのイベントは、
            moused を経由して sysmouse デバイスへ出力されます。
            一つ以上の仮想コンソールと X の
            <span class="emphasis"><em>両方で</em></span> マウスを使いたい場合、
            <a class="xref" href="#moused" title="2.11.">問：〓2.11</a>
            を参照して moused を設定してください。
          </p><p>
            そして、<code class="filename">/etc/XF86Config</code> を編集し、
            次のように書かれていることを確認してください。</p><pre class="programlisting">Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
.....</pre><p>
            上の例は、XFree86 3.3.2 以降の場合の例です。
            それより前のバージョンでは、
            <span class="emphasis"><em>Protocol</em></span> という部分を
            <span class="emphasis"><em>MouseSystems</em></span> と置き換える必要があります。
          </p><p>
            X で <code class="filename">/dev/mouse</code>
            を使うのを好む人もいます。
            この場合は、
            <code class="filename">/dev/mouse</code>
            を
            <code class="filename">/dev/sysmouse</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysmouse&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sysmouse</span>(4)</span></a> 参照)
            にリンクしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>rm -f mouse</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ln -s sysmouse mouse</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79839440"></a><a id="x-and-wheel"></a><p><strong>8.4.</strong></p></td><td align="left" valign="top"><p>わたしのマウスにはホイール機能が付いているのですが、X で使うことはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>はい、もちろん使えますが、そのためには
            X クライアントプログラムを適切に設定する必要があります。これについては、
            <a class="link" href="http://www.inria.fr/koala/colas/mouse-wheel-scroll/" target="_top">Colas Nahaboo
              氏のウェブページ(http://www.inria.fr/koala/colas/mouse-wheel-scroll/)</a>
            を参照してください。</p><p>
            <span class="application">imwheel</span>
            というプログラムを使う場合は、
            次のような簡単な手順にしたがってください。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ホイールイベントの変換</p><p>
                <span class="application">imwheel</span> は、
                マウスのボタン 4、ボタン 5 をキー押下イベントに変換するプログラムです。
                そのためホイールマウスで利用するには、マウスホイールのイベントをボタン 4、
                ボタン 5 のイベントに変換するマウスドライバを利用する必要があります。
                この変換を行なうには二つの方法があります。
                一つは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>
                で行なう方法、二つめは X サーバ自身に変換を行なわせる方法です。
              </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>ホイールイベントの変換に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を使う</p><p>
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> にイベントを変換させるには、
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> 起動時にオプション
                    <code class="option">-z 4</code> を追加します。
                    たとえば、普段 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を
                    <code class="command">moused -p /dev/psm0</code>
                    として起動しているなら、その代わりに
                    <code class="command">moused -p /dev/psm0 -z 4</code>
                    とします。
                    もし、
                    <code class="filename">/etc/rc.conf</code>
                    を使って自動的に起動するように設定しているなら、
                    <code class="filename">/etc/rc.conf</code>
                    の中の
                    <code class="varname">moused_flags</code> という変数に
                    <code class="option">-z 4</code> を追加するだけです。
                  </p><p>
                    そして、5 ボタンマウスを使うことを
                    X サーバに伝える必要があります。
                    これを行なうには
                    <code class="filename">/etc/XF86Config</code> の
                    <span class="quote">「<span class="quote">Pointer</span>」</span> セクションに
                    <code class="literal">Buttons 5</code> という行を追加するだけです。
                    そうすると
                    <code class="filename">/etc/XF86Config</code> の
                    <span class="quote">「<span class="quote">Pointer</span>」</span> は、
                    たとえば次のようになるでしょう。
                  </p><div class="example"><a id="idp79879248"></a><div class="example-title">例8.1 moused による変換を利用してホイールマウスを
                      使用するための XFree86 3.3.x 系列の XF86Config の
                      <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
   Protocol        "SysMouse"
   Device          "/dev/sysmouse"
   Buttons         5
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp79880912"></a><div class="example-title">例8.2 自動的なプロトコル認識機能およびボタン配置変換機能を
                      利用し、ホイールマウスを使用するための XFree86 4.x 系列の
                      XF86Config の <span class="quote">「<span class="quote">InputDevice</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/psm0"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp79882448"></a><div class="example-title">例8.3 ホイールマウスで Emacs 上でのページスクロールを
                      行うための <span class="quote">「<span class="quote">.emacs</span>」</span> の設定例</div><div class="example-contents"><pre class="programlisting">;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</pre></div></div><br class="example-break" /></li><li class="listitem"><p>X サーバを使ったホイールイベントの変換</p><p>
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を起動していなかったり、
                    ホイールイベントの変換に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>
                    を起動したくない場合には、その代わりに
                    X サーバを使うことができます。
                    これには、<code class="filename">/etc/XF86Config</code>
                    ファイルを書き換える必要があります。
                    まず最初に必要なのは、
                    マウスがどのプロトコルを使っているのかを確認することです。
                    ほとんどのホイールマウスは
                    <span class="quote">「<span class="quote">IntelliMouse</span>」</span>
                    プロトコルを使用していますが、
                    XFree86 サーバはその他のプロトコル、
                    たとえば
                    Logitech MouseMan+ マウスが利用している
                    <span class="quote">「<span class="quote">MouseManPlusPS/2</span>」</span>
                    プロトコルなどもサポートしています。
                    使用されているプロトコルが確認できたら
                    <span class="quote">「<span class="quote">Pointer</span>」</span> セクションに
                    <code class="varname">Protocol</code> の行を追加してください。
                  </p><p>
                    つぎに、
                    ホイールのスクロールイベントをマウスボタン 4、
                    マウスボタン 5 に割り当てることを X サーバに伝えます。
                    これを行なうには
                    <code class="varname">ZAxisMapping</code>
                    オプションを使用します。
                  </p><p>
                    たとえば、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> が起動していない状態で、
                    PS/2 マウスポートに IntelliMouse が接続されているとしたら
                    <code class="filename">/etc/XF86Config</code>
                    はおそらく次のようになります。
                  </p><div class="example"><a id="idp79891280"></a><div class="example-title">例8.4 
                      X サーバによる変換を利用してホイールマウスを使用するための
                      XF86Config の <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
   Protocol        "IntelliMouse"
   Device          "/dev/psm0"
   ZAxisMapping    4 5
EndSection</pre></div></div><br class="example-break" /></li></ol></div></li><li class="listitem"><p><span class="application">imwheel</span> のインストール</p><p>
                さて、つぎに Ports Collection から
                <span class="application">imwheel</span> をインストールします。
                これがあるのは <code class="filename">x11</code> カテゴリです。
                このプログラムは、
                マウスイベントをキーボードイベントに変換します。
                たとえば、マウスホイールを前に回した時、
                <span class="application">imwheel</span> は <span class="keycap"><strong>PageUp</strong></span>
                をアプリケーションプログラムに送るような動作をするわけです。
                <span class="application">Imwheel</span>
                はホイールイベントとキーボード押下の対応を設定ファイルを使って設定するため、
                アプリケーション毎に異なる対応を持たせることも可能です。
                <span class="application">imwheel</span> のデフォルトの設定ファイルは
                <code class="filename">/usr/X11R6/etc/imwheelrc</code>
                にインストールされます。
                これを <code class="filename">~/.imwheelrc</code> にコピーして編集し、
                お好きなように <span class="application">imwheel</span>
                で利用したいアプリケーションの設定をカスタマイズしてください。
                設定ファイルの書式は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=imwheel&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">imwheel</span>(1)</span></a> に説明されています。
              </p></li><li class="listitem"><p><span class="application">Emacs</span> で
                <span class="application">Imwheel</span> を使うように設定する
                (<span class="emphasis"><em>必須ではありません</em></span>)</p><p>
                <span class="application">emacs</span> や
                <span class="application">Xemacs</span>
                で利用するには、
                <code class="filename">~/.emacs</code> にいくらか書き加える必要があります。
                <span class="application">emacs</span> の場合は次の部分を追加してください。
              </p><div class="example"><a id="idp79911376"></a><div class="example-title">例8.5 <span class="application">Imwheel</span> を利用するための
                  <span class="application">Emacs</span> の設定例</div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /><p>
                <span class="application">Xemacs</span> の場合は
                <code class="filename">~/.emacs</code> に次の部分を追加してください。
              </p><div class="example"><a id="idp79914448"></a><div class="example-title">例8.6 <span class="application">Imwheel</span> を利用するための
                  <span class="application">XEmacs</span> の設定例</div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /></li><li class="listitem"><p><span class="application">Imwheel</span> の実行</p><p>
                インストールが完了していれば、単に xterm (訳注:
                日本語環境で広く使われている kterm でも構いません) から
                <code class="command">imwheel</code> を入力するだけで起動できます。
                起動するとバックグラウンドで動作し、すぐに利用できます。
                <span class="application">imwheel</span> をいつも使うように設定するには、
                <code class="filename">.xinitrc</code> か
                <code class="filename">.xsession</code> のファイルにそのままコマンドを追加してください。
                <span class="application">imwheel</span> が PID
                ファイルに関する警告を表示するかも知れませんが、
                無視しても危険はありません。この警告が意味を持つのは、
                Linux 版の <span class="application">imwheel</span> だけです。
              </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79920592"></a><a id="window-menu-weird"></a><p><strong>8.5.</strong></p></td><td align="left" valign="top"><p>X のメニューやダイアログボックスがうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Num Lock キーをオフにしてください。
          </p><p>Num Lock キーがデフォルトで起動時にオンになる場合は、
            <code class="filename">XF86Config</code> ファイルの
            <code class="literal">Keyboard</code>
            セクションに以下の行を加えてもいいでしょう。
          </p><pre class="programlisting"># Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
    ServerNumLock</pre><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                この問題は XFree86 3.2 以降では解決しています。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79925456"></a><a id="virtual-console"></a><p><strong>8.6.</strong></p></td><td align="left" valign="top"><p>仮想コンソールとは何ですか? どうやったら使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            仮想コンソールは、簡単にいうと、ネットワークや X
            を動かすなどの複雑なことを行なわずに、
            いくつかのセッションを同時に行なうことを可能にします。
          </p><p>
            システムのスタート時には、
            起動メッセージが出た後に login
            プロンプトが表示されます。そこで
            ログイン名とパスワードを入力すると
            1 番目の仮想コンソール上で仕事 (あるいは遊び) を始めることができます。
          </p><p>
            他のセッションを始めたい場合もあるでしょう。
            それは動かしているプログラムのドキュメントを見たり、
            FTP の転送が終わるまで待つ間、
            メールを読もうとしたりすることかもしれません。
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F2</strong></span>
            を押す (<span class="keycap"><strong>Alt</strong></span> キーを押しながら
            <span class="keycap"><strong>F2</strong></span> キーを押す) と、
            2 番目の「仮想コンソール」で
            ログインプロンプトが待機していることがわかります。
            最初のセッションに戻りたいときは
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F1</strong></span> を押します。
          </p><p>
            標準の FreeBSDインストールでは、
            3 枚 (3.3-RELEASE では 8 枚) の仮想コンソールが有効になっていて、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F1</strong></span>、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F2</strong></span>、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F3</strong></span>
            で仮想コンソール間の切替えを行ないます。
          </p><p>
            より多くの仮想コンソールを有効にするには、
            <code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            を編集して
            <span class="quote">「<span class="quote">Virtual terminals</span>」</span>
            のコメント行の後に
            <code class="filename">ttyv4</code>
            から
            <code class="filename">ttyvc</code>
            の手前までのエントリを加えます
            (以下の例は先頭には空白は入りません)。
          </p><pre class="programlisting"># /etc/ttys には ttyv3 がありますので
# "off" を "on" に変更します。
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</pre><p>
            多くするか少なくするかはあなたの自由です。
            より多くの仮想ターミナルを使うとより多くのリソースを使うことになります。
            8MB 以下のメモリしかない場合はこれは重要な問題です。
            もし必要があれば
            <code class="literal">secure</code> を
            <code class="literal">insecure</code>
            に変更してください。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">X を使いたいのであれば、
                最低一つの仮想ターミナル (のエントリ) を使わずに残しておくか、
                off にしておく必要があります。
                つまり、12 個の
                <span class="keycap"><strong>Alt</strong></span>-ファンクションキーすべてでログインプロンプトを
                出したいのならば、
                残念ながら X は利用できないということです。
                同じマシンで X サーバーも動かしたいのならば
                11 個しか使えません。
              </p></div><p>
            仮想コンソールを無効にするもっとも簡単な方法は、
            コンソールを
            off にすることです。
            たとえば 12 個すべてのターミナルを割り当てている状態で
            X を動かしたいときは、
            仮想ターミナル 12 を変更します。
          </p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</pre><p>
            これを次のように変更します。
          </p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</pre><p>
            キーボードにファンクションキーが 10 個しかないのであれば、
            次のように設定します。
          </p><pre class="programlisting">ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</pre><p>
            (これらの行を消すだけでもいいです。)
          </p><p>
            <code class="filename">/etc/ttys</code>
            を編集したら、
            次は十分な数の仮想ターミナルデバイスを作らなくてはなりません。
            もっとも簡単な方法を示します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV vty12</code></strong><span class="emphasis"><em> (12 個のデバイスをつくる場合)</em></span></pre><p>
            さて、仮想コンソールを有効にするもっとも簡単 (そして確実) な方法は、
            再起動することです。しかし、再起動したくない場合は、
            X ウィンドウシステムを終了させて次の内容を
            (<code class="systemitem">root</code>権限で) 実行します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP 1</code></strong></pre><p>
            重要な点は、
            このコマンドを実行する前に X
            ウィンドウシステムを完全に終了させておくことです。
            もしそうしないと <code class="command">kill</code>
            コマンドを実行した後、
            システムはおそらくハングアップするでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79971536"></a><a id="vty-from-x"></a><p><strong>8.7.</strong></p></td><td align="left" valign="top"><p>X から仮想コンソールに切替えるにはどうすればよいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            仮想コンソールへ戻るには
            <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> を使ってください。
            最初の仮想コンソールへは
            <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> で戻れます。
          </p><p>
            テキストコンソールへ移った後は、その中で移動するのに
            今度はいつもどおり
            <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> を使ってください。
          </p><p>
            X のセッションへ戻るには X の走っている仮想コンソールへ
            切り替える必要があります。もしあなたが X をコマンドラインから
            実行していたのであれば (たとえば <code class="command">startx</code>
            を使う) X のセッションはそれを実行したテキストコンソールではなく
            最初の使われていない仮想コンソールに割り当てられているはずです。
            あなたが仮想端末を 8 個用意している場合は X を 9 番目の
            コンソールにいるはずで、
            <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F9</strong></span> を使うことになります。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                X に戻るには、
                3 枚の仮想コンソールが有効になっている場合は
                <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F4</strong></span> です。
                有効な仮想コンソールの数 +1 のファンクションキーの
                位置に X が割り当てられます。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79987536"></a><a id="xdm-boot"></a><p><strong>8.8.</strong></p></td><td align="left" valign="top"><p>XDM を起動時に起動させるにはどうしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm" target="_top">xdm</a>
            の起動方法については二つの流派があります。
            一方の流派では提供された例を使用して xdm を
            <code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            から起動し、もう一方の流派では xdm を単に
            <code class="filename">rc.local</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 参照)
            または <code class="filename">/usr/local/etc/rc.d</code> においた
            <code class="filename">X.sh</code> スクリプトから起動します。
            どちらも正しく、片方が動作しない場合は、もう片方が動作するでしょう。
            どちらも場合でも結果は同じであり、X はグラフィカルな
            <code class="prompt">login:</code> プロンプトを表示します。
          </p><p>
            <code class="filename">ttys</code> を利用する方法の利点は、
            どの <acronym class="acronym">vty</acronym> で X が起動したかの記録が残せることと、
            ログアウト時に X サーバを再起動する責任を
            init に押しつけることができることでしょう。
          </p><p>
            <code class="filename">rc.local</code> からロードされる場合、
            <code class="command">xdm</code> は引数を持たずに
            (すなわち、デーモンとして) 起動します。
            <code class="command">xdm</code> は <code class="command">getty</code>
            が起動した後にロードされなければなりません。
            そうでないと、<code class="command">xdm</code> は <code class="command">getty</code>
            と衝突し、コンソールをロックアウトしてしまいます。
            この問題に対処する最善の方法は、
            起動スクリプト (訳注: <code class="filename">rc.local</code>
            のこと) で 10 秒ほどの <code class="command">sleep</code> を実行させ、
            その後に <code class="command">xdm</code> をロードすることです。
          </p><p>
            <code class="filename">/etc/ttys</code> から
            <code class="command">xdm</code> を起動させている場合には、
            <code class="command">xdm</code> と <code class="command">getty</code>
            が衝突する可能性があります。
            この問題を回避するには、<code class="filename">/usr/X11R6/lib/X11/xdm/Xservers</code> に
            <code class="literal">vt</code> 番号を追加してください。
          </p><pre class="programlisting">:0 local /usr/X11R6/bin/X vt4</pre><p>上の例は、<code class="filename">/dev/ttyv3</code> を
            X サーバに対応させます。番号は 1 から始まりますので注意してください。
            X サーバは
            <acronym class="acronym">vty</acronym> を 1 から数えますが、
            FreeBSD カーネルは
            <acronym class="acronym">vty</acronym> を 0 から数えます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80011856"></a><a id="xconsole-failure"></a><p><strong>8.9.</strong></p></td><td align="left" valign="top"><p><code class="command">xconsole</code> を動かそうとすると
            <span class="quote">「<span class="quote"><code class="computeroutput">Couldn't open console</code></span>」</span>
            とエラーが出ます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">X</span> を <code class="command">startx</code>
            で起動しますと、<code class="filename">/dev/console</code> のパーミッションは
            <span class="emphasis"><em>変更できない</em></span>ようになっていますので、
            <code class="command">xterm -C</code> や <code class="command">xconsole</code>
            は動きません。
          </p><p>
            これはコンソールのパーミッションが、
            標準ではそのように設定されているからです。
            マルチユーザシステムでは、
            ユーザの誰もがシステムコンソールに書き込むことが可能である必要は必ずしもありません。
            <acronym class="acronym">VTY</acronym>
            を使い直接マシンにログインするユーザのために、
            このような問題を解決するために
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a>
            というファイルがあります。
          </p><p>
            要点を述べると、次のような形式の行を
            <code class="filename">/etc/fbtab</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a> 参照) に加えます。
          </p><pre class="programlisting">/dev/ttyv0 0600 /dev/console</pre><p>
            そうすると、
            <code class="filename">/dev/ttyv0</code> からログインしたユーザが
            コンソールを所有することになるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80021456"></a><a id="xfree86-root"></a><p><strong>8.10.</strong></p></td><td align="left" valign="top"><p>わたしはいつも XFree86 を一般ユーザから起動していたのですが、
            最近になって <code class="systemitem">root</code> ユーザでなければな
            らないと言われるようになりました。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>すべての X サーバは、
            ビデオハードウェアに直接アクセスするために <code class="systemitem">root</code>
            ユーザで実行される必要があります。
            古いバージョンの XFree86 (&lt;= 3.3.6) に含まれるすべてのサーバは、
            自動的に <code class="systemitem">root</code> 権限で実行されるように
            (<code class="systemitem">root</code> ユーザに setuid
            されて) インストールされます。
            X サーバは大きく複雑なプログラムであり、
            これは明らかにセキュリティを危険に晒す要因となります。
            そのため新しいバージョンの XFree86 では、
            サーバを <code class="systemitem">root</code> ユーザに setuid
            しないでインストールするようになりました。</p><p>X サーバを root ユーザで動かすというのは、
            明らかにセキュリティ的に不適当で受け入れられないことです。
            X を一般ユーザで実行するには、二つの方法があります。
            一つは <code class="command">xdm</code> や、その他のディスプレイマネージャ
            (たとえば <code class="command">kdm</code> など) を使うこと、
            もう一つは <code class="command">Xwrapper</code> を使うことです。
          </p><p><code class="command">xdm</code> は、
            グラフィカルなログイン画面を扱うデーモンです。
            通常、起動時に実行され、
            各ユーザの認証とユーザセションを開始させる機能を実現します。
            基本的に、<code class="command">getty</code> と <code class="command">login</code>
            のグラフィック版、と考えて良いでしょう。
            <code class="command">xdm</code> の詳細については、
            <a class="link" href="http://www.xfree86.org/support.html" target="_top">XFree86
              関連文書</a> および
            <a class="link" href="#xdm-boot" title="8.8.">FAQ 項目</a>をご覧ください。</p><p><code class="command">Xwrapper</code> とは、X サーバ用のラッパ
            (wrapper) のことです。
            これは必要なセキュリティを確保しつつ、一般ユーザが X
            サーバを実行できるようにした小さなユーティリティで、
            コマンドライン引数の正当性チェックを行ない、
            それを通過すれば適切な X サーバを起動します。
            何らかの理由でディスプレイマネージャを使いたくない場合に
            これを使うと良いでしょう。
            Ports Collection 全体をインストールしていれば、
            <code class="filename">/usr/ports/x11/wrapper</code>
            にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80035920"></a><a id="ps2-x"></a><p><strong>8.11.</strong></p></td><td align="left" valign="top"><p>私の PS/2 マウスは X ウィンドウシステム上でうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            あなたのマウスとマウスドライバがうまく同期していないからかもしれません。
          </p><p>
            FreeBSD 2.2.5 までのバージョンでは、X から仮想ターミナルへ切替えて、
            また X へ戻ると再同期するかもしれません。
            この問題がよく起きるようであれば、カーネルコンフィグレーション
            ファイルに次のオプションを書いてカーネルを再構成してみてください。
          </p><pre class="programlisting">options PSM_CHECKSYNC</pre><p>
            もし、カーネルの再構築を行なったことがないのであれば、
            <a class="link" href="#make-kernel" title="6.1.">カーネルを構築する</a>の項を参照してください。
          </p><p>
            このオプションにより、
            マウスとドライバの同期で問題が起きる可能性は少なくなるでしょう。
            もしそれでもこの問題が起きるようならば、
            再同期させるにはマウスを動かさないようにしておいて
            マウスボタンのどれかを押してください。
          </p><p>
            このオプションは残念ながらすべてのシステムで働くわけではなく、
            また、PS/2 マウスポートにつながれているのが
            タップ (tap) 機能を持つ アルプス社製 GlidePoint デバイスの場合、
            タップ機能が無効となってしまいます。
          </p><p>
            FreeBSD 2.2.6 以降のバージョンでは、
            同期のチェック方法が少し改善されたので標準で有効になっています。
            GlidePoint でもうまく働きます (同期チェックが標準の機能になったので
            <code class="literal">PSM_CHECKSYNC</code>
            オプションはこれらのバージョンからは削除されました)。
            しかしながら、
            まれにドライバが間違って (訳注:
            問題がないのに) 同期に関して問題があると報告し、カーネルから
          </p><pre class="programlisting">psmintr: out of sync (xxxx != yyyy)</pre><p>
            というメッセージが出力されて、マウスが正しく動作していないように見える
            ことがあるかもしれません。
          </p><p>
            もしこのようなことが起こる場合には、PS/2 マウスドライバのフラグに
            0x100 を指定して同期チェックを無効にしてください。システムの起動時に
            <span class="quote">「<span class="quote"><code class="option">-c</code></span>」</span>
            起動オプションを与えて
            <span class="emphasis"><em>UserConfig</em></span> に入ります。
          </p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><pre class="screen"><code class="prompt">boot:</code> <strong class="userinput"><code>-c</code></strong></pre><p>
            <span class="emphasis"><em>UserConfig</em></span>
            のコマンドラインで以下のように入力してください。
          </p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x100</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80054992"></a><a id="ps2-mousesystems"></a><p><strong>8.12.</strong></p></td><td align="left" valign="top"><p>MouseSystems の PS/2 マウスがうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            MouseSystems の PS/2 マウスのあるモデルは、
            高解像度モードの場合にのみ正しく動作するということが報告されています。
            それ以外のモードでは、
            マウスカーソルがしょっちゅうスクリーン左上に行ってしまうかもしれません。
          </p><p>
            残念ながら FreeBSD 2.0.X や 2.1.X のバージョンでは、
            この問題を解決する方法はありません。
            2.2 から 2.2.5 のバージョンでは、
            以下のパッチを
            <code class="filename">/sys/i386/isa/psm.c</code>
            に適用しカーネルの再構築を行なってください。
          </p><p>
            もし、カーネルの再構築を行なったことがないのであれば、
            <a class="link" href="#make-kernel" title="6.1.">カーネルの構築</a>の項を参照してください。
          </p><pre class="programlisting">@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
         log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
             unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);    /* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);               /* stream mode */</pre><p>
            FreeBSD 2.2.6 以降のバージョンでは、
            PS/2 マウスドライバのフラグに
            0x04 を指定してマウスを高解像度モードにします。
            システムの起動時に
            <code class="option">-c</code>
            起動オプションを与えて
            <span class="emphasis"><em>UserConfig</em></span> に入ります。
          </p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><p>
            <span class="emphasis"><em>UserConfig</em></span>
            のコマンドラインで以下のように入力してください。
          </p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x04</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre><p>
            マウスに関する不具合の他の原因の可能性については、
            直前のセクションも見てみてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80063440"></a><a id="imake-tmpl"></a><p><strong>8.13.</strong></p></td><td align="left" valign="top"><p>X のアプリケーションを構築する時に、
            <code class="computeroutput">imake can't find <code class="filename">Imake.tmpl</code></code>
            となります。どこにあるのでしょうか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">Imake.tmpl</code> は
            X の標準アプリケーション構築ツールである Imake パッケージの一部です。
            <code class="filename">Imake.tmpl</code> は、
            X アプリケーションの構築に必要な多くのヘッダファイルと同様に、
            X のプログラムディストリビューションに含まれています。
            <code class="command">sysinstall</code> を使うか、
            手動で X のディストリビューションファイルからインストールすることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80067408"></a><a id="mouse-button-reverse"></a><p><strong>8.14.</strong></p></td><td align="left" valign="top"><p>マウスのボタンを入れ替える方法はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">.xinitrc</code> か
            <code class="filename">.xsession</code> で
          </p><pre class="programlisting"><code class="command">xmodmap</code> <code class="option">-e "pointer = 3 2 1"</code></pre><p>
            というコマンドを実行してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80071504"></a><a id="install-splash"></a><p><strong>8.15.</strong></p></td><td align="left" valign="top"><p>スプラッシュスクリーンのインストールはどうするのですか。
            どこで見つけることができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 3.1 のリリース直前に、起動メッセージの表示期間に
            いわゆる "スプラッシュ"
            スクリーンを表示させることができる新しい機能が追加されました。
            いまのところスプラッシュスクリーンは
            256 色のビットマップ (<code class="filename">*.BMP</code>) か
            ZSoft PCX (<code class="filename">*.PCX</code>) ファイルです。
            それに加えて、標準の <acronym class="acronym">VGA</acronym> アダプタでの動作させるには
            320x200 以下の解像度である必要があります。
            カーネルに <acronym class="acronym">VESA</acronym>
            サポートを追加すれば 1024x768
            までのより大きいビットマップを使用できます。
            <acronym class="acronym">VESA</acronym> サポートを有効化するにはまず、
            カーネルが
            <code class="literal">VM86</code>
            カーネルオプションとともにコンパイルされている必要があることに注意してください。
            <acronym class="acronym">VESA</acronym> サポートそのものは
            <code class="literal">VESA</code> カーネルコンフィグオプション
            によって直接カーネル中にコンパイルするか、
            起動時に <acronym class="acronym">VESA</acronym> kld
            モジュールを読み込ませることができます。
          </p><p>
            スプラッシュスクリーンを使うには、
            FreeBSD
            の起動プロセスをコントロールするスタートアップファイルを書き換える必要があります。
            これらのファイルは FreeBSD 3.2 のリリース以前に変更されましたので、
            現在は、スプラッシュスクリーンを読み込む方法が二つあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>FreeBSD 3.1 の場合</p><p>
                  まず最初のステップは、
                  スプラッシュスクリーンのビットマップ版を探してくることです。
                  3.1-RELEASE では Windows
                  のビットマップ形式のスプラッシュスクリーンだけをサポートしています。
                  お望みのスプラッシュスクリーンを見つけたなら、それを
                  <code class="filename">/boot/splash.bmp</code>
                  にコピーします。次に、これらの行が書かれた
                  <code class="filename">/boot/loader.rc</code>
                  ファイルが必要です。
                </p><pre class="programlisting">load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</pre></li><li class="listitem"><p>FreeBSD 3.2 以降の場合</p><p>PCX 形式のスプラッシュスクリーンのサポートが追加されると同時に、
                  FreeBSD 3.2 には起動プロセスを設定する、
                  より洗練された方法が含まれています。
                  もしお望みなら、上に示した
                  FreeBSD 3.1 用の方法を使うこともできます。
                  もしそうしたくて、かつ PCX 形式を使いたいなら、
                  <code class="literal">splash_bmp</code> を
                  <code class="literal">splash_pcx</code> と読み換えてください。
                  そうではなくて、新しい起動設定方法を使うのなら、
                  次の数行が書かれた <code class="filename">/boot/loader.rc</code>
                  ファイルと、</p><pre class="programlisting">include /boot/loader.4th
start</pre><p>
                  次の数行が含まれた
                  <code class="filename">/boot/loader.conf</code>
                  ファイルを作ることが必要です。
                </p><pre class="programlisting">splash_bmp_load="YES"
bitmap_load="YES"</pre><p>
                  この例では、スプラッシュスクリーンとして
                  <code class="filename">/boot/splash.bmp</code>
                  を使うことを想定しています。PCX 形式のファイルを使う場合には、
                  そのファイルを <code class="filename">/boot/splash.pcx</code> にコピーして、
                  上で示したように
                  <code class="filename">/boot/loader.rc</code> を作ります。
                  そして、次の内容の
                  <code class="filename">/boot/loader.conf</code>
                  というファイルを作ってください。
                </p><pre class="programlisting">splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</pre></li></ul></div><p>
            さて、あとはスプラッシュスクリーンを用意するだけです。
            それには <a class="link" href="http://www.baldwin.cx/splash/" target="_top">http://www.baldwin.cx/splash/</a>
            のギャラリーをサーフしてみてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80091472"></a><a id="windows-keys"></a><p><strong>8.16.</strong></p></td><td align="left" valign="top"><p>X で Windows(tm) キーを使うことはできるのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい、もちろん。
            どういう動作をするかについて定義するには <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xmodmap&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xmodmap</span>(1)</span></a> を使います。
          </p><p>
            標準的な "Windows(tm)" キーボードの場合、
            対応するキーコードは 3 種類あります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>115 - 左の Ctrl と Alt の間にある Windows(tm) キー</p></li><li class="listitem"><p>116 - 右の Alt と Gr の間にある Windows(tm) キー</p></li><li class="listitem"><p>117 - 右の Ctrl の左隣にあるメニューキー</p></li></ul></div><p>
            左にある Windows(tm) キーを押すとカンマ記号が入力されるようにするには、
            こんな風にします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>xmodmap -e "keycode 115 = comma"</code></strong></pre><p>
            設定を反映させるには、おそらくウィンドウマネージャを再起動する必要があります。
          </p><p>
            Windows(tm) キーのキーマップを X 起動時に毎回、
            自動的に有効化するには <code class="command">xmodmap</code> コマンドを
            <code class="filename">~/.xinitrc</code> に追加するか、
            もしくはおすすめできる方法として
            <code class="filename">~/.xmodmaprc</code> というファイルを作成して、
            そのファイルの一行一行に <code class="command">xmodmap</code>
            のオプションを記述し、次の一行
          </p><pre class="programlisting">xmodmap $HOME/.xmodmaprc</pre><p>を <code class="filename">~/.xinitrc</code>
            に追加するという方法があります。</p><p>
            たとえば、先ほどあげた三つのキーを F13、F14、F15 に割り当てるとします。
            こうしておけば、後ほど示すように、アプリケーションや
            ウィンドウマネージャの便利な機能を
            その三つのキーに簡単に割り当てることができます。
          </p><p>
            こうするには、次の内容を <code class="filename">~/.xmodmaprc</code>
            に追加します。
          </p><pre class="programlisting">keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre><p>
            たとえば <code class="command">fvwm2</code> を使っていたら、
            F13 をカーソル下のウィンドウのアイコン化、
            F14 をウィンドウの前面/背面化、
            F15 を、あたかもデスクトップにカーソルが存在しないかのように、
            メインワークスペース (アプリケーション)
            のメニューを呼び出せる機能に割り当てられます。
            最後の機能は、そのデスクトップがまったく見えないときに便利です。
            (また、キートップのロゴにもぴったりです)
            
          </p><p>
            <code class="filename">~/.fvwmrc</code> の次のエントリは、前述の
            設定を実現します。
          </p><pre class="programlisting">Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="networking"></a>第9章 ネットワーキング</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        有村 光晴 <code class="email">&lt;<a xmlns="" class="email" href="mailto:arimura@jp.FreeBSD.org">arimura@jp.FreeBSD.org</a>&gt;</code>、
        広瀬 昌一 <code class="email">&lt;<a xmlns="" class="email" href="mailto:shou@kt.rim.or.jp">shou@kt.rim.or.jp</a>&gt;</code>、
        にしか <code class="email">&lt;<a xmlns="" class="email" href="mailto:nishika@cheerful.com">nishika@cheerful.com</a>&gt;</code>、
        はらだ きろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:kiroh@jp.FreeBSD.org">kiroh@jp.FreeBSD.org</a>&gt;</code>、
        1998 年 10 月 4 日</em></span>
    </p><div class="qandaset"><a id="idp80118096"></a><dl><dt>9.1. <a href="#idp80122576">「ディスクレスブート (diskless boot)」
            に関する情報はどこで得られますか?</a></dt><dt>9.2. <a href="#idp80125776">
            FreeBSD をネットワークのルータ (router) として使用することはできますか?
          </a></dt><dt>9.3. <a href="#idp80175056">Win95 の走っているマシンを、FreeBSD 経由でインターネットに接続できますか?</a></dt><dt>9.4. <a href="#idp80186576">ISC からリリースされている BIND の最新版はコンパイルできないんでしょうか?</a></dt><dt>9.5. <a href="#idp80189392">FreeBSD で SLIP と
            PPP は使えますか?</a></dt><dt>9.6. <a href="#idp80222672">FreeBSD は NAT か
            IP マスカレードをサポートしていますか?
          </a></dt><dt>9.7. <a href="#idp80234320">/dev/ed0
            デバイスを作成することができません。</a></dt><dt>9.8. <a href="#idp80237008">Ethernet アドレスのエイリアス (alias) はどのようにして設定できますか?</a></dt><dt>9.9. <a href="#idp80241232">3C503 で他のネットワークポートを使用するにはどのようにすればよいですか?</a></dt><dt>9.10. <a href="#idp80245968">FreeBSD との間で NFS がうまくできません。</a></dt><dt>9.11. <a href="#idp80248912">何故 Linux のディスクを NFS
            マウントできないのでしょうか?</a></dt><dt>9.12. <a href="#idp80256080">何故 Sun のディスクを NFS
            マウントできないのでしょうか?</a></dt><dt>9.13. <a href="#idp80259024">mountd から
            「can't change attributes」
            というメッセージがずっと出続けていて、
            FreeBSD の NFS サーバでは
            「bad exports list」
            と表示されます。これは何が原因なのでしょう?</a></dt><dt>9.14. <a href="#idp80272976">PPP で NeXTStep
            に接続する際に問題があるのですが。
          </a></dt><dt>9.15. <a href="#idp80277072">IP
            マルチキャスト (multicast) を有効にするには?</a></dt><dt>9.16. <a href="#idp80287824">
            DEC
            の PCI チップセットを用いているネットワークカードには、
            どのような物がありますか?</a></dt><dt>9.17. <a href="#idp80290768">
            何故自分のサイトのホストに対して FQDN
            を使用する必要があるのですか?</a></dt><dt>9.18. <a href="#idp80301264">すべてのネットワークの操作に対して
            Permission denied
            というメッセージが表示されるのですが。</a></dt><dt>9.19. <a href="#idp80316368">IPFW のオーバヘッドはどのくらいでしょうか?</a></dt><dt>9.20. <a href="#idp80328016">ipfw(8) 「fwd」
            ルールを使って他のマシンにサービスをリダイレクトしたのですが、
            うまく動いてくれないようです。どうしてなんでしょう?</a></dt><dt>9.21. <a href="#idp80366288">サービス要求を他のマシンにリダイレクトするには?</a></dt><dt>9.22. <a href="#idp80371920">バンド幅の管理を行なえるツールはどこで手に入れられますか?</a></dt><dt>9.23. <a href="#idp80379216">BIND (named) が、53 番ポートのほかに
	    大きな番号のポートで受け付けています。私のホストは
	    乗っ取られたのでしょうか。</a></dt><dt>9.24. <a href="#idp80384080">なぜ 「/dev/bpf0: device not configured」
            が出るのでしょうか?</a></dt><dt>9.25. <a href="#idp80390480">Linux の smbmount のように、
            ネットワーク上の Windows
            マシンのディスクをマウントするにはどうしたら良いのでしょう?</a></dt><dt>9.26. <a href="#idp80393296">「icmp-response bandwidth limit 300/200 pps」
            というメッセージがログファイルに現れるのですが、
            どういうことでしょう?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp80122576"></a><a id="diskless-booting"></a><p><strong>9.1.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">ディスクレスブート (diskless boot)</span>」</span>
            に関する情報はどこで得られますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">ディスクレスブート (diskless boot)</span>」</span>
            というのは、FreeBSD がネットワーク上で起動し、
            必要なファイルを自分のハードディスクではなくてサーバから読み込むものです。
            詳細については
            <a class="link" href="../handbook/diskless.html" target="_top">FreeBSD
              ハンドブックの「ディスクレスブート」</a>を読んでください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80125776"></a><a id="router"></a><p><strong>9.2.</strong></p></td><td align="left" valign="top"><p>
            FreeBSD をネットワークのルータ (router) として使用することはできますか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            インターネット標準やこれまでのよい経験によって指摘されている通り、
            FreeBSD は標準ではパケットを転送 (forward) するように設定されていません。
            しかし、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
            の中で次の変数の値を
            <code class="literal">YES</code>
            とする事によってこの機能を有効にすることができます。
          </p><pre class="programlisting">gateway_enable=YES          # Set to YES if this host will be a gateway</pre><p>
            このオプションによって
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>
            の変数
            <code class="varname">net.inet.ip.forwarding</code> が
            <code class="literal">1</code> になります。
          </p><p>
            ほとんどの場合、
            ルータについての情報を同じネットワークの他の計算機等に知らせるために、
            経路制御のためのプロセスを走らせる必要があるでしょう。
            FreeBSD には BSD の標準経路制御デーモンである
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=routed&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">routed</span>(8)</span></a>
            が付属していますが、より複雑な状況に対処するためには
            <span class="application">GaTeD</span>(<a class="link" href="http://www.gated.org/" target="_top">http://www.gated.org/</a>
            から入手可能) を使用することもできます。
            3_5Alpha7 において FreeBSD がサポートされています。
          </p><p>
            注意してほしいのは、FreeBSD をこのようにして使用している場合でも、
            ルータに関するインターネット標準の必要条件を完全には満たしていない
            ということです。しかし、普通に使用する場合にはほとんど問題ありません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80175056"></a><a id="win95-connection"></a><p><strong>9.3.</strong></p></td><td align="left" valign="top"><p>Win95 の走っているマシンを、FreeBSD 経由でインターネットに接続できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            通常、この質問が出てくる状況は自宅に二台の PC があり、一台では
            FreeBSD が、もう一台では Win95 が走っているような場合です。
            ここでやろうとしていう事は FreeBSD の走っている計算機をインターネット
            に接続し、Win95 の走っているマシンからは FreeBSD
            の走っているマシンを経由して接続を行なう事です。
            これは二つ前の質問の特別な場合に相当します。
          </p><p>…で、答えは「はい」です。
            FreeBSD 3.x のユーザモード ppp には <code class="option">-nat</code>
            オプションがあります。
            <span class="application">ppp</span> を <code class="option">-nat</code>
            オプション付きで起動し、
            <code class="filename">/etc/rc.conf</code> にある
            <code class="literal">gateway_enable</code> を
            <span class="emphasis"><em>YES</em></span> に設定します。
            そして Windows マシンを正しく設定すれば、
            きちんと動作するでしょう。</p><p>
            設定に関するさらに詳しい情報は、
            Steve Sims 氏による
            <a class="link" href="http://www.FreeBSD.org/tutorials/ppp/index.html" target="_top">Pedantic
              PPP Primer</a> にあります。</p><p>カーネルモード ppp を利用する場合や、
            インターネットとのイーサネット接続が利用できる場合は、
            <code class="command">natd</code> を利用する必要があります。
            この FAQ の <a class="link" href="#natd" title="9.6.">natd</a>
            のセクションを参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80186576"></a><a id="latest-bind"></a><p><strong>9.4.</strong></p></td><td align="left" valign="top"><p>ISC からリリースされている BIND の最新版はコンパイルできないんでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            BIND の配布物と FreeBSD とでは
            <code class="filename">cdefs.h</code>
            というファイルの中でデータ型の矛盾があります。
            <code class="filename">compat/include/sys/cdefs.h</code>
            を削除してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80189392"></a><a id="slip-ppp-support"></a><p><strong>9.5.</strong></p></td><td align="left" valign="top"><p>FreeBSD で <acronym class="acronym">SLIP</acronym> と
            <acronym class="acronym">PPP</acronym> は使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            使えます。FreeBSD を用いて他のサイトに接続する場合には、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=slattach&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">slattach</span>(8)</span></a>、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sliplogin&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sliplogin</span>(8)</span></a>、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> そして
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppd</span>(8)</span></a> のマニュアルページをご覧ください。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppd</span>(8)</span></a> は、
            <acronym class="acronym">PPP</acronym> のサーバ、クライアント両方の機能を持っています。
            その一方で、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sliplogin&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sliplogin</span>(8)</span></a> は
            <acronym class="acronym">SLIP</acronym> のサーバ専用で、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=slattach&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">slattach</span>(8)</span></a> は
            <acronym class="acronym">SLIP</acronym> のクライアント専用です。
          </p><p>これらを使うためのさらなる情報については、<a class="link" href="../handbook/ppp-and-slip.html" target="_top">ハンドブックの PPP と
            SLIP の章</a>をご覧ください。</p><p>
            「シェルアカウント」を通じてのみインターネットへアクセス可能な場合、
            <span class="application">slirp</span>
            package みたいなものが欲しくなるかもしれませんね。
            これを使えば、ローカルマシンから直接 <acronym class="acronym">ftp</acronym>
            や <acronym class="acronym">http</acronym>
            のようなサービスに (限定的ではありますが) アクセスすることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80222672"></a><a id="natd"></a><p><strong>9.6.</strong></p></td><td align="left" valign="top"><p>FreeBSD は <acronym class="acronym">NAT</acronym> か
            <acronym class="acronym">IP</acronym> マスカレードをサポートしていますか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ローカルなサブネット (一台以上のローカルマシン) を持っているが、
            インターネットプロバイダから 1 つしか <acronym class="acronym">IP</acronym>
            アドレスの割り当てを受けていない場合 (または <acronym class="acronym">IP</acronym>
            アドレスを動的に割り当てられている場合でも)、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a>
            プログラムを使いたくなるかもしれませんね。
            <code class="literal">natd</code> を使えば、
            1 つしか <acronym class="acronym">IP</acronym> アドレスを持っていない場合でも、
            サブネット全体をインターネットに接続させることができます。
          </p><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            も同様の機能を持っており、<code class="option">-nat</code>
            スイッチで有効にすることができます。
            どちらの場合も
            alias ライブラリ (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a>) が使われます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80234320"></a><a id="create-dev-net"></a><p><strong>9.7.</strong></p></td><td align="left" valign="top"><p><code class="filename">/dev/ed0</code>
            デバイスを作成することができません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Berkeley UNIX におけるネットワークの構成において、
            ネットワークのインタフェースはカーネルコードからのみ、
            直接あつかうことができます。
            より詳しく知りたい場合は、
            <code class="filename">/etc/rc.network</code>
            というファイルや、
            このファイルの中に書いてある、
            さまざまなプログラムについてのマニュアルページを見てください。
            それでもまだ分からない場合には、
            他の BSD 系の OS のネットワーク管理についての本を読むべきでしょう。
            ごく少しの例外をのぞいては、FreeBSD のネットワーク管理は SunOS 4.0
            や Ultrix と基本的に同じです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80237008"></a><a id="ethernet-aliases"></a><p><strong>9.8.</strong></p></td><td align="left" valign="top"><p>Ethernet アドレスのエイリアス (alias) はどのようにして設定できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>
            のコマンドラインに
            <code class="literal">netmask 0xffffffff</code>
            を追加して、次のように書いてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ifconfig ed0 alias 204.141.95.2 netmask 0xffffffff</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80241232"></a><a id="port-3c503"></a><p><strong>9.9.</strong></p></td><td align="left" valign="top"><p>3C503 で他のネットワークポートを使用するにはどのようにすればよいですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            他のポートを使用したい場合には、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>
            のコマンドラインにパラメータを追加しなければなりません。
            デフォルトでは
            <code class="literal">link0</code>
            が用いられるようになっています。
            BNC のかわりに
            AUI ポートを使用したい場合には、
            <code class="literal">link2</code>
            というパラメータを追加してください。
            これらのフラグは、
            <code class="filename">/etc/rc.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 参照)
            にある ifconfig_*
            の変数を使って指定されるはずです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80245968"></a><a id="nfs"></a><p><strong>9.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD との間で NFS がうまくできません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            PC 用のネットワークカードによっては、
            NFS のような、
            ネットワークを酷使するアプリケーションにおいて問題を起こすものがあります。
          </p><p>
            この点に関しては
            <a class="link" href="../handbook/nfs.html" target="_top">FreeBSD
              ハンドブックの「NFS」</a>を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80248912"></a><a id="nfs-linux"></a><p><strong>9.11.</strong></p></td><td align="left" valign="top"><p>何故 Linux のディスクを NFS
            マウントできないのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Linux の NFS
            のコードには、
            許可されたポートからのリクエストしか受けつけないものがあります。
            以下を試してみてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -o -P linuxbox:/blah /mnt</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80256080"></a><a id="nfs-sun"></a><p><strong>9.12.</strong></p></td><td align="left" valign="top"><p>何故 Sun のディスクを NFS
            マウントできないのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            SunOS 4.X が走っている Sun Workstation は、
            許可されたポートからのマウント要求しか受けつけません。
            以下を試してみてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -o -P sunbox:/blah /mnt</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80259024"></a><a id="exports-errors"></a><p><strong>9.13.</strong></p></td><td align="left" valign="top"><p><code class="command">mountd</code> から
            <span class="quote">「<span class="quote">can't change attributes</span>」</span>
            というメッセージがずっと出続けていて、
            FreeBSD の NFS サーバでは
            <span class="quote">「<span class="quote">bad exports list</span>」</span>
            と表示されます。これは何が原因なのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>最も良くある問題は、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exports&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">exports</span>(5)</span></a>
            のマニュアルページの以下の部分を正しく理解していないことです。</p><div class="blockquote"><blockquote class="blockquote"><p>このファイルの各行 (# ではじまるコメント行を除く) は、
              NFS サーバのローカルファイルシステムに存在する、
              他のホストにエクスポートされるマウントポイント (複数可) と、
              それに対するエクスポートフラグを指定します。
              特定のエクスポート先ホストおよび、
              すべてのホストに適用されるデフォルトエントリは両方とも、
              サーバの各ローカルファイルシステムに対して一回だけしか指定できません。</p></blockquote></div><p>さて、ありがちな間違いをご覧になればはっきりするでしょう。
            もし <code class="filename">/usr</code>
            以下が単一のファイルシステムである (つまり
            <code class="filename">/usr</code> に何もマウントされない) 場合、
            次の exports リストは正しくありません。</p><pre class="programlisting">/usr/src   client
/usr/ports client</pre><p>一つのファイルシステムに対して属性の指定が二行になっています。
            <code class="filename">/usr</code> は同じホスト
            <code class="systemitem">client</code> にエクスポートされますから、
            正しい書き方は次のようになります。</p><pre class="programlisting">/usr/src /usr/ports  client</pre><p>もう一度マニュアルページの文章を確認すると、
            あるホストにエクスポートされる各ファイルシステムの属性は
            すべて一行に書かれていなければならない、となっています
            (ここでは、「アクセス可能なすべてのホスト」
            も一つの独立したホストとして扱われることに注意してください)。
            このことは、ファイルシステムをエクスポートするために
            奇妙な書式を使わなければならない原因にもなっているのですが、
            ほとんどの人にとって、これは問題にはならないでしょう。</p><p>次に示すのは、有効な exports リストの例です。
            ここでは、<code class="filename">/usr</code> と
            <code class="filename">/exports</code>
            がローカルファイルシステムです。</p><pre class="programlisting"># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=0    client01
/usr/src /usr/ports               client02
# The "client" machines have root and can mount anywhere
# up /exports. The world can mount /exports/obj read-only
/exports -alldirs -maproot=0      client01 client02
/exports/obj -ro</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80272976"></a><a id="ppp-nextstep"></a><p><strong>9.14.</strong></p></td><td align="left" valign="top"><p>PPP で NeXTStep
            に接続する際に問題があるのですが。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">/etc/rc.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 参照)
            の中で次の変数を NO にして、
            TCP extension を無効にしてみてください。
          </p><pre class="programlisting">tcp_extensions=NO</pre><p>
            Xylogic の Annex も同様の問題がありますので、
            Annex 経由で PPP
            を行なう場合にもこの変更を行ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80277072"></a><a id="ip-multicast"></a><p><strong>9.15.</strong></p></td><td align="left" valign="top"><p>IP
            マルチキャスト (multicast) を有効にするには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.0 かそれ以降では、
            標準の状態で完全にマルチキャストに対応しています。
            現在使用している計算機をマルチキャストのルータ (router) として使用するには、
            <code class="literal">MROUTING</code>
            というオプションを定義したカーネルを作ったうえで、
            <code class="command">mrouted</code>
            を走らせる必要があります。2.2 かそれ以降の FreeBSD ならば、
            <code class="filename">/etc/rc.conf</code>
            でフラグ
            <code class="literal">mrouted_enable</code> を
            <code class="literal">YES</code> にセットしておくことで、
            起動時に <code class="command">mrouted</code>
            を起動できます。
          </p><p>
            MBONE
            用のツールは ports 内の専用のカテゴリー mbone
            にあります。
            <code class="command">vic</code> や
            <code class="command">vat</code>
            といった会議用のツールを探している場合は、
            この場所を見てください。
          </p><p>
            詳しい情報は
            <a class="link" href="http://www.mbone.com/" target="_top">Mbone Information Web</a>
            にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80287824"></a><a id="dec-pci-chipset"></a><p><strong>9.16.</strong></p></td><td align="left" valign="top"><p>
            DEC
            の PCI チップセットを用いているネットワークカードには、
            どのような物がありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="mailto:gfoster@driver.nsta.org" target="_top">Glen Foster
              氏</a>による一覧に、
            最近の製品を追加したものを以下に示します。
          </p><pre class="programlisting">Vendor          Model
----------------------------------------------
ASUS            PCI-L101-TB
Accton          ENI1203
Cogent          EM960PCI
Compex          ENET32-PCI
D-Link          DE-530
Dayna           DP1203, DP2100
DEC             DE435, DE450
Danpex          EN-9400P3
JCIS            Condor JC1260
Linksys         EtherPCI
Mylex           LNP101
SMC             EtherPower 10/100 (Model 9332)
SMC             EtherPower (Model 8432)
TopWare         TE-3500P
Znyx            (2.2.X) ZX312, ZX314, ZX342, ZX345, ZX346, ZX348
                (3.X) ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
                      ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80290768"></a><a id="fqdn-hosts"></a><p><strong>9.17.</strong></p></td><td align="left" valign="top"><p>
            何故自分のサイトのホストに対して FQDN
            を使用する必要があるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            実際にはそのホストは別のドメインにあるのではないですか。
            たとえば、foo.bar.edu
            というドメインの中から、
            <code class="systemitem">bar.edu</code> ドメインにある
            <code class="systemitem">mumble</code>
            というホストを指定したい場合には、
            <code class="systemitem">mumble</code>
            だけではダメで、
            <code class="systemitem">mumble.bar.edu</code>
            という FQDN (fully-qualified domain name)
            で指定しなければなりません。
          </p><p>
            伝統的に、BSD の
            BIND のリゾルバ (resolver) ではこのような事は可能でしたが、
            FreeBSD に入っている
            <span class="application">bind</span> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a> 参照)
            の現在のバージョンでは、
            自分以外のドメインに対して FQDN
            でない別名を自動的につけてくれるような事はありません。
            したがって <code class="systemitem">mumble</code> というホスト名は、
            <code class="systemitem">mumble.foo.bar.edu</code>
            という名前か、もしくは root
            ドメイン内にある場合にしか適用されません。
          </p><p>
            これは、
            <code class="systemitem">mumble.bar.edu</code> と
            <code class="systemitem">mumble.edu</code>
            ということなったドメイン名に対してホスト名のサーチが行なわれていた
            以前の振る舞いとは異なったものです。このような事が悪い例もしくは
            セキュリティホールとみなされる理由については
            RFC 1535 を見てください。
          </p><p>
            <code class="filename">/etc/resolv.conf</code> ファイル
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">resolv.conf</span>(5)</span></a> 参照)
            の中で
          </p><pre class="programlisting">domain foo.bar.edu</pre><p>
            と書いてある行を、

            <code class="systemitem">search foo.bar.edu bar.edu</code>

            のように書きかえることで、上のような事ができます。しかし、
            RFC 1535 にあるように、
            検索順序が「内部 (local) と外部 (public) の管理の境界」をまたがないようにしてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80301264"></a><a id="network-permission-denied"></a><p><strong>9.18.</strong></p></td><td align="left" valign="top"><p>すべてのネットワークの操作に対して
            <code class="literal">Permission denied</code>
            というメッセージが表示されるのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="literal">IPFIREWALL</code>
            オプションを付けてカーネルをコンパイルした場合には、
            2.1-STABLE の開発の途中から変更になった 2.1.7R の標準的な方針として、
            明示的に許可されていないすべてのパケットは落とされる設定
            になっている事を覚えておいてください。
          </p><p>
            もしファイアウォールの設定を間違えた場合にネットワークの操作が再びできる
            ようにするには、<code class="systemitem">root</code>
            でログインして次のコマンドを実行してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipfw add 65534 allow all from any to any</code></strong></pre><p>
            <code class="filename">/etc/rc.conf</code> に
            <code class="literal">firewall_type='open'</code>
            を追加してもよいでしょう。
          </p><p>
            FreeBSD のファイアウォールの設定についての情報は
            <a class="link" href="../handbook/firewalls.html" target="_top">FreeBSD
              ハンドブックの「ファイアウォール」</a>にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80316368"></a><a id="ipfw-overhead"></a><p><strong>9.19.</strong></p></td><td align="left" valign="top"><p>IPFW のオーバヘッドはどのくらいでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この答えは、
            使っているルールセットとプロセッサのスピードによってほとんど決まります。
            イーサネットに対して少しのルールセットだけを使っている場合には、
            ほとんどその影響は無視できる程度です。
            実際の測定値を見ないと満足できない方々のために、
            実際の測定結果をお見せしましょう。
          </p><p>
            次の測定は 486-66 (訳注: Intel 社製 CPU i486、66MHz のこと) 上で
            2.2.5-STABLE を使用して行なわれました。
            IPFW は変更が加えられて、<code class="literal">ip_fw_chk</code>
            ルーチン内でかかる時間を
            測定して 1000
            パケット毎に結果をコンソールに表示するようになっています。
          </p><p>
            それぞれ 1000 ずつのルールが入っている 2
            つのルールセットでテストが行なわれました。
            ひとつ目のルールセットは最悪のケースを見るために
          </p><pre class="programlisting">ipfw add deny tcp from any to any 55555</pre><p>
            というルールを繰り返したものです。
          </p><p>
            IPFW のパケットチェックルーチンは、
            パケットが (ポート番号のせいで) このルールにマッチしないことがわかるまでに、
            何度も実行されます。そのため、これは最悪のケースを示します。
            このルールを 999 個繰り返し並べた後に
          </p><pre class="programlisting">allow ip from any to any</pre><p>
            が書かれています。
          </p><p>
            2つ目のルールセットは、なるべく早くチェックが終了するように書かれたものです。
          </p><pre class="programlisting">ipfw add deny ip from 1.2.3.4 to 1.2.3.4</pre><p>
            このルールでは、発信元の IP アドレスがマッチしないので、
            チェックはすぐに終了します。上のルールセットとおなじように、
            1000 個目のルールは
          </p><pre class="programlisting">allow ip from any to any</pre><p>
            です。
          </p><p>
            1 つ目のルールセットの場合、
            パケットあたりのオーバヘッドはおよそ
            2.703ms/packet、
            これはだいたい 1 つのルールあたり 2.7
            マイクロ秒かかっていることになります。
            したがって、
            このルールにおけるパケット処理時間の理論的な限界は、
            毎秒約 370 パケットです。
            10Mbps のイーサネットで 1500 バイト以下のパケットサイズを仮定すると、
            バンド幅の利用効率は 55.5% が限界となることになります。
          </p><p>
            2 つ目のルールセットでは、それぞれのパケットがおよそ
            1.172msで処理されていますので、
            だいたい 1 つのルールあたり 1.2
            マイクロ秒かかっていることになります。
            パケット処理時間の理論的な限界は、
            毎秒約 853 パケットとなりますので、
            10Mbps Ethernet のバンド幅を使い切ることができます。
          </p><p>
            このテストでのルール数は多過ぎるため、
            実際に使用する際の結果を反映している訳ではありません。
            これらは上に示した数値を出すためだけに用いられたものです。
            効率の良いルールセットを作るためには、
            次のような事を考えておけばよいでしょう。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  「確定している」ルールは先頭の方に持ってきてください。
                  これは、多数の TCP のトラフィックがこのルールで処理されるためです。
                  そしてこのルールの前には
                  <code class="literal">allow tcp</code>
                  という記述を置かないでください。
                </p></li><li class="listitem"><p>
                  良く使われるルールを、あまり良く使われないルールよりも
                  前の方に (もちろん<span class="emphasis"><em>ファイアウォールの許可設定を変えない範囲で</em></span>)
                  持ってきてください。
                  <code class="command">ipfw -a l</code> のようしてパケット数の統計を取ることで、
                  どのルールが最もよく使われているかを調べることができます。
                </p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80328016"></a><a id="ipfw-fwd"></a><p><strong>9.20.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfw</span>(8)</span></a> <span class="quote">「<span class="quote">fwd</span>」</span>
            ルールを使って他のマシンにサービスをリダイレクトしたのですが、
            うまく動いてくれないようです。どうしてなんでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>おそらく、あなたが期待している動作とは、
            単なるパケット転送ではなくネットワークアドレス変換 (NAT)
            と呼ばれるものだからでしょう。
            <span class="quote">「<span class="quote">fwd</span>」</span> ルールは文字どおり、本当に転送しか行ないません。
            パケットの中身については一切手を加えないのです。
            そのため、次のようなルールを設定したとすると、
          </p><pre class="screen">01000 fwd <em class="replaceable"><code>10.0.0.1</code></em> from any to <em class="replaceable"><code>foo 21</code></em></pre><p>宛先アドレスに <em class="replaceable"><code>foo</code></em> と書かれたパケットが
            このルールを設定したマシンに到着した場合、そのパケットは
            <em class="replaceable"><code>10.0.0.1</code></em> に転送されますが、宛先アドレスは
            <em class="replaceable"><code>foo</code></em> のままになります。
            つまり、パケットに宛先アドレスが <em class="replaceable"><code>10.0.0.1</code></em>
            に書き換えられるということは<span class="emphasis"><em>ありません</em></span>。
            自分宛でないパケットを受けとったマシンは、
            おそらくほとんどの場合、そのパケットを破棄すると思います。
            そのため <span class="quote">「<span class="quote">fwd</span>」</span> ルールは、
            そのルールを書いたユーザが意図したようには動かないことが良くあります。
            この動作はバグではなく、仕様なのです。</p><p>サービスの転送をきちんと動作させる方法については、
            <a class="link" href="#service-redirect" title="9.21.">サービスのリダイレクトに関する
              FAQ</a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=natd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">natd</span>(8)</span></a> のマニュアルページ、
            <a class="link" href="../ports/" target="_top">Ports Collection</a>
            にいくつか含まれているポート転送ユーティリティなどをご覧になると良いでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80366288"></a><a id="service-redirect"></a><p><strong>9.21.</strong></p></td><td align="left" valign="top"><p>サービス要求を他のマシンにリダイレクトするには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FTP などのサービスのリクエストは、<span class="quote">「<span class="quote">socket</span>」</span>
            パッケージを利用してリダイレクトできます。
            <span class="quote">「<span class="quote">socket</span>」</span>
            パッケージは ports の
            <code class="filename">sysutils</code>
            カテゴリに含まれています。
            (<code class="filename">/etc/inet.conf</code>に書かれている)
            コマンド行を、次のように <span class="quote">「<span class="quote">socket</span>」</span> を呼ぶように変更してください。
        </p><pre class="programlisting">ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.foo.com ftp</pre><p>
            ここで
            <em class="replaceable"><code>ftp.foo.com</code></em>
            はリダイレクト先のホスト名、
            行の最後の
            <em class="replaceable"><code>ftp</code></em> はポート名です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80371920"></a><a id="bandwidth-mgr-tool"></a><p><strong>9.22.</strong></p></td><td align="left" valign="top"><p>バンド幅の管理を行なえるツールはどこで手に入れられますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 用のバンド幅管理ツールには、無料で手に入れられる
            <a class="link" href="http://www.csl.sony.co.jp/person/kjc/programs.html" target="_top">ALTQ</a> と、
            <a class="link" href="http://www.etinc.com/" target="_top">Emerging Technologies</a>
            から入手できる Bandwidth Manager
            という市販のものの 2 種類があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80379216"></a><a id="extra-named-port"></a><p><strong>9.23.</strong></p></td><td align="left" valign="top"><p>BIND (<code class="command">named</code>) が、53 番ポートのほかに
	    大きな番号のポートで受け付けています。私のホストは
	    乗っ取られたのでしょうか。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>おそらく違います。FreeBSD 3.0 以降では、外向けの問合せに
	    ランダムな大きな番号のポートを用いるバージョンの BIND を
	    用いています。ファイアウォールを通すため、またはあなたの
	    気分で、外向きの問合せを 53 番ポートから行いたいならば、
	    <code class="filename">/etc/namedb/named.conf</code> に次のように
	    設定してみてください。</p><pre class="programlisting">options {
        query-source address * port 53;
};</pre><p>更に限定したければ、<code class="literal">*</code> を単一の IP
	    アドレスに置き換えることもできます。</p><p>それはともかく、おめでとうごさいます。
	    <code class="command">sockstat</code> の出力を見て、おかしな現象に
	    注目するのはよい習慣です。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80384080"></a><a id="bpf-not-configured"></a><p><strong>9.24.</strong></p></td><td align="left" valign="top"><p>なぜ <span class="quote">「<span class="quote"><code class="computeroutput">/dev/bpf0: device not configured</code></span>」</span>
            が出るのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            バークレーパケットフィルタ (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bpf&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">bpf</span>(4)</span></a>)
            ドライバは、それを利用するプログラムを実行する前に有効にしておく必要があります。
            カーネルコンフィグファイルに、次のように追加してカーネルの再構築をしてください。
          </p><pre class="programlisting">pseudo-device bpfilter		# Berkeley Packet Filter</pre><p>
            そして再起動してから、次にデバイスノードを作成する必要があります。
            これは、次のように入力し、<code class="filename">/dev</code> を変更することで行ないます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV bpf0</code></strong></pre><p>
            デバイスノードの作成の詳細は、
            <a class="link" href="../handbook/kernelconfig-nodes.html" target="_top">FreeBSD
              ハンドブックの「デバイスノード」</a>を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80390480"></a><a id="mount-smb-share"></a><p><strong>9.25.</strong></p></td><td align="left" valign="top"><p>Linux の smbmount のように、
            ネットワーク上の Windows
            マシンのディスクをマウントするにはどうしたら良いのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ports Collection に含まれる
            <span class="application">sharity light</span> パッケージを使ってください、</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80393296"></a><a id="icmp-response-bw-limit"></a><p><strong>9.26.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">icmp-response bandwidth limit 300/200 pps</span>」</span>
            というメッセージがログファイルに現れるのですが、
            どういうことでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、カーネル自身から「ICMP や TCP のリセット (RST)
            応答を、妥当な数よりも多く送っている」ということを、
            あなたに伝えるメッセージです。
            ICMP 応答は良く、使われていない UDP
            ポートに接続しようとした結果として生成されます。
            また、TCP リセットはオープンされていない TCP
            ポートに接続しようとした結果として生成されます。
            その他、これらのメッセージが表示される原因となる状況として、
            以下のようなものがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>(特定のセキュリティ上の弱点を悪用しようとする攻撃ではなく)
                膨大な数のパケットを使った強引なサービス妨害 (DoS) 攻撃。</p></li><li class="listitem"><p>(一部のウェルノウンポートを狙ったものではなく)
                非常に広い範囲のポートに接続を試みるポートスキャン。</p></li></ul></div><p>メッセージ中の最初の数字は、
            上限を設定しなかった場合にカーネルが送っていたであろうパケットの数を示し、
            二番目の数字は、パケット数の上限値を示します。
            この上限値は
            <code class="varname">net.inet.icmp.icmplim</code> という
            sysctl 変数を使うことで、以下のように変更可能です。
            ここでは上限を 1 秒あたりのパケット数で
            <code class="literal">300</code> にしています。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w net.inet.icmp.icmplim=300</code></strong></pre><p>カーネルの応答制限を無効にせず、
            ログファイル中のメッセージだけを抑制したい場合、
            <code class="varname">net.inet.icmp.icmplim_output</code> sysctl
            変数を次のようにすることで出力を止めることができます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w net.inet.icmp.icmplim_output=0</code></strong></pre><p>最後に、もし応答制限を無効にしたい場合は、
            <code class="varname">net.inet.icmp.icmplim</code> sysctl 変数に
            (上の例のようにして) <code class="literal">0</code>
            を設定することで実現できます。
            ただし応答制限を無効化するのは、上記の理由からおすすめしません。</p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ppp"></a>第10章 PPP</h1></div></div></div><div class="qandaset"><a id="idp80407760"></a><dl><dt>10.1. <a href="#idp80408016">ppp が動きません。どこを間違えているのでしょう?</a></dt><dt>10.2. <a href="#idp80419024">ppp を実行するとハングします</a></dt><dt>10.3. <a href="#idp80428240">ppp が
            -auto モードでダイアルしてくれない</a></dt><dt>10.4. <a href="#idp80444496">「No route to host」
            とはどういう意味ですか?</a></dt><dt>10.5. <a href="#idp80450768">3 分ほど経つと接続が切れてしまう</a></dt><dt>10.6. <a href="#idp80460112">負荷が高いと接続が切れてしまう</a></dt><dt>10.7. <a href="#idp80468304">接続がランダムに切れてしまう</a></dt><dt>10.8. <a href="#idp80471504">接続が不規則にハングアップしてしまう</a></dt><dt>10.9. <a href="#idp80516688">回線の向こう側での反応がない</a></dt><dt>10.10. <a href="#idp80523344">ppp がハングアップする</a></dt><dt>10.11. <a href="#idp80539472">Login OK!
            のメッセージが出た後、何も起こらない</a></dt><dt>10.12. <a href="#idp80554064">でもまだ 「magic is the same」
            というエラーが出る</a></dt><dt>10.13. <a href="#idp80603472">接続が切れるまで LCP
            のネゴシエーションが続くのですが。</a></dt><dt>10.14. <a href="#idp80633168">ppp が接続直後に固まってしまう</a></dt><dt>10.15. <a href="#idp80649168">ppp の内部でシェルを起動しようとすると固まってしまう</a></dt><dt>10.16. <a href="#idp80659280">ヌルモデムケーブルを使用しているとき、
            ppp が終了しない</a></dt><dt>10.17. <a href="#idp80663760">ppp を
            -auto モードで動かすと、
            勝手にダイアルすることがある</a></dt><dt>10.18. <a href="#idp80677968">CCP
            エラーとはどういう意味ですか</a></dt><dt>10.19. <a href="#idp80681808">ファイル転送の途中で、ppp が
            IO エラーを出して固まってしまう</a></dt><dt>10.20. <a href="#idp80693712">どうして ppp
            は接続速度をログに残さないんでしょう?</a></dt><dt>10.21. <a href="#idp80703696">私の chat スクリプトでは
            「\」
            という文字を PPP が解釈してくれません。</a></dt><dt>10.22. <a href="#idp80723280">ppp が
            segmentation fault になるのですが、
            ppp.core ファイルがありません</a></dt><dt>10.23. <a href="#idp80744400">auto モードでダイアルをするようなプロセスが接続されない。
          </a></dt><dt>10.24. <a href="#idp80801616">何故ほとんどのゲームが
            -nat スイッチ付きだと動かないんですか?</a></dt><dt>10.25. <a href="#idp80827344">有用なポート番号のリストはありませんか?</a></dt><dt>10.26. <a href="#idp80861648">FCS エラーって何?</a></dt><dt>10.27. <a href="#PPPoEwithNAT">ゲートウェイで PPPoE を実行すると MacOS や
            Windows 98 との接続がフリーズしてしまうのですが、
            これはなぜなのでしょうか?</a></dt><dt>10.28. <a href="#idp80904016">どれにも当てはまらない! どうしたらいいの?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp80408016"></a><a id="userppp"></a><p><strong>10.1.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が動きません。どこを間違えているのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            のマニュアルと、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP" target="_top">FreeBSD
              ハンドブックの「PPP」</a>を読んでみましょう。
            次に、
          </p><pre class="programlisting">set log Phase Chat Connect Carrier lcp ipcp ccp command</pre><p>
            という命令を <span class="application">ppp</span>
            のコマンドプロンプトに対して打ち込むか、
            設定ファイル
            <code class="filename">/etc/ppp/ppp.conf</code>
            に加えて (<code class="literal">default</code>
            セクションの先頭に加えるのが一番良いでしょう)
            ログを有効にしてみてください。
            その際、
            <code class="filename">/etc/syslog.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">syslog.conf</span>(5)</span></a> 参照)
            に
          </p><pre class="programlisting">!ppp
*.*              /var/log/ppp.log</pre><p>
            と書かれた行が含まれているか、また、
            <code class="filename">/var/log/ppp.log</code>
            が存在しているかどうか確かめておいてください。
            さて、これで何が起きているのか突き止めるために、
            ログファイルからたくさんの情報を得られるようになりました。
            ログに訳の分らない部分があっても心配ご無用。
            あなたが助けを求めた誰かにとっては、
            その部分が意味をなす場合があるのです。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                ログの取得に syslog を使用するようになったのは
                2.2.5 以降からです。
              </p></div><p>
            使用中の <code class="command">ppp</code> のバージョンで
            <span class="quote">「<span class="quote"><code class="literal">set log</code></span>」</span>
            命令を解釈しない場合は、<a class="link" href="http://people.FreeBSD.org/~brian/" target="_top">最新版</a>をダウンロードすべきです。
            FreeBSD の 2.1.5 以降でビルドできます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80419024"></a><a id="ppp-hangs"></a><p><strong>10.2.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> を実行するとハングします</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ホスト名の解決がうまくいっていないのでしょう。まず、
            リゾルバ (resolver) が
            <code class="filename">/etc/hosts</code>を参照するように、
            <code class="filename">/etc/host.conf</code>
            の最初の行に
            <code class="literal">host</code>
            と書き込んでください。
            つぎに、<code class="filename">/etc/hosts</code>
            に使用しているマシンのエントリを書き加えます。
            ローカルでネットワークを使用していない場合は、
            <code class="literal">localhost</code>
            の行を以下のように変更してください。
          </p><pre class="programlisting">127.0.0.1      foo.bar.com foo localhost</pre><p>
            使用しているホストのエントリを追加してもかまいません。
            詳細は関連するマンページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80428240"></a><a id="ppp-nodial-auto"></a><p><strong>10.3.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が
            <code class="option">-auto</code> モードでダイアルしてくれない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず最初に、デフォルトルートが確立しているかどうかチェックしてください。
            <code class="command">netstat -rn</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> 参照)
            を実行すると、以下のような情報が表示されるはずです。
          </p><pre class="screen">Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</pre><p>
            これはあなたがハンドブックやマニュアル、
            <code class="filename">ppp.conf.sample</code>
            の中で出てくるアドレスを使用していると仮定した場合の例です。
            デフォルトルートが確立していない場合、
            <code class="filename">ppp.conf</code>
            の中の
            <code class="literal">HISADDR</code>
            が理解できない、
            古いバージョンの
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            が走っている可能性があります。
            FreeBSD 2.2.5 より前のバージョンに付属していた
            <span class="application">ppp</span>
            を使用している場合、
          </p><pre class="programlisting">add 0 0 HISADDR</pre><p>
            と書かれた行を以下のように修正してください。
          </p><pre class="programlisting">add 0 0 10.0.0.2</pre><p>
            <code class="command">netstat -rn</code>
            でデフォルトルートの情報が表示されない場合、もう一つ、
            <code class="filename">/etc/rc.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 参照) (2.2.2
            より前のリリースでは
            <code class="filename">/etc/sysconfig</code>
            と呼ばれていました) の中でデフォルトのルータを誤って設定し、
            <code class="filename">ppp.conf</code> から
          </p><pre class="programlisting">delete ALL</pre><p>
            の行をうっかり消してしまった可能性があります。
            この場合は、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP-FINAL" target="_top">FreeBSD
              ハンドブックの「システムの最終設定」</a>の項を読み直してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80444496"></a><a id="no-route-to-host"></a><p><strong>10.4.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote"><code class="computeroutput">No route to host</code></span>」</span>
            とはどういう意味ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            このエラーは通常、
            <code class="filename">/etc/ppp/ppp.linkup</code>
            に以下のようなセクションが無い場合に起こります。
          </p><pre class="programlisting">MYADDR:
  delete ALL
  add 0 0 HISADDR</pre><p>
            これは動的 <acronym class="acronym">IP</acronym>
            アドレスを使用している場合、
            またはゲートウェイのアドレスを知らない場合にのみ必要な設定です。
            インタラクティブモードを使用している場合、
            <span class="emphasis"><em>パケットモード</em></span>に入った後で (プロンプトが
            <acronym class="acronym">PPP</acronym>
            と大文字に変わったらパケットモードに入ったしるしです)、
            以下の命令を入力してください。
          </p><pre class="screen">delete ALL
add 0 0 HISADDR</pre><p>
            詳しい情報については、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP" target="_top">FreeBSD
              ハンドブックの「PPP と動的 IP 設定」</a>の項を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80450768"></a><a id="connection-threeminutedrop"></a><p><strong>10.5.</strong></p></td><td align="left" valign="top"><p>3 分ほど経つと接続が切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">ppp</code>
            のタイムアウトは デフォルトでは 3 分です。
            これは
          </p><pre class="programlisting">set timeout <em class="replaceable"><code>NNN</code></em></pre><p>
            という命令によって調整することができます。
            <em class="replaceable"><code>NNN</code></em> には、
            接続が切れるまでのアイドル時間が秒数で入ります。
            <em class="replaceable"><code>NNN</code></em> が 0 の場合、
            タイムアウトによる切断は起こりません。
            このコマンドは <code class="filename">ppp.conf</code>
            に入れることも、
            インタラクティブモードでプロンプトから入力することも
            できます。
            ソケットを用いる
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> か <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppctl</span>(8)</span></a> を使用し、
            <span class="application">ppp</span>
            サーバに接続することによって、
            回線がアクティブな間に限定してタイムアウトの時間を調整することも可能です。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                <code class="command">pppctl</code> は 2.2.5R からです。
              </p></div><p>
            詳しい情報は
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80460112"></a><a id="ppp-drop-heavy-load"></a><p><strong>10.6.</strong></p></td><td align="left" valign="top"><p>負荷が高いと接続が切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Link Quality Reporting (LQR) の設定を行っている場合、
            マシンと接続先の間で非常にたくさんの <acronym class="acronym">LQR</acronym>
            パケットが失われている可能性があります。結果として
            <code class="command">ppp</code> は回線の具合いが悪いと考え、
            回線を切断するのです。2.2.5 より前のバージョンの FreeBSD では
            <acronym class="acronym">LQR</acronym>
            はデフォルトで有効になっています。
            現在ではデフォルトの状態で無効です。
            <acronym class="acronym">LQR</acronym>
            は以下の命令で無効にすることができます。
          </p><pre class="programlisting">disable lqr</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80468304"></a><a id="ppp-drop-random"></a><p><strong>10.7.</strong></p></td><td align="left" valign="top"><p>接続がランダムに切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ノイズの多い回線、あるいは待ち機能付きの回線では、
            時々モデムが (誤って) キャリアを失ったと思い込み、
            回線が切断されてしまうことがあります。
          </p><p>
            大多数のモデムでは、
            一時的なキャリアの喪失をどれくらいの時間で検出するかを、
            設定で決めることができます。
            たとえば USR Sportster では、S10 レジスタ
            の値を 10 倍した秒数がその値になります。
            この場合、モデムをもっとのんびり屋さんにするには、
            dial 行に次のような文字列を加えると良いでしょう。
          </p><pre class="programlisting">set dial "...... ATS10=10 OK ......"</pre><p>
            詳しくはお使いのモデムのマニュアルをご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80471504"></a><a id="ppp-hangs-random"></a><p><strong>10.8.</strong></p></td><td align="left" valign="top"><p>接続が不規則にハングアップしてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            たくさんの人が、原因不明のハングアップを経験しています。
            検証のために必要なのは、まずどちら側のリンクでそれが起こっているか、
            ということです。
          </p><p>
            外部接続型モデムを利用しているなら、
            単に <code class="command">ping</code> を使うことで、
            データを送信するときに <acronym class="acronym">TD</acronym>
            ランプが点灯するかどうかを確認することができます。
            もし、<acronym class="acronym">TD</acronym> ランプが点灯して、
            <acronym class="acronym">RD</acronym> ランプが点灯しなければ、
            問題は回線の向こう側にあります。<acronym class="acronym">TD</acronym> が点灯しなければ、
            問題は回線のこちら側です。内蔵型モデムの場合、
            <code class="filename">ppp.conf</code> ファイルに
            <code class="command">set server</code> コマンドを入れる必要があるでしょう。
            回線が切断されたとき、<code class="command">pppctl</code>
            を使って <code class="command">ppp</code>
            に接続してください。
            そのとき、
            ネットワーク接続が急に復旧 (診断ソケットへのアクセスで、
            <code class="command">ppp</code> が復活します) するか、
            もしくは接続自体が全くできない (ただし、
            <code class="command">ppp</code>
            起動時に <code class="command">set socket</code>
            コマンドがちゃんと実行されているとします) としたら、
            問題は回線のこちら側です。
            もし、接続可能で、かつ状況が変化しなければ、
            <code class="command">set log local async</code>
            を使ってローカル非同期ログ (async logging) を有効にし、
            <code class="command">ping</code>
            を他のウィンドウかターミナルから使ってください。
            非同期ログには、こちら側のリンクの送受信データが記録されます。
            もし、データが送信されたにもかかわらず返って来ていなければ、
            問題は回線の向こう側にあることになります。
          </p><p>
            問題が回線のどちら側かにあることが分かったら、
            つぎの二つの可能性が考えられるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80516688"></a><a id="ppp-remote-not-responding"></a><p><strong>10.9.</strong></p></td><td align="left" valign="top"><p>回線の向こう側での反応がない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これに対処できることはほとんどありません。大部分の ISP
            は、Microsoft 社製 OS 以外の利用者に対してのサポートを拒否するでしょう。
            <code class="filename">ppp.conf</code> ファイルの中に
            <code class="literal">enable lqr</code>
            を記述することで
            <code class="command">ppp</code>
            が回線の向こう側で発生する切断を検出することができますが、
            この検出は比較的遅いため、あまり役に立ちません。また、あなたは
            user-ppp を利用していることを
            ISP に知られたくないと思うかも知れませんね。
          </p><p>
            まず最初に、こちら側の圧縮機能をすべて無効にしてみてください。
            それには、設定ファイルをつぎのようにします。
          </p><pre class="programlisting">disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</pre><p>
            そして再接続し、変更前と同じように通信できることを確認します。
            もしこれによって状況が改善されるか、完全に解決したら、
            (上の設定のうち) どの設定で状況が変化したのかを、
            色々な組合せで試してみてください。これは、ISP
            に問い合わせを行なうときの有効な情報となります (ただし、
            あなたが Microsoft
            社製品以外のものを利用していることも明らかにしてしまいますが)。
          </p><p>
            ISP に問い合わせを行なう前に、こちら側の非同期ログを有効にして、
            接続がハングアップするまで待ってください。この作業は、
            非常に多くのディスク空間を消費するかも知れません。
            興味の対象となっているのは、通信ポートから最後に読み込まれたデータです。
            それは通常 <acronym class="acronym">ASCII</acronym> データで、
            問題点の詳細 (<span class="quote">「<span class="quote"><code class="computeroutput">Memory fault, core dump</code></span>」</span> など) が
            記載されている可能性があります。
          </p><p>
            回線の向こう側で通信ログを監視することは可能なはずですので、
            切断が発生した時、ISP の対応が好意的ならば
            どうして ISP 側で問題が発生したのかこちらに伝えてくれるかも知れません。
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:brian@Awfulhak.org">brian@Awfulhak.org</a>&gt;</code>
            まで詳細を送って頂くか、ISP
            に直接私に連絡するように伝えて下さっても構いません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80523344"></a><a id="ppp-hung"></a><p><strong>10.10.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> がハングアップする</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ベストな方法は、
            <code class="literal">CFLAGS+=-g</code> と
            <code class="literal">STRIP=</code> を
            <code class="command">ppp</code> の
            <code class="filename">Makefile</code>
            に追加して、
            <code class="command">ppp</code> を再構築し、
            そして
            <code class="literal">make clean &amp;&amp; make &amp;&amp; make install</code>
            を行なうことです。
            <code class="command">ppp</code> がハングアップした時、
            <code class="literal">ps ajxww | fgrep ppp</code> を使って
            <code class="command">ppp</code>
            のプロセス ID を調べ、
            <code class="literal">gdb ppp PID</code> を実行してください。
            <code class="command">gdb</code>
            のプロンプトから、
            <code class="command">bt</code>
            を使ってスタックをトレースすることができます。
          </p><p>
            スタックトレースの結果は、<code class="email">&lt;<a xmlns="" class="email" href="mailto:brian@Awfulhak.org">brian@Awfulhak.org</a>&gt;</code>
            まで送ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80539472"></a><a id="ppp-loginok-thennothing"></a><p><strong>10.11.</strong></p></td><td align="left" valign="top"><p><code class="computeroutput">Login OK!</code>
            のメッセージが出た後、何も起こらない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            2.2.5 より前のリリースの FreeBSD では、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            はリンクが確立した後、接続先が <acronym class="acronym">Line Control Protocol (LCP)</acronym>
            を発信するのを待ちます。しかし、多くの <acronym class="acronym">ISP</acronym>
            ではネゴシエーションを自分からは起こさず、
            クライアントが起こすのを待っています。
            <span class="application">ppp</span> に強制的に
            <acronym class="acronym">LCP</acronym> を発信させるには、
            次の命令を使います。
          </p><pre class="programlisting">set openmode active</pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                両方の側がネゴジェーションを起こしても、
                大抵の場合は何の問題もありません。
                ですから、現在では openmode
                はデフォルトで有効になっています。
                次のセクションでこれが<span class="emphasis"><em>問題になる場合</em></span>を説明します。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80554064"></a><a id="ppp-same-magic"></a><p><strong>10.12.</strong></p></td><td align="left" valign="top"><p>でもまだ <span class="quote">「<span class="quote"><code class="computeroutput">magic is the same</code></span>」</span>
            というエラーが出る</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            時折、接続直後のログに
            <span class="quote">「<span class="quote"><code class="computeroutput">magic is the same</code></span>」</span>
            というメッセージがあらわれることがあります。
            このメッセージがあらわれても何も起きない場合もありますし、
            どちらかの側が接続を切ってしまう場合もあります。
            <code class="command">ppp</code> の実装の多くはこの問題に対応できておらず、
            その場合にはちゃんと link が上がっている状態であっても、
            <code class="command">ppp</code> が最終的にあきらめてしまい、
            接続を切るまで設定のリクエストが繰り返し送られ、
            設定が行われたという通知がログファイルに残ると思います。
          </p><p>
            これは通常、
            ディスクアクセスの遅いサーバマシンのシリアルポートで
            <code class="command">getty</code> が生きていて、
            <code class="command">ppp</code> がログインスクリプトか、
            ログイン直後に起動されたプログラムから実行されている場合に起こります。
            <code class="command">slirp</code>
            を使用している場合に同様の症状が見られたという報告もあります。
            原因は
            <code class="command">getty</code> の終了されるまでと、
            <code class="command">ppp</code> が実行され、
            クライアント側の
            <code class="command">ppp</code> が
            <acronym class="acronym">Line Control Protocol (LCP)</acronym>
            を送り始めるまでのタイミングにあります。
            サーバ側のシリアルポートで
            <code class="literal">ECHO</code>
            が有効なままになっているので、
            クライアント側の
            <code class="command">ppp</code>
            にパケットが「反射」してしまうのです。
          </p><p>
            <acronym class="acronym">LCP</acronym>
            ネゴシエーションの一部として、
            リンクの両サイドで
            magic number を定めて、
            「反射」が起きていないかどうか確かめる作業があります。
            規約では、接続相手がこちらと同じ magic number を提示してきたら、
            <acronym class="acronym">NAK</acronym> を送って新しい
            magic number を選択しなければならないと定めています。
            この作業の間、サーバのシリアルポートの
            <code class="literal">ECHO</code> がずっと有効になったままなので、
            クライアント側の <code class="command">ppp</code>
            は <acronym class="acronym">LCP</acronym> パケットを送り、
            パケットが反射して全く同じ magic number
            が送られてくるのを見つけ、
            それに対して <acronym class="acronym">NAK</acronym>
            を送るのです。一方 <acronym class="acronym">NAK</acronym>
            自体も (これは <code class="command">ppp</code>
            が magic number
            を変更しなければいけないことを意味しています) 反射してくるので、
            結果として magic number が数えきれないほど変更され、
            そのすべてがサーバの <acronym class="acronym">tty</acronym>
            バッファの中に積み重なることになるのです。
            サーバでスタートした <code class="command">ppp</code>
            は、すぐに magic number であふれかえってしまい、
            <acronym class="acronym">LCP</acronym>
            のネゴシエーションを十分に行ったものと判断して、
            さっさと接続を切ってしまいます。
            一方、
            クライアント側は反射が帰ってこなくなったので満足しますが、
            それもサーバが接続を切ったことを知るまでです。
          </p><p>
            この事態は、以下の行を
            <code class="filename">ppp.conf</code>
            の中に書いて、
            相手がネゴシエーションを開始できるようにする事によって回避できます。
          </p><pre class="programlisting">set openmode passive</pre><p>
            これで <code class="command">ppp</code> はサーバが
            <acronym class="acronym">LCP</acronym>
            ネゴシエーションを起こすのを待つようになります。
            しかし、
            自分からは決してネゴジェーションを起こさないサーバもあるかもしれません。
            もしこの状況に遭遇した場合には、次のようにしてください。
          </p><pre class="programlisting">set openmode active 3</pre><p>
            これによって <code class="command">ppp</code> は 3 秒間
            passive モードを続けた後で、
            <acronym class="acronym">LCP</acronym> リクエストを送り始めます。
            この間に相手がリクエストを送り始めた場合には
            3 秒間待たずにこのリクエストに即座に応答します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80603472"></a><a id="ppp-lcp-constant"></a><p><strong>10.13.</strong></p></td><td align="left" valign="top"><p>接続が切れるまで <acronym class="acronym">LCP</acronym>
            のネゴシエーションが続くのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在の <span class="application">ppp</span> は、まだ
            <acronym class="acronym">LCP</acronym> や
            <acronym class="acronym">CCP</acronym>、
            <acronym class="acronym">IPCP</acronym>
            の返事が、
            元のリクエストと連携してくれる機能がきちんと実装されていません。
            その結果、ある
            <span class="application">ppp</span>
            の実装が相手よりも 6 秒以上遅い場合には、
            <acronym class="acronym">LCP</acronym> 設定のリクエストをさらに 2 回送ります。
            これは致命的な物です。
          </p><p>
            <code class="systemitem">A</code> と <code class="systemitem">B</code>という
            2 つの実装を考えてみましょう。
            <code class="systemitem">A</code> が接続の直後に
            <acronym class="acronym">LCP</acronym> リクエストを送り、
            一方 <code class="systemitem">B</code> の方はスタートするのに
            7 秒かかったとします。<code class="systemitem">B</code> がスタートする時には
            <code class="systemitem">A</code> は <acronym class="acronym">LCP</acronym>
            リクエストを 3 回送ってしまっています。
            前の節で述べた magic number の問題が起きないよう、
            <code class="literal">ECHO</code> は <code class="literal">off</code> になっていると考えています。
            <code class="systemitem">B</code> は <acronym class="acronym">REQ</acronym> を送ります。
            するとこれは <code class="systemitem">A</code> の <acronym class="acronym">REQ</acronym> のうち、
            最初の物に対する <acronym class="acronym">ACK</acronym> となります。
            結果として、<code class="systemitem">A</code>
            は <acronym class="acronym">OPENED</acronym>
            の状態に入り、
            <code class="systemitem">B</code>
            に対して (最初の) <acronym class="acronym">ACK</acronym> を送ります。
            そのうちに
            <code class="systemitem">B</code> は、<code class="systemitem">B</code>
            がスタートする前に
            <code class="systemitem">A</code>
            から送られたもう 2 つの
            <acronym class="acronym">REQ</acronym> に対する
            <acronym class="acronym">ACK</acronym> を送り返します。
            <code class="systemitem">B</code> は <code class="systemitem">A</code>
            からの最初の
            <acronym class="acronym">ACK</acronym> を受け取り
            <acronym class="acronym">OPENED</acronym> の状態に入ります。
            <code class="systemitem">A</code> は <code class="systemitem">B</code> からの
            2 つ目の <acronym class="acronym">ACK</acronym>
            を受け取りますので、
            <acronym class="acronym">REQ-SENT</acronym>の状態に戻り、
            さらに、RFC のとおりに (4 つ目の) <acronym class="acronym">REQ</acronym>
            を送ります。そして 3 つ目の
            <acronym class="acronym">ACK</acronym>
            を受け取って
            <acronym class="acronym">OPENED</acronym> 状態に入ります。
            一方、<code class="systemitem">B</code> は <code class="systemitem">A</code>
            からの 4 つ目の
            <acronym class="acronym">REQ</acronym>
            を受け取りますので、
            <acronym class="acronym">ACK-SENT</acronym>
            の状態に入り、2 つ目の
            <acronym class="acronym">REQ</acronym>
            と 4 つ目の
            <acronym class="acronym">ACK</acronym> を
            RFC のとおりに送ります。
            <code class="systemitem">A</code>は、
            <acronym class="acronym">REQ</acronym>
            を受けとると
            <acronym class="acronym">REQ-SENT</acronym>
            の状態になり、さらに
            <acronym class="acronym">REQ</acronym>
            を送ります。
            そしてすぐに
            <acronym class="acronym">ACK</acronym> を受け取って
            <acronym class="acronym">OPENED</acronym>
            の状態に入ります。
          </p><p>
            これが、片方の
            <code class="command">ppp</code>
            があきらめてしまうまで続きます。
          </p><p>
            これを回避する最も良い方法は、
            片方を
            <code class="literal">passive</code>
            モードに設定する、
            すなわち反対側がネゴシエーションを開始するまで待つようにする事です。
            これは、
          </p><pre class="programlisting">set openmode passive</pre><p>
            というコマンドでできます。
            このオプションは気を付けて使わないといけません。さらに
          </p><pre class="programlisting">set stopped <em class="replaceable"><code>N</code></em></pre><p>
            というコマンドを追加して、
            <span class="application">ppp</span> がネゴシエーションが開始するまで待つ
            最大の時間を設定してください。もしくは、
          </p><pre class="programlisting">set openmode active <em class="replaceable"><code>N</code></em></pre><p>
            というコマンド (ここで、
            <em class="replaceable"><code>N</code></em>
            はネゴシエーションが始まるまで待つ時間) を使うこともできます。
            詳しくはマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80633168"></a><a id="ppp-lockups"></a><p><strong>10.14.</strong></p></td><td align="left" valign="top"><p>ppp が接続直後に固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            2.2.5 より前のバージョンの FreeBSD では、<span class="application">ppp</span>
            が Predictor1 圧縮のネゴシエーションを誤って解釈して、
            接続直後にリンクを無効にしている可能性があります。
            これは両サイドが異なる
            <acronym class="acronym">Compression Control Protocols (CCP)</acronym>
            を使ってネゴジェーションを行った場合にのみ発生します。
            この問題は現在は解決していますが、あなたの走らせている
            <span class="application">ppp</span>
            のバージョンが古い場合でも、次の命令で解決することができます。</p><pre class="programlisting">disable pred1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80649168"></a><a id="ppp-shell-test-lockup"></a><p><strong>10.15.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> の内部でシェルを起動しようとすると固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">shell</code> あるいは
            <code class="command">!</code>
            コマンドを使用すると、
            <span class="application">ppp</span>
            はシェルを起動し (何か引数を渡した場合は、
            <span class="application">ppp</span>
            は引数も実行します)、
            コマンドが終了するまで処理を中断します。
            コマンドを実行中に <span class="application">ppp</span>
            のリンクを使おうとすると、
            リンクが固まっているように見えますが、
            これは <span class="application">ppp</span> がコマンドの終了を待っているからです。
          </p><p>
            このような場合は、代わりに
            <code class="command">!bg</code>
            コマンドを使用してください。
            与えられたコマンドがバックグラウンドで実行されるので、
            <code class="command">ppp</code>
            はリンクに関するサービスを継続することができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80659280"></a><a id="ppp-nullmodem"></a><p><strong>10.16.</strong></p></td><td align="left" valign="top"><p>ヌルモデムケーブルを使用しているとき、
            <code class="command">ppp</code> が終了しない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ヌルモデムケーブルを使用して直接接続している場合、
            <span class="application">ppp</span>
            は自動的には接続の終了を知ることができません。
            これはヌルモデムシリアルケーブルの配線に起因しています。
            この種の接続形態を用いる場合は、
            以下の命令を用いて <acronym class="acronym">LQR</acronym>
            を常に有効にする必要があります。
          </p><pre class="programlisting">enable lqr</pre><p>
            こうすると、接続先がネゴシエーションを行う場合、デフォルトで
            <acronym class="acronym">LQR</acronym> の使用を受け入れるようになります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80663760"></a><a id="ppp-auto-noreasondial"></a><p><strong>10.17.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> を
            <code class="option">-auto</code> モードで動かすと、
            勝手にダイアルすることがある</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">ppp</span>
            が思いもしないときにダイアルを始める場合、その原因を突き止め、
            防止のためにダイヤルフィルタ (dfilters) をかけてやる
            必要があります。
          </p><p>
            原因を突き止めるためには、以下の命令を使用してください。
          </p><pre class="programlisting">set log +tcp/ip</pre><p>
            これで接続を通過するすべてのトラフィックをログに残すことができるようになりました。
            次に突然回線がつながったときのログのタイムスタンプをたどれば、
            原因を突き止めることができるはずです。
          </p><p>
            原因がわかったら、次に、このような状況ではダイヤルが起こらないようにしましょう。
            通常、この手の問題は、<acronym class="acronym">DNS</acronym>
            で名前の解決をしようとしたために起こります。
            <acronym class="acronym">DNS</acronym> による名前の解決によって、
            接続が行われるのを防止するには、
            次のような手段を用います (これは <span class="application">ppp</span>
            の既に確立した接続に関してパケットのフィルタリングをするものでは<span class="emphasis"><em>ありません</em></span>)。
          </p><pre class="programlisting">set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</pre><p>
            これはデマンドダイヤル機能に問題を生じさせるため、
            常に適切であるとはかぎりません。
            ほとんどのプログラムは他のネットワーク関連の処理を行なう前に
            <acronym class="acronym">DNS</acronym>
            への問い合わせが必要になります。
          </p><p>
            <acronym class="acronym">DNS</acronym> の場合は、
            何が実際にホスト名を検索しようとしているのかを突き止めるべきでしょう。
            大抵の場合は、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendmail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sendmail</span>(8)</span></a>
            が犯人です。
            設定ファイルで sendmail が
            <acronym class="acronym">DNS</acronym> に問い合わせないようになっているか確認すべきです。
            自分用の設定ファイルを作成するための詳しい方法は、
            <a class="link" href="#ispmail" title="7.22.">メールの設定</a> の項をご覧ください。
            または、
            <code class="filename">.mc</code>
            ファイルに次のような行を追加してもよいでしょう。
          </p><pre class="programlisting">define(`confDELIVERY_MODE', `d')dnl</pre><p>
            この行を追加すると、sendmail
            はメールキューを処理する (通常
            sendmail は 30 分ごとにキューを処理するよう、
            <span class="quote">「<span class="quote"><code class="option">-bd -q30m</code></span>」</span>
            というオプションを付けて起動されます) までか、
            または (多分 <code class="filename">ppp.linkup</code> というファイルの中で)
            <span class="quote">「<span class="quote"><code class="command">sendmail -q</code></span>」</span>
            というコマンドが実行されるまで、
            すべてのメールをキューに溜めるようになります。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                <span class="quote">「<span class="quote"><code class="command">sendmail -q</code></span>」</span>
                はその時点のメールキューの内容を処理して終了します。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80677968"></a><a id="ccp-errors"></a><p><strong>10.18.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">CCP</acronym>
            エラーとはどういう意味ですか</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ログファイル中の以下のエラーは、
          </p><pre class="programlisting">CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</pre><p>
            のネゴシエーションにおいて <code class="command">ppp</code> は
            Predictor1 圧縮を用いるべく主張したのに対して、
            接続先は圧縮を使用しないことを主張した場合に起こります。
            このメッセージには何の害もありませんが、
            出るのが嫌なら、以下の命令を用いてこちら側でも
            Predictor1 圧縮を無効にすることで対応できます。
          </p><pre class="programlisting">disable pred1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80681808"></a><a id="ppp-lockup-ioerrors"></a><p><strong>10.19.</strong></p></td><td align="left" valign="top"><p>ファイル転送の途中で、<code class="command">ppp</code> が
            IO エラーを出して固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.2.2 以前のバージョンの <code class="filename">tun</code>
            ドライバには、<code class="filename">tun</code>
            インタフェースの <acronym class="acronym">MTU</acronym>
            のサイズより大きなパケットを受け取ることができないというバグがありました。
            <acronym class="acronym">MTU</acronym>
            のサイズより大きなパケットを受け付けると IO エラーが起こり、
            <code class="command">syslogd</code> 経由で記録されるのです。
          </p><p>
            <code class="command">ppp</code> の仕様では、
            <acronym class="acronym">LCP</acronym>
            のネゴシエーションを行う場合を含む<span class="emphasis"><em>どのような場合でも</em></span>最低
            1500 オクテットの
            Maximum Receive Unit (<acronym class="acronym">MRU</acronym>)
            を受け入れる必要があります。
            ですから、<acronym class="acronym">MTU</acronym> を
            1500 以下に設定した場合でも、ISP はそれに関係なく
            1500 の大きさのパケットを送ってくるでしょう。
            そしてこのイケてない機能にぶちあたって、
            リンクが固まるのを目にすることになるのです。
          </p><p>
            FreeBSD 2.2.2 以前のバージョンでは、<acronym class="acronym">MTU</acronym>
            を決して 1500 より小さくしないことで、
            この問題を回避することができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80693712"></a><a id="ppp-connectionspeed"></a><p><strong>10.20.</strong></p></td><td align="left" valign="top"><p>どうして <code class="command">ppp</code>
            は接続速度をログに残さないんでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            モデムとの「やり取り」すべての行をログに残すには、
            以下のようにして接続速度のログの有効化を行ってください。
          </p><pre class="programlisting">set log +connect</pre><p>これは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            に最後にくることが要求されている
            <span class="quote">「<span class="quote"><code class="literal">expect</code></span>」</span>
            という文字列がくるまでのすべてのものをログに記録させます。
          </p><p>
            接続速度はログにとりたいけれど、<acronym class="acronym">PAP</acronym>
            や <acronym class="acronym">CHAP</acronym>
            を使っている (その結果、ダイヤルスクリプト中の
            <code class="literal">CONNECT</code>
            以降に全く「やりとり」を行わない -
            <span class="quote">「<span class="quote"><code class="literal">set login</code></span>」</span>
            スクリプトには何も書かない) のであれば、
            <span class="application">ppp</span> に
            <span class="quote">「<span class="quote"><code class="literal">expect</code></span>」</span>
            を含んだ <code class="literal">CONNECT</code>
            行すべてがくるまで待たせるようにしないといけません、
            以下のようになります。
          </p><pre class="programlisting">set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</pre><p>
            ここで、<code class="literal">CONNECT</code> を受信してから、
            何も送らず、復帰改行 (linefeed) を待っています、
            <span class="application">ppp</span> に <code class="literal">CONNECT</code>
            の応答すべてを読み込ませているわけです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80703696"></a><a id="ppp-ignores-backslash"></a><p><strong>10.21.</strong></p></td><td align="left" valign="top"><p>私の <code class="literal">chat</code> スクリプトでは
            <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>
            という文字を <code class="command">PPP</code> が解釈してくれません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">PPP</code> は設定ファイルを読み込むときに、
            <code class="literal">set phone "123 456 789"</code>
            のような文字列を正しく解釈し、
            番号が実際に<span class="emphasis"><em>1 つの</em></span>引数であると理解します。
            <span class="quote">「<span class="quote">"</span>」</span>
            という文字を指定するには、バックスラッシュ (backslash;
            <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) でエスケープしなければなりません。
          </p><p>
            <code class="literal">chat</code> の各引数が解釈されるときには、
            <span class="quote">「<span class="quote"><code class="literal">\P</code></span>」</span>
            や
            <span class="quote">「<span class="quote"><code class="literal">\T</code></span>」</span>
            のような特別なエスケープシーケンス (マニュアルページ参照のこと) を見付けるために、
            もう 1 回、字句解析を行います。
            このように字句解析は 2 回繰り返されますので、
            正しい回数だけエスケープ処理を行わないといけません。
          </p><p>
            モデムにたとえば <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>
            のような文字を送りたい場合には、
            次のようにする必要があります。</p><pre class="programlisting">set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</pre><p>
            実際にモデムに送られる文字列は次のようになります。
          </p><pre class="programlisting">ATZ
OK
AT\X
OK</pre><p>
            他の例ですと
          </p><pre class="programlisting">set phone 1234567
              set dial "\"\" ATZ OK ATDT\\T"</pre><p>
            は次のようになります。
          </p><pre class="programlisting">ATZ
OK
ATDT1234567</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80723280"></a><a id="ppp-segfault-nocore"></a><p><strong>10.22.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が
            <code class="computeroutput">segmentation fault</code> になるのですが、
            <code class="filename">ppp.core</code> ファイルがありません</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">ppp</span> (や他のプログラム) は決して
            core を吐いてはいけません。
            <span class="application">ppp</span>
            は実効 uid が 0 で動いていますので、
            オペレーティングシステムは <span class="application">ppp</span>
            を終了させる前にディスクに core イメージを書き込みません。
            しかし <span class="application">ppp</span>
            は実際にはセグメンテーション違反や、
            他の core を吐く原因となるようなシグナルによって終了しており、
            <span class="emphasis"><em>さらに</em></span>最新のバージョン
            (このセクションの始めを見てください)
            を使用しているならば、次のようにしてください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tar xfz ppp-*.src.tar.gz</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>cd ppp*/ppp</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>echo STRIP= &gt;&gt;Makefile</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>echo CFLAGS+=-g &gt;&gt;Makefile</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>make clean all</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make install</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 555 /usr/sbin/ppp</code></strong></pre><p>
            これでデバッグ可能なバージョンの
            <span class="application">ppp</span> がインストールされます。
            <code class="systemitem">root</code> で
            <span class="application">ppp</span> を実行し、
            すべての特権が無効になっているようにする必要があるでしょう。
            <span class="application">ppp</span> を実行する時には、
            カレントディレクトリが <code class="command">make</code>
            したディレクトリであるようにしてください。
          </p><p>
            これで、<span class="application">ppp</span>
            がセグメンテーション例外を受け取ったときには
            <code class="filename">ppp.core</code>
            という名前の
            core ファイルを吐くようになります。core が
            吐かれたら次のようにしてください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>gdb /usr/sbin/ppp ppp.core</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>bt</code></strong>
.....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>f 0</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>i args</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>l</code></strong>
.....</pre><p>
            質問する際には、これらすべての情報を提供して、
            問題点の分析ができるようにしてください。
          </p><p>
            <code class="command">gdb</code>
            の使い方に慣れている場合には、実際に dump
            の原因となった理由やそのアドレス、
            関連した変数の値なども調べる事ができるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80744400"></a><a id="ppp-autodialprocess-noconnect"></a><p><strong>10.23.</strong></p></td><td align="left" valign="top"><p>auto モードでダイアルをするようなプロセスが接続されない。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは <span class="application">ppp</span>
            がローカル側の <acronym class="acronym">IP</acronym> アドレスを、
            動的に通信相手と交渉するように設定されている時に発生する良く知られた障害でした。
            最新のバージョンでは、
            この問題は修正されています。
            <code class="literal">iface</code>
            をマニュアルページから検索してみてください。
          </p><p>
            これは、最初のプログラムが
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=connect&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a>
            を呼び出した時、<code class="filename">tun</code>
            インターフェイスの <acronym class="acronym">IP</acronym> アドレスが、
            ソケットの終端に割り当てられてしまうという問題です。
            カーネルは、
            外へ出ていく最初のパケットを作り、それを <code class="filename">tun</code>
            デバイスへ書き込みます。
            そして <span class="application">ppp</span> は、
            そのパケットを読み込んで接続を確立します。
            <span class="application">ppp</span>
            は動的に <acronym class="acronym">IP</acronym>
            アドレスを割り当てるため、
            もしインターフェイスのアドレスが変化してしまうと、
            最初に割り当てられたソケット終端の <acronym class="acronym">IP</acronym>
            アドレスは無効になってしまいます。
            そのため、それ以降相手に送られるすべてのパケットは通常、
            相手に届くことはないでしょう。もし仮に届いたとしても、
            既にこちらの <acronym class="acronym">IP</acronym> アドレスは変更されているので、
            どんな反応も最初のマシンには戻ってきません。
          </p><p>
            この問題に対処する理論的な方法がいくつかあります。もし可能なら、
            相手が再度、同じ <acronym class="acronym">IP</acronym>
            アドレスを割り当ててくれることが一番です <code class="literal">:-)</code>
            <span class="application">ppp</span>
            の現在のバージョンはこれを行ないますが、
            他のほとんどの実装はそういった動作をしません。
          </p><p>
            我々の側から対処できる最も簡単な方法は、<code class="filename">tun</code>
            インターフェイスの
            <acronym class="acronym">IP</acronym> アドレスを固定する事です。またそのかわりに、
            外に出ていくパケットを変更して、
            発信元 <acronym class="acronym">IP</acronym>
            アドレスをインターフェイスの <acronym class="acronym">IP</acronym>
            アドレスから、交渉によって得られた <acronym class="acronym">IP</acronym> アドレスに、
            適宜書きかえる事によっても対処できます。
            これは、基本的に
            <span class="application">ppp</span> の最新バージョンにある <code class="literal">iface-alias</code>
            オプションが行なっていることと同じです
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a>
            および、<span class="application">ppp</span> の <code class="option">-nat</code>
            スイッチにも関係します)。それは、以前の <acronym class="acronym">IP</acronym>
            アドレスをすべて管理し、
            それらを最後の交渉によって得られた <acronym class="acronym">IP</acronym>
            アドレスに対して NAT 機能を有効化します。</p><p>
            もう 1 つの (おそらく最も信頼できる) 方法は、bind された
            すべてのソケットの <acronym class="acronym">IP</acronym> アドレスを、
            異なるものに変更できるシステムコールを実装することです。
            <span class="application">ppp</span>は、
            新しい <acronym class="acronym">IP</acronym> アドレスが割り当てられた時、
            このシステムコールを用いて実行されているプログラムにある、
            すべてのソケットを書きかえてやるわけです。
            同じシステムコールが、<acronym class="acronym">DHCP</acronym> クライアントが利用するソケットを
            強制的に再 bind するのにも使うことができるでしょう。
          </p><p>
            3 つ目の方法は、<acronym class="acronym">IP</acronym>
            アドレスを指定しないでインターフェイスを利用できるようにすることです。
            外に出ていくパケットは、最初の <code class="literal">SIOCAIFADDR</code>
            ioctl の完了まで、
            255.255.255.255 という <acronym class="acronym">IP</acronym> アドレスが与えられます。
            これによって、ソケットは常に bind することができます。
            発信元 <acronym class="acronym">IP</acronym> アドレスを変更するのは
            <span class="application">ppp</span> の仕事です。ただし、
            それは発信元 <acronym class="acronym">IP</acronym> アドレスが
            255.255.255.255 になっていて、<acronym class="acronym">IP</acronym> アドレスと
            <acronym class="acronym">IP</acronym> チェックサムを変更する必要がある場合だけです。
            これは、カーネルが不適切に設定されたインターフェイスへは
            異常なパケットを送出しようとすることを利用して、なにか他の
            仕組みが遡及的に修正を行ってくれることを前提にしている、
            割り切った方法ではあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80801616"></a><a id="ppp-nat-games"></a><p><strong>10.24.</strong></p></td><td align="left" valign="top"><p>何故ほとんどのゲームが
            <code class="option">-nat</code> スイッチ付きだと動かないんですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            

            libalias を使っている時にゲームなどの類のものが動作しない理由は、
            外側にあるマシンが接続しようとしているか、内側にあるマシンに
            (余計な) UDP パケットを送信しようとしているからです。
            内側のマシンにこれらのパケットを送るべきかについて、
            NAT ソフトウェアは関知しません。
          </p><p>
            うまく動かすためには、
            実行中のものが問題の発生しているソフトウェアだけであるかを確認し、
            ゲートウェイの <code class="filename">tun</code> インタフェースに対して
            <code class="command">tcpdump</code> を実行するか、
            ゲートウェイ上で <code class="command">ppp</code> の
            <acronym class="acronym">TCP</acronym>/<acronym class="acronym">IP</acronym>
            ログ記録を有効化 (<span class="quote">「<span class="quote"><code class="literal">set log
              +tcp/ip</code></span>」</span>) してください。</p><p>
            行儀の悪いソフトウェアを起動する際に、
            ゲートウェイマシンを通過するパケットを監視すべきです。
            外側から何かパケットが戻ってきた時に、
            そのパケットは破棄されるでしょう (それが問題なのです)。
            これらのパケットのポート番号に注意して、
            その行儀の悪いソフトウェアを停止してください。
            これを数回繰り返してポート番号が常に同じであるかを確認してみてください。
            同じであった場合は、
            <code class="filename">/etc/ppp/ppp.conf</code>
            の適切なセクションに次の行を入れると、
            そのソフトウェアは動作するようになるでしょう。
          </p><pre class="programlisting">nat <em class="replaceable"><code>port</code></em> <em class="replaceable"><code>proto</code></em> <em class="replaceable"><code>internalmachine</code></em>:<em class="replaceable"><code>port</code></em> <em class="replaceable"><code>port</code></em></pre><p>
            ここで <em class="replaceable"><code>proto</code></em> は
            <code class="literal">tcp</code> か <code class="literal">udp</code> であり、
            <em class="replaceable"><code>internalmachine</code></em>
            はパケットを送りたいマシン、そして
            <em class="replaceable"><code>port</code></em>
            はパケットの送信先のポート番号です。
          </p><p>
            上記のコマンドを変更せずに、
            他のマシン上でそのソフトウェアを使用できるようにはしたくないかもしれません。
            そして同時に二つの内部のマシン上でそのソフトウェアを実行することは、
            この質問の範囲を超えています。結局、外側の世界からは、
            内部ネットワーク全体がただ一つのマシンとして見えるのです。
          </p><p>
            ポート番号が常に同じとは限らない場合、さらに三つのオプションがあります。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                libalias でサポートするようにし、結果を送り付ける。
                特定の場合の例は <code class="filename">/usr/src/lib/libalias/alias_*.c</code>
                にあります (<code class="filename">alias_ftp.c</code>
                は良いプロトタイプです)。これには通常、外向きの特定のパケットを読み、
                内部の計算機のある特定のポートへの接続を開始するような命令が、
                外部の計算機対して送られていることを見分け、
                後続のパケットがどこに行けばいいのかが分かるように、
                エイリアステーブル中の
                <span class="quote">「<span class="quote"><em class="replaceable"><code>route</code></em></span>」</span>
                の部分を設定する、という作業が含まれます。
              </p><p>
                これは最も難しい方法ですが、最も良い方法でもありますし、ソフトウェアが
                複数の計算機で動くようにできます。
              </p></li><li class="listitem"><p>プロキシ (proxy) を使う。アプリケーションが、たとえば socks5
                をサポートしているか、(cvsup のように) <span class="quote">「<span class="quote">passive</span>」</span>
                オプションを持っているとこの方法が使えます。
                <span class="quote">「<span class="quote">passive</span>」</span>
                とは相手側のほうから接続を求めてくることを避けるためにあるオプションです。
              </p></li><li class="listitem"><p>
                <span class="quote">「<span class="quote"><code class="literal">nat addr</code></span>」</span>
                を使ってなんでもかんでも内部の計算機に向けて流してしまう。
                これはちょっと無理矢理な解決法です。
              </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80827344"></a><a id="useful-port-numbers"></a><p><strong>10.25.</strong></p></td><td align="left" valign="top"><p>有用なポート番号のリストはありませんか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まだ出来ていません。しかし、
            これは (関心を持って頂けるならば) そういったリストにしていく予定です。
            それぞれの例にある
            <em class="replaceable"><code>internal</code></em> は、
            ゲームで遊ぶマシンの <acronym class="acronym">IP</acronym> アドレスに置き換えてください。
          </p><p>
            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Asheron's Call</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:65000 65000</pre><p>手動でゲームのポート番号を 65000 に変更してください。
                    マシンが複数ある場合は、それぞれのマシンに重複しないポート番号 (つまり
                    65001、65002 など) を設定し、その設定ごとに
                    <code class="literal">nat port</code> の行を追加します。</p></dd><dt><span class="term">Half Life</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:27005 27015</pre></dd><dt><span class="term">PCAnywhere 8.0</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:5632 5632
nat port tcp <em class="replaceable"><code>internal</code></em>:5631 5631</pre></dd><dt><span class="term">Quake</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:6112 6112</pre><p>このように設定する代わりに、
                    <a class="link" href="http://www.battle.net/support/proxy/" target="_top">www.battle.net</a>
                    で Quake のプロキシ (proxy) がサポートされているか調べてもいいでしょう。
                  </p></dd><dt><span class="term">Quake2</span></dt><dd><pre class="programlisting">alias port udp <em class="replaceable"><code>internal</code></em>:27901 27910</pre></dd><dt><span class="term">Red Alert</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:8675 8675
nat port udp <em class="replaceable"><code>internal</code></em>:5009 5009</pre></dd></dl></div><p>
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80861648"></a><a id="fcs-errors"></a><p><strong>10.26.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">FCS</acronym> エラーって何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <acronym class="acronym">FCS</acronym> とは
            <code class="literal">F</code>rame <code class="literal">C</code>heck <code class="literal">S</code>equence
	    (フレームチェックシーケンス) の略です。
            個々の <span class="application">ppp</span> パケットには、
            送受信するデータが正しいかを調べるためのチェックサムが含まれています。
            受信したパケットの <acronym class="acronym">FCS</acronym> が正しくない場合は、そのパケットは廃棄され、
            <acronym class="acronym">HDLC</acronym> <acronym class="acronym">FCS</acronym> カウントが増やされます。
            <acronym class="acronym">HDLC</acronym> エラーの数は、
            <code class="command">show hdlc</code>
            コマンドを使って表示できます。
          </p><p>
            リンクの品質が悪かったり、
            シリアルドライバがパケットを取りこぼしていたりすると、
            <acronym class="acronym">FCS</acronym> エラーがたびたび発生します。
            <acronym class="acronym">FCS</acronym> エラーは、
            圧縮プロトコルの速度低下の原因にはなりますが、
            特に心配する必要はありません。
            外付けモデムを使っている場合は、
            ケーブルがちゃんとシールドされているかを確認してください。
            そうでない場合、
            <acronym class="acronym">FCS</acronym> エラーの原因となる場合があります。
          </p><p>
            接続直後からリンクがフリーズし、大量の
            <acronym class="acronym">FCS</acronym> エラーが発生する場合は、
            リンクが 8 ビットクリーンでない可能性があります。
            ソフトウェアフロー制御 (XON/XOFF)
            が使われていないことを確認してください。
            どうしてもソフトウェアフロー制御を使わなければならない場合は、
            <code class="literal">set accmap 0x000a0000</code> コマンドを使用して、
            <span class="application">ppp</span> に
            <code class="literal">^Q</code> と
            <code class="literal">^S</code> をエスケープさせてください。
          </p><p>
            リモートホストが <acronym class="acronym">PPP</acronym>
            プロトコルを使用してない場合も、大量の
            <acronym class="acronym">FCS</acronym> エラーが発生します。
            この場合はログをとりながら<span class="emphasis"><em>非同期</em></span>で接続し、
            ログインプロンプトやシェルプロンプトが送られて来ていないか確認してください。
          </p><p>
            ログファイルにリンクを終了した原因となるような記録がない場合は、
            リモートホスト (プロバイダ?) の管理者に、
            セッションを終了された理由を尋ねてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="PPPoEwithNAT"></a><a id="macos-win98-pppoe-freeze"></a><p><strong>10.27.</strong></p></td><td align="left" valign="top"><p>ゲートウェイで PPPoE を実行すると MacOS や
            Windows 98 との接続がフリーズしてしまうのですが、
            これはなぜなのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Michael Wozniak <code class="email">&lt;<a xmlns="" class="email" href="mailto:mwozniak@netcom.ca">mwozniak@netcom.ca</a>&gt;</code>
            氏が、この現象に関して説明してくれました。
            また、Dan Flemming <code class="email">&lt;<a xmlns="" class="email" href="mailto:danflemming@mac.com">danflemming@mac.com</a>&gt;</code>
            氏は MacOS での解決策を提供してくれました。
            情報の提供に感謝します。
          </p><p>これは、いわゆる「ブラックホールルータ (Black Hole router)」に原因があります。
            Windows 98 と MacOS (および、おそらく他の Microsoft 社製 OS) の TCP パケット送出は、
            PPPoE のフレーム (Ethernet の MTU は標準で
            1500) に入らないような大きなセグメントサイズを要求します。
            <span class="emphasis"><em>そしてさらに</em></span>分割禁止 (<span class="quote">「<span class="quote">don't fragment</span>」</span>)
	    フラグビットを (TCP パケットにデフォルトで) セットするのですが、
            Telco のルータは、分割が必須 ("must fragment") であることを示す
            ICMP メッセージを、接続しようとするウェブサイトに対して送出しません
            (つまり、ルータは正しく ICMP パケットを送出しているのですが、
            ウェブサイトのファイアウォールがそれを落としているのです)。
            そのためウェブサーバが PPPoE 接続に対して大きすぎるフレームを送出すると
            Telco のルータはそのフレームを捨ててしまい、
            見ようとしたページが表示されないという症状が現われます
            (MSS より小さいページや画像は表示されます)。
            ほとんどの Telco PPPoE 設定は、標準でこのように設定されているようです。
            (ああ、彼らがルーティングプログラムの作り方を理解してさえいれば…)。
          </p><p>
            一つの解決法は、Windows 95/98 マシンで regedit を使い、
            次のレジストリエントリを追加することです。
          </p><pre class="programlisting">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</pre><p>
            レジストリエントリは、<span class="quote">「<span class="quote">1450</span>」</span> の値
            (もっと正確に言うと、TCP パケットを PPPoE フレームに完全に適合させるには
            <span class="quote">「<span class="quote">1464</span>」</span> であるべきでですが、
            <span class="quote">「<span class="quote">1450</span>」</span> とすると、現われる可能性がある他の IP
            プロトコルに対してエラーマージンを確保することができます)
            にする必要があります。
            このレジストリキーは、Windows2000 で
            <code class="literal">Tcpip\Parameters\Interfaces\ID for adapter\MTU</code>
            に移されたという報告がありました。
          </p><p>
            FreeBSD/NAT/PPPoE ルータと共存させるために Windoze の MTU
            を変更する方法に関する詳細は、
            <a class="link" href="http://search.support.microsoft.com/kb" target="_top">Microsoft Knowledge
            Base</a> にある、
            番号 <span class="quote">「<span class="quote">Q158474 - Windows TCPIP Registry Entries</span>」</span>、
            および番号
            <span class="quote">「<span class="quote">Q120642 - TCPIP &amp; NBT Configuration Parameters for Windows NT</span>」</span>
            を参照してください。
          </p><p>残念なことに、MacOS には
            TCP/IP 設定を変更する方法がありません。
            しかし、<a class="link" href="http://www.softworks.com/" target="_top">Sustainable Softworks 社</a>
            が販売している OTAdvancedTuner (OT は OpenTransport という
            MacOS の TCP/IP スタックの名前のこと) のような商用ソフトウェアが存在します。
            このソフトウェアは、ユーザから TCP/IP 設定の変更を行なうことを可能にします。
            MacOS NAT ユーザはドロップダウンメニューから
            <code class="literal">ip_interface_MTU</code> を選択し、
            ボックスにある <code class="literal">1500</code> の代わりに
            <code class="literal">1450</code> を入力し、
            <code class="literal">Save as Auto Configure</code> の隣のボックスをクリックして
            <code class="literal">Make Active</code> をクリックする必要があります。
          </p><p><span class="application">ppp</span> の最新版
            (2.3 かそれ以降) には、自動的に MSS を適切な値に調節する
            <code class="command">enable tcpmssfixup</code> コマンドがあります。
            この機能は標準で有効になっています。
            もし旧バージョンの <span class="application">ppp</span>
            を使わなければならない状況にあるなら、
            <span class="application">tcpmssd</span> の port
            をご覧になると良いでしょう。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80904016"></a><a id="desperation"></a><p><strong>10.28.</strong></p></td><td align="left" valign="top"><p>どれにも当てはまらない! どうしたらいいの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これまでのすべての質問に当てはまらない場合、設定ファイル、
            <span class="application">ppp</span>
            の実行方法、ログファイルの該当部分と
            <code class="command">netstat -rn</code>
            コマンドの出力 (接続前と接続後) を含む、
            あなたの持っているすべての情報を
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions" target="_top">FreeBSD general questions メーリングリスト</a>
            や
            <a class="link" href="news:comp.unix.bsd.freebsd.misc" target="_top">comp.unix.bsd.freebsd.misc</a>
            ニュースグループへ送ってください。誰かがあなたを正しい方向へ導いてくれるでしょう。
          </p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="serial"></a>第11章 シリアル接続</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        一宮 亮 <code class="email">&lt;<a xmlns="" class="email" href="mailto:ryo@azusa.shinshu-u.ac.jp">ryo@azusa.shinshu-u.ac.jp</a>&gt;</code>、
        1997 年 11 月 16 日</em></span>
    </p><p>
      このセクションでは、FreeBSD でシリアル接続をする時の一般的な質問に答えます。
      <acronym class="acronym">PPP</acronym> および
      <acronym class="acronym">SLIP</acronym> については、
      <a class="xref" href="#networking" title="第9章 ネットワーキング">9章<em>ネットワーキング</em></a>のセクションを参照してください。
    </p><div class="qandaset"><a id="idp80911824"></a><dl><dt>11.1. <a href="#idp80912080">どうやったら FreeBSD がシリアルポートを認識したことを知る事ができますか?</a></dt><dt>11.2. <a href="#idp80925648">
            どうやったら FreeBSD がモデムカードを認識したことを知ることができますか?</a></dt><dt>11.3. <a href="#idp80927696">FreeBSD 2.0.5 にアップグレードしたら
	    tty0X
            が見つからなくなってしまったのですが</a></dt><dt>11.4. <a href="#idp80930640">どうやったら FreeBSD でシリアルポートにアクセスできますか?</a></dt><dt>11.5. <a href="#idp80938960">マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか?</a></dt><dt>11.6. <a href="#idp80945104">FreeBSD で複数のマルチポートシリアルカード間で
            irq を共有することはできますか?</a></dt><dt>11.7. <a href="#idp80955472">
            ポートにデフォルトのパラメータを設定する事は出来ますか?</a></dt><dt>11.8. <a href="#idp80966480">どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか?</a></dt><dt>11.9. <a href="#idp80997712">ダムターミナルを FreeBSD マシンに接続するにはどうしたらよいのでしょうか?</a></dt><dt>11.10. <a href="#idp81005008">どうして tip や
            cu が動かないのですか?</a></dt><dt>11.11. <a href="#idp81027024">私の Hayes モデムはサポートされていないのですが、
            どうしたらいいのでしょうか。</a></dt><dt>11.12. <a href="#idp81052496">これらの AT コマンドを入力するには?</a></dt><dt>11.13. <a href="#idp81069648">pn 機能の &lt;@&gt; 記号が使えません!</a></dt><dt>11.14. <a href="#idp81074512">コマンドラインから電話番号を指定するには?</a></dt><dt>11.15. <a href="#idp81087568">毎回 bps レートを入力しなければいけませんか?</a></dt><dt>11.16. <a href="#idp81092176">ターミナルサーバを経由して複数のホストへアクセスしたいのですが。</a></dt><dt>11.17. <a href="#idp81104336">
            tip
            を使ってそれぞれのサイトの複数の回線に接続できますか?</a></dt><dt>11.18. <a href="#idp81117264">CTRL+P を
            1 回送るために 2 度押す必要があるのはなぜ?</a></dt><dt>11.19. <a href="#idp81132880">打ち込んだ文字が突然すべて大文字になりました??</a></dt><dt>11.20. <a href="#idp81146832">tip でファイルを転送するには?</a></dt><dt>11.21. <a href="#idp81153744">tip から zmodem を実行するには?</a></dt><dt>11.22. <a href="#idp81181008">設定が正しいのにもかかわらず、FreeBSD がシリアルポートを見付けられません。</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp80912080"></a><a id="found-serial"></a><p><strong>11.1.</strong></p></td><td align="left" valign="top"><p>どうやったら FreeBSD がシリアルポートを認識したことを知る事ができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD のカーネルが起動する時、カーネルはその設定にしたがって、
            システムのシリアルポートを検出します。起動時に表示されるメッセージをよく観察するか、
            起動後に次のコマンドを実行する事によって確認できます。
          </p><pre class="screen">dmesg | grep sio</pre><p>ここに上に挙げたコマンドの出力例を示します。</p><pre class="screen">sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A</pre><p>
            これは、二つのシリアルポートを示しています。1 番目は、
            irq が 4 で <code class="literal">0x3f8</code> のポートアドレスを使用しています。
            そして、16550A-type UART チップが存在します。
            2 番目は、同じチップを使っていますが、
            irq は 3 で、<code class="literal">0x2f8</code>
            のポートアドレスを使用しています。内蔵のモデムカードは、
            通常のシリアルポートと同じように扱われますが、
            常時シリアルポートにモデムが接続されているという点で異なります。
          </p><p>
            GENERIC カーネルは、上の例と同じ irq
            とポートアドレスの設定の二つのシリアルポートをサポートしています。
            これらの設定があなたのシステムに合わない場合、
            またはモデムカードを追加した場合やカーネルの設定以上にシリアルポートを持っている場合は、
            カーネルを再構築してください。
            詳しくは、
            <a class="link" href="#make-kernel" title="6.1.">カーネルの構築</a>の項を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80925648"></a><a id="found-modem"></a><p><strong>11.2.</strong></p></td><td align="left" valign="top"><p>
            どうやったら FreeBSD がモデムカードを認識したことを知ることができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            前の質問を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80927696"></a><a id="missing-tty0X"></a><p><strong>11.3.</strong></p></td><td align="left" valign="top"><p>FreeBSD 2.0.5 にアップグレードしたら
	    <code class="filename">tty0X</code>
            が見つからなくなってしまったのですが</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>心配ありません。
	    <code class="filename">ttydX</code>
	    に統合されました。
            ただ、古い設定ファイルのすべてを更新する必要があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80930640"></a><a id="access-serial-ports"></a><p><strong>11.4.</strong></p></td><td align="left" valign="top"><p>どうやったら FreeBSD でシリアルポートにアクセスできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            3 番目のポート
            <code class="filename">sio2</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a> をご覧ください。DOS
            では、<code class="filename">COM3</code> と呼ばれます。) には、
            ダイヤルアウトデバイスとしては <code class="filename">/dev/cuaa2</code>、
            ダイヤルインデバイスとして <code class="filename">/dev/ttyd2</code> があります。
            それではこの両者にはどのような違いがあるのでしょうか?
          </p><p>
            まず、ダイヤルインの時には
            <code class="filename">ttydX</code>
	    を使います。
            <code class="filename">/dev/ttydX</code>
            をブロッキングモードでオープンすると、プロセスは対応する
            <code class="filename">cuaaX</code>
            デバイスがインアクティブになるのを待ちます。
            次に <acronym class="acronym">CD</acronym> 信号がアクティブになるのを待ちます。
            <code class="filename">cuaaX</code>
            デバイスをオープンすると、シリアルポートが
            <code class="filename">ttydX</code>
            デバイスによってすでに使われていないかどうかを確認します。
            もしこのポートが使用可能であれば、ポートの使用権を
            <code class="filename">ttydX</code>
            から「奪い取る」のです。また、
            <code class="filename">cuaaX</code>
            デバイスは <acronym class="acronym">CD</acronym> 信号を監視しません。
            この仕組みと自動応答モデムによって、
            リモートユーザーをログインさせたり、
            同じモデムでダイヤルアウトしたりすることができ、
            システムのあらゆるトラブルの面倒を見ることができるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80938960"></a><a id="enable-multiport-serial"></a><p><strong>11.5.</strong></p></td><td align="left" valign="top"><p>マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            繰り返しになりますが、
            <a class="link" href="#make-kernel" title="6.1.">カーネルコンフィグレーション</a>のセクションでは、
            あなたのカーネルの設定についての情報が得られるでしょう。
            マルチポートシリアルカードを使用するためには、カーネルの設定ファイルに、
            カードの持つそれぞれのシリアルポートに対応する
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>
            の行を記述する必要があります。しかし、
            irq とベクタアドレスは一つのエントリにのみ記述してください。
            カード上のすべてのポートは一つの irq を共有しなければなりません。
            一貫性を持たせるためにも、
            最後のシリアルポートの所で irq を指定してください。
            また、<code class="literal">COM_MULTIPORT</code> オプションも付けてください。
          </p><p>
            次に示す例は、AST の 4 ポートシリアルカードを irq 7 で設定したものです。
          </p><pre class="programlisting">options "COM_MULTIPORT"
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr</pre><p>
            このフラグはマスタポートがマイナー番号 7
            (<code class="literal">0x700</code>) を持っていて、
            検出時の診断機能を有効にし (<code class="literal">0x080</code>)、
            そしてすべてのポートで irq
            を共有する (<code class="literal">0x001</code>) ということを意味しています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80945104"></a><a id="multiport-serial-share-irq"></a><p><strong>11.6.</strong></p></td><td align="left" valign="top"><p>FreeBSD で複数のマルチポートシリアルカード間で
            irq を共有することはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在のところはできません。それぞれのカード毎に異なった irq
            を使ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80955472"></a><a id="default-serial-params"></a><p><strong>11.7.</strong></p></td><td align="left" valign="top"><p>
            ポートにデフォルトのパラメータを設定する事は出来ますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="filename">ttydX</code>
	    デバイス (または
            <code class="filename">cuaaX</code>
            デバイス) は、
            アプリケーションのためにオープンする標準的なデバイスです。
            プロセスがそのポートをオープンする時、
            プロセスはデフォルトの端末 I/O 設定を取得します。
            これらの設定は次のコマンドで確認することができます。
          </p><pre class="programlisting">stty -a -f /dev/ttyd1</pre><p>
            このデバイスに対する設定を変更した場合、
            その設定はデバイスをクローズするまで有効です。
            デバイスを再オープンした場合、それらの設定はデフォルトに戻ってしまいます。
            デフォルトの設定に変更を加えるために、
            「初期設定」デバイスをオープンし、
            設定を修正することができます。
            たとえば、<acronym class="acronym">CLOCAL</acronym> モード、8 ビット、
            <acronym class="acronym">XON/XOFF</acronym>
            フロー制御という設定を
            <code class="filename">ttyd5</code>
            のデフォルトにしたい場合、次のように行なってください。
          </p><pre class="programlisting">stty -f /dev/ttyid5 clocal cs8 ixon ixoff</pre><p>
            この設定を行なうためのコマンドを記述するのに適切なファイルは、
            <code class="filename">/etc/rc.serial</code> です。
            これでアプリケーションが
            <code class="filename">ttyd5</code> をオープンした時に、
            これらの設定をデフォルトで取得します。
            しかし、こういったリンクによる設定は変更可能です。
          </p><p>
            「設定固定」デバイスを調整してやることによって、
            アプリケーションによる設定の変更を禁止することができます。
            たとえば、<code class="filename">ttyd5</code>
            の通信速度を 57600bps
            に固定するには、次のように行ってください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>stty -f /dev/ttyld5 57600</code></strong></pre><p>
            これにより、アプリケーションは <code class="filename">ttyd5</code>
            をオープンし、ポートの通信速度を変更しようとしますが、
            通信速度は 57600bps のままになります。
          </p><p>
            当然のことながら、初期設定デバイスおよび、設定固定デバイスは
            <code class="systemitem">root</code> のみが書き込みできるようになっていなければなりません。
            しかし、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">MAKEDEV</span>(8)</span></a>
            スクリプトはデバイスエントリを作成する時に、
            このような設定は<span class="emphasis"><em>行いません</em></span>。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80966480"></a><a id="enable-dialup"></a><p><strong>11.8.</strong></p></td><td align="left" valign="top"><p>どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            つまり、インターネットサービスプロバイダーになりたいのですね。
            それにはまず、1 台ないし複数の自動応答モデムが必要です。
            モデムには、キャリアーを検出した時には
            <acronym class="acronym">CD</acronym> 信号を出力し、
            そうでない場合には出力しないことが必要とされます。
            また <acronym class="acronym">DTR</acronym> 信号が
            on から off になった時には、
            電話回線を切断し、モデム自身をリセットしなければなりません。
            おそらく、<acronym class="acronym">RTS/CTS</acronym> フロー制御を使うか、
            ローカルフロー制御をまったく使わないかのどちらかでしょう。
            最後に、コンピュータとモデムの間は固定速度でなければなりません。
            ただ、(ダイヤルアップの発呼者に対して親切であるためには、
            ) こちらのモデムと相手側のモデムの間の速度を、
            モデム間で自動調整できるようにすべきでしょう。
          </p><p>
            多くあるヘイズコマンド互換モデムに対して、次のコマンドはこれらの設定を行ない、
            その設定を不揮発性メモリーに保存します。
          </p><pre class="programlisting">AT&amp;C1&amp;D3&amp;K3&amp;Q6S0=1&amp;W</pre><p>
            MS-DOS のターミナルプログラムに頼らずに AT コマンドを送出するには、
            <a class="link" href="#direct-at" title="11.12.">「AT
              コマンドを入力するには」</a>のセクションを参照してください。
          </p><p>
            次に、モデム用のエントリを
            <code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            に作成しましょう。
            このファイルには、
            オペレーティングシステムがログインを待っているすべてのポートが記述されています。
            以下のような行を追加してください。
          </p><pre class="programlisting">ttyd1 "/usr/libexec/getty std.57600" dialup on insecure</pre><p>
            この行は、2 番目のシリアルポート
            (<code class="filename">/dev/ttyd1</code>) には、
            57600bps の通信速度でノンパリティ (<code class="literal">std.57600</code>:
            これは
            <code class="filename">/etc/gettytab</code>
            に記述されています。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gettytab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">gettytab</span>(5)</span></a> 参照)
            のモデムが接続されていることを示しています。
            このポートの端末タイプは <code class="literal">dialup</code> です。
            またこのポートは、<code class="literal">on</code>
            すなわちログイン可能であり、<code class="literal">insecure</code> です。
            これは <code class="systemitem">root</code>
            がこのポートから直接ログインするのは、
            許可されていないということを意味します。
            このようなダイヤルインポートに対しては、
            <code class="filename">ttydX</code>
            のエントリを使用してください。
          </p><p>
            これが一般的な、ターミナルタイプとして <code class="literal">dialup</code>
            を使う方法です。多くのユーザーは、
            <code class="filename">.profile</code> や
            <code class="filename">.login</code> で、
            ログイン時の端末タイプが
            <code class="literal">dialup</code> であった場合には、
            実際の端末タイプをユーザーに問い合わせるように設定しています。
            この例は、ポートが <code class="literal">insecure</code>
            でした。このポートで <code class="systemitem">root</code> になるには、
            一般ユーザーとしてログインし、それから
            <span class="quote">「<span class="quote"><a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?su" target="_top">su</a></span>」</span> を使って
            <code class="systemitem">root</code> になってください。
            もし、<code class="literal">secure</code>
            を指定したならば、
            直接 <code class="systemitem">root</code> がそのポートからログインできます。
          </p><p>
            <code class="filename">/etc/ttys</code>
            に変更を加えた後は、<acronym class="acronym">HUP</acronym> シグナル (SIGHUP) を
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>
            プロセスに送る必要があります。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP 1</code></strong></pre><p>
            この操作は <code class="command">init</code> プロセスに
            <code class="filename">/etc/ttys</code>
            を再読み込みさせます。
            これにより、init プロセスは
            <code class="command">getty</code> プロセスをすべての
            <code class="literal">on</code>
            となっているポートに起動させます。
            次のようにして、ポートがログイン可能かを知ることができます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ps -ax | grep '[t]tyd1'</code></strong></pre><p>
            ログイン可能であれば、次のような出力が得られるはずです。
          </p><pre class="screen">747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80997712"></a><a id="dumb-terminal"></a><p><strong>11.9.</strong></p></td><td align="left" valign="top"><p>ダムターミナルを FreeBSD マシンに接続するにはどうしたらよいのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もし、他のコンピューターを FreeBSD の端末として接続したいのならば、
            お互いのシリアルポート間をつなぐヌルモデムケーブル
            (訳注: リバースケーブルもしくはクロスケーブルとも呼ばれます)
            を用意してください。
            もし、既製の端末を使う場合は、付属するマニュアルを参照してください。
          </p><p>
            そして、<code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            を上と同じように変更してください。
            たとえば、WYSE-50 という端末を 5 番目のポートに接続するならば、
            次のようなエントリを使用してください。
          </p><pre class="programlisting">ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure</pre><p>
            この例は、<code class="filename">/dev/ttyd4</code> ポートにノンパリティ、
            端末タイプが wyse50、通信速度が
            38400bps (<code class="literal">std.38400</code>: この設定は、
            <code class="filename">/etc/gettytab</code>
            に記述されています。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gettytab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">gettytab</span>(5)</span></a> 参照) の端末が存在しており、
            <code class="systemitem">root</code>
            のログインが許可されている (<code class="literal">secure</code>) であることを示しています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81005008"></a><a id="cannot-tip"></a><p><strong>11.10.</strong></p></td><td align="left" valign="top"><p>どうして <code class="command">tip</code> や
            <code class="command">cu</code> が動かないのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            おそらくあなたのシステムでは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cu</span>(1)</span></a> は
            <code class="systemitem">uucp</code> ユーザーか、
            <code class="systemitem">dialer</code> グループによってのみ実行可能なのでしょう。
            <code class="systemitem">dialer</code> グループは、
            モデムやリモートシステムにアクセスするユーザーを管理するために、
            使用することができます。
            それには、<code class="filename">/etc/group</code>
            ファイルの <code class="systemitem">dialer</code>
            グループにあなた自身を追加してください。
          </p><p>
            そうする代わりに、次のようにタイプすることにより、
            あなたのシステムの全ユーザーが
            <code class="command">tip</code> や
            <code class="command">cu</code>
            を実行できるようになります。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 4511 /usr/bin/cu</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 4511 /usr/bin/tip</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81027024"></a><a id="hayes-unsupported"></a><p><strong>11.11.</strong></p></td><td align="left" valign="top"><p>私の Hayes モデムはサポートされていないのですが、
            どうしたらいいのでしょうか。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            実際、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a>
            のオンラインマニュアルは古くなっています。
            すでに、Hayes ダイアラが実装されています。
            <code class="filename">/etc/remote</code>
            ファイル (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=remote&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">remote</span>(5)</span></a> 参照) で、
            <span class="quote">「<span class="quote"><code class="literal">at=hayes</code></span>」</span>
            と指定してください。
          </p><p>
            Hayes ドライバは、最近のモデムの新しい機能である、
            <code class="literal">BUSY</code>、
            <code class="literal">NO DIALTONE</code>、
            <code class="literal">CONNECT 115200</code>
            などのメッセージを認識できるほど賢くはなく、
            単に混乱を起こすだけです。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a>
            を使う場合には (<code class="literal">ATX0&amp;W</code>とするなどして)、
            これらのメッセージを表示させないようにしなくてはいけません。
          </p><p>
            また、<code class="literal">tip</code> のダイヤルのタイムアウトは 60 秒です。
            モデムのタイムアウト設定はそれより短くすべきであり、
            そうしないと <code class="literal">tip</code>
            は通信に問題があると判断するでしょう。
            <code class="literal">ATS7=45&amp;W</code> を実行してください。
          </p><p>
            実際、デフォルトの
            <code class="literal">tip</code> は Hayes
            の完全なサポートをしているわけではありません。
            解決方法は <code class="filename">/usr/src/usr.bin/tip/tip</code>
            の下の <code class="filename">tipconf.h</code> を変更することです。
            もちろん、これにはソース配布ファイルが必要です。
          </p><p>
            <span class="quote">「<span class="quote"><code class="literal">#define HAYES 0</code></span>」</span>
            と記述されている行を
            <span class="quote">「<span class="quote"><code class="literal">#define HAYES1</code></span>」</span> と変更し、そして
            <span class="quote">「<span class="quote"><code class="command">make</code></span>」</span> と
            <span class="quote">「<span class="quote"><code class="command">make install</code></span>」</span>
            を実行します。これでうまく動作するでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81052496"></a><a id="direct-at"></a><p><strong>11.12.</strong></p></td><td align="left" valign="top"><p>これらの AT コマンドを入力するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">/etc/remote</code>
            ファイル (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=remote&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">remote</span>(5)</span></a> 参照) の中で
            <span class="quote">「<span class="quote">direct</span>」</span> エントリを作ります。
            たとえばモデムが 1 番目のシリアルポートである
            <code class="filename">/dev/cuaa0</code>に接続されている場合、
            次のようにします。</p><pre class="programlisting">cuaa0:dv=/dev/cuaa0:br#19200:pa=none</pre><p>
            モデムがサポートする最大の bps レートを
            <code class="literal">br</code> フィールドに使います。
            そして <code class="command">tip cuaa0</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a> 参照)
            を実行すると、モデムが利用できるようになります。
          </p><p>
            <code class="filename">/dev/cuaa0</code>がシステムに存在しない場合は、次のようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV cuaa0</code></strong></pre><p>
            または <code class="systemitem">root</code>
            になって以下のように cu を使います。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -lline -sspeed</code></strong></pre><p><em class="replaceable"><code>line</code></em>
            にはシリアルポート (たとえば
            <code class="filename">/dev/cuaa0</code>)を指定します。
            そして <em class="replaceable"><code>speed</code></em>
            には接続する速度 (たとえば
            <code class="literal">57600</code>) を指定します。
            その後 AT コマンドを実行したら、
            <code class="literal">~.</code>
            と入力すれば終了します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81069648"></a><a id="gt-failure"></a><p><strong>11.13.</strong></p></td><td align="left" valign="top"><p>pn 機能の <code class="literal">&lt;@&gt;</code> 記号が使えません!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>電話番号 (pn) 機能の中での
            <code class="literal">&lt;@&gt;</code> 記号は、
            <code class="command">tip</code> に
            <code class="filename">/etc/phones</code>
            にある電話番号を参照するように伝えます。しかし
            <code class="literal">&lt;@&gt;</code> の文字は
            <code class="filename">/etc/remote</code>
            のような設定ファイルの中では特殊文字となります。
            そこで、バックスラッシュを使ってエスケープを行います。
          </p><pre class="programlisting">pn=\@</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81074512"></a><a id="dial-command-line"></a><p><strong>11.14.</strong></p></td><td align="left" valign="top"><p>コマンドラインから電話番号を指定するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="quote">「<span class="quote"><code class="literal">generic</code></span>」</span>
            エントリと呼ばれるものを
            <code class="filename">/etc/remote</code> ファイル
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=remote&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">remote</span>(5)</span></a> 参照) に追加します。
            たとえば、次のようにします。
          </p><pre class="programlisting">tip115200|Dial any phone number at 115200 bps:\
:dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
:dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</pre><p>
            そして
            <span class="quote">「<span class="quote"><code class="command">tip -115200 5551234</code></span>」</span>
            のように利用できます。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a> より <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cu</span>(1)</span></a> を使いたい場合、
            <code class="command">cu</code> の
            <code class="literal">generic</code> エントリを使います。
          </p><pre class="programlisting">cu115200|Use cu to dial any number at 115200bps:\
:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</pre><p>
            そして <span class="quote">「<span class="quote"><code class="command">cu 5551234 -s 115200</code></span>」</span>
            と実行します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81087568"></a><a id="set-bps"></a><p><strong>11.15.</strong></p></td><td align="left" valign="top"><p>毎回 bps レートを入力しなければいけませんか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="literal">tip1200</code> や
            <code class="literal">cu1200</code> 用のエントリを記述し、
            適切な通信速度を <code class="literal">br</code>
            フィールドに設定します。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a> は
            1200bps が正しいデフォルト値であるとみなすので、
            <span class="quote">「<span class="quote"><code class="literal">tip1200</code></span>」</span> エントリを参照します。
            もちろん 1200bps を使わなければならないわけではありません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81092176"></a><a id="terminal-server"></a><p><strong>11.16.</strong></p></td><td align="left" valign="top"><p>ターミナルサーバを経由して複数のホストへアクセスしたいのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            毎回接続されるのを待って
            <span class="quote">「<span class="quote"><strong class="userinput"><code>CONNECT &lt;host&gt;</code></strong></span>」</span>
            と入力するかわりに、
            <code class="command">tip</code> の
            <code class="literal">cm</code> 機能を使います。
            たとえば、<code class="filename">/etc/remote</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=remote&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">remote</span>(5)</span></a> 参照)
            に次のようなエントリを追加します。
          </p><pre class="programlisting">pain|pain.deep13.com|Forrester's machine:\
	:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
	:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
	:dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre><p>
            これで、<span class="quote">「<span class="quote"><code class="command">tip pain</code></span>」</span>
            や <span class="quote">「<span class="quote"><code class="command">tip muffin</code></span>」</span>
            と実行すると
            <code class="systemitem">pain</code> や
            <code class="systemitem">muffin</code> のホストに接続することができ、
            <span class="quote">「<span class="quote"><code class="command">tip deep13</code></span>」</span>
            を実行するとターミナルサーバに接続します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81104336"></a><a id="tip-multiline"></a><p><strong>11.17.</strong></p></td><td align="left" valign="top"><p>
            <code class="command">tip</code>
            を使ってそれぞれのサイトの複数の回線に接続できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは大学に電話回線がいくつかあって、
            数千人の学生が接続しようとする場合によくある問題です。
          </p><p>
            あなたの大学のエントリを
            <code class="filename">/etc/remote</code>
            ファイル (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=remote&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">remote</span>(5)</span></a> 参照) に作成して、
            <code class="literal">pn</code> のフィールドには
            <code class="literal">&lt;\@&gt;</code> を使います。
          </p><pre class="programlisting">big-university:\
:pn=\@:tc=dialout
dialout:\
:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</pre><p>
            そして
            <code class="filename">/etc/phones</code> ファイル
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=phones&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">phones</span>(5)</span></a> 参照) に大学の電話番号の一覧を書きます。
          </p><pre class="programlisting">big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a>
            は一連の電話番号を上から順に試みて、
            最終的に接続できなければあきらめます。リトライを続けさせたい場合は、
            <code class="command">tip</code> を
            while ループに入れて実行します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81117264"></a><a id="multi-controlp"></a><p><strong>11.18.</strong></p></td><td align="left" valign="top"><p><span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>P</strong></span> を
            1 回送るために 2 度押す必要があるのはなぜ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>P</strong></span>
            は通常「強制 (force)」文字であり、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a>
            に次の文字がリテラルデータであることを伝えます。
            強制文字は「変数の設定」を意味する
            <code class="literal">~s</code> エスケープによって、
            他の文字にすることができます。
          </p><p>
            <span class="quote">「<span class="quote"><code class="literal">~sforce=&lt;single-char&gt;</code></span>」</span>
            と入力して改行します。
            <em class="replaceable"><code>&lt;single-char&gt;</code></em> は、任意の 1 バイト文字です。
            <em class="replaceable"><code>&lt;single-char&gt;</code></em> を省略すると
            <code class="literal">NUL</code> 文字になり、
            これは <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>2</strong></span> や
            <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>SPACE</strong></span>
            を押しても入力できます。
            いくつかのターミナルサーバで使われているのを見ただけですが、
            <em class="replaceable"><code>&lt;single-char&gt;</code></em> に
            <span class="keycap"><strong>SHIFT</strong></span>+<span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>6</strong></span>
            に割り当てるのもよいでしょう。
          </p><p>
            <code class="filename">$HOME/.tiprc</code> に次のように定義することで、
            任意の文字を強制文字として利用できます。
          </p><pre class="programlisting">force=<em class="replaceable"><code>&lt;single-char&gt;</code></em></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81132880"></a><a id="uppercase"></a><p><strong>11.19.</strong></p></td><td align="left" valign="top"><p>打ち込んだ文字が突然すべて大文字になりました??</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>A</strong></span>
            を押してしまい、<span class="keycap"><strong>caps-lock</strong></span>
            キーが壊れている場合のために設計された
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tip&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tip</span>(1)</span></a>
            の <span class="quote">「<span class="quote">raise character</span>」</span> モードに入ったのでしょう。
            既に述べた <code class="literal">~s</code> を使って、
            <span class="quote">「<span class="quote">raisechar</span>」</span> をより適切な値に変更してください。
            もしこれら両方の機能を使用しないのであれば、
            強制文字と同じ設定にすることもできます。
          </p><p>
            以下は <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>2</strong></span> や
            <span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>A</strong></span>
            などを頻繁に使う必要のある Emacs ユーザにうってつけの
            <code class="filename">.tiprc</code> ファイルのサンプルです。
          </p><pre class="programlisting">force=^^
raisechar=^^</pre><p>
            <code class="literal">^</code> は
            <span class="keycap"><strong>SHIFT</strong></span>+<span class="keycap"><strong>CTRL</strong></span>+<span class="keycap"><strong>6</strong></span> です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81146832"></a><a id="tip-filetransfer"></a><p><strong>11.20.</strong></p></td><td align="left" valign="top"><p><code class="command">tip</code> でファイルを転送するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もし他の UNIX のシステムと接続しているなら、
            <code class="literal">~p</code> (送信) や
            <code class="literal">~t</code> (受信) でファイルの送受信ができます。
            これらのコマンドは、相手のシステムの上で
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cat</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=echo&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">echo</span>(1)</span></a>
            を実行することで送受信をします。書式は以下のようになります。
          </p><pre class="programlisting">~p <em class="replaceable"><code>&lt;ローカルのファイル名&gt;</code></em> <em class="replaceable"><code>[&lt;リモートのファイル名&gt;]</code></em>
~t <em class="replaceable"><code>&lt;リモートのファイル名&gt;</code></em> <em class="replaceable"><code>[&lt;ローカルのファイル名&gt;]</code></em></pre><p>
            この方法ではエラーチェックを行いませんので、
            zmodem などの他のプロトコルを使った方がよいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81153744"></a><a id="zmodem-tip"></a><p><strong>11.21.</strong></p></td><td align="left" valign="top"><p><span class="application">tip</span> から zmodem を実行するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず始めに、FreeBSD Ports
            Collection から zmodem プログラムのいずれか
            (<span class="application">lrzsz</span>と <span class="application">rzsz</span>
            の、通信カテゴリーの2 つのプログラムのどちらか) をインストールします。
          </p><p>
            ファイルを受信するには、リモート側で送信プログラムを起動します。
            そして、<span class="keycap"><strong>Enter</strong></span> キーを押してから
            <span class="quote">「<span class="quote"><code class="literal">~C rz</code></span>」</span>
            (lrzsz をインストールした場合は
            <span class="quote">「<span class="quote"><code class="literal">~C lrz</code></span>」</span>) と入力すると、
            ローカル側へのファイルの受信が始まります。
          </p><p>
            ファイルを送信するには、リモート側で受信プログラムを起動します。
            そして、<span class="keycap"><strong>Enter</strong></span> キーを押してから
            <span class="quote">「<span class="quote"><code class="literal">~C sz &lt;files&gt;</code></span>」</span>
            (lrzsz をインストールした場合は
            <span class="quote">「<span class="quote"><code class="literal">~C lsz
              &lt;files&gt;</code></span>」</span>)
            と入力すると、リモート側へのファイルの送信が始まります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81181008"></a><a id="cannot-find-serial"></a><p><strong>11.22.</strong></p></td><td align="left" valign="top"><p>設定が正しいのにもかかわらず、FreeBSD がシリアルポートを見付けられません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            マザーボードやシリアルカードが Acer の UART チップを使った物の場合、
            FreeBSD の <code class="filename">sio</code> ドライバでは正しく検出する事が出来ません。
            この問題を解決するためには、
            <a class="link" href="http://www.lemis.com/serial-port-patch.html" target="_top">www.lemis.com</a>
            からパッチを入手してください。
          </p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="misc"></a>第12章 その他の質問</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        内川 喜章 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yoshiaki@kt.rim.or.jp">yoshiaki@kt.rim.or.jp</a>&gt;</code>、
        杉村 貴士 <code class="email">&lt;<a xmlns="" class="email" href="mailto:sugimura@jp.FreeBSD.org">sugimura@jp.FreeBSD.org</a>&gt;</code>、
        福間 康弘 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yasuf@big.or.jp">yasuf@big.or.jp</a>&gt;</code>、
        1997 年 11 月 10 日 - 1999 年 5 月 8 日</em></span>
    </p><div class="qandaset"><a id="idp81186896"></a><dl><dt>12.1. <a href="#idp81187152">FreeBSD は Linux より多くのスワップ領域を消費するのはなぜですか?</a></dt><dt>12.2. <a href="#idp81193808">ほとんどプログラムは実行されていないのに、
              どうして top(1) は非常に少ない free memory を報告するのでしょうか?</a></dt><dt>12.3. <a href="#idp81204304">FreeBSD の実行フォーマットの a.out、ELF
            とはどのようなものですか?
            また、a.out、ELF を使う理由は何でしょう?</a></dt><dt>12.4. <a href="#idp81243472">それにしても、なぜそんなに多くのフォーマットがあるのですか?</a></dt><dt>12.5. <a href="#idp81253712">シンボリックリンクの許可属性を
            chmod で変えられないのはなぜですか?</a></dt><dt>12.6. <a href="#idp81280720">ログイン名がいまだに
            8 文字に制限されているのはなぜですか?</a></dt><dt>12.7. <a href="#idp81289040">FreeBSD 上で DOS のバイナリを動かすことはできますか?</a></dt><dt>12.8. <a href="#idp81325776">どこで無料の FreeBSD のアカウントを取得できますか?</a></dt><dt>12.9. <a href="#idp81329488">「sup」 とは何で、
            どのようにして使うものなのでしょうか?</a></dt><dt>12.10. <a href="#idp81337552">FreeBSD をクールに使うには?</a></dt><dt>12.11. <a href="#idp81341648">誰かが私のメモリカードをひっかいているのですか??</a></dt><dt>12.12. <a href="#idp81349584">"MFC" とはどういう意味ですか</a></dt><dt>12.13. <a href="#idp81352400">"BSD" とはどういう意味ですか?</a></dt><dt>12.14. <a href="#idp81355344">リポジトリ・コピー (repo-copy)
            とは一体何のことでしょう?</a></dt><dt>12.15. <a href="#idp81359696">なんでバイク小屋 (bikeshed) の色にまで気を使わなければいけないんですか?</a></dt><dt>12.16. <a href="#idp81373520">ひとつの電球を取り替えるのに、何人の FreeBSD ハッカーが必要?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp81187152"></a><a id="more-swap"></a><p><strong>12.1.</strong></p></td><td align="left" valign="top"><p>FreeBSD は Linux より多くのスワップ領域を消費するのはなぜですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            実際にはそうではありません。
            FreeBSD は Linux よりもスワップを多く使っているように見えるだけです。
            この点における FreeBSD と Linux の主な違いは、
            FreeBSD はより多くのメインメモリを有効利用できるようにするため、
            完全にアイドルになったものやメインメモリ上の使われなくなったページを、
            スワップにあらかじめ積極的に移動しているということです。
            Linux では、
            最後の手段としてページをスワップに移動させるだけという傾向があります。
            このスワップの使い方は、
            メインメモリをより効果的に使用することによってバランスが保たれています。
          </p><p>
            FreeBSD はこのような状況では先手策を取りますが、
            システムが本当に空き状態の時に、
            理由も無くページをスワップしようと決めることはないということに注意してください。
            したがって、
            夜中に使わずにおいたシステムが朝起きたとき、
            すべてページアウトされているということはないのです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81193808"></a><a id="top-freemem"></a><p><strong>12.2.</strong></p></td><td align="left" valign="top"><p>ほとんどプログラムは実行されていないのに、
              どうして <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> は非常に少ない free memory を報告するのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>簡単に言えば、free memory
            とは無駄になっているメモリのことだからです。
            プログラムが確保しているメモリ以外のすべてのメモリは、
            FreeBSD カーネル内でディスクキャッシュとして利用されます。
            この値は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> において
            <code class="literal">Inact</code>、
            <code class="literal">Cache</code>
            <code class="literal">Buf</code> として表示され、
            それぞれは異なるエージングレベル
            (訳注: データがどれだけ古いかを示す評価値)
            でキャッシュされた全データを表します。
            データがキャッシュされると言うのは、
            最近アクセスされたデータであれば、
            再度そのデータをアクセスするためにシステムが遅いディスクにアクセスする必要がない、
            ということを意味します。
            そのため、全体のパフォーマンスが向上します。
            一般的に、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> で表示される
            <code class="literal">Free</code> メモリが小さい値を示すことは良いことで、
            自由に使えるメモリの残量が<span class="emphasis"><em>本当に</em></span>少ない、
            ということを表しているわけではありません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81204304"></a><a id="aout-elf"></a><p><strong>12.3.</strong></p></td><td align="left" valign="top"><p>FreeBSD の実行フォーマットの a.out、ELF
            とはどのようなものですか?
            また、a.out、ELF を使う理由は何でしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD が何故 ELF
            フォーマットを利用しているのかを理解するためには、
            まず UNIXにおいて現在「優勢」な
            3 種類の実行フォーマットについて
            いくらか知っておく必要があります。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD 3.x より前の FreeBSD では a.out
                フォーマットが使われていました。</p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=a.out&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">a.out</span>(5)</span></a></p><p>
                  最も古く 「由緒正しい」 unix オブジェクトフォーマットです。
                  マジックナンバを含む短くてコンパクトなヘッダが先頭にあり、
                  これがフォーマットの特徴とされています
                  (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=a.out&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">a.out</span>(5)</span></a> に詳細な内容があります)。
                  ロードされる 3種類のセグメント、
                  <code class="literal">.text</code>、
                  <code class="literal">.data</code>、
                  <code class="literal">.bss</code>
                  と加えてシンボルテーブルと文字列テーブルを含みます。
                </p></li><li class="listitem"><p><acronym class="acronym">COFF</acronym></p><p>
                  SVR3 のオブジェクトフォーマットです。
                  ヘッダは単一のセクションテーブルから成り、
                  <code class="literal">.text</code>、
                  <code class="literal">.data</code>、
                  <code class="literal">.bss</code>
                  セクション以外の部分を持つことができます。
                </p></li><li class="listitem"><p><acronym class="acronym">ELF</acronym></p><p>
                  <acronym class="acronym">COFF</acronym>の後継です。複数のセクションをサポートし、32-bit
                  と 64-bitのいずれの値も可能です。大きな欠点の一つは、<acronym class="acronym">ELF</acronym>
                  はそれぞれのシステムアーキテクチャ毎に単一の <acronym class="acronym">ABI</acronym>
                  のみが存在するという仮定で設計されていることです。
                  この仮定はまったく正しくありません。
                  商用の SYSV の世界でさえそうです (少なくとも SVR4、
                  Solaris、SCO の 3種類の ABI があります)。
                </p><p>
                  FreeBSD はこの問題を解決するための試みとして、
                  既知の <acronym class="acronym">ELF</acronym>
                  実行ファイルに <acronym class="acronym">ABI</acronym> に応じた情報を
                  <span class="emphasis"><em>書き加える</em></span>ユーティリティを提供しています。
                  詳しくは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=brandelf&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">brandelf</span>(1)</span></a>
                  のマニュアルページを参照してください。
                </p></li></ul></div><p>
            FreeBSD は伝統的な立場をとり、数多くの世代の BSD
            のリリースで試され、実証されてきた
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=a.out&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">a.out</span>(5)</span></a>
            フォーマットを伝統的に使用しています。
            いつかは FreeBSD システムでネイティブ
            <acronym class="acronym">ELF</acronym> バイナリを作り、
            実行することができるようになるかもしれませんが、
            初期の頃 FreeBSD
            では <acronym class="acronym">ELF</acronym>
            をデフォルトのフォーマットに変更するという動きは
            ありませんでした。なぜでしょうか?
            ところで Linux においては、
            <acronym class="acronym">ELF</acronym> への苦痛をともなった変更は、
            その時に <code class="filename">a.out</code>
            実行フォーマットから逃れたというよりは、
            ジャンプテーブルベースの共有ライブラリのメカニズムの柔軟性の低さからの脱却でした。
            これはベンダや開発者全体にとって、
            共有ライブラリの作成が非常に難しかった原因でした。
            <acronym class="acronym">ELF</acronym>
            のツールには共有ライブラリの問題を解決することができるものが提供されており、
            またいずれにせよ一般的に「進歩」していると考えられます。
            このため移行のコストは必要なものとして容認され、
            移行は行なわれました。
          </p><p>
            FreeBSD の場合は、共有ライブラリのメカニズムは Sun の
            <span class="application">SunOS</span> 形式の共有ライブラリの
            メカニズムに極めて近いものになっていて、
            非常に使いやすいものになっています。
            しかしながら、FreeBSD では 3.0 から <acronym class="acronym">ELF</acronym>
            バイナリをデフォルトのフォーマットとして公式にサポートしています。
            a.out 実行フォーマットはよいものを私達に提供してくれているものの、
            私たちの使っているコンパイラの作者である GNU の人々は
            a.out フォーマットのサポートをやめてしまったのでした。
            このことは、
            私たちに別バージョンのコンパイラとリンカを保守することを余儀なくされることとなり、
            最新の GNU 開発の努力による恩恵から遠ざかることになります。
            その上、ISO C++ の、
            とくにコンストラクタやデストラクタがらみの要求もあって、今後の
            FreeBSD のリリースでネイティブの <acronym class="acronym">ELF</acronym>
            のサポートされる方向へと話が進んでいます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81243472"></a><a id="binary-formats"></a><p><strong>12.4.</strong></p></td><td align="left" valign="top"><p>それにしても、なぜそんなに多くのフォーマットがあるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もうおぼろげになってしまった暗い過去に、単純なハードウェアがありました。
            この単純なハードウェアは、単純で小さなシステムをサポートしていました。
            a.out はこの単純なシステム (PDP-11)
            での作業を行なうバイナリとして完全に適したものだったのです。
            人々はこの単純なシステムから UNIX を移植する際に、a.out
            フォーマットをそのまま使いました。というのは
            Motorola 68k、VAXen、
            といったアーキテクチャへの UNIX の初期の移植ではこれで十分だったからです。
          </p><p>
            やがてある聡明なエンジニアが、
            ソフトウェアでちょっとしたトリックを使うことを決めました。
            彼はいくつかのゲートを削り取って
            CPU のコアをより速く走らせることができたのです。
            これは新しい種類のハードウェア (今日では <acronym class="acronym">RISC</acronym>
            として知られています) で動いたのです。
            a.out はこのハードウェアには適していなかったので、
            このハードウェア上で多くのフォーマットが、
            限定された単純な a.out
            フォーマットでのものよりもより良いパフォーマンスを出すことを目指して開発されたのです。
            <acronym class="acronym">COFF</acronym>、<acronym class="acronym">ECOFF</acronym>、
            そしていくつかの有名でないフォーマットが
            <acronym class="acronym">ELF</acronym> が標準になる前に開発され、
            それらの限界が探求されたのです。
          </p><p>
            さらに、プログラムサイズは巨大になり、
            ディスク (および物理メモリ) は依然として相対的に小さかったため、
            共用ライブラリのコンセプトが誕生しました。
            また、VM システムはより複雑なものになりました。
            これらの個々の進歩は a.out フォーマットを使用して遂げられましたが、
            その有用性は新しい機能とともにどんどん広がってきました。
            これらに加え、実行時に必要なものを動的にロードする、
            または初期化コードの実行後にプログラムの一部を破棄し、
            コアメモリおよびスワップ空間を節約するという要望が高まりました。
            プログラミング言語はさらに複雑になり、<code class="literal">main</code>
            関数の前に自動的にコールされるコードの要望が高まりました。
            多くの機能拡張が行なわれ、a.out
            フォーマットがこれらすべてを実現できるようになり、
            それらはしばらくは基本的に動作していました。
            やがて、a.out はコードでのオーバヘッドと複雑さを増大させずに、
            これらの問題すべてを処理することに無理がでてきました。
            一方、<acronym class="acronym">ELF</acronym> はこれらの問題の多くを解決しますが、
            現状稼働しているシステムからの切替えは厄介なものになるでしょう。
            そのため <acronym class="acronym">ELF</acronym> は、a.out のままでいることが
            <acronym class="acronym">ELF</acronym>
            への移行よりももっと厄介なものになるまで待つ必要がありました。
          </p><p>
            しかし時が経つにつれ、FreeBSD
            のビルドツールの元となったツール群 (特にアセンブラとローダ) と
            FreeBSD のビルドツール群は異なった進化の経路をたどりました。
            FreeBSD のツリーでは、共有ライブラリが追加され、
            バグフィックスも行われました。
            もともとのツール群を作成した GNU の人たちは、プログラムを書き直し、
            クロスコンパイラのサポート、
            異なるフォーマットを任意に取り込む機能などを追加していきました。
            多くの人々が FreeBSD
            をターゲットとしたクロスコンパイラの構築を試みましたが、
            FreeBSD の使っている <code class="command">as</code> と
            <code class="command">ld</code>
            の古いプログラムコードはクロスコンパイルをサポートしておらず、
            うまくいきませんでした。
            新しい GNU のツール群 (binutils) は、
            クロスコンパイル、共有ライブラリ、C++
            拡張などの機能をサポートしています。
            さらに数多くのベンダが
            <acronym class="acronym">ELF</acronym> バイナリをリリースしています。
            FreeBSD にとって <acronym class="acronym">ELF</acronym>
            バイナリが実行できることは、
            非常にメリットがあります。<acronym class="acronym">ELF</acronym> バイナリが
            FreeBSD で動くのなら、a.out
            を動かすのに手間をかける必要はありませんね。
            長い間忠実によく働いた老いた馬は、
            そろそろ牧草地で休ませてあげましょう。
          </p><p>
            <acronym class="acronym">ELF</acronym> は a.out に比べてより表現力があり、
            ベースのシステムに対してより幅広い拡張性を提供できます。
            <acronym class="acronym">ELF</acronym> 用のツールはよりよく保守されています。
            また多くの人にとって重要なクロスコンパイルもサポートしています。
            <acronym class="acronym">ELF</acronym> の実行速度は、ほんの少し a.out より遅いかもしれませんが、
            実際に速度の差をはかるのは困難でしょう。
            <acronym class="acronym">ELF</acronym> と a.out の間には、ページマッピング、
            初期化コードの処理など多くの違いがありますが、
            とりたてて重要なものはありません。しかし違いがあるのは確かです。ほどなく、
            GENERIC カーネルから a.out のサポートが外されます。
            a.out のプログラムを実行する必要性がなくなれば、
            最終的に a.out のサポートはカーネルから削除されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81253712"></a><a id="chmod-symlinks"></a><p><strong>12.5.</strong></p></td><td align="left" valign="top"><p>シンボリックリンクの許可属性を
            <code class="command">chmod</code> で変えられないのはなぜですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>シンボリックリンクは許可属性を持ちません。
            また <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a> のデフォルト動作は、
            シンボリックリンクをたどってリンク先のファイルの許可属性を変更するようになっていません。
            そのため、
            <code class="filename">foo</code> というファイルがあり、
            このファイルへのシンボリックリンク
            <code class="filename">bar</code> があったとすると、
            以下のコマンドは常に成功します。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>chmod g-w bar</code></strong></pre><p>しかしこの場合、<code class="filename">foo</code> の許可属性は変更されません。</p><p>
            この場合、<span class="quote">「<span class="quote"><code class="option">-H</code></span>」</span> か
            <span class="quote">「<span class="quote"><code class="option">-L</code></span>」</span> のどちらかのオプションを
            <span class="quote">「<span class="quote"><code class="option">-R</code></span>」</span> と同時に使う必要があります。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=symlink&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">symlink</span>(7)</span></a>
            のマニュアルページにはもっと詳しい情報があります。
          </p><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                <span class="quote">「<span class="quote"><code class="option">-R</code></span>」</span> オプションは<span class="emphasis"><em>再帰的に</em></span>
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a>
                を実行します。ディレクトリやディレクトリへのシンボリックリンクを
                <code class="command">chmod</code> する場合は気をつけてください。
                シンボリックリンクで参照されている単一のディレクトリのパーミッションを変更したい場合は、
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a>
                をオプションをつけずに、
                シンボリックリンクの名前の後ろにスラッシュ (<span class="quote">「<span class="quote"><code class="filename">/</code></span>」</span>)
                をつけて使います。たとえば、<span class="quote">「<span class="quote"><code class="filename">foo</code></span>」</span>
                がディレクトリ <span class="quote">「<span class="quote"><code class="filename">bar</code></span>」</span>
                へのシンボリックリンクである場合、
                <span class="quote">「<span class="quote"><code class="filename">foo</code></span>」</span>
                (実際には <span class="quote">「<span class="quote"><code class="filename">bar</code></span>」</span>)
                のパーミッションを変更したい場合には、このようにします。
              </p><pre xmlns="http://www.w3.org/1999/xhtml" class="screen"><code class="prompt">%</code> <strong class="userinput"><code>chmod 555 foo/</code></strong></pre><p xmlns="http://www.w3.org/1999/xhtml">
                後ろにスラッシュをつけると、
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a> はシンボリックリンク
                <span class="quote">「<span class="quote"><code class="filename">foo</code></span>」</span>
                を追いかけてディレクトリ
                <span class="quote">「<span class="quote"><code class="filename">bar</code></span>」</span>
                のパーミッションを変更します。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81280720"></a><a id="login-8char"></a><p><strong>12.6.</strong></p></td><td align="left" valign="top"><p>ログイン名が<span class="emphasis"><em>いまだに</em></span>
            8 文字に制限されているのはなぜですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="literal">UT_NAMESIZE</code>
            を変更してシステム全体を作り直せば十分で、
            それだけでうまくいくだろうとあなたは考えるかもしれません。
            残念ながら多くのアプリケーションやユーティリティ (システムツールも含めて) は、
            小さな数値を構造体やバッファなどに使っています (必ずしも
            <span class="quote">「<span class="quote">8</span>」</span> や <span class="quote">「<span class="quote">9</span>」</span> ではなく、
            <span class="quote">「<span class="quote">15</span>」</span> や <span class="quote">「<span class="quote">20</span>」</span> などの変った値を使うものもあります)。
            (固定長のレコードを期待するところで可変長レコードになるため、
            ) 台無しになったログファイルを得ることになるということだけでなく、
            Sun の <acronym class="acronym">NIS</acronym>
            のクライアントの場合は問題が起きますし、他の UNIX
            システムとの関連においてこれら以外の問題も起きる可能性があります。
          </p><p>
            しかし、FreeBSD 3.0 以降では 16 文字となり、
            多くのユーティリティのハードコードされた名前の長さの問題も解決されます。
            実際にはシステムのあまりに多くの部分を修正するために、
            3.0 になるまでは変更が行われませんでした。
          </p><p>
            それ以前のバージョンでは、これらの問題が起こった場合に、
            問題を自分自身で発見し、解決できることに絶対的な自信がある場合は
            <code class="filename">/usr/include/utmp.h</code> を編集し、
            <code class="literal">UT_NAMESIZE</code> の変更にしたがって、
            長いユーザ名を使うことができます。
            また、
            <code class="literal">UT_NAMESIZE</code> の変更と一致するように
            <code class="filename">/usr/include/sys/param.h</code> の
            <code class="literal">MAXLOGNAME</code> 更新しなくてはなりません。
            最後に、ソースからビルドする場合は
            <code class="filename">/usr/include</code>
            を毎回アップデートする必要があることを忘れないように!
            <code class="filename">/usr/src/..</code> 上のファイルを変更しておいて置き換えましょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81289040"></a><a id="dos-binaries"></a><p><strong>12.7.</strong></p></td><td align="left" valign="top"><p>FreeBSD 上で DOS のバイナリを動かすことはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい、FreeBSD 3.0 からは、
            統合と改良が重ねられた BSDI の <span class="application">doscmd</span>
            DOS エミュレーションサブシステムを使ってできるようになりました。
            今なお続けられているこの努力に興味を持って参加していただけるなら、
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-emulation" target="_top">FreeBSD-emulation メーリングリスト</a>
            へメールを送ってください。
          </p><p>FreeBSD 3.0 以前のシステムでは、
            <span class="application">pcemu</span>
            という巧妙なユーティリティが FreeBSD Ports Collection にあり、
            8088 のエミュレーションと DOS
            のテキストモードアプリケーションを動かすに十分な
            BIOS サービスを行ないます。これは X ウィンドウシステムが必要です (XFree86
            として提供されています)。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81325776"></a><a id="free-account"></a><p><strong>12.8.</strong></p></td><td align="left" valign="top"><p>どこで無料の FreeBSD のアカウントを取得できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD はいずれのサーバーにもアクセスを開放していませんが、
            Unix システムへの自由なアクセスを提供しているところがあります。
            費用はまちまちで、限定されたサービスが利用できます。</p><p>M-Net としても知られる <a class="link" href="http://www.arbornet.org/" target="_top">Arbornet, Inc</a> は
            1983 年から Unix システムへのアクセスを提供しています。
            System III が動作する Altos に始まり、1991 年には
            BSD/OS に移行しました。2000 年 6 月には、再び FreeBSD に
            移行しています。M-Net には SSH または telnet 経由で
            アクセスすることができ、FreeBSD ソフトウェア一式が
            利用できるようになっています。ただし、ネットワーク接続は
            会員と、非営利組織として運営されているシステムに寄付をする
            後援者に制限されています。また、M-Net は掲示板システムと
            双方向チャットも提供しています。</p><p><a class="link" href="http://www.grex.org/" target="_top">Grex</a> は、
            掲示板システムと双方向チャットソフトウェアが同じであることも含め、
            M-Net とよく似たサイトを提供しています。しかし、
            マシンは Sun 4M で、SunOS が動作しています。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81329488"></a><a id="sup-define"></a><p><strong>12.9.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote"><acronym class="acronym">sup</acronym></span>」</span> とは何で、
            どのようにして使うものなのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="http://www.FreeBSD.org/cgi/ports.cgi?^sup" target="_top">SUP</a>
            とは、ソフトウェアアップデートプロトコル (Software Update Protocol) で
            カーネギーメロン大学 (CMU) で開発ツリーの同期のために開発されました。
            私たちの中心開発ツリーをリモートサイトで同期させるために使っていました。
          </p><p>
            SUP はバンド幅を浪費しますので、今は使っていません。
            ソースコードのアップデートの現在のおすすめの方法は
            <a class="link" href="../handbook/synching.html#CVSUP" target="_top">FreeBSD
              ハンドブックの「CVSup」</a>にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81337552"></a><a id="very-very-cool"></a><p><strong>12.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD をクールに使うには?</p><p>
            FreeBSD を動かす時に温度測定を行なった人はいますか? Linux
            は dos よりも温度が下がるということは知っていますが、FreeBSD
            についてはこのようなことに触れたものを見たことはありません。
            実際熱くなっているように見えます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            いいえ。
            私たちは 250 マイクログラムの LSD-25
            をあらかじめ与えておいたボランティアに対する、
            目隠し味覚テストを大量に行なっています。
            35% のボランティアは FreeBSD
            はオレンジのような味がすると言っているのに対し、
            Linux は紫煙のような味わいがあると言っている人もいます。
            両方のグループとも温度の不一致については何も触れていません。
            この調査で、非常に多くのボランティアがテストを行なった部屋から不思議そうに出てきて、
            このようなおかしな結果を示したことに私たちは当惑させられました。
            私たちは、ほとんどのボランティアは Apple
            にいて彼らの最新の「引っかいて匂いをかぐ」GUI
            を使っているのではないかと考えています。
            私たちは奇妙な古い仕事をしているのでしょう!
          </p><p>
            真面目に言うと、FreeBSD や Linux は共に
            <span class="quote">「<span class="quote"><acronym class="acronym">HLT</acronym></span>」</span> (停止)
            命令をシステムのアイドル (idle) 時に使い、
            エネルギーの消費を押えていますので熱の発生も少なくなります。
            また、<acronym class="acronym">APM (advanced power management)</acronym>
            を設定してあるなら FreeBSD は <acronym class="acronym">CPU</acronym>
            をローパワーモードにすることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81341648"></a><a id="letmeoutofhere"></a><p><strong>12.11.</strong></p></td><td align="left" valign="top"><p>誰かが私のメモリカードをひっかいているのですか??</p><p>
            FreeBSDでカーネルのコンパイルをしている時、
            メモリから引っかいているような奇妙な音が聞こえるようなことはあるのでしょうか?
            コンパイルをしている時 (あるいは起動時にフロッピドライブを認識した後の短い間など)、
            奇妙な引っかくような音がメモリカードのあたりから聞こえてきます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            その通り! BSD の文書には良く、デーモン (daemon) という言葉が出てきます。
            ほとんどの人は知らないのですが、
            デーモンとは、あなたのコンピュータを依り代とする、
            純粋で非物質的な存在のことです。
            メモリから聞こえるひっかくような音は、
            さまざまあるシステム管理タスクの扱いをいかに最善なものにするか、
            といったことを決めるときにデーモンたちが交わす、
            かん高いささやき声なのです。
          </p><p>
            この雑音が聞こえたとき、DOS から
            <span class="quote">「<span class="quote"><code class="command">fdisk /mbr</code></span>」</span>
            というプログラムを実行すれば、
            うまくデーモンを追い出すことができるでしょう。
            でも、デーモンはそれに歯向かって <code class="command">fdisk</code>
            の実行をやめさせようとするかも知れません。
            もし、それを実行しているときにスピーカならビル ゲイツ (Bill
            Gates) の悪魔のささやきが聞こえてきたら、
            すぐに立ち上がって逃げてください。決して振り返ってはいけません!
            BSD のデーモンたちが押え込んでいた双子のデーモン、DOS と Windows が解放され、
            あなたの魂を永遠の破滅へ導こうとマシンを再び支配してしまうことでしょう。
            それを知った今や、選べと言われたら、
            むしろひっかき音に慣れる方を選ぶのではありませんか?
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81349584"></a><a id="define-MFC"></a><p><strong>12.12.</strong></p></td><td align="left" valign="top"><p>"MFC" とはどういう意味ですか</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <acronym class="acronym">MFC</acronym> とは、
            「CURRENT との合流 (Merged From -CURRENT)」の頭文字をとったものです。
            <acronym class="acronym">CVS</acronym> ログで
            -CURRENT から
            -STABLE ブランチへの合流を示します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81352400"></a><a id="define-BSD"></a><p><strong>12.13.</strong></p></td><td align="left" valign="top"><p>"BSD" とはどういう意味ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この言葉は、仲間うちだけに分かる隠語で何とかという意味です。
            文字どおりに訳すことはできませんが、
            BSD の訳は「F1 のレーシングチーム」か「ペンギンはおいしいスナック」、
            あるいは「俺たちゃ
            Linux より洒落は利いてるぜ」とかそのへんだと言っておけばおっけーでしょう。
            <code class="literal">:-)</code>
          </p><p>
            冗談はさておき、BSD とは、Berkeley
            CSRG (コンピュータシステム評議会) が彼らの
            UNIX の配布形態の名前として当時選んだ
            "Berkeley Software Distribution"
            の略です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81355344"></a><a id="define-repocopy"></a><p><strong>12.14.</strong></p></td><td align="left" valign="top"><p>リポジトリ・コピー (repo-copy)
            とは一体何のことでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>repo-copy (<span class="quote">「<span class="quote">repository copy</span>」</span> の略) とは、
            CVS リポジトリの中で直接ファイルをコピーすることを示す用語です。</p><p>repo-copy を行なわない場合を考えます。
            リポジトリの中の異なる場所にファイルをコピーしたり、
            移動したりする必要性が生じると、コミッターは
            ファイルを新しい場所に置くために <code class="command">cvs add</code> を、
            そして古いファイルが削除される場合は、古いファイルに対して
            <code class="command">cvs rm</code> を実行するでしょう。</p><p>この方法の欠点は、ファイルの変更履歴
            (たとえば CVS ログのエントリ) が新しい場所にコピーされないことです。
            FreeBSD プロジェクトではこの変更履歴をとても有用なものだと考えているため、
            前述の方法の代わりにリポジトリコピーが良く用いられます。
            この操作は <code class="command">cvs</code> プログラムを利用するのではなく、
            リポジトリの管理担当者がリポジトリの中でファイルを直接コピーすることによって行なわれます。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81359696"></a><a id="bikeshed-painting"></a><p><strong>12.15.</strong></p></td><td align="left" valign="top"><p>なんでバイク小屋 (bikeshed) の色にまで気を使わなければいけないんですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一言で言ってしまえば、そうすべきではありません。
            もう少し詳しく説明しましょう。
            たとえば、あなたがバイク小屋を建てる技術を持っていたとします。
            しかしそれは、塗ろうとしている色が気に入らないからと言って、
            他人がバイク小屋を建てようとしているのを止めて良い理由にはなりませんよね。
            これは、自分の行動について十分な理解を持っているなら、
            あなたは細かな機能すべてにわたって議論する必要はないことを示す比喩です。
            ある変更によって産み出されるノイズの総量は、
            その変更の複雑さに反比例するのだと言っている人達もいます。</p><p>さらに詳しく、完全な回答を紹介しましょう。
            Poul-Henning Kamp は、
            「<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sleep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sleep</span>(1)</span></a> は分数の秒数を引数として取るべきか」という
            非常に長い議論の後で、
            <span class="quote">「<span class="quote"><a class="link" href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers" target="_top">A bike shed (any colour will do) on greener
            grass...</a></span>」</span>
            というタイトルの長文を投稿しました。
            関係のある部分だけを以下に掲載します。</p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top">〓</td><td width="80%" valign="top"><p>
              <span class="quote">「<span class="quote">このバイク小屋、どうだろう?</span>」</span>
              誰かがたずねました。
            </p><p>
              長い…というか、むしろ古い話になりますが、
              中身はわりと簡単な話です。パーキンソン
              (C. Northcote Parkinson) は 1960 年代初頭に
              <span class="quote">「<span class="quote">パーキンソンの法則</span>」</span> と呼ばれる本を書きました。
              この中にはさまざまな経営の力学に関する洞察が含まれています。
            </p><p>[ この本に関する解説があったが省略 ]</p><p>バイク小屋に関連する例として、
              もう一つの重要な構成要素となっているのは原子力発電所です。
              この本の年代がわかりますね。</p><p>パーキンソンは、あなたが重役会に出席して
              数百万から数10億ドル規模の原子力発電所の建設の承認を得る
              ことはできるでしょうが、あなたが建てたいのがバイク小屋ならば、
              終わりなき議論に巻き込まれるだろうと言っています。</p><p>パーキンソンはこのように説明しています。
              これは原発が余りに巨大で高価で複雑なので誰もこれを一手に握ることができず、
              それを試みるくらいならむしろ、手が出せなくなる前に
              他の誰かがすべてを詳細にチェックすることを
              引き受けることに頼るのです。
              リチャード・ファインマン (Richard P. Feynmann) は、
              ロスアラモスでこの手の重要な経験を何度も見てきたと本に書いています。
            </p><p>一方でバイク小屋の場合は、誰でも週末にこれを作り上げることができ、
              しかも TV の試合を見る時間があまるほどです。
              なので、どんなに準備が整えてあって、どんなに計画が順当であったとしても、
              わたしは仕事をやっているよ、
              わたしは注意を払っているよ、そして
              わたしは<span class="emphasis"><em>ここ</em></span>にいるよ、
              ということを示そうとする人が必ず現れます。</p><p>デンマークではこれを「指紋をつける」と呼んでいます。
              これは個人的なプライドや名声を求め、
              ある場所を指し示して「ここ! ここは<span class="emphasis"><em>俺</em></span>が
              やったんだぜ〜」というようなものです。
              これは政治家に見られる強い特徴ですが、
              その他のほとんどの人もこういう風に振舞う可能性はあるのです。
              生乾きのセメントにつけられた足跡のことを考えればお分かりでしょう。</p></td><td width="10%" valign="top">〓</td></tr><tr><td width="10%" valign="top">〓</td><td colspan="2" align="right" valign="top">--<span class="attribution">1999 年 10 月 2 日  freebsd-hackers にて
              Poul-Henning Kamp</span></td></tr></table></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81373520"></a><a id="changing-lightbulbs"></a><p><strong>12.16.</strong></p></td><td align="left" valign="top"><p>ひとつの電球を取り替えるのに、何人の FreeBSD ハッカーが必要?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            1,172人です。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>電球が消えていると -CURRENT で文句を言うのに 23 人。</p></li><li class="listitem"><p>設定上の問題で -questions で話をすべきことについて騒ぐのに 4 人。</p></li><li class="listitem"><p>それを send-pr (訳注: 障害報告) するのに 3
                人 (そのうちのひとつは間違って doc カテゴリに送りつけられたうえに、
                内容が「暗くなった」というだけのもの)。</p></li><li class="listitem"><p>buildworld を失敗させ、5 分後には元に戻されるような電球を
                テストもせずにコミットするのに 1 人。</p></li><li class="listitem"><p>send-pr した人に、パッチが含まれていないと「いちゃもん」を付けるのに
                8 人。</p></li><li class="listitem"><p>buildworld が失敗すると文句を言うのに 5 人。</p></li><li class="listitem"><p>自分のところではちゃんと動く、
                cvsup したタイミングが悪かったんだろうと答えるのに 31 人。</p></li><li class="listitem"><p>新しい電球のためのパッチを -hackers に投げるのに 1 人。</p></li><li class="listitem"><p>自分は 3 年も前にパッチを作ったが、それを -CURRENT
                に投げたときには無視されただけだった、
                自分は send-pr のシステムには嫌な経験があると (おまけに、
                提案された新しい電球には柔軟性が無いとまで) 文句を言うのに 1 人。</p></li><li class="listitem"><p>電球が基本システムに組み込まれていない、
                committer はコミュニティの意見を聞くこと無しにこんなことをする権利は無いと叫び、
                「こんなときに -core は何をやってるんだ!?」とわめきちらすのに 37 人。</p></li><li class="listitem"><p>自転車置き場の色に文句を言うのに 200 人。</p></li><li class="listitem"><p>パッチが <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=style&amp;sektion=9"><span class="citerefentry"><span class="refentrytitle">style</span>(9)</span></a> 違反だと指摘するのに 3 人。</p></li><li class="listitem"><p>提案された新しい電球は GPL の下にあると文句を言うのに 70 人。</p></li><li class="listitem"><p>GPL と BSD ライセンスと MIT ライセンスと NPL と、
                某 FSF 創立者らの個人的な健康法の優位性についての論争を戦わすのに 586 人。</p></li><li class="listitem"><p>スレッドのあちこちの枝を -chat や -advocacy に移動するのに 7 人。</p></li><li class="listitem"><p>提案された電球を、古いのよりずっと薄暗いのにコミットしてしまうのに 1 人。</p></li><li class="listitem"><p>FreeBSD に薄暗い電球を付けるくらいなら真っ暗のほうがましだという、
                コミットメッセージへの凄まじい非難の嵐によって、
                それを元に戻すのに 2 人。</p></li><li class="listitem"><p>薄暗い電球が帳消しにされたことに対してどなり声で口論し、
                -core の声明を要求するのに 46 人。</p></li><li class="listitem"><p>もし FreeBSD をたまごっちに移植することになったときに都合がいいように、
                もっと小さな電球を要求するのに 11 人。</p></li><li class="listitem"><p>-hackers と -chat の S/N比に文句を言い、
                抗議のため講読を取りやめるのに 73 人。</p></li><li class="listitem"><p>「unsubscribe」「どうやったら講読をやめられるんですか?」
                「このメーリングリストからわたしを外してください」といった
                メッセージを、例のフッタをくっつけて投稿するのに 13 人。</p></li><li class="listitem"><p>みんなが激論を戦わせるのに忙がしくて気付かない間に、
                作業中の電球をコミットするのに 1 人。</p></li><li class="listitem"><p>新しい電球は TenDRA を使ってコンパイルされた場合に 0.364%
                も明るくなる (ただし電球を立方体にしなければならない)、
                だから FreeBSD は EGCS から TenDRA に変えるべきだと指摘するのに 31 人。</p></li><li class="listitem"><p>新しい電球は美しさに欠けていると文句を言うのに 1 人。</p></li><li class="listitem"><p>「MFC って何ですか?」と聞くのに 9 人 (send-pr した人も含む)。</p></li><li class="listitem"><p>電球が取り替えられてから
                2 週間も消えっぱなしだと文句を言うのに 57 人。</p></li></ul></div><div xmlns="" class="note"><h3 class="admontitle">Nik Clayton <code xmlns="http://www.w3.org/1999/xhtml" class="email">&lt;<a xmlns="" class="email" href="mailto:nik@FreeBSD.org">nik@FreeBSD.org</a>&gt;</code> による追記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                これには爆笑しました。
              </p><p xmlns="http://www.w3.org/1999/xhtml">
                それからわたしは考えました。
                「ちょっと待てよ? このリストのどこかに、
                『これを文書にまとめるのに 1人』というのがあってもいいんじゃないか?」
              </p><p xmlns="http://www.w3.org/1999/xhtml">
                それからわたしは悟りを開いたのです <code class="literal">:-)</code>
              </p></div><p><span class="emphasis"><em>この項目の著作権は
              Copyright (c) 1999 Dag-Erling C. Smørgrav にあります。
              無断で使用しないでください。</em></span>
          </p></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="hackers"></a>第13章 まじめな FreeBSD ハッカーだけの話題</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@FreeBSD.org">iwasaki@FreeBSD.org</a>&gt;</code>、
        1997 年 11 月 8 日</em></span>
    </p><div class="qandaset"><a id="idp81439824"></a><dl><dt>13.1. <a href="#idp81440080">SNAP とか RELEASE とかは何?</a></dt><dt>13.2. <a href="#idp81454416">自分用のカスタムリリースを構築するには?</a></dt><dt>13.3. <a href="#idp81473488">カスタムのインストールディスクを作るにはどうすればいいのですか? </a></dt><dt>13.4. <a href="#idp81480912">「make world」
            を行なうと既存のバイナリを上書きしてしまうのですが。</a></dt><dt>13.5. <a href="#idp81495248">システム起動時に
            「(bus speed defaulted)」 とメッセージが出ます。
          </a></dt><dt>13.6. <a href="#idp81498576">インターネットアクセスに制限があっても current を追いかけられますか?</a></dt><dt>13.7. <a href="#idp81501520">どのようにして配布ファイルを 240KB
            に分割しているのですか?</a></dt><dt>13.8. <a href="#idp81509968">私はカーネルに拡張を行ないました。
            誰に送ればいいですか? </a></dt><dt>13.9. <a href="#idp81512784">PnP ISA
            カードの検出と初期化はどのように行なうのですか? </a></dt><dt>13.10. <a href="#idp81527504">FreeBSD は、他のアーキテクチャをサポートしないんですか? </a></dt><dt>13.11. <a href="#idp81533904">デバイスドライバを開発したので、メジャー番号が欲しいのですが。</a></dt><dt>13.12. <a href="#idp81541840">代替のディレクトリ配置ポリシー</a></dt><dt>13.13. <a href="#idp81543888">カーネルパニックを最大限に利用する</a></dt><dt>13.14. <a href="#idp81605200">dlsym() が ELF 実行形式では動作しなくなります!</a></dt><dt>13.15. <a href="#idp81634896">カーネルアドレス空間を大きくしたり、
            小さくするにはどうしたら良いのですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp81440080"></a><a id="define-snap-release"></a><p><strong>13.1.</strong></p></td><td align="left" valign="top"><p>SNAP とか RELEASE とかは何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>現在、FreeBSD の
            <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">CVS リポジトリ</a>
            には、三つのアクティブ/準アクティブなブランチがあります
            (アクティブな開発ブランチは三つしか存在しないため、
            おそらく RELENG_2 ブランチの変更は年に 2 回だけになるでしょう)。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  <code class="literal">RELENG_2_2</code>
                  通称 <span class="emphasis"><em>2.2-STABLE</em></span>
                </p></li><li class="listitem"><p>
                  <code class="literal">RELENG_3</code>
                  通称 <span class="emphasis"><em>3.X-STABLE</em></span>
                </p></li><li class="listitem"><p>
                  <code class="literal">RELENG_4</code>
                  通称 <span class="emphasis"><em>4-STABLE</em></span></p></li><li class="listitem"><p><acronym class="acronym">HEAD</acronym>
                  通称 <code class="option">-CURRENT</code> あるいは
                  <span class="emphasis"><em>5.0-CURRENT</em></span></p></li></ul></div><p>
            <acronym class="acronym">HEAD</acronym>
            は他の二つと違って、
            実際のブランチタグではなく、
            <span class="emphasis"><em>「current、
              分岐していない開発本流」</em></span>のための単なるシンボリックな定数です。
            私たちはこれを <code class="literal">-CURRENT</code> と呼んでいます。
          </p><p>
            現在、
            <span class="quote">「<span class="quote">-CURRENT</span>」</span> は 5.0 の開発本流であり、
            <code class="literal">4.0-STABLE</code> ブランチ、
            つまり <code class="literal">RELENG_4</code> は
            2000 年 3 月に
            <span class="quote">「<span class="quote">-CURRENT</span>」</span> から分岐しています。
          </p><p>
            <code class="literal">2.2-STABLE</code> ブランチ、
            <code class="literal">RELENG_2_2</code> は
            1996 年 11 月に <span class="quote">「<span class="quote">-CURRENT</span>」</span> から分岐しました。
            これは保守が完全に終了しています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81454416"></a><a id="custrel"></a><p><strong>13.2.</strong></p></td><td align="left" valign="top"><p>自分用のカスタムリリースを構築するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            リリースを構築するには三つのことが必要です。まず、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vn&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">vn</span>(4)</span></a>
            ドライバが組み込まれたカーネルを実行させている必要があります。
            以下をカーネルコンフィグレーションファイルに追加し、
            カーネルを作り直してください。
          </p><pre class="programlisting">pseudo-device vn         #Vnode driver (turns a file into a device)</pre><p>
            次に、CVS リポジトリ全体を手元においておく必要があります。
            これを入手するには
            <a class="link" href="../handbook/synching.html#CVSUP" target="_top">CVSUP</a>
            が使用できますが、supfile で release の名称を cvs にして
            他のタグや date フィールドを削除する必要があります。
          </p><pre class="programlisting">*default prefix=/home/ncvs
*default base=/a
*default host=cvsup.FreeBSD.org
*default release=cvs
*default delete compress use-rel-suffix

## Main Source Tree
src-all
src-eBones
src-secure

# Other stuff
ports-all
www
doc-all</pre><p>
            そして <code class="command">cvsup -g supfile</code> を実行して自分のマシンに
            CVS リポジトリ全体をコピーします…。
          </p><p>
            最後に、ビルド用にかなりの空き領域を用意する必要があります。
            そのディレクトリを <code class="filename">/some/big/filesystem</code> として、
            上の例で CVS リポジトリを <code class="filename">/home/ncvs</code> に置いたものとすると、
            以下のようにしてリリースを構築します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>setenv CVSROOT /home/ncvs</code></strong>
 # or export CVSROOT=/home/ncvs
<code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make buildworld</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/release</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/some/big/filesystem/release</code></strong>
      </pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">ただし、すでに <code class="filename">/usr/obj</code>
            以下に構築物が存在しているなら、buildworld
            の必要は<span class="emphasis"><em>ありません</em></span>。</p></div><p>
            処理が終了すると、
            リリース全体が <code class="filename">/some/big/filesystem/release</code>
            に構築され、完全な <acronym class="acronym">FTP</acronym> インストール用の配布物が
            <code class="filename">/some/big/filesystem/release/R/ftp</code> に作成されます。
            -current 以外の開発ブランチの SNAP を自分で構築したい場合は、
            <code class="literal">RELEASETAG=SOMETAG</code>
            を上の <code class="command">make release</code> のコマンドラインに追加します。
            たとえば、<code class="literal">RELEASETAG=RELENG_2_2</code>
            とすると最新の 2.2-STABLE snapshot が構築されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81473488"></a><a id="custom-install-disks"></a><p><strong>13.3.</strong></p></td><td align="left" valign="top"><p>カスタムのインストールディスクを作るにはどうすればいいのですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">/usr/src/release/Makefile</code>
            のいろいろなターゲットとしてインストールディスク、
            ソース、バイナリアーカイブを作る完全な処理を自動的に行なうようになっています。
            <code class="filename">Makefile</code> に十分な情報があります。
            しかし、実行には <span class="quote">「<span class="quote">make world</span>」</span> が必要で、
            多くの時間とディスクの容量が必要です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81480912"></a><a id="makeworld-clobbers"></a><p><strong>13.4.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">make world</span>」</span>
            を行なうと既存のバイナリを上書きしてしまうのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ええ、それが一般的な考え方です。名前が示しているように
            <span class="quote">「<span class="quote">make world</span>」</span>
            はすべてのシステムのバイナリを最初から作り直しますので、結果として、
            クリーンで一貫性のある環境を得ることができます
            (これがそれだけ長い時間がかかる理由です)。
          </p><p>
            環境変数 <code class="literal">DESTDIR</code> を
            <span class="quote">「<span class="quote"><code class="command">make world</code></span>」</span> や
            <span class="quote">「<span class="quote"><code class="command">make install</code></span>」</span>
            を実行する時に定義しておくと、新しく作られたバイナリは
            <code class="literal">${DESTDIR}</code>を <code class="systemitem">root</code>
            とみなしたディレクトリツリーにインストールされます。
            あるでたらめな共有ライブラリの変更やプログラムの再構築によって
            <span class="quote">「<span class="quote"><code class="command">make world</code></span>」</span>
            は失敗することもあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81495248"></a><a id="bus-speed-defaulted"></a><p><strong>13.5.</strong></p></td><td align="left" valign="top"><p>システム起動時に
            <span class="quote">「<span class="quote">(<code class="computeroutput">bus speed defaulted</code>)</span>」</span> とメッセージが出ます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Adaptec の 1542 SCSI ホストアダプタは、
            ユーザがソフトウェア的にバスアクセス速度の設定を行なうことができます。
            以前のバージョンの 1542 ドライバは、
            使用可能な最大の速度を求めてアダプタをその設定にしようとしました。
            これは特定のユーザのシステムでは問題がある事がわかり、
            現在ではカーネルコンフィグオプションに
            <span class="quote">「<span class="quote"><span class="symbol">TUNE_1542</span></span>」</span> が加えられています。
            これを使用すると、これが働くシステムではディスクが速くなりますが、
            データの衝突が起きて速くはならないシステムもあるでしょう
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81498576"></a><a id="ctm"></a><p><strong>13.6.</strong></p></td><td align="left" valign="top"><p>インターネットアクセスに制限があっても current を追いかけられますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい、
            <a class="link" href="../handbook/synching.html#CTM" target="_top">CTM
              システム</a>を使って、
            ソースツリー全体のダウンロードを<span class="emphasis"><em>行なわず</em></span>に追いかけることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81501520"></a><a id="split-240k"></a><p><strong>13.7.</strong></p></td><td align="left" valign="top"><p>どのようにして配布ファイルを 240KB
            に分割しているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            比較的新しい BSD ベースのシステムでは、
            <code class="command">split</code> に任意のバイト境界で分割する
            <span class="quote">「<span class="quote"><code class="option">-b</code></span>」</span> オプションがあります。
          </p><p>
            以下は <code class="filename">/usr/src/Makefile</code> からの例です。
          </p><pre class="programlisting">bin-tarball:
              (cd ${DISTDIR}; \
              tar cf - . \
              gzip --no-name -9 -c | \
              split -b 240640 - \
              ${RELEASEDIR}/tarballs/bindist/bin_tgz.)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81509968"></a><a id="submitting-kernel-extensions"></a><p><strong>13.8.</strong></p></td><td align="left" valign="top"><p>私はカーネルに拡張を行ないました。
            誰に送ればいいですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="../handbook/contrib.html" target="_top">FreeBSD
              ハンドブックの「FreeBSD への貢献」</a>を参照してください。
          </p><p>
            あなたのアイディアに感謝します!
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81512784"></a><a id="pnp-initialize"></a><p><strong>13.9.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">PnP</acronym> <acronym class="acronym">ISA</acronym>
            カードの検出と初期化はどのように行なうのですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="mailto:uhclem@nemesis.lonestar.org" target="_top">Frank Durda IV 氏</a> より:
          </p><div class="blockquote"><blockquote class="blockquote"><p>
              要点は、ホストが認識されていないボードを探す時に、すべての
              PnP ボードが応答することのできる少数の I/O
              ポートがあるということです。
              それにより、PnP プローブルーチンが開始したとき、PnP
              ボードが存在するなら、すべての PnP ボードは自分のモデル番号を返します。
              そのポートを I/O read するとプローブルーチンは問いに対するワイアード-OR
              された <span class="quote">「<span class="quote">yes</span>」</span> を得ます。この場合は
              少なくとも 1 ビットが ON になります。
              そして、プローブルーチンはモデル ID (Microsoft/Intel
              によって割り当てられています)が X より小さいボードを
              <span class="quote">「<span class="quote">オフライン</span>」</span> にすることができます。
              この操作を行ない、問い合わせに応答しているボードがまだ
              残っているかどうかを調べます。
              もし <span class="quote">「<span class="quote"><code class="literal">0</code></span>」</span> が返ってくるなら X
              より大きな ID を持つボードはないことになります。
              今度は <span class="quote">「<span class="quote">X</span>」</span>
              よりも小さな値を持つボードについて問い合わせます。
              もしあるのであれば、
              プローブルーチンはモデル番号が X より小さいことを知ります。
              今度は、X-(limit/4)
              より大きな値を持つボードをオフラインにして問い合わせを繰り返します。
              この ID の範囲による準バイナリサーチを十分繰り返すことにより、
              プローブルーチンはマシンに存在するすべての
              PnP ボードの値を最終的に得ることができます。その繰り返しの回数は
              2^64 よりはるかに少ない回数です。
            </p><p>
              ID は二つの 32-bit (つまり 64bit) フィールド + 8 bit
              チェックサムからなります。最初の 32 bits はベンダの識別子です。
              これは公表されてはいませんが、
              同一のベンダから供給されている異なるタイプのボードでは異なる
              32-bit ベンダ ID を持つことができるように考えられます。
              製造元を特定するだけのために 32-bit
              はいくらか過剰です。
            </p><p>
              下位の 32-bit はシリアル番号、
              イーサネットアドレスなどのボードを特定するものです。
              ベンダは上位 32 bits が異なっていないのであれば、
              下位 32-bit が同一である 2枚目のボードを製造することはありません。
              したがって、同じタイプの複数のボードをマシンにいれることができ、
              この場合でも 64-bit
              全体ではユニークです。
            </p><p>
              32-bit のフィールドはすべてを 0 にすることはできません。
              これは初期化のバイナリサーチの間ワイアード-OR
              によって 0 ではない
              ビットを参照するからです。
            </p><p>
              システムがすべてのボードの与えられた ID を認識すると、
              それぞれのボードに対応した処理を一つずつ (同一の
              I/O ポートを通して) 行ないます。
              そして、利用できる割り込みの選択などのボードが必要とするリソースを検出します。
              すべてのボードについてこの情報を集めます。
            </p><p>
              この情報はハードディスク上の ECU ファイルなどの情報とまとめられ、
              マザーボードの BIOS にも結合されます。
              マザーボード上のハードウェアへの ECU と
              BIOS PnP のサポートは通常は統合されていますが、
              周辺機器については真の PnPであるとはいえません。
              しかし、BIOS の情報に ECU の情報を加えて調査することで、
              プローブルーチンは PnP
              デバイスが再配置できなくなることを避けることができます。
            </p><p>
              それから、再度 PnP デバイスにアクセスし、I/O、DMA、IRQ、
              メモリマップアドレスの設定をします。
              デバイスはこのアドレスに見えるようになり、
              次に再起動するまでこの位置を占めます。しかし、
              あなたの望む時に移動させることが不可能である、
              といっているわけではありません。
            </p><p>
              以上の話では大きく単純化をしてありますが、
              基本的な考え方は得られたでしょう。
            </p><p>
              マイクロソフトは、ボードのロジックが対立する
              I/O サイクルではデコードしていない (訳注:
              おそらく read 時しかデコードされていず
              write 時はポートが空いているという意味でしょう)、
              プライマリプリンタのステータスポートのいくつかを PnP
              のために占有しました。
              私は初期の PnP の提案レビュー時に IBM
              純正のプリンタボードでステータスポートの write
              のデコードがされているということに気がつきましたが、
              MS は <span class="quote">「<span class="quote">tough (頑固、不運、無法な)</span>」</span>
              と言っています。
              そしてプリンタのステータスポートへアドレスの設定のために
              write を行なっています。また、
              そのアドレス + <code class="literal">0x800</code> と
              read のための 3番目の I/O ポートが
              <code class="literal">0x200</code> から
              <code class="literal">0x3ff</code> の間のどこかに置かれるでしょう。
            </p></blockquote></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81527504"></a><a id="architectures"></a><p><strong>13.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD は、他のアーキテクチャをサポートしないんですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            いくつかのグループの人々が、FreeBSD
            の他のアーキテクチャへの移植に関心を示しており、
            FreeBSD/AXP (ALPHA) はこれらの成果としてはとても成功したものの一つです。
            FreeBSD/AXP は現在
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</a>
            から入手できます。
            ALPHA への移植版が現在動く機種は増えつつあり、
            その中には AlphaStation、AXPpci、PC164、Miata そして Multia
            といったモデルが含まれています。
            現状についての情報を得るには
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-alpha@FreeBSD.org">freebsd-alpha@FreeBSD.org</a>&gt;</code><a class="link" href="#mailing" title="11.">メーリングリスト</a>に参加してください。
          </p><p>
            その他に FreeBSD の SPARC アーキテクチャへの移植があります。
            プロジェクトへの参加に興味がある方は
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-sparc@FreeBSD.org">freebsd-sparc@FreeBSD.org</a>&gt;</code><a class="link" href="#mailing" title="11.">メーリングリスト</a>
            に参加してください。
            進行中のプラットホームのリストにもっとも最近追加されたのが
            IA-64 と PowerPCです。詳細は
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-ia64@FreeBSD.org">freebsd-ia64@FreeBSD.org</a>&gt;</code> および/あるいは
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-ppc@FreeBSD.org">freebsd-ppc@FreeBSD.org</a>&gt;</code><a class="link" href="#mailing" title="11.">メーリングリスト</a>に参加してください。
            新しいアーキテクチャに関する一般的な議論については
            新しいアーキテクチャに関する一般的な議論については
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-platforms@FreeBSD.org">freebsd-platforms@FreeBSD.org</a>&gt;</code><a class="link" href="#mailing" title="11.">メーリングリスト</a>
            へ参加してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81533904"></a><a id="major-numbers"></a><p><strong>13.11.</strong></p></td><td align="left" valign="top"><p>デバイスドライバを開発したので、メジャー番号が欲しいのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは、開発したドライバを公開するかどうかに依存します。
            公開するのであれば、ドライバのソースコード、
            <code class="filename">files.i386</code> の変更、
            コンフィグファイルのサンプル、
            デバイスが使うスペシャルファイルを作成する
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">MAKEDEV</span>(8)</span></a>
            のコードを私たちに送ってください。
            公開するつもりがない場合、ライセンスの問題により公開できない場合は、
            キャラクタメジャー番号 32 および、
            ブロックメジャー番号 8 がこのような目的のために予約されています。
            これらの番号を使用してください。
            どちらの場合であれ、ドライバに関する情報を
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers" target="_top">FreeBSD technical discussions メーリングリスト</a>
            に流して頂けると助かります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81541840"></a><a id="alternate-directory-layout"></a><p><strong>13.12.</strong></p></td><td align="left" valign="top"><p>代替のディレクトリ配置ポリシー</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在使われているディレクトリの配置ポリシーは、
            私が 1983 年に書いたものから全く変更されていません。
            私は当初の配置ポリシーを、オリジナルの fast filesystem のために書き、
            まったく改定していません。
            このポリシーはシリンダグループを使い尽くすのを防ぐにはうまくいきましたが、
            お気づきの方もいる通り find の動作には不適切です。
            ほとんどのファイルシステムの内容は、
            深さ優先検索 (ftw とも呼ばれます) によって作られたアーカイブから、
            抽出 (restore) して作成されます。この際、
            ディレクトリは、シリンダグループにまたがって配置され、
            以降の深さ優先検索を行うには、
            考え得る限り最悪の状態になります。
            もし作成するディレクトリの総数がわかっていれば、
            解決方法はあります。(総数/シリンダグループ数) 個のディレクトリを、
            シリンダグループごとにまとめて作成すれば良いのです。
            もちろん最適なディレクトリ配置になるように、
            総数を予測する方法を考えなければなりません。
            しかし仮にシリンダグループあたりのディレクトリ数を
            10 くらいの小さな数に固定してしまったとしても、
            大幅な改善が望めるでしょう。
            このポリシーを用いるべきリストア作業を、通常の作業
            (おそらく既存のポリシーを使用したほうが良いでしょう)
            を区別するには、
            10 秒間の間に作成されたディレクトリを最大
            10 個までまとめて単一のシリンダグループに書き込むという手順が使えるでしょう。
            とにかく私の結論は、そろそろ実験を始めて見る時期だろうということです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81543888"></a><a id="kernel-panic-troubleshooting"></a><p><strong>13.13.</strong></p></td><td align="left" valign="top"><p>カーネルパニックを最大限に利用する</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                この節は、freebsd-current <a class="link" href="#mailing" title="11.">メーリングリスト</a>に
                Bill Paul 氏が投稿したメールを、
                Dag-Erling C. Smørgrav 氏が校正し、[] 内のコメントを追加して引用したものです。
              </p></div><pre class="programlisting">From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: ben@rosengart.com
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.ORG</pre><p><span class="emphasis"><em>[&lt;ben@rosengart.com&gt; が以下のパニックメッセージを投稿しました。]</em></span></p><pre class="programlisting">&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</pre><p>
            このようなメッセージが表示された場合、問題が起きる状況を確認して、
            情報を送るだけでは十分ではありません。
            下線をつけた命令ポインタ値は重要な値ですが、
            残念ながらこの値は構成に依存します。つまり、
            この値は使っているカーネルのイメージに依存するのです。
            もしスナップショットなどの GENERIC カーネルを使っているのであれば、
            他の人間が問題のある関数について追試をすることができますが、
            カスタマイズされたカーネルの場合は、
            使っている本人にしか問題の起こった場所は特定できないのです。
          </p><p>
            何をすれば良いのでしょう?
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  命令ポインタ値をメモします。
                  <code class="literal">0x8:</code> という部分は今回必要ありません。
                  必要なのは <code class="literal">0xf0xxxxxx</code> という部分です。
                </p></li><li class="step"><p>
                  システムが再起動したら、以下の操作を行います。

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</code></strong></pre><p>

                  ここで、<code class="literal">f0xxxxxx</code> は命令ポインタ値です。
                  カーネルシンボルのテーブルは関数のエントリポイントを含み、
                  命令ポインタ値は、関数内部のある点であり最初の点ではないため、
                  この操作を行っても完全に一致するものが表示されない場合もあります。
                  この場合は、
                  最後の桁を省いてもういちどやってみてください。
                  このようになります。

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</code></strong></pre><p>

                  これでも一致しない場合は、
                  桁を減らしながら何らかの出力があるまで繰り返してください。
                  何か出力されたら、
                  それがカーネルパニックを引き起こした可能性のある関数のリストです。
                  これは、問題点を見付ける正確な方法ではありませんが、何もないよりましです。
                </p></li></ol></div><p>
            このようなパニックメッセージを投稿している人はよく見掛けますが、
            このように、命令ポインタ値を、
            カーネルシンボルテーブルの中の関数とつき合わせて調べている人はまれです。
          </p><p>
            パニックの原因を突き止める最良の方法は、クラッシュダンプをとり、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> でスタックトレースを行うことです。
          </p><p>
            どっちにしろ、私は普通以下のようにします。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  カーネルコンフィグファイルを作ります。
                  カーネルデバッガが必要そうであれば
                  <code class="literal">options 'DDB'</code>
                  を加えても良いです (私は永久ループが起こっていそうな場合に、
                  ブレークポイントを設定するのに使っています)。
                </p></li><li class="step"><p>
                  <code class="command">config -g KERNELCONFIG</code>
                  としてビルドディレクトリを設定します。
                </p></li><li class="step"><p>
                  <code class="command">cd /sys/compile/KERNELCONFIG; make</code> を実行します。
                </p></li><li class="step"><p>カーネルのコンパイルが終了するのを待ちます。</p></li><li class="step"><p><code class="command">make install</code> を実行します。</p></li><li class="step"><p>再起動します。</p></li></ol></div><p>
              <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> プロセスは２つのカーネル、
            <code class="filename">kernel</code> と
            <code class="filename">kernel.debug</code> をビルドします。
            <code class="filename">kernel</code> は <code class="filename">/kernel</code>
            としてインストールされ、
            <code class="filename">kernel.debug</code> は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>
            のデバッグ用シンボル情報を取り出すために利用されます。
          </p><p>
            確実にクラッシュダンプをとるには、<code class="filename">/etc/rc.conf</code>
            を編集して <code class="literal">dumpdev</code>
            を使用しているスワップパーティションに指定する必要があります。
            こうすると <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> スクリプトから
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> コマンドが実行され、
            クラッシュダンプ機能が有効になります。
            手動で <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> コマンドを実行してもかまいません。
            パニックの後、クラッシュダンプは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
            コマンドを使用して取り出すこと ができます。
            <code class="literal">dumpdev</code> が
            <code class="filename">/etc/rc.conf</code> で設定されていれば、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> スクリプトから
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> が自動的に実行され、クラッシュダンプを
            <code class="filename">/var/crash</code> に保存します。
           </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD のクラッシュダンプのサイズは、
                ふつう物理メモリサイズと同じです。
                つまり 64MB のメモリを積んでいれば、
                64MB のクラッシュダンプが生成されることになります。
                <code class="filename">/var/crash</code>
                に十分な空き容量があることを確認してください。手動で
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> を実行すれば、
                もっと空き容量のあるディレクトリにクラッシュダンプを保存できます。
                <code class="literal">options MAXMEM=(foo)</code>
                という行をカーネルコンフィグファイルに追加することで、
                カーネルのメモリ使用量を制限できます。
                たとえば 128MB のメモリがある場合も、
                カーネルのメモリ使用量を 16MB
                に制限し、クラッシュダンプのサイズも
                128MB ではなく 16MB にすることができます。
              </p></div><p>
            クラッシュダンプを取り出せたら、
            以下のように <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>
            を使ってスタックトレースをとります。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>where</code></strong></pre><p>
            必要な情報が 1 画面に収まらないことも多いので、できれば
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> を使って出力を記録します。
            strip していないカーネルイメージを使うことで、
            すべてのデバッグシンボルが参照でき、
            パニックの発生したカーネルのソースコードの行が表示されているはずです。
            通常、正確なクラッシュへの過程を追跡するには、
            出力を最後の行から逆方向に読まなければなりません。
            また <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> を使って、
            変数や構造体の内容を表示させ、
            クラッシュした時のシステムの状態を調べられます。
          </p><p>
            もしあなたがデバッグ狂で、同時に別のコンピュータを利用できる環境にあれば、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> をリモートデバッグに使うこともできます。
            リモートデバッグを使うと、あるコンピュータ上の
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> を使って、
            別のコンピュータのカーネルをデバッグできます。
            ブレークポイントの設定、カーネルコードのステップ実行など、
            ふつうのプログラムのデバッグと変わりません。
            コンピュータを 2 台並べてデバッグするチャンスにはなかなか恵まれないので、
            私はまだリモートデバッグを試したことはありません。
          </p><div xmlns="" class="note"><h3 class="admontitle">Bill による追記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                DDB を有効にしていてカーネルがデバッガに
                落ちたら、ddb のプロンプトで "<code class="command">panic</code>"
                と入力すれば、強制的にパニックを起こしクラッシュダンプさせることができます。
                パニックの途中で、再びデバッガに落ちるかもしれませんが、
                "<code class="command">continue</code>"
                と入力すれば、
                クラッシュダンプを最後まで実行させられます。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81605200"></a><a id="dlsym-failure"></a><p><strong>13.14.</strong></p></td><td align="left" valign="top"><p><code class="function">dlsym()</code> が ELF 実行形式では動作しなくなります!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <acronym class="acronym">ELF</acronym> のツール類は、
            デフォルトでは実行形式の中に定義されているシンボルを、
            ダイナミックリンカから見えるようにはしません。
            このため、<code class="function">dlopen(NULL, flags)</code>
            を呼び出して得られたハンドルに対して、
            <code class="function">dlsym()</code> で探索を行っても、
            こういったシンボルを見つけられません。
          </p><p>
            もし、あなたがプロセスの中心にあたる実行形式の中にあるシンボルを探索したければ、
            ELF リンカ (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>) に
            <code class="option">-export-dynamic</code>
            オプションを付けて実行形式をリンクする必要があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81634896"></a><a id="change-kernel-address-space"></a><p><strong>13.15.</strong></p></td><td align="left" valign="top"><p>カーネルアドレス空間を大きくしたり、
            小さくするにはどうしたら良いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            カーネルアドレス空間は、FreeBSD 3.X 上で
            256MB、FreeBSD 4.X 上で 1GB がデフォルトになっています。
            負荷の高いネットワークサーバ (たとえば大きな FTP、HTTP サーバ)
            を運用する場合は、256MB では足りないことに気付くかも知れません。
          </p><p>
            では、アドレス空間を大きくするにはどうしたら良いのでしょうか?
            それには、二つの段階を踏みます。まず、
            より大きいアドレス空間を割り当てることをカーネルに知らせる必要があります。
            次に、カーネルはアドレス空間の先頭にロードされるため、
            アドレスの先頭が天井
            (訳注:カーネルアドレス空間の最下端アドレスのこと) と
            ぶつかることのないように、ロードアドレスを今までより低位に設定する必要があります。
          </p><p>
            最初の段階は、<code class="filename">src/sys/i386/include/pmap.h</code> にある
            <code class="literal">NKPDE</code> の値を増加させることで行ないます。
            ここに 1GB のアドレス空間にするために、どのようにすれば良いかを示します。
          </p><pre class="programlisting">#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</pre><p>
            正確な <code class="literal">NKPDE</code> の値を計算するには、
            望みのアドレス空間の大きさ (メガバイト単位) を 4 で割って、
            それから単一プロセッサ (UP) なら 1、SMP なら 2 を引き算してください。
          </p><p>
            次の段階を行なうには、ロードアドレスを正確に計算することが必要です。
            単純に、アドレス空間の大きさ
            (バイト単位) を 0x100100000 から引き算してください。
            1GB アドレス空間の場合、その結果は 0xc0100000 になります。
            そして、<code class="filename">src/sys/i386/conf/Makefile.i386</code> にある
            <span class="symbol">LOAD_ADDRESS</span> に、今計算した値を入れます。また、次のように
            <code class="filename">src/sys/i386/conf/kernel.script</code>
            のセクションの始めの方にあるロケーションカウンタにも同じ値を入れてください。
          </p><pre class="programlisting">OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</pre><p>
            それが完了したら、<code class="command">config</code> し直してカーネルを再構築してください。
            おそらく、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a>、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>
            などに不具合が出るでしょう。
            それらを正常にするために、<code class="command">make world</code>
            (もしくは、変更した <code class="filename">pmap.h</code> を
            <code class="filename">/usr/include/vm/</code> にコピーした後に、
            <code class="filename">libkvm</code>、
            <code class="command">ps</code> および <code class="command">top</code>
            を手動で再構築すること) を行なうべきです。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">カーネルアドレス空間の大きさは、4MB の倍数である必要があります。</p></div><div xmlns="" class="note"><h3 class="admontitle">David Greenman 氏による補足: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                カーネルアドレス空間は 2 の乗数である必要があると思いますが、
                それが確かなことかどうかははっきりしていません。
                昔の起動コードには、良く高位アドレスビットのトリックが使われていたため、
                少なくとも 256MB の粒度であることが想定されていたと思います。
              </p></div></td></tr></tbody></table></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="acknowledgments"></a>第14章 謝辞</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        こがよういちろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:y-koga@ccs.mt.nec.co.jp">y-koga@ccs.mt.nec.co.jp</a>&gt;</code>、
        1997 年 11 月 10 日</em></span>
    </p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top">〓</td><td width="80%" valign="top"><p>
        この FAQ について問題を見つけたり、何か登録したい場合は、
        FAQ 保守担当者 <code class="email">&lt;<a xmlns="" class="email" href="mailto:faq@FreeBSD.org">faq@FreeBSD.org</a>&gt;</code> までメールを送ってください。
        フィードバックしてくれるみなさんには感謝感謝なのです。
        みなさんに手伝ってもらわないとこの FAQ はよくなりませんから!
      </p></td><td width="10%" valign="top">〓</td></tr><tr><td width="10%" valign="top">〓</td><td colspan="2" align="right" valign="top">--<span class="attribution">FreeBSD Core Team</span></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Jordan K. Hubbard</span></dt><dd><p>たまに起こす FAQ の並べ替えや更新の発作</p></dd><dt><span class="term">Doug White</span></dt><dd><p>freebsd-questions メーリングリストでの義務を超えたサービス</p></dd><dt><span class="term">Jörg Wunsch</span></dt><dd><p>Usenet (NetNews) での義務を超えたサービス</p></dd><dt><span class="term">Garrett Wollman</span></dt><dd><p>ネットワーク節の執筆と文書整形</p></dd><dt><span class="term">Jim Lowe</span></dt><dd><p>マルチキャストについて</p></dd><dt><span class="term">Peter da Silva</span></dt><dd><p>FreeBSD FAQ タイピング機械奴隷</p></dd><dt><span class="term">FreeBSD チーム</span></dt><dd><p>不平を言ったり、うめいたり、情報提供してくれたり</p></dd></dl></div><p>
      あと、抜けてしまった他の方々に対して、謝罪と心からの感謝を捧げます!
    </p></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="jcontrib"></a>第15章 FreeBSD FAQ 日本語化について</h1></div></div></div><p>
      FreeBSD 日本語ドキュメンテーションプロジェクトは、
      FreeBSD 関係の日本語文書が少ないことを嘆いた数人の
      FreeBSD ユーザの提唱によって 1996 年 2 月 26 日にスタートし、
      FreeBSD 日本語ハンドブックの作成をはじめとした活動を行なってきました。
      FreeBSD FAQ の日本語化についてはオリジナルの翻訳作業だけでなく、
      日本国内に固有の話題についても広く情報を集め、
      日本の FreeBSD ユーザにとって真に有益なドキュメントを提供しようと考えています。
      オリジナルの FAQ は日毎に更新されており、
      私たちもまたこれに追い付くために作業を続けていきます。もちろん、新しいメンバも大歓迎です。
      日本語翻訳版について、何かお気づきの点がありましたら、
      日本語ドキュメンテーションプロジェクト <code class="email">&lt;<a xmlns="" class="email" href="mailto:doc-jp@jp.FreeBSD.org">doc-jp@jp.FreeBSD.org</a>&gt;</code>
      までご連絡ください。
      また、もし私たちの作業を手伝ってくれるなら、
      <a class="link" href="http://www.jp.FreeBSD.org/doc-jp/" target="_top">FreeBSD
        日本語ドキュメンテーションプロジェクトのページ</a>をご覧の上、是非参加してください。
    </p><h3 class="title"><a id="idp81697872"></a>翻訳者 (五十音順)</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>有村 光晴 <code class="email">&lt;<a xmlns="" class="email" href="mailto:arimura@jp.FreeBSD.org">arimura@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>一宮 亮 <code class="email">&lt;<a xmlns="" class="email" href="mailto:ryo@azusa.shinshu-u.ac.jp">ryo@azusa.shinshu-u.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@FreeBSD.org">iwasaki@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>内川 喜章 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yoshiaki@kt.rim.or.jp">yoshiaki@kt.rim.or.jp</a>&gt;</code></p></li><li class="listitem"><p>栗山 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:kuriyama@FreeBSD.org">kuriyama@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>こがよういちろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:y-koga@ccs.mt.nec.co.jp">y-koga@ccs.mt.nec.co.jp</a>&gt;</code></p></li><li class="listitem"><p>今野 元之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:motoyuki@FreeBSD.org">motoyuki@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>杉村 貴士 <code class="email">&lt;<a xmlns="" class="email" href="mailto:sugimura@jp.FreeBSD.org">sugimura@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>中井 幸博 <code class="email">&lt;<a xmlns="" class="email" href="mailto:nakai@mlab.t.u-tokyo.ac.jp">nakai@mlab.t.u-tokyo.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>にしか <code class="email">&lt;<a xmlns="" class="email" href="mailto:nishika@cheerful.com">nishika@cheerful.com</a>&gt;</code></p></li><li class="listitem"><p>花井 浩之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:hanai@FreeBSD.org">hanai@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>はらだ きろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:kiroh@jp.FreeBSD.org">kiroh@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>広瀬 昌一 <code class="email">&lt;<a xmlns="" class="email" href="mailto:shou@kt.rim.or.jp">shou@kt.rim.or.jp</a>&gt;</code></p></li><li class="listitem"><p>福間 康弘 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yasuf@big.or.jp">yasuf@big.or.jp</a>&gt;</code></p></li><li class="listitem"><p>むらたしゅういちろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:mrt@mickey.ai.kyutech.ac.jp">mrt@mickey.ai.kyutech.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>山下 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:junkun@esys.tsukuba.ac.jp">junkun@esys.tsukuba.ac.jp</a>&gt;</code></p></li></ul></div><h3 class="title"><a id="idp81715408"></a>査読者 (五十音順)</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>浅見 賢 <code class="email">&lt;<a xmlns="" class="email" href="mailto:asami@FreeBSD.org">asami@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@FreeBSD.org">iwasaki@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>内川 喜章 <code class="email">&lt;<a xmlns="" class="email" href="mailto:yoshiaki@kt.rim.or.jp">yoshiaki@kt.rim.or.jp</a>&gt;</code></p></li><li class="listitem"><p>大橋 健 <code class="email">&lt;<a xmlns="" class="email" href="mailto:ohashi@mickey.ai.kyutech.ac.jp">ohashi@mickey.ai.kyutech.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>栗山 淳 <code class="email">&lt;<a xmlns="" class="email" href="mailto:kuriyama@FreeBSD.org">kuriyama@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>今野 元之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:motoyuki@FreeBSD.org">motoyuki@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>佐伯 隆司 <code class="email">&lt;<a xmlns="" class="email" href="mailto:saeki@jp.FreeBSD.org">saeki@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>杉村 貴士 <code class="email">&lt;<a xmlns="" class="email" href="mailto:sugimura@jp.FreeBSD.org">sugimura@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>花井 浩之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:hanai@FreeBSD.org">hanai@FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>浜田 直樹 <code class="email">&lt;<a xmlns="" class="email" href="mailto:nao@tom-yam.or.jp">nao@tom-yam.or.jp</a>&gt;</code></p></li><li class="listitem"><p>はらだ きろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:kiroh@jp.FreeBSD.org">kiroh@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>日野 浩志 <code class="email">&lt;<a xmlns="" class="email" href="mailto:hino@ccm.cl.nec.co.jp">hino@ccm.cl.nec.co.jp</a>&gt;</code></p></li><li class="listitem"><p>檜山  卓 <code class="email">&lt;<a xmlns="" class="email" href="mailto:shiyama@intercity.or.jp">shiyama@intercity.or.jp</a>&gt;</code></p></li><li class="listitem"><p>広瀬 昌一 <code class="email">&lt;<a xmlns="" class="email" href="mailto:shou@kt.rim.or.jp">shou@kt.rim.or.jp</a>&gt;</code></p></li><li class="listitem"><p>むらたしゅういちろう <code class="email">&lt;<a xmlns="" class="email" href="mailto:mrt@mickey.ai.kyutech.ac.jp">mrt@mickey.ai.kyutech.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>若井  久史 <code class="email">&lt;<a xmlns="" class="email" href="mailto:earth@hokuto7.or.jp">earth@hokuto7.or.jp</a>&gt;</code></p></li></ul></div><h3 class="title"><a id="idp81737040"></a>作業環境整備 (五十音順)</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>一宮 亮 <code class="email">&lt;<a xmlns="" class="email" href="mailto:ryo@azusa.shinshu-u.ac.jp">ryo@azusa.shinshu-u.ac.jp</a>&gt;</code></p></li><li class="listitem"><p>岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@jp.FreeBSD.org">iwasaki@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>下川 英敏 <code class="email">&lt;<a xmlns="" class="email" href="mailto:simokawa@jp.FreeBSD.org">simokawa@jp.FreeBSD.org</a>&gt;</code></p></li><li class="listitem"><p>鈴木  秀幸 <code class="email">&lt;<a xmlns="" class="email" href="mailto:hideyuki@jp.FreeBSD.org">hideyuki@jp.FreeBSD.org</a>&gt;</code></p></li></ul></div></div><div class="bibliography"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="bibliography"></a>有用な書籍</h1></div></div></div><div class="biblioentry"><a id="biblio-44sysman"></a><p>[biblio-44sysman] <span class="biblioset"><em>4.4BSD System Manager's Manual</em>. <span class="author"><span class="orgname">Computer Systems Research Group, University of
          California, Berkeley. </span></span><span class="publisher"><span class="publishername">O'Reilly and Associates. </span></span><span class="edition">1st Edition. </span><span class="pubdate">June 1994. </span><span class="pagenums">804 pages. </span><span class="biblioid">ISBN 1-56592-080-5. </span></span></p></div><div class="biblioentry"><a id="biblio-44userman"></a><p>[biblio-44userman] <span class="biblioset"><em>4.4BSD User's Reference Manual</em>. <span class="author"><span class="orgname">Computer Systems Research Group, University of
          California, Berkeley. </span></span><span class="publisher"><span class="publishername">O'Reilly and Associates. </span></span><span class="edition">1st Edition. </span><span class="pubdate">June 1994. </span><span class="pagenums">905 pages. </span><span class="biblioid">ISBN 1-56592-075-9. </span></span></p></div><div class="biblioentry"><a id="biblio-44suppman"></a><p>[biblio-44suppman] <span class="biblioset"><em>4.4BSD User's Supplementary Documents</em>. <span class="author"><span class="orgname">Computer Systems Research Group, University of
          California, Berkeley. </span></span><span class="publisher"><span class="publishername">O'Reilly and Associates. </span></span><span class="edition">1st Edition. </span><span class="pubdate">June 1994. </span><span class="pagenums">712 pages. </span><span class="biblioid">ISBN 1-56592-076-7. </span></span></p></div><div class="biblioentry"><a id="biblio-44progman"></a><p>[biblio-44progman] <span class="biblioset"><em>4.4BSD Programmer's Reference Manual</em>. <span class="author"><span class="orgname">Computer Systems Research Group, University of
         California, Berkeley. </span></span><span class="publisher"><span class="publishername">O'Reilly and Associates. </span></span><span class="edition">1st Edition. </span><span class="pubdate">June 1994. </span><span class="pagenums">866 pages. </span><span class="biblioid">ISBN 1-56592-078-3. </span></span></p></div><div class="biblioentry"><a id="biblio-44progsupp"></a><p>[biblio-44progsupp] <span class="biblioset"><em>4.4BSD Programmer's Supplementary Documents</em>. <span class="author"><span class="orgname">Computer Systems Research Group, University of
          California, Berkeley. </span></span><span class="publisher"><span class="publishername">O'Reilly and Associates. </span></span><span class="edition">1st Edition. </span><span class="pubdate">June 1994. </span><span class="pagenums">596 pages. </span><span class="biblioid">ISBN 1-56592-079-1. </span></span></p></div><div class="biblioentry"><a id="biblio-44kernel"></a><p>[biblio-44kernel] <span class="biblioset"><em>The Design and Implementation of the 4.4BSD Operating System</em>. <span class="authorgroup"><span class="surname">McKusick</span> <span class="firstname">M. K.</span> [FAMILY Given], <span class="surname">Marshall</span> <span class="firstname">Kirk</span> [FAMILY Given], <span class="surname">Bostic</span> <span class="firstname">Keith</span> [FAMILY Given], <span class="surname">Karels</span> <span class="firstname">Michael J</span> [FAMILY Given], 、 <span class="surname">Quarterman</span> <span class="firstname">John</span> [FAMILY Given]. </span><span class="publisher"><span class="publishername">Addison-Wesley. </span><span class="address">
            <span class="city">Reading</span>
            <span class="state">MA</span>
          . </span></span><span class="pubdate">1996. </span><span class="biblioid">ISBN 0-201-54979-4. </span></span></p></div><div class="biblioentry"><a id="biblio-nemeth3rd"></a><p>[biblio-nemeth3rd] <span class="biblioset"><em>Unix System Administration Handbook</em>. <span class="authorgroup"><span class="surname">Nemeth</span> <span class="firstname">Evi</span> [FAMILY Given], <span class="surname">Snyder</span> <span class="firstname">Garth</span> [FAMILY Given], <span class="surname">Seebass</span> <span class="firstname">Scott</span> [FAMILY Given], <span class="surname">Hein</span> <span class="firstname">Trent R.</span> [FAMILY Given], 、 <span class="surname">Quarterman</span> <span class="firstname">John</span> [FAMILY Given]. </span><span class="publisher"><span class="publishername">Prentice-Hall. </span></span><span class="edition">3rd edition. </span><span class="pubdate">2000. </span><span class="biblioid">ISBN 0-13-020601-6. </span></span></p></div><div class="biblioentry"><a id="lehey3rd"></a><p>[lehey3rd] <span class="biblioset"><em>The Complete FreeBSD</em>. <span class="author"><span class="surname">Lehey</span> <span class="firstname">Greg</span> [FAMILY Given]. </span><span class="publisher"><span class="publishername">Walnut Creek. </span></span><span class="edition">3rd edition. </span><span class="pubdate">June 1999. </span><span class="pagenums">773 pages. </span><span class="biblioid">ISBN 1-57176-246-9. </span></span></p></div><div class="biblioentry"><a id="biblio-mckusick-1"></a><p>[<abbr class="abbrev">McKusick et al, 1994</abbr>] <span class="biblioset"><em>Berkeley Software Architecture Manual, 4.4BSD
          Edition</em>. <span class="authorgroup"><span class="surname">McKusick</span> <span class="firstname">M. K.</span> [FAMILY Given], <span class="surname">Karels</span> <span class="firstname">M. J.</span> [FAMILY Given], <span class="surname">Leffler</span> <span class="firstname">S. J.</span> [FAMILY Given], <span class="surname">Joy</span> <span class="firstname">W. N.</span> [FAMILY Given], 、 <span class="surname">Faber</span> <span class="firstname">R. S.</span> [FAMILY Given]. </span><span class="pagenums">5:1-42. </span></span></p></div></div></div></body></html>