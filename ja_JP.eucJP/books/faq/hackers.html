<?xml version="1.0" encoding="euc-jp" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>第13章 まじめな FreeBSD ハッカーだけの話題</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="up" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="prev" href="misc.html" title="第12章 その他の質問" /><link rel="next" href="acknowledgments.html" title="第14章 謝辞" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第13章 まじめな FreeBSD ハッカーだけの話題</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="misc.html">戻る</a>〓</td><th width="60%" align="center">〓</th><td width="20%" align="right">〓<a accesskey="n" href="acknowledgments.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="hackers"></a>第13章 まじめな FreeBSD ハッカーだけの話題</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        岩崎 満 <code class="email">&lt;<a xmlns="" class="email" href="mailto:iwasaki@FreeBSD.org">iwasaki@FreeBSD.org</a>&gt;</code>、
        1997 年 11 月 8 日</em></span>
    </p><div class="qandaset"><a id="idp83245776"></a><dl><dt>13.1. <a href="hackers.html#idp83246032">SNAP とか RELEASE とかは何?</a></dt><dt>13.2. <a href="hackers.html#idp83264464">自分用のカスタムリリースを構築するには?</a></dt><dt>13.3. <a href="hackers.html#idp83287760">カスタムのインストールディスクを作るにはどうすればいいのですか? </a></dt><dt>13.4. <a href="hackers.html#idp83290960">「make world」
            を行なうと既存のバイナリを上書きしてしまうのですが。</a></dt><dt>13.5. <a href="hackers.html#idp83297104">システム起動時に
            「(bus speed defaulted)」 とメッセージが出ます。
          </a></dt><dt>13.6. <a href="hackers.html#idp83300432">インターネットアクセスに制限があっても current を追いかけられますか?</a></dt><dt>13.7. <a href="hackers.html#idp83307600">どのようにして配布ファイルを 240KB
            に分割しているのですか?</a></dt><dt>13.8. <a href="hackers.html#idp83311824">私はカーネルに拡張を行ないました。
            誰に送ればいいですか? </a></dt><dt>13.9. <a href="hackers.html#idp83318864">PnP ISA
            カードの検出と初期化はどのように行なうのですか? </a></dt><dt>13.10. <a href="hackers.html#idp83329360">FreeBSD は、他のアーキテクチャをサポートしないんですか? </a></dt><dt>13.11. <a href="hackers.html#idp83372752">デバイスドライバを開発したので、メジャー番号が欲しいのですが。</a></dt><dt>13.12. <a href="hackers.html#idp83376464">代替のディレクトリ配置ポリシー</a></dt><dt>13.13. <a href="hackers.html#idp83378512">カーネルパニックを最大限に利用する</a></dt><dt>13.14. <a href="hackers.html#idp83460304">dlsym() が ELF 実行形式では動作しなくなります!</a></dt><dt>13.15. <a href="hackers.html#idp83490000">カーネルアドレス空間を大きくしたり、
            小さくするにはどうしたら良いのですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp83246032"></a><a id="define-snap-release"></a><p><strong>13.1.</strong></p></td><td align="left" valign="top"><p>SNAP とか RELEASE とかは何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>現在、FreeBSD の
            <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">CVS リポジトリ</a>
            には、三つのアクティブ/準アクティブなブランチがあります
            (アクティブな開発ブランチは三つしか存在しないため、
            おそらく RELENG_2 ブランチの変更は年に 2 回だけになるでしょう)。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  <code class="literal">RELENG_2_2</code>
                  通称 <span class="emphasis"><em>2.2-STABLE</em></span>
                </p></li><li class="listitem"><p>
                  <code class="literal">RELENG_3</code>
                  通称 <span class="emphasis"><em>3.X-STABLE</em></span>
                </p></li><li class="listitem"><p>
                  <code class="literal">RELENG_4</code>
                  通称 <span class="emphasis"><em>4-STABLE</em></span></p></li><li class="listitem"><p><acronym class="acronym">HEAD</acronym>
                  通称 <code class="option">-CURRENT</code> あるいは
                  <span class="emphasis"><em>5.0-CURRENT</em></span></p></li></ul></div><p>
            <acronym class="acronym">HEAD</acronym>
            は他の二つと違って、
            実際のブランチタグではなく、
            <span class="emphasis"><em>「current、
              分岐していない開発本流」</em></span>のための単なるシンボリックな定数です。
            私たちはこれを <code class="literal">-CURRENT</code> と呼んでいます。
          </p><p>
            現在、
            <span class="quote">「<span class="quote">-CURRENT</span>」</span> は 5.0 の開発本流であり、
            <code class="literal">4.0-STABLE</code> ブランチ、
            つまり <code class="literal">RELENG_4</code> は
            2000 年 3 月に
            <span class="quote">「<span class="quote">-CURRENT</span>」</span> から分岐しています。
          </p><p>
            <code class="literal">2.2-STABLE</code> ブランチ、
            <code class="literal">RELENG_2_2</code> は
            1996 年 11 月に <span class="quote">「<span class="quote">-CURRENT</span>」</span> から分岐しました。
            これは保守が完全に終了しています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83264464"></a><a id="custrel"></a><p><strong>13.2.</strong></p></td><td align="left" valign="top"><p>自分用のカスタムリリースを構築するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            リリースを構築するには三つのことが必要です。まず、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vn&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">vn</span>(4)</span></a>
            ドライバが組み込まれたカーネルを実行させている必要があります。
            以下をカーネルコンフィグレーションファイルに追加し、
            カーネルを作り直してください。
          </p><pre class="programlisting">pseudo-device vn         #Vnode driver (turns a file into a device)</pre><p>
            次に、CVS リポジトリ全体を手元においておく必要があります。
            これを入手するには
            <a class="link" href="../handbook/synching.html#CVSUP" target="_top">CVSUP</a>
            が使用できますが、supfile で release の名称を cvs にして
            他のタグや date フィールドを削除する必要があります。
          </p><pre class="programlisting">*default prefix=/home/ncvs
*default base=/a
*default host=cvsup.FreeBSD.org
*default release=cvs
*default delete compress use-rel-suffix

## Main Source Tree
src-all
src-eBones
src-secure

# Other stuff
ports-all
www
doc-all</pre><p>
            そして <code class="command">cvsup -g supfile</code> を実行して自分のマシンに
            CVS リポジトリ全体をコピーします…。
          </p><p>
            最後に、ビルド用にかなりの空き領域を用意する必要があります。
            そのディレクトリを <code class="filename">/some/big/filesystem</code> として、
            上の例で CVS リポジトリを <code class="filename">/home/ncvs</code> に置いたものとすると、
            以下のようにしてリリースを構築します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>setenv CVSROOT /home/ncvs</code></strong>
 # or export CVSROOT=/home/ncvs
<code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make buildworld</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/release</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/some/big/filesystem/release</code></strong>
      </pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">ただし、すでに <code class="filename">/usr/obj</code>
            以下に構築物が存在しているなら、buildworld
            の必要は<span class="emphasis"><em>ありません</em></span>。</p></div><p>
            処理が終了すると、
            リリース全体が <code class="filename">/some/big/filesystem/release</code>
            に構築され、完全な <acronym class="acronym">FTP</acronym> インストール用の配布物が
            <code class="filename">/some/big/filesystem/release/R/ftp</code> に作成されます。
            -current 以外の開発ブランチの SNAP を自分で構築したい場合は、
            <code class="literal">RELEASETAG=SOMETAG</code>
            を上の <code class="command">make release</code> のコマンドラインに追加します。
            たとえば、<code class="literal">RELEASETAG=RELENG_2_2</code>
            とすると最新の 2.2-STABLE snapshot が構築されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83287760"></a><a id="custom-install-disks"></a><p><strong>13.3.</strong></p></td><td align="left" valign="top"><p>カスタムのインストールディスクを作るにはどうすればいいのですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">/usr/src/release/Makefile</code>
            のいろいろなターゲットとしてインストールディスク、
            ソース、バイナリアーカイブを作る完全な処理を自動的に行なうようになっています。
            <code class="filename">Makefile</code> に十分な情報があります。
            しかし、実行には <span class="quote">「<span class="quote">make world</span>」</span> が必要で、
            多くの時間とディスクの容量が必要です。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83290960"></a><a id="makeworld-clobbers"></a><p><strong>13.4.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">make world</span>」</span>
            を行なうと既存のバイナリを上書きしてしまうのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ええ、それが一般的な考え方です。名前が示しているように
            <span class="quote">「<span class="quote">make world</span>」</span>
            はすべてのシステムのバイナリを最初から作り直しますので、結果として、
            クリーンで一貫性のある環境を得ることができます
            (これがそれだけ長い時間がかかる理由です)。
          </p><p>
            環境変数 <code class="literal">DESTDIR</code> を
            <span class="quote">「<span class="quote"><code class="command">make world</code></span>」</span> や
            <span class="quote">「<span class="quote"><code class="command">make install</code></span>」</span>
            を実行する時に定義しておくと、新しく作られたバイナリは
            <code class="literal">${DESTDIR}</code>を <code class="systemitem">root</code>
            とみなしたディレクトリツリーにインストールされます。
            あるでたらめな共有ライブラリの変更やプログラムの再構築によって
            <span class="quote">「<span class="quote"><code class="command">make world</code></span>」</span>
            は失敗することもあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83297104"></a><a id="bus-speed-defaulted"></a><p><strong>13.5.</strong></p></td><td align="left" valign="top"><p>システム起動時に
            <span class="quote">「<span class="quote">(<code class="computeroutput">bus speed defaulted</code>)</span>」</span> とメッセージが出ます。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Adaptec の 1542 SCSI ホストアダプタは、
            ユーザがソフトウェア的にバスアクセス速度の設定を行なうことができます。
            以前のバージョンの 1542 ドライバは、
            使用可能な最大の速度を求めてアダプタをその設定にしようとしました。
            これは特定のユーザのシステムでは問題がある事がわかり、
            現在ではカーネルコンフィグオプションに
            <span class="quote">「<span class="quote"><span class="symbol">TUNE_1542</span></span>」</span> が加えられています。
            これを使用すると、これが働くシステムではディスクが速くなりますが、
            データの衝突が起きて速くはならないシステムもあるでしょう
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83300432"></a><a id="ctm"></a><p><strong>13.6.</strong></p></td><td align="left" valign="top"><p>インターネットアクセスに制限があっても current を追いかけられますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい、
            <a class="link" href="../handbook/synching.html#CTM" target="_top">CTM
              システム</a>を使って、
            ソースツリー全体のダウンロードを<span class="emphasis"><em>行なわず</em></span>に追いかけることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83307600"></a><a id="split-240k"></a><p><strong>13.7.</strong></p></td><td align="left" valign="top"><p>どのようにして配布ファイルを 240KB
            に分割しているのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            比較的新しい BSD ベースのシステムでは、
            <code class="command">split</code> に任意のバイト境界で分割する
            <span class="quote">「<span class="quote"><code class="option">-b</code></span>」</span> オプションがあります。
          </p><p>
            以下は <code class="filename">/usr/src/Makefile</code> からの例です。
          </p><pre class="programlisting">bin-tarball:
              (cd ${DISTDIR}; \
              tar cf - . \
              gzip --no-name -9 -c | \
              split -b 240640 - \
              ${RELEASEDIR}/tarballs/bindist/bin_tgz.)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83311824"></a><a id="submitting-kernel-extensions"></a><p><strong>13.8.</strong></p></td><td align="left" valign="top"><p>私はカーネルに拡張を行ないました。
            誰に送ればいいですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="../handbook/contrib.html" target="_top">FreeBSD
              ハンドブックの「FreeBSD への貢献」</a>を参照してください。
          </p><p>
            あなたのアイディアに感謝します!
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83318864"></a><a id="pnp-initialize"></a><p><strong>13.9.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">PnP</acronym> <acronym class="acronym">ISA</acronym>
            カードの検出と初期化はどのように行なうのですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="mailto:uhclem@nemesis.lonestar.org" target="_top">Frank Durda IV 氏</a> より:
          </p><div class="blockquote"><blockquote class="blockquote"><p>
              要点は、ホストが認識されていないボードを探す時に、すべての
              PnP ボードが応答することのできる少数の I/O
              ポートがあるということです。
              それにより、PnP プローブルーチンが開始したとき、PnP
              ボードが存在するなら、すべての PnP ボードは自分のモデル番号を返します。
              そのポートを I/O read するとプローブルーチンは問いに対するワイアード-OR
              された <span class="quote">「<span class="quote">yes</span>」</span> を得ます。この場合は
              少なくとも 1 ビットが ON になります。
              そして、プローブルーチンはモデル ID (Microsoft/Intel
              によって割り当てられています)が X より小さいボードを
              <span class="quote">「<span class="quote">オフライン</span>」</span> にすることができます。
              この操作を行ない、問い合わせに応答しているボードがまだ
              残っているかどうかを調べます。
              もし <span class="quote">「<span class="quote"><code class="literal">0</code></span>」</span> が返ってくるなら X
              より大きな ID を持つボードはないことになります。
              今度は <span class="quote">「<span class="quote">X</span>」</span>
              よりも小さな値を持つボードについて問い合わせます。
              もしあるのであれば、
              プローブルーチンはモデル番号が X より小さいことを知ります。
              今度は、X-(limit/4)
              より大きな値を持つボードをオフラインにして問い合わせを繰り返します。
              この ID の範囲による準バイナリサーチを十分繰り返すことにより、
              プローブルーチンはマシンに存在するすべての
              PnP ボードの値を最終的に得ることができます。その繰り返しの回数は
              2^64 よりはるかに少ない回数です。
            </p><p>
              ID は二つの 32-bit (つまり 64bit) フィールド + 8 bit
              チェックサムからなります。最初の 32 bits はベンダの識別子です。
              これは公表されてはいませんが、
              同一のベンダから供給されている異なるタイプのボードでは異なる
              32-bit ベンダ ID を持つことができるように考えられます。
              製造元を特定するだけのために 32-bit
              はいくらか過剰です。
            </p><p>
              下位の 32-bit はシリアル番号、
              イーサネットアドレスなどのボードを特定するものです。
              ベンダは上位 32 bits が異なっていないのであれば、
              下位 32-bit が同一である 2枚目のボードを製造することはありません。
              したがって、同じタイプの複数のボードをマシンにいれることができ、
              この場合でも 64-bit
              全体ではユニークです。
            </p><p>
              32-bit のフィールドはすべてを 0 にすることはできません。
              これは初期化のバイナリサーチの間ワイアード-OR
              によって 0 ではない
              ビットを参照するからです。
            </p><p>
              システムがすべてのボードの与えられた ID を認識すると、
              それぞれのボードに対応した処理を一つずつ (同一の
              I/O ポートを通して) 行ないます。
              そして、利用できる割り込みの選択などのボードが必要とするリソースを検出します。
              すべてのボードについてこの情報を集めます。
            </p><p>
              この情報はハードディスク上の ECU ファイルなどの情報とまとめられ、
              マザーボードの BIOS にも結合されます。
              マザーボード上のハードウェアへの ECU と
              BIOS PnP のサポートは通常は統合されていますが、
              周辺機器については真の PnPであるとはいえません。
              しかし、BIOS の情報に ECU の情報を加えて調査することで、
              プローブルーチンは PnP
              デバイスが再配置できなくなることを避けることができます。
            </p><p>
              それから、再度 PnP デバイスにアクセスし、I/O、DMA、IRQ、
              メモリマップアドレスの設定をします。
              デバイスはこのアドレスに見えるようになり、
              次に再起動するまでこの位置を占めます。しかし、
              あなたの望む時に移動させることが不可能である、
              といっているわけではありません。
            </p><p>
              以上の話では大きく単純化をしてありますが、
              基本的な考え方は得られたでしょう。
            </p><p>
              マイクロソフトは、ボードのロジックが対立する
              I/O サイクルではデコードしていない (訳注:
              おそらく read 時しかデコードされていず
              write 時はポートが空いているという意味でしょう)、
              プライマリプリンタのステータスポートのいくつかを PnP
              のために占有しました。
              私は初期の PnP の提案レビュー時に IBM
              純正のプリンタボードでステータスポートの write
              のデコードがされているということに気がつきましたが、
              MS は <span class="quote">「<span class="quote">tough (頑固、不運、無法な)</span>」</span>
              と言っています。
              そしてプリンタのステータスポートへアドレスの設定のために
              write を行なっています。また、
              そのアドレス + <code class="literal">0x800</code> と
              read のための 3番目の I/O ポートが
              <code class="literal">0x200</code> から
              <code class="literal">0x3ff</code> の間のどこかに置かれるでしょう。
            </p></blockquote></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83329360"></a><a id="architectures"></a><p><strong>13.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD は、他のアーキテクチャをサポートしないんですか? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            いくつかのグループの人々が、FreeBSD
            の他のアーキテクチャへの移植に関心を示しており、
            FreeBSD/AXP (ALPHA) はこれらの成果としてはとても成功したものの一つです。
            FreeBSD/AXP は現在
            <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</a>
            から入手できます。
            ALPHA への移植版が現在動く機種は増えつつあり、
            その中には AlphaStation、AXPpci、PC164、Miata そして Multia
            といったモデルが含まれています。
            現状についての情報を得るには
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-alpha@FreeBSD.org">freebsd-alpha@FreeBSD.org</a>&gt;</code><a class="link" href="preface.html#mailing" title="11.">メーリングリスト</a>に参加してください。
          </p><p>
            その他に FreeBSD の SPARC アーキテクチャへの移植があります。
            プロジェクトへの参加に興味がある方は
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-sparc@FreeBSD.org">freebsd-sparc@FreeBSD.org</a>&gt;</code><a class="link" href="preface.html#mailing" title="11.">メーリングリスト</a>
            に参加してください。
            進行中のプラットホームのリストにもっとも最近追加されたのが
            IA-64 と PowerPCです。詳細は
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-ia64@FreeBSD.org">freebsd-ia64@FreeBSD.org</a>&gt;</code> および/あるいは
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-ppc@FreeBSD.org">freebsd-ppc@FreeBSD.org</a>&gt;</code><a class="link" href="preface.html#mailing" title="11.">メーリングリスト</a>に参加してください。
            新しいアーキテクチャに関する一般的な議論については
            新しいアーキテクチャに関する一般的な議論については
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:freebsd-platforms@FreeBSD.org">freebsd-platforms@FreeBSD.org</a>&gt;</code><a class="link" href="preface.html#mailing" title="11.">メーリングリスト</a>
            へ参加してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83372752"></a><a id="major-numbers"></a><p><strong>13.11.</strong></p></td><td align="left" valign="top"><p>デバイスドライバを開発したので、メジャー番号が欲しいのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは、開発したドライバを公開するかどうかに依存します。
            公開するのであれば、ドライバのソースコード、
            <code class="filename">files.i386</code> の変更、
            コンフィグファイルのサンプル、
            デバイスが使うスペシャルファイルを作成する
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">MAKEDEV</span>(8)</span></a>
            のコードを私たちに送ってください。
            公開するつもりがない場合、ライセンスの問題により公開できない場合は、
            キャラクタメジャー番号 32 および、
            ブロックメジャー番号 8 がこのような目的のために予約されています。
            これらの番号を使用してください。
            どちらの場合であれ、ドライバに関する情報を
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers" target="_top">FreeBSD technical discussions メーリングリスト</a>
            に流して頂けると助かります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83376464"></a><a id="alternate-directory-layout"></a><p><strong>13.12.</strong></p></td><td align="left" valign="top"><p>代替のディレクトリ配置ポリシー</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在使われているディレクトリの配置ポリシーは、
            私が 1983 年に書いたものから全く変更されていません。
            私は当初の配置ポリシーを、オリジナルの fast filesystem のために書き、
            まったく改定していません。
            このポリシーはシリンダグループを使い尽くすのを防ぐにはうまくいきましたが、
            お気づきの方もいる通り find の動作には不適切です。
            ほとんどのファイルシステムの内容は、
            深さ優先検索 (ftw とも呼ばれます) によって作られたアーカイブから、
            抽出 (restore) して作成されます。この際、
            ディレクトリは、シリンダグループにまたがって配置され、
            以降の深さ優先検索を行うには、
            考え得る限り最悪の状態になります。
            もし作成するディレクトリの総数がわかっていれば、
            解決方法はあります。(総数/シリンダグループ数) 個のディレクトリを、
            シリンダグループごとにまとめて作成すれば良いのです。
            もちろん最適なディレクトリ配置になるように、
            総数を予測する方法を考えなければなりません。
            しかし仮にシリンダグループあたりのディレクトリ数を
            10 くらいの小さな数に固定してしまったとしても、
            大幅な改善が望めるでしょう。
            このポリシーを用いるべきリストア作業を、通常の作業
            (おそらく既存のポリシーを使用したほうが良いでしょう)
            を区別するには、
            10 秒間の間に作成されたディレクトリを最大
            10 個までまとめて単一のシリンダグループに書き込むという手順が使えるでしょう。
            とにかく私の結論は、そろそろ実験を始めて見る時期だろうということです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83378512"></a><a id="kernel-panic-troubleshooting"></a><p><strong>13.13.</strong></p></td><td align="left" valign="top"><p>カーネルパニックを最大限に利用する</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                この節は、freebsd-current <a class="link" href="preface.html#mailing" title="11.">メーリングリスト</a>に
                Bill Paul 氏が投稿したメールを、
                Dag-Erling C. Smørgrav 氏が校正し、[] 内のコメントを追加して引用したものです。
              </p></div><pre class="programlisting">From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: ben@rosengart.com
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.ORG</pre><p><span class="emphasis"><em>[&lt;ben@rosengart.com&gt; が以下のパニックメッセージを投稿しました。]</em></span></p><pre class="programlisting">&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</pre><p>
            このようなメッセージが表示された場合、問題が起きる状況を確認して、
            情報を送るだけでは十分ではありません。
            下線をつけた命令ポインタ値は重要な値ですが、
            残念ながらこの値は構成に依存します。つまり、
            この値は使っているカーネルのイメージに依存するのです。
            もしスナップショットなどの GENERIC カーネルを使っているのであれば、
            他の人間が問題のある関数について追試をすることができますが、
            カスタマイズされたカーネルの場合は、
            使っている本人にしか問題の起こった場所は特定できないのです。
          </p><p>
            何をすれば良いのでしょう?
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  命令ポインタ値をメモします。
                  <code class="literal">0x8:</code> という部分は今回必要ありません。
                  必要なのは <code class="literal">0xf0xxxxxx</code> という部分です。
                </p></li><li class="step"><p>
                  システムが再起動したら、以下の操作を行います。

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</code></strong></pre><p>

                  ここで、<code class="literal">f0xxxxxx</code> は命令ポインタ値です。
                  カーネルシンボルのテーブルは関数のエントリポイントを含み、
                  命令ポインタ値は、関数内部のある点であり最初の点ではないため、
                  この操作を行っても完全に一致するものが表示されない場合もあります。
                  この場合は、
                  最後の桁を省いてもういちどやってみてください。
                  このようになります。

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</code></strong></pre><p>

                  これでも一致しない場合は、
                  桁を減らしながら何らかの出力があるまで繰り返してください。
                  何か出力されたら、
                  それがカーネルパニックを引き起こした可能性のある関数のリストです。
                  これは、問題点を見付ける正確な方法ではありませんが、何もないよりましです。
                </p></li></ol></div><p>
            このようなパニックメッセージを投稿している人はよく見掛けますが、
            このように、命令ポインタ値を、
            カーネルシンボルテーブルの中の関数とつき合わせて調べている人はまれです。
          </p><p>
            パニックの原因を突き止める最良の方法は、クラッシュダンプをとり、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> でスタックトレースを行うことです。
          </p><p>
            どっちにしろ、私は普通以下のようにします。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  カーネルコンフィグファイルを作ります。
                  カーネルデバッガが必要そうであれば
                  <code class="literal">options 'DDB'</code>
                  を加えても良いです (私は永久ループが起こっていそうな場合に、
                  ブレークポイントを設定するのに使っています)。
                </p></li><li class="step"><p>
                  <code class="command">config -g KERNELCONFIG</code>
                  としてビルドディレクトリを設定します。
                </p></li><li class="step"><p>
                  <code class="command">cd /sys/compile/KERNELCONFIG; make</code> を実行します。
                </p></li><li class="step"><p>カーネルのコンパイルが終了するのを待ちます。</p></li><li class="step"><p><code class="command">make install</code> を実行します。</p></li><li class="step"><p>再起動します。</p></li></ol></div><p>
              <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> プロセスは２つのカーネル、
            <code class="filename">kernel</code> と
            <code class="filename">kernel.debug</code> をビルドします。
            <code class="filename">kernel</code> は <code class="filename">/kernel</code>
            としてインストールされ、
            <code class="filename">kernel.debug</code> は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>
            のデバッグ用シンボル情報を取り出すために利用されます。
          </p><p>
            確実にクラッシュダンプをとるには、<code class="filename">/etc/rc.conf</code>
            を編集して <code class="literal">dumpdev</code>
            を使用しているスワップパーティションに指定する必要があります。
            こうすると <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> スクリプトから
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> コマンドが実行され、
            クラッシュダンプ機能が有効になります。
            手動で <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> コマンドを実行してもかまいません。
            パニックの後、クラッシュダンプは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
            コマンドを使用して取り出すこと ができます。
            <code class="literal">dumpdev</code> が
            <code class="filename">/etc/rc.conf</code> で設定されていれば、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> スクリプトから
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> が自動的に実行され、クラッシュダンプを
            <code class="filename">/var/crash</code> に保存します。
           </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD のクラッシュダンプのサイズは、
                ふつう物理メモリサイズと同じです。
                つまり 64MB のメモリを積んでいれば、
                64MB のクラッシュダンプが生成されることになります。
                <code class="filename">/var/crash</code>
                に十分な空き容量があることを確認してください。手動で
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> を実行すれば、
                もっと空き容量のあるディレクトリにクラッシュダンプを保存できます。
                <code class="literal">options MAXMEM=(foo)</code>
                という行をカーネルコンフィグファイルに追加することで、
                カーネルのメモリ使用量を制限できます。
                たとえば 128MB のメモリがある場合も、
                カーネルのメモリ使用量を 16MB
                に制限し、クラッシュダンプのサイズも
                128MB ではなく 16MB にすることができます。
              </p></div><p>
            クラッシュダンプを取り出せたら、
            以下のように <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>
            を使ってスタックトレースをとります。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>where</code></strong></pre><p>
            必要な情報が 1 画面に収まらないことも多いので、できれば
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> を使って出力を記録します。
            strip していないカーネルイメージを使うことで、
            すべてのデバッグシンボルが参照でき、
            パニックの発生したカーネルのソースコードの行が表示されているはずです。
            通常、正確なクラッシュへの過程を追跡するには、
            出力を最後の行から逆方向に読まなければなりません。
            また <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> を使って、
            変数や構造体の内容を表示させ、
            クラッシュした時のシステムの状態を調べられます。
          </p><p>
            もしあなたがデバッグ狂で、同時に別のコンピュータを利用できる環境にあれば、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> をリモートデバッグに使うこともできます。
            リモートデバッグを使うと、あるコンピュータ上の
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> を使って、
            別のコンピュータのカーネルをデバッグできます。
            ブレークポイントの設定、カーネルコードのステップ実行など、
            ふつうのプログラムのデバッグと変わりません。
            コンピュータを 2 台並べてデバッグするチャンスにはなかなか恵まれないので、
            私はまだリモートデバッグを試したことはありません。
          </p><div xmlns="" class="note"><h3 class="admontitle">Bill による追記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                DDB を有効にしていてカーネルがデバッガに
                落ちたら、ddb のプロンプトで "<code class="command">panic</code>"
                と入力すれば、強制的にパニックを起こしクラッシュダンプさせることができます。
                パニックの途中で、再びデバッガに落ちるかもしれませんが、
                "<code class="command">continue</code>"
                と入力すれば、
                クラッシュダンプを最後まで実行させられます。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83460304"></a><a id="dlsym-failure"></a><p><strong>13.14.</strong></p></td><td align="left" valign="top"><p><code class="function">dlsym()</code> が ELF 実行形式では動作しなくなります!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <acronym class="acronym">ELF</acronym> のツール類は、
            デフォルトでは実行形式の中に定義されているシンボルを、
            ダイナミックリンカから見えるようにはしません。
            このため、<code class="function">dlopen(NULL, flags)</code>
            を呼び出して得られたハンドルに対して、
            <code class="function">dlsym()</code> で探索を行っても、
            こういったシンボルを見つけられません。
          </p><p>
            もし、あなたがプロセスの中心にあたる実行形式の中にあるシンボルを探索したければ、
            ELF リンカ (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>) に
            <code class="option">-export-dynamic</code>
            オプションを付けて実行形式をリンクする必要があります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp83490000"></a><a id="change-kernel-address-space"></a><p><strong>13.15.</strong></p></td><td align="left" valign="top"><p>カーネルアドレス空間を大きくしたり、
            小さくするにはどうしたら良いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            カーネルアドレス空間は、FreeBSD 3.X 上で
            256MB、FreeBSD 4.X 上で 1GB がデフォルトになっています。
            負荷の高いネットワークサーバ (たとえば大きな FTP、HTTP サーバ)
            を運用する場合は、256MB では足りないことに気付くかも知れません。
          </p><p>
            では、アドレス空間を大きくするにはどうしたら良いのでしょうか?
            それには、二つの段階を踏みます。まず、
            より大きいアドレス空間を割り当てることをカーネルに知らせる必要があります。
            次に、カーネルはアドレス空間の先頭にロードされるため、
            アドレスの先頭が天井
            (訳注:カーネルアドレス空間の最下端アドレスのこと) と
            ぶつかることのないように、ロードアドレスを今までより低位に設定する必要があります。
          </p><p>
            最初の段階は、<code class="filename">src/sys/i386/include/pmap.h</code> にある
            <code class="literal">NKPDE</code> の値を増加させることで行ないます。
            ここに 1GB のアドレス空間にするために、どのようにすれば良いかを示します。
          </p><pre class="programlisting">#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</pre><p>
            正確な <code class="literal">NKPDE</code> の値を計算するには、
            望みのアドレス空間の大きさ (メガバイト単位) を 4 で割って、
            それから単一プロセッサ (UP) なら 1、SMP なら 2 を引き算してください。
          </p><p>
            次の段階を行なうには、ロードアドレスを正確に計算することが必要です。
            単純に、アドレス空間の大きさ
            (バイト単位) を 0x100100000 から引き算してください。
            1GB アドレス空間の場合、その結果は 0xc0100000 になります。
            そして、<code class="filename">src/sys/i386/conf/Makefile.i386</code> にある
            <span class="symbol">LOAD_ADDRESS</span> に、今計算した値を入れます。また、次のように
            <code class="filename">src/sys/i386/conf/kernel.script</code>
            のセクションの始めの方にあるロケーションカウンタにも同じ値を入れてください。
          </p><pre class="programlisting">OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</pre><p>
            それが完了したら、<code class="command">config</code> し直してカーネルを再構築してください。
            おそらく、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a>、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>
            などに不具合が出るでしょう。
            それらを正常にするために、<code class="command">make world</code>
            (もしくは、変更した <code class="filename">pmap.h</code> を
            <code class="filename">/usr/include/vm/</code> にコピーした後に、
            <code class="filename">libkvm</code>、
            <code class="command">ps</code> および <code class="command">top</code>
            を手動で再構築すること) を行なうべきです。
          </p><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">カーネルアドレス空間の大きさは、4MB の倍数である必要があります。</p></div><div xmlns="" class="note"><h3 class="admontitle">David Greenman 氏による補足: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                カーネルアドレス空間は 2 の乗数である必要があると思いますが、
                それが確かなことかどうかははっきりしていません。
                昔の起動コードには、良く高位アドレスビットのトリックが使われていたため、
                少なくとも 256MB の粒度であることが想定されていたと思います。
              </p></div></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="misc.html">戻る</a>〓</td><td width="20%" align="center">〓</td><td width="40%" align="right">〓<a accesskey="n" href="acknowledgments.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第12章 その他の質問〓</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">〓第14章 謝辞</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文書、および他の文書は
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>
    からダウンロードできます。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>FreeBSD に関する質問がある場合には、
    <a href="http://www.FreeBSD.org/ja/docs.html">ドキュメント</a> を読んだ上で
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt; まで (英語で) 連絡してください。<br></br>
    本文書に関する質問については、
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt; まで電子メールを (英語で) 送ってください。</small></p></body></html>