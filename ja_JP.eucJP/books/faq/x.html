<?xml version="1.0" encoding="euc-jp" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>第8章 X Window System と仮想コンソール</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="up" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="prev" href="admin.html" title="第7章 システム管理" /><link rel="next" href="networking.html" title="第9章 ネットワーキング" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第8章 X Window System と仮想コンソール</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="admin.html">戻る</a>〓</td><th width="60%" align="center">〓</th><td width="20%" align="right">〓<a accesskey="n" href="networking.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x"></a>第8章 X Window System と仮想コンソール</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        今野 元之 <code class="email">&lt;<a xmlns="" class="email" href="mailto:motoyuki@FreeBSD.org">motoyuki@FreeBSD.org</a>&gt;</code>
        1997 年 11 月 13 日</em></span>
    </p><div class="qandaset"><a id="idp81635024"></a><dl><dt>8.1. <a href="x.html#idp81635280">X を動かしたいのですが、どうすればいいのですか?</a></dt><dt>8.2. <a href="x.html#idp81639504">X を実行しようとして
            startx
            と入力したのですが、
            KDENABIO failed (Operation not permitted)
            というエラーが表示されます。
            何かおかしなことをやってしまったんでしょうか?</a></dt><dt>8.3. <a href="x.html#idp81651280">私のマウスはなぜ X で動かないのでしょうか?</a></dt><dt>8.4. <a href="x.html#idp81661776">わたしのマウスにはホイール機能が付いているのですが、X で使うことはできますか?</a></dt><dt>8.5. <a href="x.html#idp81730640">X のメニューやダイアログボックスがうまく動きません。</a></dt><dt>8.6. <a href="x.html#idp81739728">仮想コンソールとは何ですか? どうやったら使えますか?</a></dt><dt>8.7. <a href="x.html#idp81777616">X から仮想コンソールに切替えるにはどうすればよいのですか?</a></dt><dt>8.8. <a href="x.html#idp81789392">XDM を起動時に起動させるにはどうしますか?</a></dt><dt>8.9. <a href="x.html#idp81871056">xconsole を動かそうとすると
            「Couldn't open console」
            とエラーが出ます。</a></dt><dt>8.10. <a href="x.html#idp81884752">わたしはいつも XFree86 を一般ユーザから起動していたのですが、
            最近になって root ユーザでなければな
            らないと言われるようになりました。</a></dt><dt>8.11. <a href="x.html#idp81895120">私の PS/2 マウスは X ウィンドウシステム上でうまく動きません。</a></dt><dt>8.12. <a href="x.html#idp81910224">MouseSystems の PS/2 マウスがうまく動きません。</a></dt><dt>8.13. <a href="x.html#idp81922768">X のアプリケーションを構築する時に、
            imake can't find Imake.tmpl
            となります。どこにあるのでしょうか?
          </a></dt><dt>8.14. <a href="x.html#idp81926608">マウスのボタンを入れ替える方法はありますか?</a></dt><dt>8.15. <a href="x.html#idp81930832">スプラッシュスクリーンのインストールはどうするのですか。
            どこで見つけることができますか?</a></dt><dt>8.16. <a href="x.html#idp81958992">X で Windows(tm) キーを使うことはできるのでしょうか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp81635280"></a><a id="running-X"></a><p><strong>8.1.</strong></p></td><td align="left" valign="top"><p>X を動かしたいのですが、どうすればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            もっとも簡単な方法は FreeBSD のインストールの際に
            X を動かすことを指定するだけです。
          </p><p>それから <code class="command">xf86config</code>
            ツールのドキュメントを読んでこれに従ってください。
            このツールはあなたのグラフィックカードやマウスなどに合わせて
            XFree86(tm) の設定を行うのを助けてくれます。
          </p><p>
            Xaccel サーバーについて調べてみるのもいいでしょう。
            詳しくは <a class="link" href="commercial.html#xig">Xi Graphics について</a> か
            <a class="link" href="commercial.html#metrox">Metro Link</a> をご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81639504"></a><a id="running-X-securelevels"></a><p><strong>8.2.</strong></p></td><td align="left" valign="top"><p>X を<span class="emphasis"><em>実行しようと</em></span>して
            <code class="command">startx</code>
            と入力したのですが、
            <span class="errorname">KDENABIO failed (Operation not permitted)</span>
            というエラーが表示されます。
            何かおかしなことをやってしまったんでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>あなたのシステムは高いセキュアレベルで運用されていますね?
            実は、高いセキュアレベルで X を起動することはできないのです。
            どうしてなのかについては、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>
            のマニュアルページに書かれています。</p><p>では、代わりにどうすれば良いのかお答えしましょう。
            基本的に 2 つの方法があります。
            一つはセキュアレベルを 0 にする (通常、これは
            <code class="filename">/etc/rc.conf</code> で指定します) こと、
            もう一つは起動時 (セキュアレベルを上げる前) に
              <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> を実行するかです。</p><p>起動時に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> を実行する方法の詳細については、
            <a class="xref" href="x.html#xdm-boot" title="8.8.">問：〓8.8</a> を参照してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81651280"></a><a id="x-and-moused"></a><p><strong>8.3.</strong></p></td><td align="left" valign="top"><p>私のマウスはなぜ X で動かないのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>syscons (デフォルトのコンソールドライバ) を使っているのであれば、
            それぞれの仮想スクリーンでマウスポインターをサポートするように
            FreeBSD を設定できます。X でのマウスの衝突を避けるために、syscons は
            <code class="filename">/dev/sysmouse</code>
            という仮想デバイスをサポートしています。
            本物のマウスデバイスから入力されたすべてのマウスのイベントは、
            moused を経由して sysmouse デバイスへ出力されます。
            一つ以上の仮想コンソールと X の
            <span class="emphasis"><em>両方で</em></span> マウスを使いたい場合、
            <a class="xref" href="hardware.html#moused" title="2.11.">問：〓2.11</a>
            を参照して moused を設定してください。
          </p><p>
            そして、<code class="filename">/etc/XF86Config</code> を編集し、
            次のように書かれていることを確認してください。</p><pre class="programlisting">Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
.....</pre><p>
            上の例は、XFree86 3.3.2 以降の場合の例です。
            それより前のバージョンでは、
            <span class="emphasis"><em>Protocol</em></span> という部分を
            <span class="emphasis"><em>MouseSystems</em></span> と置き換える必要があります。
          </p><p>
            X で <code class="filename">/dev/mouse</code>
            を使うのを好む人もいます。
            この場合は、
            <code class="filename">/dev/mouse</code>
            を
            <code class="filename">/dev/sysmouse</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysmouse&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sysmouse</span>(4)</span></a> 参照)
            にリンクしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>rm -f mouse</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ln -s sysmouse mouse</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81661776"></a><a id="x-and-wheel"></a><p><strong>8.4.</strong></p></td><td align="left" valign="top"><p>わたしのマウスにはホイール機能が付いているのですが、X で使うことはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>はい、もちろん使えますが、そのためには
            X クライアントプログラムを適切に設定する必要があります。これについては、
            <a class="link" href="http://www.inria.fr/koala/colas/mouse-wheel-scroll/" target="_top">Colas Nahaboo
              氏のウェブページ(http://www.inria.fr/koala/colas/mouse-wheel-scroll/)</a>
            を参照してください。</p><p>
            <span class="application">imwheel</span>
            というプログラムを使う場合は、
            次のような簡単な手順にしたがってください。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ホイールイベントの変換</p><p>
                <span class="application">imwheel</span> は、
                マウスのボタン 4、ボタン 5 をキー押下イベントに変換するプログラムです。
                そのためホイールマウスで利用するには、マウスホイールのイベントをボタン 4、
                ボタン 5 のイベントに変換するマウスドライバを利用する必要があります。
                この変換を行なうには二つの方法があります。
                一つは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>
                で行なう方法、二つめは X サーバ自身に変換を行なわせる方法です。
              </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>ホイールイベントの変換に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を使う</p><p>
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> にイベントを変換させるには、
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> 起動時にオプション
                    <code class="option">-z 4</code> を追加します。
                    たとえば、普段 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を
                    <code class="command">moused -p /dev/psm0</code>
                    として起動しているなら、その代わりに
                    <code class="command">moused -p /dev/psm0 -z 4</code>
                    とします。
                    もし、
                    <code class="filename">/etc/rc.conf</code>
                    を使って自動的に起動するように設定しているなら、
                    <code class="filename">/etc/rc.conf</code>
                    の中の
                    <code class="varname">moused_flags</code> という変数に
                    <code class="option">-z 4</code> を追加するだけです。
                  </p><p>
                    そして、5 ボタンマウスを使うことを
                    X サーバに伝える必要があります。
                    これを行なうには
                    <code class="filename">/etc/XF86Config</code> の
                    <span class="quote">「<span class="quote">Pointer</span>」</span> セクションに
                    <code class="literal">Buttons 5</code> という行を追加するだけです。
                    そうすると
                    <code class="filename">/etc/XF86Config</code> の
                    <span class="quote">「<span class="quote">Pointer</span>」</span> は、
                    たとえば次のようになるでしょう。
                  </p><div class="example"><a id="idp81693392"></a><div class="example-title">例8.1 moused による変換を利用してホイールマウスを
                      使用するための XFree86 3.3.x 系列の XF86Config の
                      <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
   Protocol        "SysMouse"
   Device          "/dev/sysmouse"
   Buttons         5
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp81695056"></a><div class="example-title">例8.2 自動的なプロトコル認識機能およびボタン配置変換機能を
                      利用し、ホイールマウスを使用するための XFree86 4.x 系列の
                      XF86Config の <span class="quote">「<span class="quote">InputDevice</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/psm0"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp81696720"></a><div class="example-title">例8.3 ホイールマウスで Emacs 上でのページスクロールを
                      行うための <span class="quote">「<span class="quote">.emacs</span>」</span> の設定例</div><div class="example-contents"><pre class="programlisting">;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</pre></div></div><br class="example-break" /></li><li class="listitem"><p>X サーバを使ったホイールイベントの変換</p><p>
                    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> を起動していなかったり、
                    ホイールイベントの変換に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>
                    を起動したくない場合には、その代わりに
                    X サーバを使うことができます。
                    これには、<code class="filename">/etc/XF86Config</code>
                    ファイルを書き換える必要があります。
                    まず最初に必要なのは、
                    マウスがどのプロトコルを使っているのかを確認することです。
                    ほとんどのホイールマウスは
                    <span class="quote">「<span class="quote">IntelliMouse</span>」</span>
                    プロトコルを使用していますが、
                    XFree86 サーバはその他のプロトコル、
                    たとえば
                    Logitech MouseMan+ マウスが利用している
                    <span class="quote">「<span class="quote">MouseManPlusPS/2</span>」</span>
                    プロトコルなどもサポートしています。
                    使用されているプロトコルが確認できたら
                    <span class="quote">「<span class="quote">Pointer</span>」</span> セクションに
                    <code class="varname">Protocol</code> の行を追加してください。
                  </p><p>
                    つぎに、
                    ホイールのスクロールイベントをマウスボタン 4、
                    マウスボタン 5 に割り当てることを X サーバに伝えます。
                    これを行なうには
                    <code class="varname">ZAxisMapping</code>
                    オプションを使用します。
                  </p><p>
                    たとえば、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> が起動していない状態で、
                    PS/2 マウスポートに IntelliMouse が接続されているとしたら
                    <code class="filename">/etc/XF86Config</code>
                    はおそらく次のようになります。
                  </p><div class="example"><a id="idp81705552"></a><div class="example-title">例8.4 
                      X サーバによる変換を利用してホイールマウスを使用するための
                      XF86Config の <span class="quote">「<span class="quote">Pointer</span>」</span> セクションの設定例</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
   Protocol        "IntelliMouse"
   Device          "/dev/psm0"
   ZAxisMapping    4 5
EndSection</pre></div></div><br class="example-break" /></li></ol></div></li><li class="listitem"><p><span class="application">imwheel</span> のインストール</p><p>
                さて、つぎに Ports Collection から
                <span class="application">imwheel</span> をインストールします。
                これがあるのは <code class="filename">x11</code> カテゴリです。
                このプログラムは、
                マウスイベントをキーボードイベントに変換します。
                たとえば、マウスホイールを前に回した時、
                <span class="application">imwheel</span> は <span class="keycap"><strong>PageUp</strong></span>
                をアプリケーションプログラムに送るような動作をするわけです。
                <span class="application">Imwheel</span>
                はホイールイベントとキーボード押下の対応を設定ファイルを使って設定するため、
                アプリケーション毎に異なる対応を持たせることも可能です。
                <span class="application">imwheel</span> のデフォルトの設定ファイルは
                <code class="filename">/usr/X11R6/etc/imwheelrc</code>
                にインストールされます。
                これを <code class="filename">~/.imwheelrc</code> にコピーして編集し、
                お好きなように <span class="application">imwheel</span>
                で利用したいアプリケーションの設定をカスタマイズしてください。
                設定ファイルの書式は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=imwheel&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">imwheel</span>(1)</span></a> に説明されています。
              </p></li><li class="listitem"><p><span class="application">Emacs</span> で
                <span class="application">Imwheel</span> を使うように設定する
                (<span class="emphasis"><em>必須ではありません</em></span>)</p><p>
                <span class="application">emacs</span> や
                <span class="application">Xemacs</span>
                で利用するには、
                <code class="filename">~/.emacs</code> にいくらか書き加える必要があります。
                <span class="application">emacs</span> の場合は次の部分を追加してください。
              </p><div class="example"><a id="idp81717328"></a><div class="example-title">例8.5 <span class="application">Imwheel</span> を利用するための
                  <span class="application">Emacs</span> の設定例</div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /><p>
                <span class="application">Xemacs</span> の場合は
                <code class="filename">~/.emacs</code> に次の部分を追加してください。
              </p><div class="example"><a id="idp81724624"></a><div class="example-title">例8.6 <span class="application">Imwheel</span> を利用するための
                  <span class="application">XEmacs</span> の設定例</div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /></li><li class="listitem"><p><span class="application">Imwheel</span> の実行</p><p>
                インストールが完了していれば、単に xterm (訳注:
                日本語環境で広く使われている kterm でも構いません) から
                <code class="command">imwheel</code> を入力するだけで起動できます。
                起動するとバックグラウンドで動作し、すぐに利用できます。
                <span class="application">imwheel</span> をいつも使うように設定するには、
                <code class="filename">.xinitrc</code> か
                <code class="filename">.xsession</code> のファイルにそのままコマンドを追加してください。
                <span class="application">imwheel</span> が PID
                ファイルに関する警告を表示するかも知れませんが、
                無視しても危険はありません。この警告が意味を持つのは、
                Linux 版の <span class="application">imwheel</span> だけです。
              </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81730640"></a><a id="window-menu-weird"></a><p><strong>8.5.</strong></p></td><td align="left" valign="top"><p>X のメニューやダイアログボックスがうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Num Lock キーをオフにしてください。
          </p><p>Num Lock キーがデフォルトで起動時にオンになる場合は、
            <code class="filename">XF86Config</code> ファイルの
            <code class="literal">Keyboard</code>
            セクションに以下の行を加えてもいいでしょう。
          </p><pre class="programlisting"># Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
    ServerNumLock</pre><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                この問題は XFree86 3.2 以降では解決しています。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81739728"></a><a id="virtual-console"></a><p><strong>8.6.</strong></p></td><td align="left" valign="top"><p>仮想コンソールとは何ですか? どうやったら使えますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            仮想コンソールは、簡単にいうと、ネットワークや X
            を動かすなどの複雑なことを行なわずに、
            いくつかのセッションを同時に行なうことを可能にします。
          </p><p>
            システムのスタート時には、
            起動メッセージが出た後に login
            プロンプトが表示されます。そこで
            ログイン名とパスワードを入力すると
            1 番目の仮想コンソール上で仕事 (あるいは遊び) を始めることができます。
          </p><p>
            他のセッションを始めたい場合もあるでしょう。
            それは動かしているプログラムのドキュメントを見たり、
            FTP の転送が終わるまで待つ間、
            メールを読もうとしたりすることかもしれません。
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F2</strong></span>
            を押す (<span class="keycap"><strong>Alt</strong></span> キーを押しながら
            <span class="keycap"><strong>F2</strong></span> キーを押す) と、
            2 番目の「仮想コンソール」で
            ログインプロンプトが待機していることがわかります。
            最初のセッションに戻りたいときは
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F1</strong></span> を押します。
          </p><p>
            標準の FreeBSDインストールでは、
            3 枚 (3.3-RELEASE では 8 枚) の仮想コンソールが有効になっていて、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F1</strong></span>、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F2</strong></span>、
            <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F3</strong></span>
            で仮想コンソール間の切替えを行ないます。
          </p><p>
            より多くの仮想コンソールを有効にするには、
            <code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            を編集して
            <span class="quote">「<span class="quote">Virtual terminals</span>」</span>
            のコメント行の後に
            <code class="filename">ttyv4</code>
            から
            <code class="filename">ttyvc</code>
            の手前までのエントリを加えます
            (以下の例は先頭には空白は入りません)。
          </p><pre class="programlisting"># /etc/ttys には ttyv3 がありますので
# "off" を "on" に変更します。
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</pre><p>
            多くするか少なくするかはあなたの自由です。
            より多くの仮想ターミナルを使うとより多くのリソースを使うことになります。
            8MB 以下のメモリしかない場合はこれは重要な問題です。
            もし必要があれば
            <code class="literal">secure</code> を
            <code class="literal">insecure</code>
            に変更してください。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">X を使いたいのであれば、
                最低一つの仮想ターミナル (のエントリ) を使わずに残しておくか、
                off にしておく必要があります。
                つまり、12 個の
                <span class="keycap"><strong>Alt</strong></span>-ファンクションキーすべてでログインプロンプトを
                出したいのならば、
                残念ながら X は利用できないということです。
                同じマシンで X サーバーも動かしたいのならば
                11 個しか使えません。
              </p></div><p>
            仮想コンソールを無効にするもっとも簡単な方法は、
            コンソールを
            off にすることです。
            たとえば 12 個すべてのターミナルを割り当てている状態で
            X を動かしたいときは、
            仮想ターミナル 12 を変更します。
          </p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</pre><p>
            これを次のように変更します。
          </p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</pre><p>
            キーボードにファンクションキーが 10 個しかないのであれば、
            次のように設定します。
          </p><pre class="programlisting">ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</pre><p>
            (これらの行を消すだけでもいいです。)
          </p><p>
            <code class="filename">/etc/ttys</code>
            を編集したら、
            次は十分な数の仮想ターミナルデバイスを作らなくてはなりません。
            もっとも簡単な方法を示します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV vty12</code></strong><span class="emphasis"><em> (12 個のデバイスをつくる場合)</em></span></pre><p>
            さて、仮想コンソールを有効にするもっとも簡単 (そして確実) な方法は、
            再起動することです。しかし、再起動したくない場合は、
            X ウィンドウシステムを終了させて次の内容を
            (<code class="systemitem">root</code>権限で) 実行します。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP 1</code></strong></pre><p>
            重要な点は、
            このコマンドを実行する前に X
            ウィンドウシステムを完全に終了させておくことです。
            もしそうしないと <code class="command">kill</code>
            コマンドを実行した後、
            システムはおそらくハングアップするでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81777616"></a><a id="vty-from-x"></a><p><strong>8.7.</strong></p></td><td align="left" valign="top"><p>X から仮想コンソールに切替えるにはどうすればよいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            仮想コンソールへ戻るには
            <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> を使ってください。
            最初の仮想コンソールへは
            <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> で戻れます。
          </p><p>
            テキストコンソールへ移った後は、その中で移動するのに
            今度はいつもどおり
            <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> を使ってください。
          </p><p>
            X のセッションへ戻るには X の走っている仮想コンソールへ
            切り替える必要があります。もしあなたが X をコマンドラインから
            実行していたのであれば (たとえば <code class="command">startx</code>
            を使う) X のセッションはそれを実行したテキストコンソールではなく
            最初の使われていない仮想コンソールに割り当てられているはずです。
            あなたが仮想端末を 8 個用意している場合は X を 9 番目の
            コンソールにいるはずで、
            <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F9</strong></span> を使うことになります。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                X に戻るには、
                3 枚の仮想コンソールが有効になっている場合は
                <span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>F4</strong></span> です。
                有効な仮想コンソールの数 +1 のファンクションキーの
                位置に X が割り当てられます。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81789392"></a><a id="xdm-boot"></a><p><strong>8.8.</strong></p></td><td align="left" valign="top"><p>XDM を起動時に起動させるにはどうしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm" target="_top">xdm</a>
            の起動方法については二つの流派があります。
            一方の流派では提供された例を使用して xdm を
            <code class="filename">/etc/ttys</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a> 参照)
            から起動し、もう一方の流派では xdm を単に
            <code class="filename">rc.local</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 参照)
            または <code class="filename">/usr/local/etc/rc.d</code> においた
            <code class="filename">X.sh</code> スクリプトから起動します。
            どちらも正しく、片方が動作しない場合は、もう片方が動作するでしょう。
            どちらも場合でも結果は同じであり、X はグラフィカルな
            <code class="prompt">login:</code> プロンプトを表示します。
          </p><p>
            <code class="filename">ttys</code> を利用する方法の利点は、
            どの <acronym class="acronym">vty</acronym> で X が起動したかの記録が残せることと、
            ログアウト時に X サーバを再起動する責任を
            init に押しつけることができることでしょう。
          </p><p>
            <code class="filename">rc.local</code> からロードされる場合、
            <code class="command">xdm</code> は引数を持たずに
            (すなわち、デーモンとして) 起動します。
            <code class="command">xdm</code> は <code class="command">getty</code>
            が起動した後にロードされなければなりません。
            そうでないと、<code class="command">xdm</code> は <code class="command">getty</code>
            と衝突し、コンソールをロックアウトしてしまいます。
            この問題に対処する最善の方法は、
            起動スクリプト (訳注: <code class="filename">rc.local</code>
            のこと) で 10 秒ほどの <code class="command">sleep</code> を実行させ、
            その後に <code class="command">xdm</code> をロードすることです。
          </p><p>
            <code class="filename">/etc/ttys</code> から
            <code class="command">xdm</code> を起動させている場合には、
            <code class="command">xdm</code> と <code class="command">getty</code>
            が衝突する可能性があります。
            この問題を回避するには、<code class="filename">/usr/X11R6/lib/X11/xdm/Xservers</code> に
            <code class="literal">vt</code> 番号を追加してください。
          </p><pre class="programlisting">:0 local /usr/X11R6/bin/X vt4</pre><p>上の例は、<code class="filename">/dev/ttyv3</code> を
            X サーバに対応させます。番号は 1 から始まりますので注意してください。
            X サーバは
            <acronym class="acronym">vty</acronym> を 1 から数えますが、
            FreeBSD カーネルは
            <acronym class="acronym">vty</acronym> を 0 から数えます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81871056"></a><a id="xconsole-failure"></a><p><strong>8.9.</strong></p></td><td align="left" valign="top"><p><code class="command">xconsole</code> を動かそうとすると
            <span class="quote">「<span class="quote"><code class="computeroutput">Couldn't open console</code></span>」</span>
            とエラーが出ます。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">X</span> を <code class="command">startx</code>
            で起動しますと、<code class="filename">/dev/console</code> のパーミッションは
            <span class="emphasis"><em>変更できない</em></span>ようになっていますので、
            <code class="command">xterm -C</code> や <code class="command">xconsole</code>
            は動きません。
          </p><p>
            これはコンソールのパーミッションが、
            標準ではそのように設定されているからです。
            マルチユーザシステムでは、
            ユーザの誰もがシステムコンソールに書き込むことが可能である必要は必ずしもありません。
            <acronym class="acronym">VTY</acronym>
            を使い直接マシンにログインするユーザのために、
            このような問題を解決するために
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a>
            というファイルがあります。
          </p><p>
            要点を述べると、次のような形式の行を
            <code class="filename">/etc/fbtab</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a> 参照) に加えます。
          </p><pre class="programlisting">/dev/ttyv0 0600 /dev/console</pre><p>
            そうすると、
            <code class="filename">/dev/ttyv0</code> からログインしたユーザが
            コンソールを所有することになるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81884752"></a><a id="xfree86-root"></a><p><strong>8.10.</strong></p></td><td align="left" valign="top"><p>わたしはいつも XFree86 を一般ユーザから起動していたのですが、
            最近になって <code class="systemitem">root</code> ユーザでなければな
            らないと言われるようになりました。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>すべての X サーバは、
            ビデオハードウェアに直接アクセスするために <code class="systemitem">root</code>
            ユーザで実行される必要があります。
            古いバージョンの XFree86 (&lt;= 3.3.6) に含まれるすべてのサーバは、
            自動的に <code class="systemitem">root</code> 権限で実行されるように
            (<code class="systemitem">root</code> ユーザに setuid
            されて) インストールされます。
            X サーバは大きく複雑なプログラムであり、
            これは明らかにセキュリティを危険に晒す要因となります。
            そのため新しいバージョンの XFree86 では、
            サーバを <code class="systemitem">root</code> ユーザに setuid
            しないでインストールするようになりました。</p><p>X サーバを root ユーザで動かすというのは、
            明らかにセキュリティ的に不適当で受け入れられないことです。
            X を一般ユーザで実行するには、二つの方法があります。
            一つは <code class="command">xdm</code> や、その他のディスプレイマネージャ
            (たとえば <code class="command">kdm</code> など) を使うこと、
            もう一つは <code class="command">Xwrapper</code> を使うことです。
          </p><p><code class="command">xdm</code> は、
            グラフィカルなログイン画面を扱うデーモンです。
            通常、起動時に実行され、
            各ユーザの認証とユーザセションを開始させる機能を実現します。
            基本的に、<code class="command">getty</code> と <code class="command">login</code>
            のグラフィック版、と考えて良いでしょう。
            <code class="command">xdm</code> の詳細については、
            <a class="link" href="http://www.xfree86.org/support.html" target="_top">XFree86
              関連文書</a> および
            <a class="link" href="x.html#xdm-boot" title="8.8.">FAQ 項目</a>をご覧ください。</p><p><code class="command">Xwrapper</code> とは、X サーバ用のラッパ
            (wrapper) のことです。
            これは必要なセキュリティを確保しつつ、一般ユーザが X
            サーバを実行できるようにした小さなユーティリティで、
            コマンドライン引数の正当性チェックを行ない、
            それを通過すれば適切な X サーバを起動します。
            何らかの理由でディスプレイマネージャを使いたくない場合に
            これを使うと良いでしょう。
            Ports Collection 全体をインストールしていれば、
            <code class="filename">/usr/ports/x11/wrapper</code>
            にあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81895120"></a><a id="ps2-x"></a><p><strong>8.11.</strong></p></td><td align="left" valign="top"><p>私の PS/2 マウスは X ウィンドウシステム上でうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            あなたのマウスとマウスドライバがうまく同期していないからかもしれません。
          </p><p>
            FreeBSD 2.2.5 までのバージョンでは、X から仮想ターミナルへ切替えて、
            また X へ戻ると再同期するかもしれません。
            この問題がよく起きるようであれば、カーネルコンフィグレーション
            ファイルに次のオプションを書いてカーネルを再構成してみてください。
          </p><pre class="programlisting">options PSM_CHECKSYNC</pre><p>
            もし、カーネルの再構築を行なったことがないのであれば、
            <a class="link" href="kernelconfig.html#make-kernel" title="6.1.">カーネルを構築する</a>の項を参照してください。
          </p><p>
            このオプションにより、
            マウスとドライバの同期で問題が起きる可能性は少なくなるでしょう。
            もしそれでもこの問題が起きるようならば、
            再同期させるにはマウスを動かさないようにしておいて
            マウスボタンのどれかを押してください。
          </p><p>
            このオプションは残念ながらすべてのシステムで働くわけではなく、
            また、PS/2 マウスポートにつながれているのが
            タップ (tap) 機能を持つ アルプス社製 GlidePoint デバイスの場合、
            タップ機能が無効となってしまいます。
          </p><p>
            FreeBSD 2.2.6 以降のバージョンでは、
            同期のチェック方法が少し改善されたので標準で有効になっています。
            GlidePoint でもうまく働きます (同期チェックが標準の機能になったので
            <code class="literal">PSM_CHECKSYNC</code>
            オプションはこれらのバージョンからは削除されました)。
            しかしながら、
            まれにドライバが間違って (訳注:
            問題がないのに) 同期に関して問題があると報告し、カーネルから
          </p><pre class="programlisting">psmintr: out of sync (xxxx != yyyy)</pre><p>
            というメッセージが出力されて、マウスが正しく動作していないように見える
            ことがあるかもしれません。
          </p><p>
            もしこのようなことが起こる場合には、PS/2 マウスドライバのフラグに
            0x100 を指定して同期チェックを無効にしてください。システムの起動時に
            <span class="quote">「<span class="quote"><code class="option">-c</code></span>」</span>
            起動オプションを与えて
            <span class="emphasis"><em>UserConfig</em></span> に入ります。
          </p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><pre class="screen"><code class="prompt">boot:</code> <strong class="userinput"><code>-c</code></strong></pre><p>
            <span class="emphasis"><em>UserConfig</em></span>
            のコマンドラインで以下のように入力してください。
          </p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x100</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81910224"></a><a id="ps2-mousesystems"></a><p><strong>8.12.</strong></p></td><td align="left" valign="top"><p>MouseSystems の PS/2 マウスがうまく動きません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            MouseSystems の PS/2 マウスのあるモデルは、
            高解像度モードの場合にのみ正しく動作するということが報告されています。
            それ以外のモードでは、
            マウスカーソルがしょっちゅうスクリーン左上に行ってしまうかもしれません。
          </p><p>
            残念ながら FreeBSD 2.0.X や 2.1.X のバージョンでは、
            この問題を解決する方法はありません。
            2.2 から 2.2.5 のバージョンでは、
            以下のパッチを
            <code class="filename">/sys/i386/isa/psm.c</code>
            に適用しカーネルの再構築を行なってください。
          </p><p>
            もし、カーネルの再構築を行なったことがないのであれば、
            <a class="link" href="kernelconfig.html#make-kernel" title="6.1.">カーネルの構築</a>の項を参照してください。
          </p><pre class="programlisting">@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
         log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
             unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);    /* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);               /* stream mode */</pre><p>
            FreeBSD 2.2.6 以降のバージョンでは、
            PS/2 マウスドライバのフラグに
            0x04 を指定してマウスを高解像度モードにします。
            システムの起動時に
            <code class="option">-c</code>
            起動オプションを与えて
            <span class="emphasis"><em>UserConfig</em></span> に入ります。
          </p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><p>
            <span class="emphasis"><em>UserConfig</em></span>
            のコマンドラインで以下のように入力してください。
          </p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x04</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre><p>
            マウスに関する不具合の他の原因の可能性については、
            直前のセクションも見てみてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81922768"></a><a id="imake-tmpl"></a><p><strong>8.13.</strong></p></td><td align="left" valign="top"><p>X のアプリケーションを構築する時に、
            <code class="computeroutput">imake can't find <code class="filename">Imake.tmpl</code></code>
            となります。どこにあるのでしょうか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">Imake.tmpl</code> は
            X の標準アプリケーション構築ツールである Imake パッケージの一部です。
            <code class="filename">Imake.tmpl</code> は、
            X アプリケーションの構築に必要な多くのヘッダファイルと同様に、
            X のプログラムディストリビューションに含まれています。
            <code class="command">sysinstall</code> を使うか、
            手動で X のディストリビューションファイルからインストールすることができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81926608"></a><a id="mouse-button-reverse"></a><p><strong>8.14.</strong></p></td><td align="left" valign="top"><p>マウスのボタンを入れ替える方法はありますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="filename">.xinitrc</code> か
            <code class="filename">.xsession</code> で
          </p><pre class="programlisting"><code class="command">xmodmap</code> <code class="option">-e "pointer = 3 2 1"</code></pre><p>
            というコマンドを実行してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81930832"></a><a id="install-splash"></a><p><strong>8.15.</strong></p></td><td align="left" valign="top"><p>スプラッシュスクリーンのインストールはどうするのですか。
            どこで見つけることができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 3.1 のリリース直前に、起動メッセージの表示期間に
            いわゆる "スプラッシュ"
            スクリーンを表示させることができる新しい機能が追加されました。
            いまのところスプラッシュスクリーンは
            256 色のビットマップ (<code class="filename">*.BMP</code>) か
            ZSoft PCX (<code class="filename">*.PCX</code>) ファイルです。
            それに加えて、標準の <acronym class="acronym">VGA</acronym> アダプタでの動作させるには
            320x200 以下の解像度である必要があります。
            カーネルに <acronym class="acronym">VESA</acronym>
            サポートを追加すれば 1024x768
            までのより大きいビットマップを使用できます。
            <acronym class="acronym">VESA</acronym> サポートを有効化するにはまず、
            カーネルが
            <code class="literal">VM86</code>
            カーネルオプションとともにコンパイルされている必要があることに注意してください。
            <acronym class="acronym">VESA</acronym> サポートそのものは
            <code class="literal">VESA</code> カーネルコンフィグオプション
            によって直接カーネル中にコンパイルするか、
            起動時に <acronym class="acronym">VESA</acronym> kld
            モジュールを読み込ませることができます。
          </p><p>
            スプラッシュスクリーンを使うには、
            FreeBSD
            の起動プロセスをコントロールするスタートアップファイルを書き換える必要があります。
            これらのファイルは FreeBSD 3.2 のリリース以前に変更されましたので、
            現在は、スプラッシュスクリーンを読み込む方法が二つあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>FreeBSD 3.1 の場合</p><p>
                  まず最初のステップは、
                  スプラッシュスクリーンのビットマップ版を探してくることです。
                  3.1-RELEASE では Windows
                  のビットマップ形式のスプラッシュスクリーンだけをサポートしています。
                  お望みのスプラッシュスクリーンを見つけたなら、それを
                  <code class="filename">/boot/splash.bmp</code>
                  にコピーします。次に、これらの行が書かれた
                  <code class="filename">/boot/loader.rc</code>
                  ファイルが必要です。
                </p><pre class="programlisting">load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</pre></li><li class="listitem"><p>FreeBSD 3.2 以降の場合</p><p>PCX 形式のスプラッシュスクリーンのサポートが追加されると同時に、
                  FreeBSD 3.2 には起動プロセスを設定する、
                  より洗練された方法が含まれています。
                  もしお望みなら、上に示した
                  FreeBSD 3.1 用の方法を使うこともできます。
                  もしそうしたくて、かつ PCX 形式を使いたいなら、
                  <code class="literal">splash_bmp</code> を
                  <code class="literal">splash_pcx</code> と読み換えてください。
                  そうではなくて、新しい起動設定方法を使うのなら、
                  次の数行が書かれた <code class="filename">/boot/loader.rc</code>
                  ファイルと、</p><pre class="programlisting">include /boot/loader.4th
start</pre><p>
                  次の数行が含まれた
                  <code class="filename">/boot/loader.conf</code>
                  ファイルを作ることが必要です。
                </p><pre class="programlisting">splash_bmp_load="YES"
bitmap_load="YES"</pre><p>
                  この例では、スプラッシュスクリーンとして
                  <code class="filename">/boot/splash.bmp</code>
                  を使うことを想定しています。PCX 形式のファイルを使う場合には、
                  そのファイルを <code class="filename">/boot/splash.pcx</code> にコピーして、
                  上で示したように
                  <code class="filename">/boot/loader.rc</code> を作ります。
                  そして、次の内容の
                  <code class="filename">/boot/loader.conf</code>
                  というファイルを作ってください。
                </p><pre class="programlisting">splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</pre></li></ul></div><p>
            さて、あとはスプラッシュスクリーンを用意するだけです。
            それには <a class="link" href="http://www.baldwin.cx/splash/" target="_top">http://www.baldwin.cx/splash/</a>
            のギャラリーをサーフしてみてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81958992"></a><a id="windows-keys"></a><p><strong>8.16.</strong></p></td><td align="left" valign="top"><p>X で Windows(tm) キーを使うことはできるのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい、もちろん。
            どういう動作をするかについて定義するには <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xmodmap&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xmodmap</span>(1)</span></a> を使います。
          </p><p>
            標準的な "Windows(tm)" キーボードの場合、
            対応するキーコードは 3 種類あります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>115 - 左の Ctrl と Alt の間にある Windows(tm) キー</p></li><li class="listitem"><p>116 - 右の Alt と Gr の間にある Windows(tm) キー</p></li><li class="listitem"><p>117 - 右の Ctrl の左隣にあるメニューキー</p></li></ul></div><p>
            左にある Windows(tm) キーを押すとカンマ記号が入力されるようにするには、
            こんな風にします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>xmodmap -e "keycode 115 = comma"</code></strong></pre><p>
            設定を反映させるには、おそらくウィンドウマネージャを再起動する必要があります。
          </p><p>
            Windows(tm) キーのキーマップを X 起動時に毎回、
            自動的に有効化するには <code class="command">xmodmap</code> コマンドを
            <code class="filename">~/.xinitrc</code> に追加するか、
            もしくはおすすめできる方法として
            <code class="filename">~/.xmodmaprc</code> というファイルを作成して、
            そのファイルの一行一行に <code class="command">xmodmap</code>
            のオプションを記述し、次の一行
          </p><pre class="programlisting">xmodmap $HOME/.xmodmaprc</pre><p>を <code class="filename">~/.xinitrc</code>
            に追加するという方法があります。</p><p>
            たとえば、先ほどあげた三つのキーを F13、F14、F15 に割り当てるとします。
            こうしておけば、後ほど示すように、アプリケーションや
            ウィンドウマネージャの便利な機能を
            その三つのキーに簡単に割り当てることができます。
          </p><p>
            こうするには、次の内容を <code class="filename">~/.xmodmaprc</code>
            に追加します。
          </p><pre class="programlisting">keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre><p>
            たとえば <code class="command">fvwm2</code> を使っていたら、
            F13 をカーソル下のウィンドウのアイコン化、
            F14 をウィンドウの前面/背面化、
            F15 を、あたかもデスクトップにカーソルが存在しないかのように、
            メインワークスペース (アプリケーション)
            のメニューを呼び出せる機能に割り当てられます。
            最後の機能は、そのデスクトップがまったく見えないときに便利です。
            (また、キートップのロゴにもぴったりです)
            
          </p><p>
            <code class="filename">~/.fvwmrc</code> の次のエントリは、前述の
            設定を実現します。
          </p><pre class="programlisting">Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="admin.html">戻る</a>〓</td><td width="20%" align="center">〓</td><td width="40%" align="right">〓<a accesskey="n" href="networking.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第7章 システム管理〓</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">〓第9章 ネットワーキング</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文書、および他の文書は
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>
    からダウンロードできます。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>FreeBSD に関する質問がある場合には、
    <a href="http://www.FreeBSD.org/ja/docs.html">ドキュメント</a> を読んだ上で
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt; まで (英語で) 連絡してください。<br></br>
    本文書に関する質問については、
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt; まで電子メールを (英語で) 送ってください。</small></p></body></html>