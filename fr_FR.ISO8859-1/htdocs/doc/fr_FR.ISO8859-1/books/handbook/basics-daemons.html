<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>4.8. Daemons, signaux, et comment tuer un processus</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manuel FreeBSD" /><link rel="up" href="basics.html" title="Chapitre 4. Quelques bases d'UNIX" /><link rel="prev" href="basics-processes.html" title="4.7. Processus" /><link rel="next" href="shells.html" title="4.9. Interpréteurs de commandes - &#8220;Shells&#8221;" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.8. Daemons, signaux, et comment tuer un processus</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="basics-processes.html">Précédent</a> </td><th width="60%" align="center">Chapitre 4. Quelques bases d'UNIX</th><td width="20%" align="right"> <a accesskey="n" href="shells.html">Suivant</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="basics-daemons"></a>4.8. Daemons, signaux, et comment tuer un processus</h2></div></div></div><p>Quand vous utilisez un éditeur il est facile de le
      contrôler, de lui dire de charger des fichiers, et ainsi de suite.
      Vous pouvez faire cela parce que l'éditeur fournit les
      possibilités de le faire, et parce qu'un éditeur est
      attaché à un <em class="firstterm">terminal</em>.
      Certains programmes ne sont pas conçus pour fonctionner avec
      un dialogue constant avec l'utilisateur, et donc ils se
      déconnectent du terminal à la première occasion.
      Par exemple, un serveur web passe son temps à répondre
      aux requêtes web, il n'attend normalement pas d'entrée de
      votre part.  Les programmes qui transportent le courrier
      électronique de site en site sont un autre exemple de cette
      classe d'application.</p><p>Nous appelons ces programmes des
      <em class="firstterm">daemons</em> (démons).  Les
      &#8220;daemons&#8221; étaient des personnages de la mythologie
      Grecque: ni bon ni mauvais, c'étaient de petits esprits serviteurs
      qui, généralement, ont été à l'origine
      de choses utiles à l'humanité,
      un peu comme les serveurs web ou de messagerie d'aujourd'hui nous
      sont utiles.  C'est pourquoi la mascotte BSD a été, pendant
      longtemps, un démon à l'apparence joyeuse portant des
      chaussures de tennis et une fourche.</p><p>Il existe une convention pour nommer les programmes qui
      fonctionnent normalement en tant que daemons qui est d'utiliser
      une terminaison en &#8220;d&#8221;.
      <span class="application">BIND</span> est le &#8220;Berkeley Internet Name
      Domain&#8221;, mais le programme réel qui est exécuté
      s'appelle <code class="command">named</code>); le programme
      correspondant au serveur web <span class="application">Apache</span> est
      appelé <code class="command">httpd</code>; le daemon de gestion de la file
      d'attente de l'imprimante est <code class="command">lpd</code>, et ainsi de
      suite.  C'est une convention, mais pas une obligation pure et
      simple; par exemple le daemon principal de gestion du courrier
      électronique pour l'application
      <span class="application">Sendmail</span> est appelé
      <code class="command">sendmail</code>, et non pas <code class="command">maild</code>,
      comme vous pourriez l'imaginer.</p><p>Parfois vous devrez communiquer avec un processus daemon.
      Une manière de procéder est de lui (ou à tout processus en cours
      d'exécution) envoyer ce que l'on appelle un
      <em class="firstterm">signal</em>.  Il existe un certain
      nombre de signaux différents que vous pouvez
      envoyer&#8212;certains d'entre eux ont une signification précise,
      d'autres sont interprétés par l'application, et la
      documentation de l'application vous indiquera comment l'application
      interprète ces signaux.  Vous ne pouvez envoyer de signaux
      qu'aux processus dont vous êtes le propriétaire.
      Si vous envoyez un signal à un
      processus appartenant à quelqu'un d'autre avec <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>
      ou <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">kill</span>(2)</span></a>, vous obtiendrez un refus de permission.  Il existe
      une exception à cela: l'utilisateur <code class="systemitem">root</code>, qui
      peut envoyer des signaux aux processus de chacun.</p><p>Dans certain cas FreeBSD enverra également aux applications
      des signaux.  Si une application est mal écrite, et tente
      d'accéder à une partie de mémoire à
      laquelle elle n'est pas supposée avoir accès, FreeBSD
      envoie au processus le signal de
      <em class="firstterm">violation de segmentation</em>
      (<code class="literal">SIGSEGV</code>).  Si une application a utilisé
      l'appel système <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=alarm&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">alarm</span>(3)</span></a> pour être avertie
      dès qu'une période de temps précise est
      écoulée alors lui sera envoyé le signal d'alarme
      (<code class="literal">SIGALRM</code>), et ainsi de suite.</p><p>Deux signaux peuvent être utilisés pour arrêter
      un processus, <code class="literal">SIGTERM</code> et <code class="literal">SIGKILL</code>.
      <code class="literal">SIGTERM</code> est la manière polie de tuer un
      processus; le processus peut <span class="emphasis"><em>attraper</em></span> le signal,
      réaliser que vous désirez qu'il se termine, fermer les
      fichiers de trace qu'il a peut-être ouvert, et
      généralement
      finir ce qu'il était en train de faire juste avant la demande
      d'arrêt.  Dans certains cas un processus peut ignorer un
      <code class="literal">SIGTERM</code> s'il est au milieu d'une tâche qui ne
      peut être interrompue.</p><p><code class="literal">SIGKILL</code> ne peut être ignoré par un
      processus.  C'est le signal &#8220;Je me fiche de ce que vous
      faites, arrêtez immédiatement&#8221;.  Si vous envoyez un
      <code class="literal">SIGKILL</code> à un processus alors FreeBSD
      stoppera le processus<a href="#ftn.idp70537808" class="footnote" id="idp70537808"><sup class="footnote">[4]</sup></a>.</p><p>Les autres signaux que vous pourriez avoir envie d'utiliser
      sont <code class="literal">SIGHUP</code>, <code class="literal">SIGUSR1</code>, et
      <code class="literal">SIGUSR2</code>.  Ce sont des signaux d'usage
      général, et différentes applications se
      comporteront différemment quand ils
      sont envoyés.</p><p>Supposez que vous avez modifié le fichier de configuration de
      votre serveur web&#8212;vous voudriez dire à votre serveur web de
      relire son fichier de configuration.  Vous pourriez arrêter et
      relancer <code class="command">httpd</code>, mais il en résulterait une
      brève période d'indisponibilité de votre serveur
      web, ce qui peut être indésirable.
      La plupart des daemons sont écrits pour répondre
      au signal <code class="literal">SIGHUP</code> en relisant leur fichier de
      configuration.  Donc au lieu de tuer et relancer
      <code class="command">httpd</code> vous lui enverriez le signal
      <code class="literal">SIGHUP</code>.  Parce qu'il n'y a pas de manière
      standard de répondre à ces signaux, différents
      daemons auront différents comportements, soyez sûr
      de ce que vous faites et lisez
      la documentation du daemon en question.</p><p>Les signaux sont envoyés en utilisant la commande
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>, comme cet exemple le montre:</p><div class="procedure"><a id="idp70543440"></a><div class="procedure-title">Procédure 4.1. Envoyer un signal à un processus</div><p>Cet exemple montre comment envoyer un signal à
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>.  Le fichier de configuration d'<code class="command">inetd</code> est
	<code class="filename">/etc/inetd.conf</code>, et <code class="command">inetd</code> relira ce
	fichier de configuration quand un signal
	<code class="literal">SIGHUP</code> est envoyé.</p><ol class="procedure" type="1"><li class="step"><p>Trouvez l'identifiant du processus (PID) auquel vous
	  voulez envoyer le signal.  Faites-le en employant <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a>
	  et <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a>.  La commande <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a> est utilisée pour
	  rechercher dans le résultat la chaîne de
	  caractères que
	  vous spécifiez.  Cette commande est lancée en tant
	  qu'utilisateur normal, et <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> est lancé en tant que
	  <code class="systemitem">root</code>, donc les options <code class="option">ax</code>
	  doivent être passées à <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a>.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ps -ax | grep inetd</code></strong>
  198  ??  IWs    0:00.00 inetd -wW</pre><p>Donc le PID d'<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> est 198.  Dans certains cas la
	  commande <code class="literal">grep inetd</code> pourrait aussi
	  apparaître dans le résultat.  C'est à
	  cause de la façon dont
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> recherche la liste des processus en
	  fonctionnement.</p></li><li class="step"><p>Utilisez <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> pour envoyer le signal.  Etant donné
	  qu'<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> tourne sous les droits de l'utilisateur
	  <code class="systemitem">root</code> vous devez utilisez <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> pour
	  devenir, en premier lieu, <code class="systemitem">root</code>.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">Password:</code>
<code class="prompt">#</code> <strong class="userinput"><code>/bin/kill -s HUP 198</code></strong></pre><p>Comme la plupart des commandes <span class="trademark">UNIX</span>®, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> n'affichera
	  rien si la commande est couronnée de succès.  Si vous
	  envoyez un signal à un processus dont vous n'êtes pas le
	  propriétaire alors vous verrez <span class="errorname">kill:
	  <em class="replaceable"><code>PID</code></em>: Operation not
	  permitted</span>.  Si vous avez fait une erreur dans le
	  PID, vous enverrez le signal soit à un mauvais processus, ce
	  qui peut être mauvais, soit, si vous êtes chanceux, vous
	  enverrez le signal à un PID qui n'est pas actuellement
	  utilisé, et vous verrez <span class="errorname">kill:
	  <em class="replaceable"><code>PID</code></em>: No such
	  process</span>.</p><div xmlns="" class="note"><h3 class="admontitle">Pourquoi utiliser <code xmlns="http://www.w3.org/1999/xhtml" class="command">/bin/kill</code>?: </h3><p xmlns="http://www.w3.org/1999/xhtml">De nombreux interpréteurs de commandes fournissent la
	    commande <code class="command">kill</code> comme commande interne;
	    c'est à dire, que l'interpréteur de commandes enverra
	    directement le signal, plutôt que de lancer
	    <code class="filename">/bin/kill</code>.  Cela peut être utile,
	    cependant les différents interpréteurs ont une syntaxe
	    différente pour spécifier le nom du signal à
	    envoyer.
	    Plutôt que de tenter de les apprendre toutes, il peut
	    être plus simple de juste employer directement la commande
	    <code class="command">/bin/kill
	    ...</code>.</p></div></li></ol></div><p>Envoyer d'autres signaux est très semblable, substituez juste
      <code class="literal">TERM</code> ou <code class="literal">KILL</code> dans la ligne
      de commande si nécessaire.</p><div xmlns="" class="important"><h3 class="admontitle">Important: </h3><p xmlns="http://www.w3.org/1999/xhtml">Tuer au hasard des processus sur le système peut
	être une mauvaise idée.
	En particulier, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>, processus à
	l'identifiant 1, qui est très particulier.  Lancer la commande
	<code class="command">/bin/kill -s KILL 1</code> est une manière
	rapide d'arrêter votre système.  Vérifiez
	<span class="emphasis"><em>toujours</em></span> à deux fois les arguments que vous
	utilisez avec <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> <span class="emphasis"><em>avant</em></span> d'appuyer
	sur <span class="keycap"><strong>Entrée</strong></span>.</p></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp70537808" class="footnote"><p><a href="#idp70537808" class="para"><sup class="para">[4] </sup></a>Ce n'est pas tout à fait vrai&#8212;il y a quelques cas
	  où les choses ne peuvent être interrompues.  Par exemple,
	  si le processus est en train d'essayer de lire un fichier qui
	  est sur un autre ordinateur sur le réseau, et que l'autre
	  ordinateur n'est plus accessible pour quelque raison
	  (a été éteint, ou le réseau a un
	  problème),
	  alors le processus est dit &#8220;non interruptible&#8221;.
	  Par la suite le processus entrera en pause, typiquement après
	  deux minutes.  Dès que cette pause sera effective le processus
	  sera tué.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="basics-processes.html">Précédent</a> </td><td width="20%" align="center"><a accesskey="u" href="basics.html">Niveau supérieur</a></td><td width="40%" align="right"> <a accesskey="n" href="shells.html">Suivant</a></td></tr><tr><td width="40%" align="left" valign="top">4.7. Processus </td><td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td><td width="40%" align="right" valign="top"> 4.9. Interpréteurs de commandes - &#8220;Shells&#8221;</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ce document, ainsi que d'autres peut être téléchargé sur
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Pour toutes questions à propos de FreeBSD, lisez la
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> avant de contacter
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Pour les questions sur cette documentation, contactez
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>