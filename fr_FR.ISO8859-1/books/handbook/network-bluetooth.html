<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>31.4. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manuel FreeBSD" /><link rel="up" href="advanced-networking.html" title="Chapitre 31. Administration réseau avancée" /><link rel="prev" href="network-wireless.html" title="31.3. Réseau sans fil" /><link rel="next" href="network-bridging.html" title="31.5. Bridging" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.4. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-wireless.html">Précédent</a> </td><th width="60%" align="center">Chapitre 31. Administration réseau avancée</th><td width="20%" align="right"> <a accesskey="n" href="network-bridging.html">Suivant</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>31.4. Bluetooth</h2></div><div><span class="authorgroup">Ecrit par <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pav</span> <span class="surname">Lucistnik</span></span>. </span></div></div></div><a id="idp86633680" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86634192"></a>31.4.1. Introduction</h3></div></div></div><p><span class="trademark">Bluetooth</span>® est une technologie sans fil pour créer
	des réseaux personnels sans fils fonctionnant dans la
	bande 2.4 GHz ne nécessitant pas d'autorisation, avec
	une portée de 10 mètres.  Les réseaux
	étant généralement composés de
	périphériques nomades comme les
	téléphones portables, les assistants personnels
	et les ordinateurs portables.  Contrairement à l'autre
	technologie sans fil, Wi-Fi, <span class="trademark">Bluetooth</span>® offre un niveau plus
	élevé de profils de service, par exemple des
	serveurs de fichiers semblables à FTP, &#8220;file
	pushing&#8221;, transport de la voix, émulation de
	lignes séries, et bien plus.</p><p>La pile <span class="trademark">Bluetooth</span>® sous FreeBSD utilise le système
	Netgraph (voir <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a>).  Une large gamme
	d'adaptateurs USB <span class="trademark">Bluetooth</span>® sont supportés par le
	pilote <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a>.  Les périphériques
	<span class="trademark">Bluetooth</span>® basés sur le circuit Broadcom BCM2033 sont
	supportés par les pilotes <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ubtbcmfw</span>(4)</span></a> et
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a>.  La carte 3Com <span class="trademark">Bluetooth</span>® PC Card 3CRWB60-A
	demande le pilote <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a>.  Les
	périphériques <span class="trademark">Bluetooth</span>® de type série
	et UART sont supportés via les pilotes <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>,
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a> et <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>.  Cette section
	décrit l'utilisation d'un adaptateur USB <span class="trademark">Bluetooth</span>®.
	Le support <span class="trademark">Bluetooth</span>® est disponible sur les systèmes
	5.0 et suivants.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86655056"></a>31.4.2. Branchement du périphérique</h3></div></div></div><p>Par défaut les pilotes de
	périphériques <span class="trademark">Bluetooth</span>® sont disponibles sous
	la forme de modules du noyau.  Avant de brancher le
	périphérique, vous devrez charger le pilote dans
	le noyau:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>Si le périphérique <span class="trademark">Bluetooth</span>® est
	présent au démarrage du système, chargez
	le module à partir de
	<code class="filename">/boot/loader.conf</code>:</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>Branchez votre clé USB.  Une sortie semblable
	à celle-ci devrait s'afficher sur la console (ou dans
	les journaux du système):</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">La pile Bluetooth doit être lancée
	  manuellement sous FreeBSD 6.0, et sous les versions 5.0
	  antérieures à la 5.5.  Ce lancement est
	  automatique à partir de <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a> sous
	  FreeBSD 5.5, 6.1 et versions suivantes.</p><p xmlns="http://www.w3.org/1999/xhtml">Copiez
	<code class="filename">/usr/share/examples/netgraph/bluetooth/rc.bluetooth</code>
	à un emplacement adapté, comme
	<code class="filename">/etc/rc.bluetooth</code>.  Cette
	procédure est utilisée pour démarrer et
	arrêter la pile <span class="trademark">Bluetooth</span>®.  C'est une bonne
	idée d'arrêter la pile avant de débrancher
	le périphérique, mais ce n'est pas
	(généralement) fatal.  Quand la pile
	démarre, vous devriez avoir des messages similaires aux
	suivants:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86672592"></a>31.4.3. Interface de contrôle de l'hôte (HCI)</h3></div></div></div><a id="idp86673232" class="indexterm"></a><p>L'interface de contrôle de l'hôte (HCI)
	fournit une interface de commande pour le contrôleur de
	la bande de base et le gestionnaire de liaisons, et
	l'accès à l'état du matériel et
	aux registres de contrôle.  Cette interface offre une
	méthode uniforme d'accès aux fonctions de la
	bande de base <span class="trademark">Bluetooth</span>®.  La couche HCI de l'hôte
	échange des données et des commandes avec le
	firmware HCI du matériel <span class="trademark">Bluetooth</span>®.  Le pilote de la
	couche de transport du contrôleur d'hôte (i.e.  le
	bus physique) fournit aux deux couches HCI la
	possibilité d'échanger des informations entre
	elles.</p><p>Un seul noeud Netgraph de type <span class="emphasis"><em>hci</em></span>
	est créé pour un périphérique
	<span class="trademark">Bluetooth</span>®.  Le noeud HCI est normalement connecté au
	noeud du pilote <span class="trademark">Bluetooth</span>® (flux descendant) et au noeud
	L2CAP (flux montant).  Toutes les opérations HCI
	doivent être effectuées sur le noeud HCI et non
	pas sur le noeud du pilote de périphérique.  Le
	nom par défaut pour le noeud HCI est
	&#8220;devicehci&#8221;.  Pour plus de détails
	consultez la page de manuel <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a>.</p><p>Une des tâches les plus courantes est la recherche
	de périphériques <span class="trademark">Bluetooth</span>® dans le voisinage
	hertzien.  Cette opération est appelée
	<span class="emphasis"><em>inquiry</em></span> (enquête, recherche).
	Cette recherche et les autres opérations relatives
	à HCI sont effectuées par l'utilitaire
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a>.  L'exemple ci-dessous montre comment
	déterminer quels périphériques
	<span class="trademark">Bluetooth</span>® sont dans le voisinage.  Vous devriez obtenir une
	listes de périphériques au bout de quelques
	secondes.  Notez qu'un périphérique distant ne
	répondra à la recherche que s'il est
	placé dans le mode <span class="emphasis"><em>discoverable</em></span>.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> est l'adresse unique d'un
	périphérique <span class="trademark">Bluetooth</span>®, similaire à
	l'adresse MAC d'une carte réseau.  Cette adresse est
	nécessaire pour communiquer avec un
	périphérique.  Il est possible d'assigner un nom
	humainement compréhensible à l'adresse BD_ADDR.
	Le fichier <code class="filename">/etc/bluetooth/hosts</code> contient
	des informations concernant les hôtes <span class="trademark">Bluetooth</span>®
	connus.  L'exemple suivant montre comment obtenir le nom qui a
	été assigné au périphérique
	distant:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>Si vous effectuez une recherche sur un
	périphérique <span class="trademark">Bluetooth</span>® distant, vous devriez
	trouver votre ordinateur en tant que &#8220;votre.machine.nom
	(ubt0)&#8221;.  Le nom affecté au
	périphérique local peut être
	modifié à tout moment.</p><p>Le système <span class="trademark">Bluetooth</span>® fournit une connexion point
	à point (seules deux matériels <span class="trademark">Bluetooth</span>® sont
	concernés), ou une connexion point à
	multipoints.  Dans le cas d'une connexion point à
	multipoints, la connexion est partagés entre plusieurs
	périphériques <span class="trademark">Bluetooth</span>®.  L'exemple suivant
	montre comment obtenir la liste des connexions en bande de
	base actives pour le périphérique local:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p>Une <span class="emphasis"><em>manipulation de la connexion</em></span> est
	utile quand la fin d'une connexion en bande de base est
	nécessaire.  Notez qu'il n'est normalement pas
	nécessaire de le faire à la main.  La pile
	mettra fin automatiquement aux connexions en bande de base
	inactives.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>Référez-vous à la commande
	<code class="command">hccontrol help</code> pour une liste
	complète des commandes HCI disponibles.  La plupart des
	commandes HCI ne nécessitent pas les privilèges
	du super-utilisateur.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86696016"></a>31.4.4. Protocole d'adaptation et de contrôle de lien
	logique (L2CAP)</h3></div></div></div><a id="idp86701008" class="indexterm"></a><p>Le protocole d'adaptation et de contrôle de lien
	logique (L2CAP) fournit des services orientés connexion
	ou non aux protocoles de niveaux supérieurs, et cela
	avec des possibilités de multiplexage de protocoles, de
	segmentation et de réassemblage.  L2CAP permet aux
	applications et aux protocoles de niveaux supérieurs de
	transmettre et recevoir des paquets L2CAP d'une taille allant
	jusqu'à 64 Ko.</p><p>L2CAP est basé sur le concept de
	<span class="emphasis"><em>canaux</em></span>.  Un canal est une connexion
	logique au sommet de la connexion en bande de base.  Chaque
	canal est attaché à un protocole suivant le
	schéma plusieurs-vers-un.  Plusieurs canaux peuvent
	être attachés au même protocole, mais un
	canal ne peut être attachés à plusieurs
	protocoles.  Chaque paquet L2CAP reçu sur un canal est
	dirigé vers le protocole de niveau supérieur
	approprié.  Plusieurs canaux peuvent partager la
	même connexion en bande de base.</p><p>Un seul noeud Netgraph de type <span class="emphasis"><em>l2cap</em></span>
	est créé pour un périphérique
	<span class="trademark">Bluetooth</span>®.  Le noeud L2CAP est normalement connecté
	au noeud HCI <span class="trademark">Bluetooth</span>® (flux descendant) et aux noeuds des
	&#8220;sockets&#8221; <span class="trademark">Bluetooth</span>® (flux montant).  Le nom par
	défaut pour le noeud L2CAP est
	&#8220;device2cap&#8221;.  Pour plus de détails
	consultez la page de manuel <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a>.</p><p>Une commande utile est <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a>, qui peut être
	utilisée pour &#8220;pinguer&#8221; les autres
	périphériques.  Certaines implémentations
	de <span class="trademark">Bluetooth</span>® peuvent ne pas renvoyer toutes les
	données qui leur sont envoyées, aussi <code class="literal">0
	bytes</code> dans ce qui suit est normal.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p>L'utilitaire <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> est employé pour
	effectuer diverses opérations sur les noeuds L2CAP.
	Cet exemple montre comment obtenir la liste des connexions
	logiques (canaux) et la liste des connexions en bande de base
	pour le périphérique local:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p>Un autre outil de diagnostic est <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a>.  Il
	effectue un travail similaire à celui de
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>, mais relatif aux structures de données
	réseau <span class="trademark">Bluetooth</span>®.  L'exemple ci-dessous montre la
	même connexion logique que <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a>
	ci-dessus.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86728912"></a>31.4.5. Protocole RFCOMM</h3></div></div></div><a id="idp86733776" class="indexterm"></a><p>Le protocole RFCOMM permet l'émulation du port
	série au-dessus du protocole L2CAP.  Le protocole est
	basé sur la norme ETSI TS 07.10.  RFCOMM est un
	protocole de transport simple, avec les dispositions
	supplémentaires pour émuler les 9 circuits
	(signaux) d'un port série RS232 (EIATIA-232-E).  Le
	protocole RFCOMM supporte jusqu'à 60 connexions
	simultanées (canaux RFCOMM) entre deux
	périphériques <span class="trademark">Bluetooth</span>®.</p><p>Dans le cas de RFCOMM, l'établissement d'une
	communication implique deux applications tournant sur des
	périphériques différents (les
	extrémités de la communication) avec un segment
	de communication entre eux.  RFCOMM est prévu pour
	couvrir les applications faisant usage des ports séries
	des périphériques sur lesquels elles
	résident.  Le segment de communication est une liaison
	<span class="trademark">Bluetooth</span>® d'un périphérique vers un autre
	(connexion directe).</p><p>RFCOMM est seulement concerné par la connexion
	entre périphériques dans le cas d'un
	raccordement direct, ou entre le périphérique et
	un modem dans le cas d'un réseau.  RFCOMM peut
	supporter d'autres configurations, comme les modules qui
	communiquent par l'intermédiaire de la technologie sans
	fil <span class="trademark">Bluetooth</span>® d'un côté et utilise une
	interface câblée de l'autre
	côté.</p><p>Sous FreeBSD, le protocole RFCOMM est
	implémenté au niveau de la couche des
	&#8220;sockets&#8221; <span class="trademark">Bluetooth</span>®.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86738128"></a>31.4.6. Couplage des périphériques</h3></div></div></div><a id="idp86738768" class="indexterm"></a><p>Par défaut, une communication <span class="trademark">Bluetooth</span>® n'est pas
	authentifiée, et n'importe quel
	périphérique peut parler avec n'importe quel
	autre périphérique.  Un
	périphérique <span class="trademark">Bluetooth</span>® (par exemple un
	téléphone portable) peut choisir de demander une
	authentification pour fournir un service particulier (par
	exemple un service de connexion téléphonique).
	L'authentification <span class="trademark">Bluetooth</span>® est généralement
	effectuée avec des <span class="emphasis"><em>codes PIN</em></span>.  Un
	code PIN est une chaîne ASCII d'une longueur de 16
	caractères.  L'utilisateur doit entrer le même
	code PIN sur les deux périphériques.  Une fois
	que l'utilisateur a entré le code PIN, les deux
	périphériques génèrent une
	<span class="emphasis"><em>clé de liaison</em></span> (link key).
	Ensuite la clé peut être enregistrée soit
	dans les périphériques eux-mêmes ou sur un
	moyen de stockage non-volatile.  La fois suivante les deux
	périphériques utiliseront la clé
	précédemment générée.  La
	procédure décrite est appelée
	<span class="emphasis"><em>couplage</em></span>.  Si la clé de liaison
	est perdue par un des périphériques alors
	l'opération de couplage doit être
	répétée.</p><p>Le &#8220;daemon&#8221; <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> est responsable de
	la gestion de toutes les requêtes d'authentification
	<span class="trademark">Bluetooth</span>®.  Le fichier de configuration par défaut
	est <code class="filename">/etc/bluetooth/hcsecd.conf</code>.  Un
	exemple de section pour un téléphone portable
	avec un code PIN arbitraire de &#8220;1234&#8221; est
	donné ci-dessous:</p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>Il n'y pas de limitation sur les codes PIN (en dehors de
	la longueur).  Certains périphériques (comme les
	casques-micro <span class="trademark">Bluetooth</span>®) peuvent avoir un code PIN
	définitivement fixé.  Le paramètre
	<code class="option">-d</code> force le &#8220;daemon&#8221;
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> à rester en tâche de fond, il est
	donc aisé de voir ce qu'il se passe.  Configurez le
	périphérique distant pour recevoir le couplage
	et initier la connexion <span class="trademark">Bluetooth</span>® vers le
	périphérique distant.  Le
	périphérique distant devrait annoncer que le
	couplage a été accepté, et demander le
	code PIN.  Entrez le même code PIN que celui que vous
	avez dans le fichier <code class="filename">hcsecd.conf</code>.
	Maintenant votre PC et le périphérique distant
	sont couplés.  Alternativement, vous pouvez initier le
	couplage sur le périphérique distant.</p><p>Sous FreeBSD 5.5, 6.1 et versions suivantes, la ligne
	suivante peut être ajoutée au fichier
	<code class="filename">/etc/rc.conf</code> pour obtenir un lancement
	automatique de <span class="application">hcsecd</span> au
	démarrage du système:</p><pre class="programlisting">hcsecd_enable="YES"</pre><p>Ce qui
	suit est une partie de la sortie du &#8220;daemon&#8221;
	<span class="application">hcsecd</span>:</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86787792"></a>31.4.7. Le protocole de découverte de service
	(SDP)</h3></div></div></div><a id="idp86788432" class="indexterm"></a><p>Le protocole de découverte de service (SDP) offre
	aux applications clientes les moyens de découvrir
	l'existence des services fournis par les applications serveurs
	ainsi que les propriétés (attributs) de ces
	services.  Les attributs d'un service comprennent le type ou
	la classe du service offert et le mécanisme ou
	l'information sur le protocole nécessaire pour utiliser
	le service.</p><p>Le SDP implique la communication entre un serveur SDP et
	un client SDP.  Le serveur maintient une liste
	d'enregistrements de services qui décrit les
	caractéristiques des services associés avec le
	serveur.  Chaque enregistrement de service contient
	l'information sur un seul serveur.  Un client peut
	récupérer l'information à partir d'un
	enregistrement de service maintenu par le serveur SDP en
	émettant une requête SDP.  Si le client, ou une
	application associée avec le client, décide
	d'utiliser un service, il doit ouvrir une connexion
	séparée avec le fournisseur du service afin
	d'utiliser ce service.  Le SDP fournit un mécanisme
	pour découvrir les services et leur attributs, mais
	n'offre pas de mécanisme pour utiliser ces
	services.</p><p>Généralement, un client SDP recherche les
	services sur la base de caractéristiques de services
	désirées.  Cependant, il est parfois
	désirable de découvrir quel type de services
	sont décrits par les enregistrements de services d'un
	serveur SDP sans aucune information préalable sur les
	services.  Ce processus de recherche des services offerts est
	appelé <span class="emphasis"><em>navigation</em></span>
	(&#8220;browsing&#8221;).</p><p>Le serveur SDP <span class="trademark">Bluetooth</span>® <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> et le client en
	ligne de commande <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> font partie de
	l'installation FreeBSD standard.  L'exemple suivant montre
	comment effectuer un requête de navigation
	(&#8220;browse&#8221;) SDP:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec browse</code></strong>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</pre><p>... et ainsi de suite.  Remarquez que chaque service a une
	liste d'attributs (canal RFCOMM par exemple).  En fonction du
	service vous pourrez avoir besoin de prendre note de certains
	de ces attributs.  Certaines implémentations
	<span class="trademark">Bluetooth</span>® ne supportent pas les requêtes de navigation
	et peuvent renvoyer une liste vide.  Dans ce cas il est
	possible de chercher un service spécifique.  L'exemple
	ci-dessous montre comment chercher le service OBEX Object Push
	(OPUSH):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></strong></pre><p>Offrir des services sous FreeBSD aux clients <span class="trademark">Bluetooth</span>® se
	fait à l'aide du serveur <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.  Sous les
	versions de FreeBSD 5.5, 6.1 et plus récentes, la ligne
	suivante peut être ajoutée au fichier
	<code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">sdpd_enable="YES"</pre><p>Ensuite, le <span class="quote">« <span class="quote">démon</span> »</span>
	<span class="application">sdpd</span> peut être
	démarré avec:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/sdpd start</code></strong></pre><p>Sous FreeBSD 6.0, et sous les versions FreeBSD 5.X
	antérieures à 5.5, <span class="application">sdpd</span>
	n'est pas intégré aux procédures de
	démarrage du système.  Il doit être
	lancé manuellement:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpd</code></strong></pre><p>L'application serveur locale qui désire offrir un
	service <span class="trademark">Bluetooth</span>® à des clients distants enregistrera
	le service auprès du &#8220;daemon&#8221; SDP local.
	Un exemple d'une telle application est <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.
	Une fois démarré, il enregistrera un service de
	réseau local <span class="trademark">Bluetooth</span>® auprès du serveur SDP
	local.</p><p>La liste des services enregistrés auprès du
	serveur SDP local peut être obtenue en émettant
	une requête de navigation (&#8220;browse&#8221;) SDP par
	l'intermédiaire du canal de contrôle:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpcontrol -l browse</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86818128"></a>31.4.8. Les profils Dial-Up Networking (DUN) et accès au
	réseau local avec PPP (LAN)</h3></div></div></div><p>Le profil Dial-Up Networking (DUN) est principalement
	utilisé avec les modems et les téléphones
	portables.  Les cas de figure couverts par ce profil sont les
	suivants:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Utilisation d'un téléphone portable ou
	    d'un modem par un ordinateur comme modem sans fil pour se
	    connecter à un serveur d'accès Internet, ou
	    pour l'utilisation de services accessibles par
	    téléphone;</p></li><li class="listitem"><p>Utilisation d'un téléphone portable ou
	    d'un modem par un ordinateur pour recevoir des appels avec
	    transmission de données.</p></li></ul></div><p>Le profil d'accès au réseau local avec PPP
	(LAN) peut être utilisé dans les situations
	suivantes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Accès au réseau local pour un
	    périphérique <span class="trademark">Bluetooth</span>®;</p></li><li class="listitem"><p>Accès au réseau local pour plusieurs
	    périphériques <span class="trademark">Bluetooth</span>®;</p></li><li class="listitem"><p>Liaison PC à PC (en utilisant le protocole PPP
	    sur une émulation de câble
	    série).</p></li></ul></div><p>Sous FreeBSD les deux profils sont implémentés
	par <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> et <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>&#8212;un
	&#8220;wrapper&#8221; convertit la connexion <span class="trademark">Bluetooth</span>®
	RFCOMM en quelque chose d'utilisable par PPP.  Avant qu'un
	profil ne soit utilisable, un nouveau label doit être
	créé dans le fichier
	<code class="filename">/etc/ppp/ppp.conf</code>.  Consultez la page de
	manuel <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> pour des exemples.</p><p>Dans l'exemple suivant <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> sera
	employé pour ouvrir un connexion RFCOMM avec le
	périphérique distant avec une adresse BD_ADDR
	00:80:37:29:19:a4 sur un canal DUN RFCOMM.  Le numéro
	de canal RFCOMM réel sera obtenu du
	périphérique distant par l'intermédiaire
	de SDP.  Il est possible de préciser le canal RFCOMM
	à la main, dans ce cas <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>
	n'émettra pas de requête SDP.  Utilisez
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> pour trouver le canal RFCOMM sur le
	périphérique distant.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>Afin de fournir un service d'accès au réseau
	local avec PPP, le serveur <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> doit être en
	fonctionnement.  Une nouvelle entrée pour les clients
	du réseau local doit être créée
	dans le fichier <code class="filename">/etc/ppp/ppp.conf</code>.
	Consultez la page de manuel <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> pour des
	exemples.  Enfin, lancez le serveur RFCOMM PPP sur un
	numéro de canal RFCOMM valide.  Le serveur RFCOMM PPP
	enregistrera automatiquement un service <span class="trademark">Bluetooth</span>® LAN
	auprès du &#8220;daemon&#8221; SDP local.  L'exemple
	ci-dessous montre comment démarrer le serveur RFCOMM
	PPP:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86836688"></a>31.4.9. Le profil OBEX Object Push (OPUSH)</h3></div></div></div><a id="idp86837328" class="indexterm"></a><p>OBEX (échange d'objets) est un protocole
	très largement utilisé pour les transferts de
	fichiers entre périphériques mobiles.  Son
	utilisation principale se trouve dans les communications par
	infrarouge, où il est utilisé pour le transfert
	des fichiers entre ordinateurs portables ou PDAs, et pour
	envoyer des cartes de visite électronique ou des
	éléments d'agenda entre téléphones
	portables et d'autres périphériques disposant
	d'applications de gestion d'informations personnelles
	(PIM).</p><p>Le serveur et le client OBEX sont
	implémentés dans le logiciel tierce-partie
	<span class="application">obexapp</span>, qui est disponible sous la
	forme du logiciel porté <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/obexapp/pkg-descr">comms/obexapp</a>.</p><p>Le client OBEX est employé pour
	&#8220;pousser&#8221; et/ou &#8220;tirer&#8221; des objets du
	serveur OBEX.  Un objet peut être, par exemple, une
	carte de visite ou un rendez-vous.  Le client OBEX peut
	obtenir un numéro de canal RFCOMM d'un
	périphérique distant par l'intermédiaire
	de SDP.  Cela peut être fait en spécifiant le nom
	du service plutôt que le numéro du canal RFCOMM.
	Les noms de service supportés sont: IrMC, FTRN et
	OPUSH.  Il est possible de préciser le canal RFCOMM par
	un nombre.  Un exemple de session OBEX est
	présenté ci-dessous, où l'objet
	information du périphérique d'un
	téléphone portable est
	récupéré, et un nouvel objet (carte de
	visite) est envoyé dans le répertoire du
	téléphone.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>Afin de fournir le service OBEX Object Push, le serveur
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> doit tourner.  Un dossier racine où tous
	les objets entrant seront stockés doit être
	créé.  Le chemin d'accès par
	défaut du répertoire racine est <code class="filename">/var/spool/obex</code>.  Le serveur OBEX
	enregistrera automatiquement le service OBEX Object Push
	auprès du &#8220;daemon&#8221; SDP local.  L'exemple
	ci-dessous montre comment démarrer le serveur
	OBEX:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86843472"></a>31.4.10. Le profil port série (SPP)</h3></div></div></div><p>Le profil port série (SPP) permet aux
	périphériques <span class="trademark">Bluetooth</span>® d'émuler un
	câble série RS232 (ou similaire).  Ce profil
	traite avec les applications classiques en utilisant
	<span class="trademark">Bluetooth</span>® comme un câble de remplacement, à
	travers une abstraction de port série virtuel.</p><p>L'utilitaire <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> implémente le
	profil port série.  Un pseudo terminal est
	utilisé comme abstraction de port série virtuel.
	L'exemple ci-dessous montre comment se connecter à un
	service port série d'un périphérique
	distant.  Notez que vous n'avez pas besoin d'indiquer un canal
	RFCOMM &#8212; <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> peut l'obtenir
	auprès du périphérique distant via SDP.
	Si vous désirez forcer cela, spécifiez un canal
	RFCOMM sur la ligne de commande.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>Une fois connecté, le pseudo-terminal peut
	être utilisé comme un port série:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86854224"></a>31.4.11. Dépannage</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86854864"></a>31.4.11.1. Un périphérique distant ne peut pas se
	  connecter</h4></div></div></div><p>Certains anciens périphériques <span class="trademark">Bluetooth</span>®
	  ne supportent pas de changement de rôle.  Par
	  défaut, quand FreeBSD accepte une nouvelle connexion, il
	  tente d'effectuer un changement de rôle et de devenir
	  maître.  Les périphériques qui ne
	  supportent pas cela ne seront pas en mesure de se connecter.
	  Notez qu'un changement de rôle est effectué
	  quand une nouvelle connexion est établie, il n'est
	  donc pas possible de demander au périphérique
	  distant s'il supporte le changement de rôle.  Il
	  existe une option HCI pour désactiver le changement
	  de rôle au niveau local:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86857424"></a>31.4.11.2. Quelque chose ne va pas, puis-je voir ce qui se passe
	  exactement?</h4></div></div></div><p>Bien sûr.  Utilisez le logiciel tierce-partie
	  <span class="application">hcidump</span> qui est disponible sous
	  <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/hcidump/pkg-descr">comms/hcidump</a> dans le
	  catalogue des logiciels portés.
	  L'utilitaire <span class="application">hcidump</span> est
	  similaire à <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Il peut être
	  utilisé pour afficher le contenu des paquets
	  <span class="trademark">Bluetooth</span>® à l'écran et les sauvegarder dans
	  un fichier.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-wireless.html">Précédent</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Niveau supérieur</a></td><td width="40%" align="right"> <a accesskey="n" href="network-bridging.html">Suivant</a></td></tr><tr><td width="40%" align="left" valign="top">31.3. Réseau sans fil </td><td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td><td width="40%" align="right" valign="top"> 31.5. Bridging</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ce document, ainsi que d'autres peut être téléchargé sur
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Pour toutes questions à propos de FreeBSD, lisez la
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> avant de contacter
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Pour les questions sur cette documentation, contactez
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>