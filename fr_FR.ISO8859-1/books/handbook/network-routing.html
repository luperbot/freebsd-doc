<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>31.2. Passerelles et routes</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manuel FreeBSD" /><link rel="up" href="advanced-networking.html" title="Chapitre 31. Administration réseau avancée" /><link rel="prev" href="advanced-networking.html" title="Chapitre 31. Administration réseau avancée" /><link rel="next" href="network-wireless.html" title="31.3. Réseau sans fil" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.2. Passerelles et routes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="advanced-networking.html">Précédent</a> </td><th width="60%" align="center">Chapitre 31. Administration réseau avancée</th><td width="20%" align="right"> <a accesskey="n" href="network-wireless.html">Suivant</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-routing"></a>31.2. Passerelles et routes</h2></div><div><span class="authorgroup">Contribution de <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Coranth</span> <span class="surname">Gryphon</span></span>. </span></div></div></div><a id="idp86218704" class="indexterm"></a><a id="idp86219216" class="indexterm"></a><a id="idp86219728" class="indexterm"></a><p>Pour qu'une machine soit en mesure d'en contacter une autre,
      il faut que soit mis en place un mécanisme qui
      décrive comment aller de l'une à l'autre.  C'est ce
      que l'on appelle le <em class="firstterm">routage</em>.  Une
      &#8220;route&#8221; est définie par une paire d'adresses:
      une &#8220;destination&#8221; et une &#8220;passerelle&#8221;.
      Cette paire signifie que pour atteindre cette
      <span class="emphasis"><em>destination</em></span>, vous devez passer par cette
      <span class="emphasis"><em>passerelle</em></span>.  Il y a trois sortes de
      destination: les machines individuelles, les sous-réseaux,
      et &#8220;default&#8221;&#8212;la destination par défaut.
      La route par défaut (&#8220;default route&#8221;) est
      utilisée lorsqu'aucune autre route n'est applicable.  Nous
      parlerons un peu plus des routes par défaut par la suite.
      Il existe également trois sortes de passerelles: les
      machines individuelles, les interfaces (aussi appelées
      &#8220;liens&#8221;), et les adresses Ethernet matérielles
      (adresses MAC).</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86221776"></a>31.2.1. Un exemple</h3></div></div></div><p>Pour illustrer différents aspects du routage,
	nous utiliserons l'exemple suivant, qui est produit par la
	commande <code class="command">netstat</code>:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -r</code></strong>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0</pre><a id="idp86224208" class="indexterm"></a><p>Les deux premières lignes définissent la
	route par défaut (dont nous parlerons dans la <a class="link" href="network-routing.html#network-routing-default" title="31.2.2. Routes par défaut">section suivante</a>) et la
	route <code class="systemitem">localhost</code>.</p><a id="idp86230224" class="indexterm"></a><p>L'interface (colonne <code class="literal">Netif</code>) qu'il est
	indiqué d'utiliser pour <code class="literal">localhost</code> est
	<code class="filename">lo0</code>, aussi appelée interface
	&#8220;loopback&#8221;&#8212;en boucle.  Ce qui veut dire que
	tout le trafic vers cette destination doit rester interne, au
	lieu d'être envoyé sur le réseau local,
	puisqu'il reviendra de toute façon à son point de
	départ.</p><a id="idp86232272" class="indexterm"></a><p>Ce qui se remarque ensuite, ce sont les adresses
	commençant par <code class="systemitem">0:e0:</code>.  Ce
	sont les adresses Ethernet matérielles, qui sont
	également connues sous le nom d'adresses MAC.  FreeBSD
	reconnaîtra automatiquement toute machine
	(<code class="systemitem">test0</code> dans l'exemple) sur le réseau
	local Ethernet et ajoutera une route vers cette machine,
	directement via l'interface Ethernet
	<code class="filename">ed0</code>.  Il y a aussi un délai
	(colonne <code class="literal">Expire</code>) associé à ce
	type de route, qui est utilisé si l'on entend plus parler
	de cette machine pendant un laps de temps précis.  Quand
	cela arrive, la route vers cette machine est automatiquement
	supprimée.  Ces machines sont identifiées par un
	mécanisme appelé RIP (&#8220;Routing Information
	Protocol&#8221;&#8212;protocole d'information de routage), qui
	met en place des routes vers les machines locales en
	déterminant le chemin le plus court.</p><a id="idp86235472" class="indexterm"></a><p>FreeBSD ajoutera également des routes de
	sous-réseau pour le sous-réseau local (<code class="systemitem">10.20.30.255</code> est l'adresse de diffusion
	pour le sous-réseau <code class="systemitem">10.20.30</code>, et <code class="systemitem">example.com</code> est le nom de domaine
	associé à ce sous-réseau).  La
	dénomination <code class="literal">link#1</code> fait
	référence à la première carte
	Ethernet de la machine.  Vous constaterez qu'il n'y a pas
	d'autre interface associée à ces routes.</p><p>Ces deux types de routes (vers les machines du
	réseau local et les sous-réseaux locaux) sont
	automatiquement configurés par un &#8220;daemon&#8221;
	appelé <span class="application">routed</span>.  S'il ne
	tourne pas, alors seules les routes définies comme
	statiques (i.e. explicitement définies)
	existeront.</p><p>La ligne <code class="literal">host1</code> fait
	référence à votre machine, qui est
	identifiée par l'adresse Ethernet.  Puisque nous sommes
	l'émetteur, FreeBSD sait qu'il faut utiliser l'interface
	en &#8220;boucle&#8221; (<code class="filename">lo0</code>)
	plutôt que d'envoyer les données sur l'interface
	Ethernet.</p><p>Les deux lignes <code class="literal">host2</code> montrent ce qui
	se passe quand on utilise un alias avec <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>
	(lisez la section sur l'Ethernet pour savoir pour quelles
	raisons on peut vouloir cela).  Le symbole
	<code class="literal">=&gt;</code> qui suit l'interface
	<code class="filename">lo0</code> indique que non seulement nous
	utilisons l'interface en &#8220;boucle&#8221; (puisque cette
	adresse correspond également à la machine
	locale), mais que c'est plus spécifiquement un alias.
	Ce type de route n'apparaît que sur la machine pour
	laquelle est défini l'alias; sur toutes les autres
	machines du réseau local il n'y aura q'une ligne
	<code class="literal">link#1</code> pour cette machine.</p><p>La dernière ligne (le sous-réseau
	destinataire <code class="systemitem">224</code>) concerne le
	multicasting (diffusion pour plusieurs destinataires), qui
	sera abordé dans une autre section.</p><p>Et enfin, diverses caractéristiques de chaque route
	sont indiquées dans la colonne <code class="literal">Flags</code>
	(indicateurs).  Ci-dessous, une courte table présente
	certains de ces indicateurs et leur signification:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><tbody><tr><td>U</td><td>Active (&#8220;Up&#8221;): la route est
		active.</td></tr><tr><td>H</td><td>Machine (&#8220;Host&#8221;): la destination de
		la route est une machine.</td></tr><tr><td>G</td><td>Passerelle (&#8220;Gateway&#8221;): envoyer tout
		ce qui concerne cette destination sur la machine
		distante indiquée, qui déterminera
		à qui transmettre ensuite.</td></tr><tr><td>S</td><td>Statique (&#8220;Static&#8221;): cette route a
		été configurée manuellement et non
		pas générée automatiquement par le
		système.</td></tr><tr><td>C</td><td>Clone: génère une nouvelle route
		sur la base de celle-ci pour les machines auxquelles
		nous nous connectons.  Ce type de route est normalement
		utilisé pour les réseaux locaux.</td></tr><tr><td>W</td><td>Clonée (&#8220;WasCloned&#8221;): cette
		route a été auto-configurée (Clone)
		à partir d'une route pour le réseau
		local.</td></tr><tr><td>L</td><td>Lien (&#8220;Link&#8221;): la route fait
		référence à une adresse
		matérielle Ethernet.</td></tr></tbody></table></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-routing-default"></a>31.2.2. Routes par défaut</h3></div></div></div><a id="idp86297168" class="indexterm"></a><p>Quand le système local doit établir une
	connexion avec une machine distante, il consulte la table de
	routage pour voir s'il existe déjà une route
	connue.  Si la machine distante appartient à un
	sous-réseau auquel le système sait se connecter
	(routes clonées), alors le système vérifie
	s'il peut se connecter via cette interface.</p><p>Si toutes les routes connues échouent, il reste
	alors au système une dernière option: la route
	par &#8220;défaut&#8221;.  Cette route est un type
	particulier de route passerelle (c'est
	généralement la seule du système), et est
	toujours marquée avec un <code class="literal">c</code> dans le
	champ des indicateurs.  Pour les machines du réseau
	local, cette passerelle est définie avec la machine qui
	est directement connectée au monde extérieur
	(que ce soit par une liaison PPP, DSL, cable, T1, ou toute
	autre interface réseau).</p><p>Si vous configurez la route par défaut sur une
	machine qui fonctionne comme passerelle vers le monde
	extérieur, alors la route par défaut sera la
	passerelle de votre Fournisseur d'Accès à
	Internet (FAI).</p><p>Examinons un exemple de route par défaut.  Voici
	une configuration classique:</p><div class="mediaobject"><img src="advanced-networking/net-routing.png" /></div><p>Les machines <code class="systemitem">Local1</code> et
	<code class="systemitem">Local2</code> sont sur votre site.
	<code class="systemitem">Local1</code> est connectée au serveur du FAI
	via une liaison PPP par modem.  Ce serveur PPP est
	connecté par l'intermédiaire d'un réseau
	local à un autre ordinateur passerelle relié au
	point d'entrée Internet du FAI.</p><p>Les routes par défaut sur chacune de vos machines
	seront:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Machine</th><th>Passerelle par défaut</th><th>Interface</th></tr></thead><tbody><tr><td>Local2</td><td>Local1</td><td>Ethernet</td></tr><tr><td>Local1</td><td>T1-GW</td><td>PPP</td></tr></tbody></table></div><p>Une question qui revient souvent est &#8220;Pourquoi
	(ou comment) définir <code class="systemitem">T1-GW</code> comme
	passerelle par défaut pour <code class="systemitem">Local1</code>,
	plutôt que le serveur du FAI auquel elle est
	connectée?&#8220;.</p><p>Rappelez-vous, puisque l'interface PPP utilise, de votre
	côté de la connexion, une adresse IP du
	réseau local du FAI, les routes vers toute autre
	machine du réseau local du FAI seront automatiquement
	générées.  Par conséquent vous
	savez déjà comment atteindre la machine
	<code class="systemitem">T1-GW</code>, il n'y a donc pas besoin
	d'étape intermédiaire qui passe par le serveur
	du FAI.</p><p>Il est habituel d'attribuer l'adresse <code class="systemitem">X.X.X.1</code> à la passerelle sur
	votre réseau local.  Donc (dans notre exemple), si
	votre espace d'adresse de classe C local était <code class="systemitem">10.20.30</code> et que votre FAI utilisait
	l'espace <code class="systemitem">10.9.9</code>, alors les
	routes par défaut seraient:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Machine</th><th>Route par défaut</th></tr></thead><tbody><tr><td>Local2 (10.20.30.2)</td><td>Local1 (10.20.30.1)</td></tr><tr><td>Local1 (10.20.30.1, 10.9.9.30)</td><td>T1-GW (10.9.9.1)</td></tr></tbody></table></div><p>Vous pouvez aisément définir la route par
	défaut via le fichier
	<code class="filename">/etc/rc.conf</code>.  Dans notre exemple, sur la
	machine <code class="systemitem">Local2</code>, nous avons ajouté la
	ligne suivante dans <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">defaultrouter="10.20.30.1"</pre><p>Il est également possible de faire directement cela
	à partir de la ligne de commande avec la commande
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add default 10.20.30.1</code></strong></pre><p>Pour plus d'informations sur la manipulation à la
	main des tables de routage réseau, consultez la page de
	manuel <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86374352"></a>31.2.3. Machines sur deux réseaux</h3></div></div></div><a id="idp86374992" class="indexterm"></a><p>Il y a un autre type de configuration dont il faut parler,
	c'est celle d'une machine qui est connectée à deux
	réseaux différents.  Techniquement, toute machine
	servant de passerelle (comme dans l'exemple ci-dessus, en
	utilisant une connexion PPP) est une machine sur deux
	réseaux.  Mais ce terme n'est normalement utilisé
	que pour faire référence à une machine qui
	est sur deux réseaux locaux différents.</p><p>Selon le cas, la machine dispose de deux cartes Ethernet,
	ayant chacune une adresse sur des sous-réseaux
	séparés.  Alternativement, la machine peut ne
	disposer que d'une seule carte Ethernet, et utiliser des alias
	avec <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>.  Le premier cas correspond à
	l'utilisation de deux réseaux Ethernet physiquement
	séparés, le deuxième cas est
	employé s'il n'y a qu'un seul réseau physique
	mais deux sous-réseaux logiquement distincts.</p><p>Dans les deux cas, les tables de routage sont
	définies de telle sorte que chaque sous-réseau
	sache que cette machine est la passerelle (route entrante)
	vers l'autre sous-réseau.  Cette configuration,
	où la machine sert de routeur entre les deux
	sous-réseaux, est souvent utilisée quand il faut
	mettre en place un dispositif de sécurité:
	filtrage de paquets ou coupe-feu, dans l'une ou dans les deux
	directions.</p><p>Si vous voulez que cette machine transmette
	réellement les paquets entre les deux interfaces, vous
	devez demander à FreeBSD d'activer cette
	fonctionnalité.  Lisez la section suivante pour plus de
	détails sur comment faire cela.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-dedicated-router"></a>31.2.4. Mettre en place un routeur</h3></div></div></div><a id="idp86378832" class="indexterm"></a><p>Un routeur est un système qui transmet les paquets
	d'une interface à une autre.  Les standards de
	l'Internet et de bons principes d'ingénierie
	empêchent le projet FreeBSD d'activer cette fonction par
	défaut sous FreeBSD.  Vous pouvez l'activer en
	positionnant à <code class="literal">YES</code> la variable
	suivante du fichier <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>:</p><pre class="programlisting">gateway_enable=YES          # Set to YES if this host will be a gateway</pre><p>Cette option fixera la variable <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>
	<code class="varname">net.inet.ip.forwarding</code> à la valeur
	<code class="literal">1</code>.  Si vous devez arrêter
	temporairement le routage, vous pouvez positionner la variable
	momentanément à <code class="literal">0</code>.</p><p>Votre nouveau routeur aura besoin de route pour savoir
	où envoyer le trafic.  Si votre réseau est
	suffisamment simple vous pouvez utiliser des routes statiques.
	FreeBSD est également fourni avec le &#8220;daemon&#8221;
	de routage BSD standard <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=routed&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">routed</span>(8)</span></a>, qui comprend et
	utilise les protocoles RIP (version 1 est 2) et IRDP.  Le
	support de BGP v4, OSPF v2, et d'autres protocoles de routage
	sophistiqué est disponible avec le logiciel <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/zebra/pkg-descr">net/zebra</a>.  Des produits commerciaux
	comme <span class="application"><span class="trademark">GateD</span>®</span> sont également
	disponibles comme solutions avancées de routage.</p><a id="idp86389968" class="indexterm"></a><a id="idp86390480" class="indexterm"></a><a id="idp86390992" class="indexterm"></a></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86391632"></a>31.2.5. Configurarion des routes statiques</h3></div><div><span class="authorgroup">Contribution de <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Al</span> <span class="surname">Hoang</span></span>. </span></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86394320"></a>31.2.5.1. Configuration manuelle</h4></div></div></div><p>Supposons que nous avons un réseau comme
	  celui-ci:</p><div class="mediaobject"><img src="advanced-networking/static-routes.png" /></div><p>Dans ce scénario, <code class="systemitem">RouteurA</code> est
	  notre machine FreeBSD qui joue le rôle de routeur pour
	  l'Internet.  Elle a une route par défaut vers <code class="systemitem">10.0.0.1</code> qui permet de se connecter
	  au reste du monde extérieur.  Nous supposerons que la
	  machine <code class="systemitem">RouteurB</code> est correctement
	  configurée et sait comment transmettre vers n'importe
	  quelle destination (D'après notre schéma c'est
	  relativement simple.  Ajoutez juste une route par
	  défaut sur <code class="systemitem">RouteurB</code> en utilisant
	  <code class="systemitem">192.168.1.1</code> comme
	  passerelle).</p><p>Si nous regardons la table de routage de
	  <code class="systemitem">RouteurA</code> nous verrions quelque chose
	  comme:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>netstat -nr</code></strong>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</pre><p>Avec la table de routage actuelle,
	  <code class="systemitem">RouteurA</code> ne sera pas en mesure d'atteindre
	  notre réseau interne 2.  Elle ne dispose pas de route
	  pour <code class="systemitem">192.168.2.0/24</code>.  Une
	  manière de résoudre cela est d'ajouter
	  manuellement la route.  La commande suivante ajouterait le
	  réseau interne 2 à la table de routage de
	  <code class="systemitem">RouteurA</code> en utilisant <code class="systemitem">192.168.1.2</code> comme point
	  intermédiaire:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add -net 192.168.2.0/24 192.168.1.2</code></strong></pre><p>Maintenant <code class="systemitem">RouteurA</code> peut joindre
	  n'importe quelle machine du réseau <code class="systemitem">192.168.2.0/24</code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86410576"></a>31.2.5.2. Configuration persistante</h4></div></div></div><p>L'exemple précédent est parfait pour
	  configurer une route statique sur un système en
	  fonctionnement.  Cependant, le problème est que
	  l'information de routage ne sera pas conservée si
	  vous redémarrez votre machine FreeBSD.  L'addition d'une
	  route statique doit se faire dans votre fichier
	  <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting"># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</pre><p>La variable <code class="literal">static_routes</code> est une
	  liste de chaîne de caractères
	  séparées par une espace.  Chaque chaîne
	  fait référence à un nom de route.  Dans
	  notre exemple nous avons qu'une seule chaîne dans
	  <code class="literal">static_routes</code>.  Cette chaîne est
	  <em class="replaceable"><code>internalnet2</code></em>.  Nous ajoutons
	  ensuite une variable de configuration appelée
	  <code class="literal">route_internalnet2</code>
	  dans laquelle nous mettons tous les paramètres de
	  configuration que nous passerions à la commande
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=route&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">route</span>(8)</span></a>.  Pour nous exemple précédent
	  nous aurions utilisé la commande:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>route add -net 192.168.2.0/24 192.168.1.2</code></strong></pre><p>nous avons donc besoin de <code class="literal">"-net 192.168.2.0/24
	    192.168.1.2"</code>.</p><p>Comme cela a été précisé,
	  nous pouvons avoir plus d'une chaîne dans la variable
	  <code class="literal">static_routes</code>.  Cela nous permet de
	  créer plusieurs routes statiques.  Les lignes
	  suivantes donnent un exemple d'ajout de routes statiques
	  pour les réseaux <code class="systemitem">192.168.0.0/24</code> et <code class="systemitem">192.168.1.0/24</code> sur un routeur
	  imaginaire:</p><pre class="programlisting">static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86419536"></a>31.2.6. Propagation de route</h3></div></div></div><a id="idp86420176" class="indexterm"></a><p>Nous avons déjà expliqué comment
	définir nos routes vers le monde extérieur, mais
	pas comment le monde extérieur apprend à nous
	localiser.</p><p>Nous savons déjà que les tables de routages
	peuvent être renseignées pour que tout le trafic
	pour un espace d'adresses donné (dans nos exemples, un
	sous-réseau de classe C) soit envoyé à
	une machine précise de ce réseau, qui
	transmettra les paquets entrants.</p><p>Lorsqu'il attribue un espace d'adresses à votre
	site, votre fournisseur d'accès définira ses
	tables de routage de sorte que tout le trafic destiné
	à votre sous-réseau vous soit envoyé sur
	votre liaison PPP.  Mais comment les sites à l'autre
	bout du pays savent-ils qu'ils doivent passer par votre
	fournisseur d'accès?</p><p>Il existe un mécanisme (assez semblable au
	système d'information distribué du DNS) qui
	conserve un enregistrement de tous les espaces d'adresses
	affectés, et définit leur point de connexion
	à la dorsale Internet (&#8220;backbone&#8221;).  La
	&#8220;dorsale&#8221; comprend les liaisons principales qui
	véhiculent le trafic Internet à travers le pays
	et le monde entier.  Chaque machine de la dorsale dispose
	d'une copie de l'ensemble des tables maîtresses qui
	aiguillent le trafic pour un réseau donné vers
	le transporteur correspondant de la dorsale, et de là
	par l'intermédiaire de fournisseurs d'accès
	successifs, jusqu'à atteindre votre
	réseau.</p><p>C'est le rôle de votre fournisseur d'accès
	d'annoncer aux sites de la dorsale qu'il est le point de
	connexion (et par conséquent la route entrante) pour
	votre site.  C'est ce que l'on appelle la propagation de
	route.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86422736"></a>31.2.7. En cas de problème</h3></div></div></div><a id="idp86423376" class="indexterm"></a><p>Il se peut qu'il y ait parfois un problème avec la
	propagation de route et que certains sites ne puissent vous
	atteindre.  La commande probablement la plus utile pour
	déterminer où une route est défaillante est
	la commande <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a>.  Elle est également utile
	si vous n'arrivez pas à vous connecter à une
	machine distante (i.e.  lorsque <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ping</span>(8)</span></a>
	échoue).</p><p>La commande <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a> prend comme
	paramètre le nom de la machine distante avec laquelle
	vous essayez d'établir une connexion.  Elle vous
	donnera la liste de passerelles intermédiaires
	jusqu'à la machine cible, ou jusqu'à ce qu'il
	n'y ait plus de connexion.</p><p>Pour plus d'informations, consultez la page de manuel de
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=traceroute&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">traceroute</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86449232"></a>31.2.8. Routage multicast</h3></div></div></div><a id="idp86449872" class="indexterm"></a><a id="idp86450640" class="indexterm"></a><p>FreeBSD supporte nativement les applications et le routage
	multicast (diffusion pour plusieurs destinataires).  Les
	applications multicast ne nécessitent pas de
	configuration spécifique de FreeBSD,
	généralement, elles fonctionneront directement.
	Le routage multicast demande à ce que le support soit
	compilé dans le noyau:</p><pre class="programlisting">options MROUTING</pre><p>De plus, le &#8220;daemon&#8221; de routage multicast,
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mrouted&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mrouted</span>(8)</span></a> doit être configuré par
	l'intermédiaire du fichier
	<code class="filename">/etc/mrouted.conf</code> pour mettre en place
	des tunnels et le protocole <acronym class="acronym">DVMRP</acronym>.  Plus de détails sur
	la configuration du routage multicast peuvent être
	trouvés dans la page de manuel de
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mrouted&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mrouted</span>(8)</span></a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced-networking.html">Précédent</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Niveau supérieur</a></td><td width="40%" align="right"> <a accesskey="n" href="network-wireless.html">Suivant</a></td></tr><tr><td width="40%" align="left" valign="top">Chapitre 31. Administration réseau avancée </td><td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td><td width="40%" align="right" valign="top"> 31.3. Réseau sans fil</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ce document, ainsi que d'autres peut être téléchargé sur
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Pour toutes questions à propos de FreeBSD, lisez la
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> avant de contacter
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Pour les questions sur cette documentation, contactez
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>