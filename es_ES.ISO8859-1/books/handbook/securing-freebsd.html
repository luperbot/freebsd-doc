<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>14.3. Asegurar FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manual de FreeBSD" /><link rel="up" href="security.html" title="Capítulo 14. Seguridad" /><link rel="prev" href="security-intro.html" title="14.2. Introducción" /><link rel="next" href="crypt.html" title="14.4. DES, MD5 y Crypt" /><link rel="copyright" href="legalnotice.html" title="Aviso Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.3. Asegurar FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Anterior</a> </td><th width="60%" align="center">Capítulo 14. Seguridad</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Siguiente</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>14.3. Asegurar FreeBSD</h2></div></div></div><a id="idp75037520" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Orden vs. protocolo: </h3><p xmlns="http://www.w3.org/1999/xhtml">En este capítulo usaremos el texto en
        <span class="application">negrita</span> para referirnos a una orden o
        aplicación, y una fuente en <code class="command">cursiva</code> para
        referirnos a órdenes específicas.  Usaremos un tipo normal
        para los protocolos.  Esta diferencia tipográfica nos
        será útil por ejemplo con ssh, que es tanto un
        protocolo como una orden.</p></div><p>Las siguientes secciones cubren los métodos a seguir para
      asegurar su sistema FreeBSD que se mencionados en la
      <a class="link" href="security-intro.html" title="14.2. Introducción"> sección anterior</a> de este
      capítulo.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>14.3.1. Asegurar la cuenta <code class="systemitem">root</code> y las
        cuentas administrativas</h3></div></div></div><a id="idp75042896" class="indexterm"></a><p>En primer lugar, no se moleste en asegurar las cuentas
        administrativas (o <span class="quote">&#8220;<span class="quote">staff</span>&#8221;</span>) si no ha asegurado la
        cuenta <code class="systemitem">root</code>.
        La mayoría de los sistemas tienen una contraseña
        asignada para la cuenta <code class="systemitem">root</code>.  Lo primero que
        se hace es asumir que la contraseña está
        <span class="emphasis"><em>siempre</em></span> amenazada.
        Esto no significa que deba eliminar la contraseña.  La
        contraseña es casi siempre necesaria para el acceso por
        consola a la máquina; significa que no se debe permitir
        el uso de la contraseña fuera de la consola o, mejor
        aún, mediante <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a>.  Por ejemplo,
        asegúrese de que sus ptys aparezcan como
        <span class="emphasis"><em>inseguras</em></span> en el fichero
        <code class="filename">/etc/ttys</code>, con lo que hará que
        los accesos como <code class="systemitem">root</code> vía
        <code class="command">telnet</code> o <code class="command">rlogin</code> no sean
        posibles.
        Si utiliza otros tipos de login como
        <span class="application">sshd</span> asegúrese de que
        los accesos al sistema como <code class="systemitem">root</code>
        estén también deshabilitados.
        Para ello edite su
        <code class="filename">/etc/ssh/sshd_config</code> y asegúrese de
        que <code class="literal">PermitRootLogin</code> esté puesto a
        <code class="literal">NO</code>.  Estudie cada método de acceso:
        hay servicios como FTP que frecuentemente son origen de grietas
        en la estructura del sistema.  El acceso directo como usuario
        <code class="systemitem">root</code> sólamente debe permitirse
        a través de la consola.</p><a id="idp75055696" class="indexterm"></a><p>Es evidente que, como administrador del sistema, debe usted
        tener la posibilidad de acceder a <code class="systemitem">root</code>,
        así que tendrá que abrir algunos agujeros, pero
        debe asegurarse de que estos agujeros necesiten contraseñas
        adicionales para verificar su correcto uso.  Puede hacer
        que <code class="systemitem">root</code> sea accesible añadiendo
        cuentas administrativas al grupo
        <code class="systemitem">wheel</code> (en
        <code class="filename">/etc/group</code>).  El personal que administra los
        sistemas que aparezcan en el grupo
        en el grupo <code class="systemitem">wheel</code> pueden hacer
        <code class="command">su</code> a <code class="systemitem">root</code>.
        Nunca debe de proporcionar al personal administrativo el acceso
        nativo a <code class="systemitem">wheel</code> poniéndolos
        en el grupo <code class="systemitem">wheel</code> en su entrada de
        contraseña.  Las cuentas administrativas deben colocarse
        en un grupo <code class="systemitem">staff</code>, y agregarse
        después al grupo <code class="systemitem">wheel</code> en
        <code class="filename">/etc/group</code>.  Sólo aquellos
        administradores que realmente necesiten acceder a
        <code class="systemitem">root</code> deben pertenecer al grupo
        <code class="systemitem">wheel</code>.  También es posible,
        mediante un método de autentificación como
        Kerberos, usar el fichero <code class="filename">.k5login</code> en
        la cuenta <code class="systemitem">root</code> para permitir un
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> a <code class="systemitem">root</code> sin tener que
        colocar a nadie en el grupo
        <code class="systemitem">wheel</code>.  Puede ser una mejor solución,
        ya que el mecanismo <code class="systemitem">wheel</code> aún
        permite a un atacante comprometer <code class="systemitem">root</code>
        si el intruso ha conseguido el fichero de contraseñas
        y puede comprometer una cuenta de administración.
        Recurrir al mecanismo <code class="systemitem">wheel</code> es mejor que
        no tener nada, pero no es necesariamente la opción
        más segura.</p><p>Una manera indirecta de asegurar las cuentas de staff y
        el acceso a <code class="systemitem">root</code> es utilizar un método
        de acceso alternativo: es lo que se conoce como
        <span class="quote">&#8220;<span class="quote">estrellar</span>&#8221;</span> las contraseñas cifradas de las
        cuentas administrativas.  Use <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vipw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">vipw</span>(8)</span></a> para reemplazar
        cada contraseña cifrada por un sólo caracter
        asterisco (<span class="quote">&#8220;<span class="quote"><code class="literal">*</code></span>&#8221;</span>).  Esto
        actualizará
        <code class="filename">/etc/master.passwd</code> y la base de datos de
        usuario/contraseña y deshabilitará los accesos
        al sistema validados mediante
        contraseñas.</p><p>Veamos una cuenta administrativa típica:</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>y cómo debería quedar:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Este cambio evitará que se efectúen logins normales,
        ya que la contraseña cifrada nunca se corresponderá
        con <span class="quote">&#8220;<span class="quote"><code class="literal">*</code></span>&#8221;</span>.  Hecho esto, el personal
        de administración tendrá que usar otro mecanismo
        de validación como <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kerberos&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kerberos</span>(1)</span></a> o
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> que use un par de llave pública/privada.
        Si decide usar algo como Kerberos tendrá que asegurar
        la máquina que ejecuta los servidores Kerberos
        y su estación de trabajo.  Si usa un par de llave
        pública/privada con ssh, debe asegurar la
        máquina <span class="emphasis"><em>desde</em></span> desde la que se hace el
        login (normalmente nuestra estación de trabajo).  Puede
        añadir una capa adicional de protección  al par de
        llaves protegiéndolas con contraseña al crearlo
        con <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh-keygen</span>(1)</span></a>.
        El <span class="quote">&#8220;<span class="quote">estrellado</span>&#8221;</span> de las contraseñas
        administrativas también garantiza que dicho personal
        sólo pueda entrar a través de métodos de
        acceso que haya usted configurado.  Así obligará
        al personal administrativo a usar conexiones seguras, cifradas,
        en todas sus sesiones, lo que cierra un importante agujero
        de seguridad al que recurren muchos intrusos: usar un
        sniffer (olfateador) de red desde una máquina que le
        permita hacer tal cosa.</p><p>Los mecanismos de seguridad más indirectos también
        asumen que está validando su identidad desde un servidor
        más restrictivo un servidor menos restrictivo.
        Por ejemplo, si su máquina principal ejecuta toda clase de
        servidores su estación de trabajo no debe ejecutar ninguno.
        Para que su estación de trabajo sea razonablemente segura
        debe ejecutar los mínimos servidores posibles, si es posible
        ninguno, y debe usar un salvapantallas protegido por
        contraseña.  Es evidente que un atancante con acceso
        físico al sistema puede romper cualquier barrera de seguridad
        que se disponga.  Es un problema a tener en cuenta, pero la
        mayoría de las intrusiones tienen lugar de forma remota,
        a través de la red, por parte de gente que no tiene acceso
        físico a su estación de trabajo ni a sus
        servidores.</p><a id="idp75094096" class="indexterm"></a><p>Usar Kerberos le ofrece también el poder
        de deshabilitar o cambiar la contraseña para una cuenta
        administrativa en un lugar, y que tenga un efecto inmediato en todas
        las máquinas en las cuales ese administrador pueda
        tener una cuenta.  Si una de esas cuentas se ve comprometida
        la posibilidad para cambiar instantáneamente su
        contraseña en todas las máquinas no debe ser
        desestimada.  Con contraseñas distintas, el cambio
        de una contraseña en N máquinas puede ser un
        problema.  También puede imponer restricciones de
        re-contraseñas con Kerberos: no sólo se puede
        hacer un ticket de Kerberos que expire después de un
        tiempo, sino que el sistema Kerberos puede requerir al usuario
        que escoja una nueva contraseña después de cierto
        tiempo (digamos una vez al mes).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75095120"></a>14.3.2. Asegurar servidores que se ejecutan como
          <code class="systemitem">root</code>
          y binarios SUID/SGID</h3></div></div></div><a id="idp75096272" class="indexterm"></a><a id="idp75097168" class="indexterm"></a><a id="idp75098064" class="indexterm"></a><a id="idp75098960" class="indexterm"></a><a id="idp75099984" class="indexterm"></a><a id="idp75101008" class="indexterm"></a><a id="idp75101904" class="indexterm"></a><a id="idp75102800" class="indexterm"></a><p>Un administrador de sistemas prudente sólo
        ejecutará los servidores que necesita, ni uno más
        ni uno menos.  Dese cuenta de que los servidores ajenos son
        los más propensos a contener errores.  Por ejemplo,
        ejecutando una versión desfasada de
        <span class="application">imapd</span> o
        <span class="application">popper</span> es como dar una entrada universal
        de <code class="systemitem">root</code> al mundo entero.
        Nunca ejecute un servidor que no haya revisado cuidadosamente.
        Muchos servidores no necesitan ejecutarse como
        <code class="systemitem">root</code>.  Por ejemplo, los dæmons
        <span class="application">ntalk</span>,
        <span class="application">comsat</span> y
        <span class="application">finger</span> pueden ejecutarse en una
        <em class="firstterm">caja de arena (sandbox)</em> especial de usuario.
        Una caja de arena no es perfecta, a menos que pase por muchos
        problemas, pero la aproximación de cebolla a la seguridad
        prevalece aún y todo: Si alguien es capaz de penetrar a
        través de un servidor ejecutándose en una caja
        de arena, todavía tendrá que salir de la caja de
        arena.  Cuantas más capas tenga que romper el atacante
        menor será la posibilidad de éxito que tenga.
        Se han encontrado vías de entrada a
        <code class="systemitem">root</code> en virtualmente todos los servidores
        que se haya ejecutado como <code class="systemitem">root</code>,
        incluyendo servidores básicos del sistema.
        Si está tiene una máquina a través de
        la cual la gente sólo entra por
        <span class="application">sshd</span>, y nunca entra por
        <span class="application">telnetd</span>,
        <span class="application">rshd</span>, o
        <span class="application">rlogind</span>
        <span class="emphasis"><em>apague esos servicios</em></span>.</p><p>FreeBSD ejecuta por defecto
        <span class="application">ntalkd</span>,
        <span class="application">comsat</span> y
        <span class="application">finger</span> en una caja de arena.
        Otro programa que puede ser candidato para ejecutarse en una
        caja de arena es <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.
        <code class="filename">/etc/defaults/rc.conf</code> contiene las directrices
        necesarias (con comentarios) para usar <span class="application">named</span>
        en una caja de arena.  Dependiendo de si
        está instalando un nuevo sistema o actualizando un sistema
        ya existente, las cuentas especiales de usuario que usan
        estas cajas de arena puede que no estén instaladas.
        El administrador de sistemas prudente debe investigar e
        implementar cajas de arena para servidores siempre que sea
        posible.</p><a id="idp75113680" class="indexterm"></a><p>Existen numerosos servidores que no se suelen
        ejecutar en cajas de arena:
        <span class="application">sendmail</span>,
        <span class="application">imapd</span>, <span class="application">ftpd</span>,
        y otros.  Existen alternativas para algunos de ellos, pero
        instalarlas puede requerir más trabajo del que tal vez
        esté dispuesto a realizar (el factor comodidad ataca de
        nuevo).  Tal vez tenga que ejecutar estos servidores como
        <code class="systemitem">root</code> y depender de otros mecanismos para
        detectar intrusiones que puedan tener lugar a través de
        ellos.</p><p>Los otros grandes agujeros potenciales de
         <code class="systemitem">root</code> que encontramos en un sistema son los
         binarios suid-root y sgid.  La mayoría
         de estos binarios, como <span class="application">rlogin</span>,
         están en <code class="filename">/bin</code>, <code class="filename">/sbin</code>,
         <code class="filename">/usr/bin</code> o <code class="filename">/usr/sbin</code>.
         Aunque no hay nada absolutamente seguro los binarios suid y sgid
         del sistema por defecto pueden considerarse razonablemente
         seguros.  Aún así, de vez en cuando aparecen
         agujeros <code class="systemitem">root</code> en estos binarios.
         En 1998 se encontró un agujero
         <code class="systemitem">root</code> en
         <code class="literal">Xlib</code>, que hacía a
         <span class="application">xterm</span> (que suele ser suid)
         vulnerable.  Es mejor prevenir que curar, y el administrador de
         sistemas prudente restringirá los binarios suid, que
         sólo el personal de administración debe ejecutar,
         a un grupo especial al que sólo dicho personal pueda acceder,
         y deshacerse de cualquier binario suid
         (<code class="command">chmod 000</code>) que no se use.
         Un servidor sin pantalla generalmente no necesita un binario
         <span class="application">xterm</span>.  Los  binarios sgid pueden ser
         igual de peligrosos.  Si un intruso logra comprometer un binario
         sgid-kmem, el intruso podría leer
         <code class="filename">/dev/kmem</code> y llegar a leer el fichero
         cifrado de contraseñas, poniendo en compromiso potencial
         cualquier cuenta con contraseña.  Por otra parte, un intruso
         que comprometa el grupo <code class="literal">kmem</code> puede monitorizar
         las pulsaciones de teclado que se envien a través de ptys,
         incluyendo las ptys a las que acceden usuarios que emplean
         métodos seguros.  Un intruso que comprometa el grupo
         <code class="systemitem">tty</code> puede escribir en la pty de casi
         cualquier usuario.  Si un usuario ejecuta un programa de terminal
         o un emulador capaz de simular un teclado, el intruso podría
         generar un flujo de datos que provoque que la terminal del
         usuario muestre una orden en pantalla, orden que el usuario
         ejecutará.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>14.3.3. Asegurar las cuentas de usuario</h3></div></div></div><p>Las cuentas de usuario suelen ser las más
        difíciles de asegurar.  Aunque puede imponer restricciones
        de acceso draconianas a su personal administrativo  y
        <span class="quote">&#8220;<span class="quote">estrellar</span>&#8221;</span> sus contraseñas, tal vez no pueda
        hacerlo con todas las cuentas de todos sus usuarios.  Si mantiene
        el control en un grado suficiente quizás lo logre y sea
        capaz de hacer que las cuentas de sus usuarios sean seguras.  Si no,
        tendrá que ser más cuidadoso (aún) en la
        monitorización de esas cuentas.  Usar ssh y Kerberos en
        cuentas de usuario da más problemas debido al soporte
        técnico y administrativo que requerirá, pero sigue
        siendo mejor solución que un fichero de
        contraseñas cifradas.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75137616"></a>14.3.4. Asegurar el fichero de contraseñas</h3></div></div></div><p>La única manera segura es ponerle <code class="literal">*</code>
        a tantas contraseñas como sea posible y utilizar ssh o
        Kerberos para acceder a esas cuentas.  Aunque el fichero
        cifrado de contraseñas (<code class="filename">/etc/spwd.db</code>)
        sólo puede ser legible para <code class="systemitem">root</code>, puede
        que un intruso consiga acceso de lectura a ese fichero, incluso sin
        haber alcanzado el acceso de escritura como root.</p><p>Sus <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span> de seguridad deben buscar siempre
        cambios en el fichero de contraseñas
        (consulte <a class="link" href="securing-freebsd.html#security-integrity" title="14.3.6. Revisión de integridad de ficheros: binarios, ficheros de configuración, etc.">Revisión de
        integridad de ficheros</a> más abajo) e informar de
        ellos.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75141328"></a>14.3.5. Asegurar el Kernel, dispositivos en bruto y el sistema
          sistema de ficheros</h3></div></div></div><p>Si un atacante compromete <code class="systemitem">root</code> puede
        hacer cualquier cosa, pero hay ciertas cosas que puede usted
        preparar para <span class="quote">&#8220;<span class="quote">curarse en salud</span>&#8221;</span>.  Por ejemplo,
        la mayoría de los kernel modernos tienen un dispositivo
        de los Kernels modernos tienen un integrado un
        dispositivo de paquetes.  En FreeBSD se llama
        <code class="filename">bpf</code>.  Un intruso típico
        tratará de ejecutar un <span class="quote">&#8220;<span class="quote">sniffer</span>&#8221;</span> de paquetes
        en una máquina comprometida.  No debería darle a
        ese intruso tal recurso, y la mayoría de los sistemas no
        necesitan el dispositivo
        <code class="filename">bpf</code>.</p><a id="idp75144400" class="indexterm"></a><p>Pero si desactiva el dispositivo <code class="filename">bpf</code>
        todavía tendrá que preocuparse por
        <code class="filename">/dev/mem</code> y
        <code class="filename">/dev/kmem</code>.
        Desde ellos el intruso podría en dispositivos de disco
        en bruto.  También hay que tener muy en cuenta
        una opción del kernel llamada cargador de módulos,
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.  Un intruso con iniciativa puede usar un
        módulo KLD para instalar su propio dispositivo
        <code class="filename">bpf</code>, u otro dispositivo
        que le permita el <span class="quote">&#8220;<span class="quote">sniffing</span>&#8221;</span> en un kernel en
        ejecución.  Para prevenir estos problemas debe ejecutar el
        kernel en un nivel de seguridad mayor, al menos en securelevel 1.
        Puede configurar el securelevel mediante una <code class="command">sysctl</code>
        en la variable <code class="varname">kern.securelevel</code>.
        Una vez que tiene su securelevel a 1, los accesos de
        escritura a dispositivos en bruto se
        denegarán y se impondrán las banderas especiales
        <code class="literal">schg</code>.
        También debe cerciorarse de activar la bandera
        <code class="literal">schg</code> en binarios críticos para el arranque,
        directorios y scripts (dicho de otro modo, todo aquello que se
        ejecuta <span class="emphasis"><em>antes</em></span> de que se active el
        securelevel).  Puede ser que todo esto sea una exageración,
        sobre todo teniendo en cuenta que la actualización del sistema
        se complica bastante a medida que se incrementa el nivel de
        seguridad.  Puede ejecutar el sistema a un nivel de seguridad
        superior pero no activar la bandera <code class="literal">schg</code>
        en cada fichero y directorio del sistema.  Otra posibilidad es
        montar <code class="filename">/</code> y <code class="filename">/usr</code> como
        sólo lectura.  Recuerde que siendo demasiado draconiano
        en aquello que busca proteger puede dificultar mucho la
        detección de una intrusión.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>14.3.6. Revisión de integridad de ficheros: binarios,
        ficheros de configuración, etc.</h3></div></div></div><p>Cuando se piensa de proteccón, sólo se puede
        proteger la configuración central del sistema y los ficheros
        de control hasta el momento en el que el factor comodidad salta
        a la palestra.  Por ejemplo, si usa
        <code class="command">chflags</code> para activar el bit <code class="literal">schg</code>
        en la mayoría de los ficheros de <code class="filename">/</code>
        y <code class="filename">/usr</code> probablemente sea contraproducente;
        puede proteger los ficheros haciéndolo, pero también
        cierra una vía de detección.  La última capa
        de su modelo de seguridad tipo cebolla es quizás la
        más importante: la detección.  El resto de su
        estructura de seguridad será inútil (o peor
        aún, le proporcionará un sentimiento de seguridad
        totalmente infundado) si no puede detectar posibles intrusiones.
        La mitad del trabajo de la cebolla es alentar al atacante, en lugar
        de detenerlo, para darle a la parte de la ecuación de
        detección una oportunidad de atraparlo con las manos en la
        masa.</p><p>La mejor manera de detectar una intrusión es buscar
        ficheros modificados, perdidos, o cuya presencia o estado sea
        inesperado.  La mejor forma de buscar ficheros modificados es
        desde otro sistema (que muchas veces es centralizado) con acceso
        restringido.
        Escribir sus <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span> de seguridad en un sistema
        <span class="quote">&#8220;<span class="quote">extraseguro</span>&#8221;</span> y con acceso restringido los hace casi
        invisibles a posibles atacantes, y esto es algo muy importante.
        potenciales, y esto es importante.  Para poderle sacar el
        máximo partido debe proporcionar a esa máquina con
        acceso restringido un acceso preferente al contenido de las otras
        máquinas de su entorno; suele hacerse mediante la
        importación vía NFS de sólo lectura de las
        demás máquinas, o configurando pares de llaves ssh
        para acceder a las otras máquinas desde la que tiene el
        acceso restringido.  Si exceptuamos el tráfico de red, NFS
        es el método menos visible y le permite monitorizar los
        sistemas de ficheros de cada máquina cliente de forma
        prácticamente indetectable.  Si su servidor de acceso
        restringido está conectado a las máquinas clientes
        a través de un concentrador o a través de varias
        capas de encaminamiento el método NFS puede ser muy inseguro,
        por lo que ssh puede ser la mejor opción, incluso con
        las huellas de auditoría que ssh va dejando.</p><p>Una vez que le da a una máquina de acceso restringido
        (al menos) acceso de lectura a los sistemas cliente que va
        a monitorizar, tendrá que escribir <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span>
        para efectuar la monitorización.  Si va a usar un montaje
        NFS puede escribir <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span> utilizando simples
        herramientas del sistema como
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> y <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>.  Es aconsejable ejecutar MD5
        físicamente en los ficheros de las máquinas cliente
        al menos una vez al día, y comprobar los ficheros de control
        (los que hay en <code class="filename">/etc</code> y
        <code class="filename">/usr/local/etc</code>) con una frecuencia incluso
        mayor.  Si aparecen discrepancias al compararlos con la
        información basada en MD5 que la máquina de acceso
        restringido usa como base debe hacer una comprobación
        inmediata y profunda.  Un buen <span class="quote">&#8220;<span class="quote">script</span>&#8221;</span> también
        debe buscar binarios que sean suid sin razón aparente, y
        ficheros nuevos o borrados en particiones del sistema como
        <code class="filename">/</code> y <code class="filename">/usr</code>.</p><p>Si usa ssh en lugar de NFS será mucho más
        complicado escribir el <span class="quote">&#8220;<span class="quote">script</span>&#8221;</span> de seguridad.
        En esencia, tiene que pasar por <code class="command">scp</code> los
        <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span> a la máquina cliente para poder
        ejecutarlos, haciéndolos visibles; por seguridad,
        también tendrá que pasar vía
        <code class="command">scp</code> los binarios (por ejemplo find) que
        utilizan dichos <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span>.  El cliente
        <span class="application">ssh</span> de la máquina cliente
        puede estar ya bajo el control del intruso.  Con todo y con eso,
        puede ser necesario usar ssh si trabaja sobre enlaces inseguros,
        también es mucho más difícil de manejar.</p><p>Un buen <span class="quote">&#8220;<span class="quote">script</span>&#8221;</span> de seguridad buscará
        también cambios en la configuración de los ficheros
        de acceso de usuarios y miembros del personal de
        administración:
        <code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
        <code class="filename">.ssh/authorized_keys</code>, etc; en resumen,
        ficheros fuera del rango de revisión
        <code class="literal">MD5</code>.</p><p>Si tiene que vérselas con una cantidad enorme de
        espacio en disco para usuarios le llevará mucho tiempo
        recorrer cada fichero de cada partición.  En su caso
        sería una buena idea configurar mediante opciones de
        montaje la deshabilitación de binarios y dispositivos
        suid en esas particiones.  Revise las opciones
        <code class="literal">nodev</code> y <code class="literal">nosuid</code> de
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>.  Debería comprobarlos de todas maneras
        al menos una vez por semana, ya que el objeto de esta capa es
        detectar intrusiones, efectivas o no.</p><p>La contabilidad de procesos (vea <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) es una
        opción con una carga relativamente ligera para el sistema
        operativo, y puede ayudarle como mecanismo de
        evaluación tras una intrusión.  Es especialmente
        útil para rastrear cómo consiguión realmente
        acceder el intruso al sistema (asumiendo que el fichero
        esté intacto después de la intrusión).</p><p>Los <span class="quote">&#8220;<span class="quote">scripts</span>&#8221;</span> de seguridad deben procesar los
        logs, y los propios logs deben generarse de la forma más
        segura posible: un syslog remoto puede ser muy
        útil.  Un intruso trata de cubrir sus huellas, los logs
        son un recurso crítico cuando el administrador de sistemas
        intenta determinar la hora y el método de la intrusión
        inicial.  La ejecución de la consola del sistema en un
        puerto serie y recolectar la información de forma
        periódica en una máquina segura de
        monitorización de consolas es una forma de cumplir esta
        tarea.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75181648"></a>14.3.7. Paranoia</h3></div></div></div><p>Un poco de paranoia nunca está de más.
        Como norma, un administrador de sistemas puede añadir
        cualquier tipo de mecanismo de seguridad siempre y cuando no
        afecte a la comodidad, y puede añadir mecanismos de seguridad
        que <span class="emphasis"><em>sí</em></span> afecten a la comodidad
        si tiene una buena razón para hacerlo.  Más
        aún, un administrador de seguridad debe mezclar
        un poco de ambas cosas: si sigue al pie de la letra las
        recomendaciones que se dan en este documento también
        está sirviendo en bandeja de plata al posible atancante
        su metodología.  Ese posible atacante también
        tiene acceso a este documento.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75183312"></a>14.3.8. Ataques de denegación de servicio</h3></div></div></div><a id="idp75183952" class="indexterm"></a><p>Esta sección cubre ataques de denegación de
        servicio.  Un ataque DoS suele consistir en un ataque mediante
        paquetes.  NO hay mucho que pueda hacerse contra un ataque
        mediante paquetes falsificados (<span class="quote">&#8220;<span class="quote">spoofed</span>&#8221;</span>) que busque
        saturar su red, pero puede limitar el daño
        asegurándose de que los ataques no tiren sus servidores.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Limitación de forks en el servidor.</p></li><li class="listitem"><p>Limitación de ataques <span class="quote">&#8220;<span class="quote">springboard</span>&#8221;</span>
            (ataques de respuesta ICMP, ping broadcast, etc.)</p></li><li class="listitem"><p>Caché de rutas del kernel.</p></li></ol></div><p>Un típico ataque DoS contra un servidor con instancias
        (forks) sería tratar de provocar que el servidor consuma
        procesos, descriptores de fichero y memoria hasta tirar la
        máquina.
        <span class="application">inetd</span> (consulte <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>)
        dispone de varias opciones para limitar este tipo de ataque.
        Recuerde que aunque es posible evitar que una máquina
        caiga, generalmente no es posible evitar que un servicio sea
        vea interrumpido a causa el ataque.  Consulte la página
        de manual de <span class="application">inetd</span> atentamente y
        sobre todo estudie las las opciones
        <code class="option">-c</code>, <code class="option">-C</code>,
        y <code class="option">-R</code>.  Observe que los ataques con direcciones IP
        falsificadas sortearán la opción <code class="option">-C</code> de
        <span class="application">inetd</span>, así que debe usar una
        combinación de opciones.  Algunos servidores
        autónomos (<span class="quote">&#8220;<span class="quote">standalone</span>&#8221;</span>) cuentan con
        parámetros de autolimitación de instancias.</p><p><span class="application">Sendmail</span> tiene la opción
        <code class="option">-OMaxDaemonChildren</code>, que tiende a funcionar
        mucho mejor que las opciones de límite
        de carga de sendmail debido al retraso que provoca la carga.
        Debe especificar un parámetro
        <code class="literal">MaxDaemonChildren</code> al inicio de
        <span class="application">sendmail</span> que sea lo suficientemente alto
        como para gestionar la carga esperada, pero no tan alto que la
        computadora no pueda absorber tal número de
        <span class="application">sendmails</span> sin caerse de boca.
        También es prudente ejecutar sendmail en modo de cola
        (<code class="option">-ODeliveryMode=queued</code>) y ejecutar el
        dæmon (<code class="command">sendmail -bd</code>)
        de manera independiente de las ejecuciones de cola
        (<code class="command">sendmail -q15m</code>).  Si a pesar de todo necesita
        entregas en tiempo real puede ejecutar la cola a un intervalo
        menor, como <code class="option">-q1m</code>, pero asegúrese de
        especificar una opción <code class="literal">MaxDaemonChildren</code>
        razonable para <span class="emphasis"><em>ese</em></span> sendmail y así
        evitar fallos en cascada.</p><p><span class="application">Syslogd</span> puede recibir ataques directos
        y se recomienda encarecidamente que utilice la opción
        <code class="option">-s</code> siempre que sea posible, y si no la opción
        <code class="option">-a</code>.</p><p>También debe ser extremadamente cuidadoso con servicios
        de conexión inversa como el ident inverso de
        <span class="application">TCP Wrapper</span>, que puede recibir ataques
        directos.  No se suele usar el ident inverso de
        <span class="application">TCP Wrapper</span> por esa misma
        razón.</p><p>Es una muy buena idea proteger los servicios internos
        de acceso externo protegiéndolos vía con un cortafuegos
        en los routers de frontera.  La idea es prevenir ataques de
        saturación desde el exterior de la LAN, y no tanto para
        proteger servicios internos de compromisos
        <code class="systemitem">root</code> basados en red.
        Configure siempre un cortafuegos exclusivo, esto es,
        <span class="quote">&#8220;<span class="quote">restringir todo <span class="emphasis"><em>menos</em></span> los puertos
        A, B, C, D y M-Z</span>&#8221;</span>.  De esta manera restringirá
        todos sus puertos con números bajos excepto ciertos
        servicios específicos como
        <span class="application">named</span> (si es el servidor primario de
        una zona), <span class="application">ntalkd</span>,
        <span class="application">sendmail</span>, y otros servicios accesibles
        desde Internet.  Si configura el cortafuegos de la otra
        manera (como un cortafuegos inclusivo o permisivo), tiene grandes
        posibilidades de que olvide <span class="quote">&#8220;<span class="quote">cerrar</span>&#8221;</span> un
        par de servicios, o de que agregue un nuevo servicio interno y
        olvide actualizar el cortafuegos.  Puede incluso abrir el rango
        de números de puerto altos en el cortafuegos para permitir
        operaciones de tipo permisivo sin comprometer sus puertos
        bajos.  Recuerde también que FreeBSD le permite controlar
        el rango de números de puerto utilizados para asignación
        dinámica a través de las numerosas
        <code class="varname">net.inet.ip.portrange</code> de
        <code class="command">sysctl</code>
        (<code class="command">sysctl -a | fgrep portrange</code>), lo cual
        también facilita la complejidad de la configuración
        de su cortafuegos.  Por ejemplo, puede utilizar un rango normal
        primero/último de 4000 ó 5000, y un rango de puerto
        alto de 49152 a 65535; bloquée todo por debajo de
        4000 (excepto para ciertos puertos específicos
        accesibles desde Internet, por supuesto).</p><a id="idp75216592" class="indexterm"></a><p>Otro ataque DoS común es llamado ataque
        <span class="quote">&#8220;<span class="quote">springboard</span>&#8221;</span>: atacar un servidor de forma que
        genere respuestas que lo sobrecarguen, sobrecarguen la red local
        o alguna otra máquina.  Los ataques más
        comunes de este tipo son los
        <span class="emphasis"><em>ataques ICMP ping broadcast</em></span>.
        El atacante falsifica paquetes ping enviados a la dirección
        broadcast de su LAN simulando que la dirección IP origen
        es la de la máquina que desean atacar.  Si sus routers
        de frontera no están configurados para lidiar con pings a
        direcciones de broadcast su LAN termina generando suficientes
        respuestas a la dirección origen falsificada como para saturar
        a la víctima, especialmente cuando el atacante utiliza
        el mismo truco en varias docenas de direcciones broadcast en
        varias docenas de redes diferentes a la vez.  Se han medido
        ataques de broadcast de más de ciento veinte megabits.
        Un segundo tipo de ataque <span class="quote">&#8220;<span class="quote">springboard</span>&#8221;</span> bastante
        común se da contra el sistema de informe de error de ICMP.
        Un atacante puede saturar la conexión entrante de red de un
        servidor mediante la construcción de paquetes que generen
        respuestas de error ICMP, provocando que el servidor sature su
        conexión saliente de red con respuestas ICMP.  Este tipo
        de ataque también puede tumbar el servidor agotando sus
        <span class="quote">&#8220;<span class="quote">mbufs</span>&#8221;</span>, especialmente si el servidor no puede
        drenar lo suficientemente rápido las respuestas ICMP que
        genera.  El kernel de FreeBSD tiene una opción de
        compilación llamada <code class="option">ICMP_BANDLIM</code>,
        que limita la efectividad de este tipo de ataques.
        La última gran categoría de ataques
        <span class="quote">&#8220;<span class="quote">springboard</span>&#8221;</span> está relacionada con
        ciertos servicios de <span class="application">inetd</span>, como
        el servicio de eco udp.  El atacante simplemente imita un paquete
        UDP con el puerdo de eco del servidor A como dirección de
        origen, y el puerto eco del servidor B como dirección de
        destino, estando ambos servidores en la misma LAN.  Un atacante
        puede sobrecargar ambos servidores y la propia LAN inyectando
        simplemente un par de paquetes.  Existen problemas similares
        con el puerto
        <span class="application">chargen</span>.  Un administrador de sistemas
        competente apagará todos estos servicios internos de
        verificación de inetd.</p><p>Los ataques con paquetes falsificados pueden utilizarse
        también para sobrecargar la caché de rutas del kernel.
        Consulte los parámetros de <code class="command">sysctl</code>
        <code class="varname">net.inet.ip.rtexpire</code>,
        <code class="varname">rtminexpire</code>, y
        <code class="varname">rtmaxcache</code>.
        Un ataque de paquetes falsificados que utiliza una dirección
        IP origen aleatoria provocará que el kernel genere una
        ruta temporal en caché en su tabla de rutas, visible con
        <code class="command">netstat -rna | fgrep W3</code>.  Estas rutas
        suelen expiran en 1600 segundos más o menos.  Si el
        kernel detecta que la tabla de rutas en caché es ya
        demasiado grande reducirá dinámicamente
        <code class="varname">rtexpire</code>, pero nunca la reducirá a un
        valor que sea menor que <code class="varname">rtminexpire</code>.
        Esto nos presenta dos problemas:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>El kernel no reacciona con suficiente rapidez cuando
            un servidor ligeramente cargado es atacado.</p></li><li class="listitem"><p>El <code class="varname">rtminexpire</code> no es lo suficientemente
            bajo para que el kernel sobreviva a un ataque sostenido.</p></li></ol></div><p>Si sus servidores están conectados a Internet mediante
        mediante una línea T3 o superior puede ser prudente corregir
        manualmente
        <code class="varname">rtexpire</code> y <code class="varname">rtminexpire</code>
        por medio de <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  Nunca ponga ambos parámetros
        a cero (a menos que desée estrellar la máquina).
        Configurar ambos parámetros a 2 segundos debería
        bastar para proteger de ataques la tabla de rutas.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp75232464"></a>14.3.9. Otros aspectos del acceso con Kerberos y SSH</h3></div></div></div><a id="idp75233104" class="indexterm"></a><a id="idp75233744" class="indexterm"></a><p>Existen un par de detalles con respecto a
        Kerberos y ssh que debe analizar sy pretende usarlos.
        Kerberos V es un excelente protocolo de
        protocolo de autentificación, pero hay errores en la
        versión kerberizada de <span class="application">telnet</span>
        y <span class="application">rlogin</span> que las hacen
        inapropiadas para gestionar flujos binarios.
        Ademé Kerberos no cifra por defecto una
        sesión a menos que utilice la opción
        <code class="option">-x</code>.  <span class="application">ssh</span> cifra todo
        por defecto.</p><p>ssh funciona bastante bien en todos los casos, con la sola
        salvedad de que por defecto reenvía llaves de cifrado.
        Esto significa que si usted tiene una estación de trabajo
        segura, que contiene llaves que le dan acceso al resto del sistema,
        y hace ssh a una máquina insegura, sus llaves se pueden
        utilizar.   Las llaves en sí no se exponen, pero ssh
        crea un puerto de reenvío durante el login, y si un
        atacante ha comprometido el <code class="systemitem">root</code>
        de la máquina insegura, puede utilizar ese puerto
        para usar sus llaves y obtener acceso a cualquier otra
        máquina que sus llaves abran.</p><p>Le recomendamos que, siempre que sea posible, use ssh
        combinado con Kerberos en los login de su personal de
        administración.
        para logins de staff.  Puede compilar
        <span class="application">ssh</span> con soporte de Kerberos.
        Esto reducirá su dependencia de llaves ssh expuestas,
        al mismo tiempo que protege las contraseñas vía
        Kerberos.  Las llaves ssh deben usarse sólamente para
        tareas automáticas desde máquinas seguras
        (algo que Kerberos no hace por incompatibilidad).  Recomendamos
        también que desactive el reenvío de llaves
        en la configuración de ssh, o que use la
        opción <code class="literal">from=IP/DOMAIN</code> que ssh incluye
        en <code class="filename">authorized_keys</code>; así la llave
        sólo podrá ser utilizada por entidades que se
        validen desde máquinas
        específicas.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Introducción </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> 14.4. DES, MD5 y Crypt</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Puede descargar éste y muchos otros documentos desde
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Si tiene dudas sobre FreeBSD consulte la
    <a href="http://www.FreeBSD.org/docs.html">documentación</a> antes de escribir a la lista
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Envíe sus preguntas sobre la documentación a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>