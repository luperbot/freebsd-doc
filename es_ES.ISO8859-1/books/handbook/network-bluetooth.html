<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>29.4. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manual de FreeBSD" /><link rel="up" href="advanced-networking.html" title="Capítulo 29. Networking avanzado" /><link rel="prev" href="network-wireless.html" title="29.3. Redes sin cables (&#8220;wireless&#8221;)" /><link rel="next" href="network-bridging.html" title="29.5. Puenteado" /><link rel="copyright" href="legalnotice.html" title="Aviso Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">29.4. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-wireless.html">Anterior</a> </td><th width="60%" align="center">Capítulo 29. Networking avanzado</th><td width="20%" align="right"> <a accesskey="n" href="network-bridging.html">Siguiente</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>29.4. Bluetooth</h2></div><div><span class="authorgroup">Escrito por <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pav</span> <span class="surname">Lucistnik</span></span>. </span></div></div></div><a id="idp82266704" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82267216"></a>29.4.1. Introducción</h3></div></div></div><p>Bluetooth es una tecnología inalámbrica que opera en
        banda de 2.4 GHz (donde no se necesita licencia).  Se trata de una
        tecnología pensada para la creación de redes de
        ámbito personal (de cobertura reducida, normalmente de unos 10
        metros).  Las redes se suelen construir en modo <span class="quote">&#8220;<span class="quote">ad-hoc</span>&#8221;</span>
        utilizando dispositivos heterogéneos como teléfonos
        móviles, dispositivos manuales (<span class="quote">&#8220;<span class="quote">handhelds</span>&#8221;</span>) y
	computadoras portátiles.  A diferencia de otras
        tecnologías inalámbricas como Wi-Fi, Bluetooth ofrece
        perfiles de servicio más detallados; por ejemplo un perfil para
        actuar como un servidor de ficheros basado en FTP, para la
        difusión de ficheros (<span class="quote">&#8220;<span class="quote">file pushing</span>&#8221;</span>), para el
        transporte de voz, para la emulación de línea serie y
        muchos más.</p><p>La pila de Bluetooth en FreeBSD se implementa utilizando el entorno
        de Netgraph (véase <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a>). La mayoría de los
        dispositivos USB Bluetooth se pueden utilizar mediante el controlador
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a>. Los dispositivos Bluetooth basados en el chip Broadcom
        BCM2033 están soportados mediante los controladores
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ubtbcmfw</span>(4)</span></a> y <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a>.  Los dispositivos Bluetooth
        basados en la interfaz serie o de Rayos Infrarrojos (UART) se
	controlan mediante <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a> y <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>.
        Este capítulo describe el uso de dispositivos Bluetooth USB.
        El soporte para Bluetooth se encuentra en las versiones de FreeBSD 5.0 y
        posteriores.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82279632"></a>29.4.2. Instalación del dispositivo</h3></div></div></div><p>Por defecto los controladores de los dispositivos Bluetooth se
        encuentran disponibles como módulos del kernel.  Antes de
        enchufar el dispositivo Bluetooth se debe cargar el módulo
        correspondiente dentro del núcleo.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>Si el dispositivo Bluetooth se encuentra conectado cuando el
        sistema arranca se debe cargar el módulo modificando a tal
	efecto el fichero <code class="filename">/boot/loader.conf</code>.</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>Al conectar el dispositivo Bluetooth aparecerá en la
        consola (o en syslog) la siguiente información:</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><p>Se debe copiar
        <code class="filename">/usr/share/examples/netgraph/bluetooth/rc.bluetooth</code>
        a algún lugar más conveniente, por ejemplo
        <code class="filename">/etc/rc.bluetooth</code>.  Este script se usa para
        ejecutar y detener la pila Bluetooth del sistema.  Se suele recomendar
	quitar la pila antes de desenchufar el dispositivo pero si no se hace
	no debería producirse ningún desastre.  Cuando se
	arranca la pila aparece un mensaje similar a este:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82294224"></a>29.4.3. Interfaz de la controladora de la máquina (HCI)</h3></div></div></div><a id="idp82294864" class="indexterm"></a><p>La interfaz de la Controladora de la Máquina (Host
        Controller Interface) proporciona una interfaz de órdenes
        para la controladora de banda base y para el gestor de enlace,
        y permite acceder al estado del hardware y a los
        registros de control.  Esta interfaz proporciona una capa de
        acceso homogénea para todos los dispositivos Bluetooth
        de banda base. La capa HCI de la máquina intercambia
        órdenes y datos con el firmware del HCI presente en el
        dispositivo Bluetooth. El driver de la capa de transporte de
        la controladora de la máquina
        (es decir, el driver del bus físico) proporciona
        ambas capas de HCI la posibilidad de intercambiar
        información entre ellas.</p><p>Se crea un nodo Netgraph de tipo <span class="emphasis"><em>HCI</em></span>
        para cada dispositivo Bluetooth.  El nodo Netgraph HCI
        se conecta normalmente con el nodo que representa el
        controlador del dispositivo Bluetooth de la máquina
        (sentido de bajada) y con el nodo Netgraph L2CAP en el sentido
        de subida. Todas las operaciones HCI se realizan sobre el
        nodo Netgraph HCI y no  sobre el el nodo que representa al
        dispositivo. El nombre por defecto para el nodo HCI es
        <span class="quote">&#8220;<span class="quote">devicehci</span>&#8221;</span>. Para obtener más detalles,
        por favor consulte la página del manual de
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a>.</p><p>Una de las tareas más importantes que se deben
        realizar es el descubrimiento automático de otros
        dispositivos Bluetooth que se encuentren dentro del radio de
        cobertura. Esta operación se denomina en inglés
        <span class="emphasis"><em>inquiry</em></span> (consulta). Esta operación
        o otras operaciones HCI relacionadas se realizan mediante
        la utilidad <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a>. El siguiente ejemplo muestra
        cómo descubrir dispositivos en pocos segundos.
        Tenga siempre presente que un dispositivo remoto sólo
        contesta a la consulta si se encuentra configurado en modo
        descubrimiento (<span class="emphasis"><em>discoverable mode</em></span>).</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> es la dirección
        identificativa única del dispositivo Bluetooth,
        similar a las direcciones MAC de las tarjetas Ethernet. Esta
        dirección se necesita para transmitir otro tipo de
        información a otros dispositivos. Se puede asignar un nombre
        más significativo para los humanos en la variable BD_ADDR.
        El fichero <code class="filename">/etc/bluetooth/hosts</code> contiene
        información relativa a los dispositivos Bluetooth conocidos.
        El siguiente ejemplo muestra cómo obtener un nombre
        significativo para los humanos que fué asignado a un
        dispositivo remoto:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>Si se realiza una consulta (inquiry) sobre el dispositivo
        Bluetooth remoto, dicho dispositivo identificará nuestro
        computador como <span class="quote">&#8220;<span class="quote">nombre.de.su.sistema
          (ubt0)</span>&#8221;</span>. El nombre asignado al dispositivo local se puede
        modificar en cualquier momento.</p><p>El sistema Bluetooth proporciona una conexión punto a punto
        (con sólo dos unidades Bluetooth involucradas) o
        también una conexión punto multipunto. En el
        último caso, la conexión se comparte entre varios
        dispositivos Bluetooth.  El siguiente ejemplo muestra como obtener una
	lista de las conexiones de banda base activas en el dispositivo
        local:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p>Resulta útil disponer de un <span class="emphasis"><em>manejador de
          la conexión</em></span> cuando se necesita terminar la
        conexión de banda base. Es importante recalcar que normalmente
        no es necesario realizar esta terminación de forma manual.
        La pila Bluetooth puede concluír  automáticamente las
        conexiones de banda base que se encuentren inactivas.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>Se ruega consultar la salida de la orden
        <code class="command">hccontrol help</code> para obtener un listado completo de
        las órdenes HCI disponibles. La mayoría de
        estas órdenes no requiren privilegios de superusuario.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82307664"></a>29.4.4. Protocolo de adaptación y de control de enlace a
        nivel lógico (L2CAP)</h3></div></div></div><a id="idp82308304" class="indexterm"></a><p>El protocolo L2CAP (Logical Link Control and Adaptation
        Protocol) proporciona servicios de datos tanto orientados a
        conexión como no orientados a conexión a los protocolos
        de las capas superiores, junto con facilidades de
        multiplexación y de segmentacion y reensamblaje. L2CAP permite
        que los protocolos de capas superiores puedan transmitir y recibir
        paquetes de datos L2CAP de hasta 64 kilobytes de longitud.</p><p>L2CAP se basa en el concepto de <span class="emphasis"><em>canales</em></span>.
        Un canal es una conexión lógica que se sitúa
        sobre la conexión de banda base.  Cada canal se asocia a un
        único protocolo.  Cada paquete L2CAP que se recibe a un canal
        se redirige al protocolo superior correspondiente.  Varios canales
        pueden operar sobre la misma conexión de banda base, pero un
        canal no puede tener asociados más de un protocolo de alto
        nivel.</p><p>Para cada dispositivo Bluetooth se cre un único nodo
        Netgraph de tipo <span class="emphasis"><em>l2cap</em></span>.  El nodo L2CAP se conecta
        normalmente conectado al nodo Netgraph HCI (hacia abajo) y con nodos
        Bluetooth tipo <span class="quote">&#8220;<span class="quote">sockets</span>&#8221;</span> hacia arriba. El nombre por
	defecto para el nodo Netgraph L2CAP es <span class="quote">&#8220;<span class="quote">devicel2cap</span>&#8221;</span>.
        Para obtener más detalles se ruega consultar la página
        del manual <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a>.</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a> le será muy útil para
        hacer ping a otros dispositivos.  Algunas
        implementaciones de Bluetooth no devuelven todos los datos que se
        envían, de tal forma que el valor <span class="emphasis"><em>0 bytes</em></span>
        que se observa a continuación es normal:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p>La herramienta <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> se utiliza para realizar
        varias operaciones sobre los nodos L2CAP.  Este ejemplo muestra
        cómo obtener la lista de conexiones lógicas (canales) y
	la lista de conexiones de banda base (física) que mantiene el
        dispositivo local:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p>Otra herramienta de diagnóstico interesante es
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a>.  Realiza un trabajo similar a la orden
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>, pero en este caso para las estructuras de datos
        relacionadas con el sistema Bluetooth. A continuación se
	muestra la información relativa a la misma conexión
        lógica del ejemplo anterior.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82325328"></a>29.4.5. Protocolo RFCOMM </h3></div></div></div><a id="idp82325968" class="indexterm"></a><p>El protocolo RFCOMM proporciona emulación de puertos serie
        a través del protocolo L2CAP. Este protocolo se basa en el
        estándar de la ETSI denominado TS 07.10. RFCOMM es un
        protoclo de transporte sencillo, con soporte para hasta 9 puertos
        serie RS-232 (EIATIA-232-E).  El protocolo RFCOMM permite hasta 60
        conexiones simultaneas (canales RFCOMM) entre dos dispositivos
        Bluetooth.</p><p>Para los propósitos de RFCOMM, un camino de
        comunicación involucra siempre a dos aplicaciones que se
        ejecutan en dos dispositivos distintos (los extremos de la
        comunicación). Entre ellos existe un segmento que los
        comunica.  RFCOMM pretende cubrir aquellas aplicaciones que utilizan
        los puertos serie de las máquinas donde se ejecutan. El
        segmento de comunicación es un enlace Bluetooth desde un
        dispositivo al otro (conexión directa).</p><p>RFCOMM trata únicamente con la conexión de
        dispositivos directamente, y también con conexiones entre el
        dispositivo y el modem para realizar conexiones de red. RFCOMM puede
        soportar otras configuraciones, tales como módulos que
        se comunican via Bluetooth por un lado y que proporcionan una interfaz
        de red cableada por el otro.</p><p>En FreeBSD el protocolo RFCOMM se implementa utilizando la
        capa de <span class="quote">&#8220;<span class="quote">sockets</span>&#8221;</span> de Bluetooth.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82328528"></a>29.4.6. Enparejamiento de dispositivos</h3></div></div></div><a id="idp82329168" class="indexterm"></a><p>Por defecto, la comunicación Bluetooth no se valida, por lo
        que cualquier dispositivo puede en principio hablar con cualquier
        otro. Un dispositivo Bluetooth (por ejemplo un teléfono
        celular) puede solicitar autenticación para realizar un
        determinado servicio (por ejemplo para el servicio de
        marcación por modem).  La autenticación de Bluetooth
        normalmente se realiza utilizando <span class="emphasis"><em>códigos
          PIN</em></span>.  Un código PIN es una cadena ASCII de hasta
        16 caracteres de longitud.  Los usuarios deben introducir
        el mismo código PIN en ambos dispositivos. Una vez que el
        usuario ha introducido el PIN adecuado ambos dispositivos generan una
        <span class="emphasis"><em>clave de enlace</em></span>. Una vez generada, la clave se
        puede almacenar en el propio dispositivo o en un dispositivo de
        almacenamiento externo.  La siguiente vez que se comuniquen ambos
        dispositivos se reutilizará la misma clave. El procedimiento
        descrito hasta este punto se denomina
        <span class="emphasis"><em>emparejamiento (pairing)</em></span>. Es importante recordar
        que si la clave de enlace se pierde en alguno de los dispositivos
        involucrados se debe volver a ejecutar el procedimiento de
        emparejamiento.</p><p>El dæmon <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> se encarga de gestionar todas las
        peticiones de autenticación Bluetooth. El archivo de
        configuración predeterminado se denomina
        <code class="filename">/etc/bluetooth/hcsecd.conf</code>. A
        continuación se muestra una sección de ejemplo de un
        teléfono celular con el código PIN arbitrariamente
        fijado al valor <span class="quote">&#8220;<span class="quote">1234</span>&#8221;</span>:
       </p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>No existe ninguna limitación en los códigos PIN a
        excepción de su longitud.  Algunos dispositivos (por ejemplo
        los dispositivos de mano Bluetooth) pueden obligar a escribir un
        número predeterminado de caracteres para el código
        PIN.  La opción <code class="option">-d</code> fuerza al dæmon
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> a permanecer ejecutádose en primer plano,
        de tal forma que se puede observar fácilmente lo que ocurre.  Si
	se configura el dispositivo Bluetooth remoto para aceptar el
        procedimiento de emparejamiento y se inicia la conexión con
        dicho dispositivo, el dispositivo remoto debería decir que el
        procedimiento de emparejamiento se ha aceptado y debería
	solicitar el código PIN.  Si se introduce el mismo
        código PIN que se escribió en su momento en el fichero
        <code class="filename">hcsecd.conf</code> el procedimiento de emparejamiento y
        de generación de la clave de enlace debería terminar
        satisfactoriamente.  Por otra parte el procedimiento de emparejamiento
        se puede iniciar en el dispositivo remoto. A continuación
        se muestra un ejemplo de la salida del dæmon
        <code class="command">hcsecd</code>.</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82340688"></a>29.4.7. Protocolo de descubrimiento de servicios (SDP)</h3></div></div></div><a id="idp82341328" class="indexterm"></a><p>El Protocolo de Descubrimiento de Servicios (Service
        Discovery Protocol o SDP) permite a las aplicaciones
        cliente descubrir la existencia de diversos servicios
        proporcionados por uno o varios servidores de aplicaciones,
        junto con los atributos y propiedades de los servicios que se
        ofrecen. Estos atributos de servicio incluyen
        el tipo o clase de servicio ofrecido y el mecanismo o la
        información necesaria para utilizar dichos servicios.</p><p>SDP se basa en una determinada comunicación entre
        un servidor SDP y un cliente SDP.  El servidor mantiene una lista de
        registros de servicios, los cuales describen las
        características de los servicios ofrecidos.  Cada registro
        contiene información sobre un determinado servicio.  Un cliente
        puede recuperar la información de un registro de servicio
        almacenado en un servidor SDP lanzando una petición SDP.  Si el
        cliente o la aplicación asociada con el cliente decide utilizar
	un determinado servicio, debe establecer una conexión
        independiente con el servicio en cuestión.  SDP proporciona un
        mecanismo para el descubrimiento de servicios y sus atributos
	asociados, pero no proporciona ningún mecanismo ni protocolo
        para utilizar dichos servicios.</p><p>Normalmente, un cliente SDP realiza una búsqueda de
        servicios acotada por determinadas características. No obstante
        hay momentos en los que resulta deseable descubrir todos los
        servicios ofrecidos por un servidor SDP sin que pueda existir
        ningún conocimiento previo sobre los registros que pueda
        contener. Este proceso de búsqueda de cualquier servicio
        ofrecido se denomina <span class="emphasis"><em>navegación</em></span> o
	<span class="emphasis"><em>browsing</em></span>.</p><p>El servidor Bluetooth SDP denominado <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> y el cliente de
        línea de órdenes <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> se incluyen en
        la instalación estándar de FreeBSD.  El siguiente ejemplo
        muestra cómo realizar una consulta de navegación
        una consulta de navegación SDP.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec browse</code></strong>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</pre><p>... y así sucesivamente. Resulta importante resaltar una
        vez más que cada servicio posee una lista de atributos (por
        ejemplo en el canal RFCOMM). Dependiendo de los servicios que se
        quieran utilizar puede resultar necesario anotar algunos de los
        atributos. Algunas implementaciones de Bluetooth no soportan
        navegación de servicios y pueden devolver una lista
        vacía. En este caso se puede intentar buscar algún
        servicio determinado. El ejemplo siguiente muestra cómo buscar
        el servicio OBEX Object Push (OPUSH):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></strong></pre><p>En FreeBSD los servicios a clientes Bluetooth se suministran mediante
        el servidor <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpd</code></strong></pre><p>La aplicación local servidora que quiere proporcionar
        servicio Bluetooth a los clientes remotos puede registrar su servicio
	con el dæmon SDP local.  Un ejemplo de dicha aplicación
        Un ejemplo de dicha aplicación lo constituye el dæmon
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.
        Una vez ejecutado el dæmon registra un servicio LAN de Bluetooth
        en el dæmon SDP local.</p><p>Se puede obtener la lista de servicios registrados con el servidor
        SDP local lanzando una consulta de navegación SDP utilizando
        el canal de control local.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpcontrol -l browse</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82356944"></a>29.4.8. Acceso telefónico a redes (DUN) y acceso a redes mediante
        perfiles PPP (LAN)</h3></div></div></div><p>El perfil de Acceso Telefónico a Redes (Dial-Up Networking
        o DUN) se utiliza mayoritariamente con modems y teléfonos
        celulares. Los escenarios cubiertos por este perfil se describen a
        continuación:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Utilización de un teléfono celular o un
            modem por una computadora para simular un modem sin cables
            que se conecte a un servidor de acceso telefónico a redes o
            para otros servicios de acceso telefónico relacionados;
          </p></li><li class="listitem"><p>Utilización de un teléfono celular o un
            modem por un computador para recibir llamadas de datos.
            </p></li></ul></div><p>El Acceso a Redes con perfiles PPP (LAN) se puede utilizar en las
        siguientes situaciones:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Acceso LAN para un único dispositivo Bluetooth;
           </p></li><li class="listitem"><p>Acceso LAN para múltiples dispositivos
            Bluetooth;
          </p></li><li class="listitem"><p>Conexión de PC a PC (utilizando
            emulación de PPP sobre una línea serie).
          </p></li></ul></div><p>En FreeBSD ambos perfiles se implementan bajo las órdenes
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> y <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>, un encapsulador que convierte la
        conexión RFCOMM de Bluetooth en algo que puede ser utilizado
        por PPP.  Antes de que se puedan utilizar los perfiles se debe
        definir una nueva etiqueta PPP en el fichero de configuración
        <code class="filename">/etc/ppp/ppp.conf</code>.  Consulte <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>
        para ver algunos ejemplos.</p><p>En el siguiente ejemplo se va a utilizar <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> para
        abrir una conexión RFCOMM con un dispositivo remoto con
        BD_ADDR 00:80:37:29:19:a4 sobre un canal RFCOMM basado en DUN (Dial-Up
        Networking).  El número de canal RFCOMM se obtiene a partir del
        dispositivo remoto a través de SDP.  Es posible especificar el
        canal RFCOMM a mano, en cuyo caso <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> no
        realizará ninguna consulta SDP.  Se puede utilizar la orden
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> para descubrir el canal RFCOMM utilizado en el
        dispositivo remoto.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>Para proporcionar el servicio de Acceso a Redes a través de
        PPP (LAN) se debe ejecutar el servidor <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.  Se debe crear
        una nueva entrada en <code class="filename">/etc/ppp/ppp.conf</code>.  Le
        rogamos que consulte <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> y observe los ejemplos que
        se facilitan. Por último se debe ejecutar el servidor PPP
        RFCOMM sobre un número de canal RFCOMM adecuado.  El servidor
        PPP RFCOMM registrará automáticamente el servicio LAN
        de Bluetooth con el servidor SDP local.  El ejemplo que se muestra a
        continuación describe cómo ejecutar el servidor PPP
        RFCOMM.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82380240"></a>29.4.9. Perfil OBEX Object Push (OPUSH)</h3></div></div></div><a id="idp82380880" class="indexterm"></a><p>OBEX es un protocolo muy utilizado para transferencias de ficheros
        sencillas entre dispositivos móviles.  Su uso más
        importante se produce en comuncaciones por infrarrojos, donde se
        utiliza para transferencia de ficheros genéricos entre
        portátiles o dispositivos Palm y para enviar tarjetas de visita
        o entradas de la agenda entre teléfonos celulares y otros
        dispositivos con aplicaciones PIM.</p><p>El cliente y el servidor de OBEX se implementan como un paquete
        denominado <span class="application">obexapp</span> disponible como <span class="quote">&#8220;<span class="quote">
        port</span>&#8221;</span> en
	<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/obexapp/pkg-descr">comms/obexapp</a>.</p><p>El cliente OBEX se utiliza para introducir y para recuperar
        recuperar objetos del servidor OBEX.  Un objeto puede por ejemplo ser
        una tarjeta de visita o una cita.  El cliente OBEX puede obtener un
        número de canal RFCOMM del dispositivo remoto utilizando SDP.
        Esto se hace especificando el nombre del servicio en lugar del
        número de canal RFCOMM.  Los nombres de servicios soportados
        son: IrMC, FTRN y OPUSH. Es posible especificar el canal RFCOMM como
        un número. A continuación se muestra un ejemplo de una
        sesión OBEX donde el objeto que posee la información del
        dispositivo se recupera del teléfono celular y un nuevo objeto
        (la tarjeta de visita) se introduce en el directorio de dicho
        teléfono.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>Para proporcionar servicio de OBEX el servidor <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> debe
        estar en funcionamiento. Además se debe crear un directorio
        raíz donde todos los objetos van a ser almacenados.  La ruta
	por defecto para el directorio raíz es <code class="filename">
        /var/spool/obex</code>.   Por último se debe ejecutar el
        servidor OBEX en un número de canal RFCOMM válido.  El
	servidor OBEX registra automáticamente el servicio de Object
	Push con el dæmon SDP local.  El ejemplo que se muestra a
        local. El ejemplo que se muestra a continuación
        continuación describe cómo ejecutar el servidor
	OBEX.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82387280"></a>29.4.10. Perfil de puerto serie (SP) </h3></div></div></div><p>El perfil de puerto serie (Serial Port o SP) permite que
        dispositivos Bluetooth realicen emulación de RS232 (o
        similar).  El escenario cubierto por este perfil trata con
        con aplicaciones comerciales que utilizan Bluetooth como un sustituto
        sustituto del cable, utilizando una capa de abstracción que
        representa un puerto serie virtual.</p><p>La aplicación <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> implementa el perfil
        Puerto Serie.  Usa una pseudo tty como abstracción de puerto
	serie virtual.  El ejemplo de más abajo muestra cómo
	conectarse a un servicio de dispositivo remoto de Puerto Serie.
	Observe que no necesita especificarse el canal RFCOMM:
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> puede obtenerlo del dispotivo remoto via
	SDP.  Si necesita especificarlo por alguna razón
	hágalo en la propia línea de órdenes.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>Una vez conectado el pseudo tty se puede utilizar como un puerto
        serie.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82392784"></a>29.4.11. Solución de problemas</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82393424"></a>29.4.11.1. Un dispositivo remoto no puede conectarse</h4></div></div></div><p>Algunos dispositivos Bluetooh antiguos no soportan el cambio de
          cambio de roles. Por defecto,
          roles.  Cuando FreeBSD acepta una nueva conexión por defecto
          intenta realizar un cambio de rol y convertirse en maestro.
          Dispositivos que no son capaces de realizar este cambio no pueden
          conectarse.  Es interesante resaltar que el cambio de roles se
          realiza cuando se está estableciendo una nueva
          conexión de tal forma que no es posible preguntar al
          dispositivo si soporta intercambio de roles.  Existe una
          opción HCI para desactivar el intercambio de roles en la
          parte local.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82395472"></a>29.4.11.2. Algo va mal ?puedo ver exactamente qué
          está ocurriendo?</h4></div></div></div><p>Sí, se puede.  Utilice el paquete
          <span class="application">hcidump-1.5</span>, que se puede descargar de
          <a class="link" href="http://www.geocities.com/m_evmenkin/" target="_top">aquí</a>.
          La herramienta <span class="application">hcidump</span> es similar a la
          herramienta <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>. Se puede utilizar para mostrar el
          contenido de los paquetes Bluetooth sobre el terminal y para volcar
          los paquetes Bluetooth a un fichero.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-wireless.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="network-bridging.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">29.3. Redes sin cables (<span class="quote">&#8220;<span class="quote">wireless</span>&#8221;</span>) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> 29.5. Puenteado</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Puede descargar éste y muchos otros documentos desde
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Si tiene dudas sobre FreeBSD consulte la
    <a href="http://www.FreeBSD.org/docs.html">documentación</a> antes de escribir a la lista
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Envíe sus preguntas sobre la documentación a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>