<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 14. Sólo para hackers serios de FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Preguntas más frecuentes de FreeBSD 4.X, 5.X y 6.X" /><link rel="up" href="index.html" title="Preguntas más frecuentes de FreeBSD 4.X, 5.X y 6.X" /><link rel="prev" href="misc.html" title="Capítulo 13. Preguntas varias" /><link rel="next" href="acknowledgments.html" title="Capítulo 15. AGRADECIMIENTOS" /><link rel="copyright" href="legalnotice.html" title="Aviso Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 14. Sólo para hackers serios de FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="misc.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="acknowledgments.html">Siguiente</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="hackers"></a>Capítulo 14. Sólo para hackers serios de FreeBSD</h1></div></div></div><div class="qandaset"><a id="idp68885712"></a><dl><dt>14.1. <a href="hackers.html#idp68885968">?Qué son SNAPs y RELEASEs?</a></dt><dt>14.2. <a href="hackers.html#idp68906320">?Cómo puedo hacerme mi propia release personalizada?</a></dt><dt>14.3. <a href="hackers.html#idp68916176">?Cómo creo discos de instalación personalizados?</a></dt><dt>14.4. <a href="hackers.html#idp68918480">``make world'' destruye mis binarios instalados.</a></dt><dt>14.5. <a href="hackers.html#idp68943824">Cuando mi sistema arranca, dice (bus speed defaulted).</a></dt><dt>14.6. <a href="hackers.html#idp68946128">?Puedo seguir la rama current con acceso limitado a Internet?</a></dt><dt>14.7. <a href="hackers.html#idp68953296">?Cómo partir la distribución en archivos de 240k?</a></dt><dt>14.8. <a href="hackers.html#idp68957264">?He escrito una extensión del kernel, a quien la
        envío?</a></dt><dt>14.9. <a href="hackers.html#idp68959952">?Cómo se detectan e inicializan las tarjetas ISA y PnP?</a></dt><dt>14.10. <a href="hackers.html#idp68964816">?Soporta FreeBSD arquitecturas diferentes a x86?</a></dt><dt>14.11. <a href="hackers.html#idp68974544">Necesito un numero de dispositivo para un driver propio</a></dt><dt>14.12. <a href="hackers.html#idp68978000">Alternativas a la política de directorios</a></dt><dt>14.13. <a href="hackers.html#idp68980304">Obtener todo lo posible de un "kernel panic"</a></dt><dt>14.14. <a href="hackers.html#idp69043152">dlsym() no funciona con ejecutables ELF!</a></dt><dt>14.15. <a href="hackers.html#idp69051984">Incrementando o reduciendo el espacio de direcciones del kernel</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp68885968"></a><a id="idp68886224"></a><p><strong>14.1.</strong></p></td><td align="left" valign="top"><p>?Qué son SNAPs y RELEASEs?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Hay actualmente tres ramas activas/semi-activas en el desarrollo de
        FreeBSD y en su
        <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">CVS Repository</a>:</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="symbol">RELENG_2_2</span> AKA <span class="emphasis"><em>2.2-stable</em></span>
            AKA <span class="emphasis"><em>"2.2 branch"</em></span></p></li><li class="listitem"><p><span class="symbol">RELENG_3</span> AKA <span class="emphasis"><em>3.x-stable</em></span>
            AKA <span class="emphasis"><em>"3.0 branch"</em></span></p></li><li class="listitem"><p><acronym class="acronym">HEAD</acronym>  AKA <code class="option">-current</code> AKA
            <span class="emphasis"><em>4.0-current</em></span></p></li></ul></div><p>
        </p><p><acronym class="acronym">HEAD</acronym> no es una rama actual, como las otras dos, es
        simplemente una constante simbólica para <span class="emphasis"><em>la versión
        de desarrollo actual</em></span> a la cual nos referimos simplemente como
        <code class="option">-current</code>.</p><p>Actualmente, <code class="option">-current</code> es el desarrollo de la
        versión 4.0 y la rama <span class="emphasis"><em>3.0-stable</em></span> es
        <span class="symbol">RELENG_3</span>, separada de -current en Enero
        de 1999.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68906320"></a><a id="custrel"></a><p><strong>14.2.</strong></p></td><td align="left" valign="top"><p>?Cómo puedo hacerme mi propia release personalizada?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Para hacer una release necesitas hacer tres cosas: primero,
        necesitas usar un kernel con el driver
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?vn" target="_top">vn</a> configurado.
        Añade esto a tu archivo de configuración del kernel y
        crea un nuevo kernel:</p><p>
        </p><div class="literallayout"><p><br />
          pseudo-device vn         #Vnode driver (turns a file into a device)<br />
        </p></div><p>
        </p><p>Segundo, debes tener las herramientas del CVS a mano. Para hacer
        esto, puedes usar
        <a class="link" href="../../handbook/synching.html#CVSUP" target="_top">CVSUP</a>
        pero en tu supfile pon el nombre de la release a cvs y borra cualquier
        tag campo de fecha:</p><p>
        </p><div class="literallayout"><p>        *default prefix=/home/ncvs<br />
        *default base=/a<br />
        *default host=cvsup.FreeBSD.org<br />
        *default release=cvs<br />
        *default delete compress use-rel-suffix<br />
<br />
        ## Main Source Tree<br />
        src-all<br />
        src-eBones<br />
        src-secure<br />
<br />
        # Other stuff<br />
        ports-all<br />
        www<br />
        doc-all<br />
        </p></div><p>
        </p><p>A continuación ejecuta <code class="command">cvsup -g supfile</code>
        para tener todos los bits correctos en tu computador.</p><p>Finalmente, necesitas una buena cantidad de espacio vacío para
        crear en el la release. Digamos que está en
        <code class="filename">/algun/disco/grande</code> y en el ejemplo anterior has dejado los
        archivos del CVS en <code class="filename">/home/ncvs</code>:</p><p>
        </p><div class="literallayout"><p><br />
        setenv CVSROOT /home/ncvs        # or export CVSROOT=/home/ncvs<br />
        cd /usr/src/release<br />
        make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/algun/disco/grande/release<br />
        </p></div><p>
        </p><p>Una release completa será creada en
        <code class="filename">/algun/disco/grande/</code> y tendrás una
        instalación completa de tipo FTP en
        <code class="filename">/algun/disco/grande/R/ftp</code> cuando acabes.
        Si quieres crear tu SNAP usando otra rama de desarrollo diferente de
        -current, puedes añadir <code class="literal">RELEASETAG=SOMETAG</code> a la
        línea de comando anterior de creación de la release. Por ejemplo,
        <code class="literal">RELEASETAG=RELENG_2_2</code> crearía un snapshot 2.2 GAMMA.
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68916176"></a><a id="idp68916432"></a><p><strong>14.3.</strong></p></td><td align="left" valign="top"><p>?Cómo creo discos de instalación personalizados?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>El proceso completo de creacación de discos de
        instalación y archivos fuentes y binarios esta automatizado por
        varios targets en <code class="filename">/usr/src/release/Makefile</code>. La
        información alli contenida debería ser suficiente para que
        puedas empezar. Falta decir que este proceso necesita la ejecución
        del comando "make world" y quizás te use mucho tiempo y espacio
        en disco.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68918480"></a><a id="idp68918736"></a><p><strong>14.4.</strong></p></td><td align="left" valign="top"><p>``make world'' destruye mis binarios instalados.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sí, esta es la idea general; como su nombre sugiere,
        "make world" rehace todos los binarios del sistema, de manera que puedas
        estar seguro de tener un entorno limpio y consistente al final (que es
        por lo que tarda tanto).</p><p>Si la variable de entorno <acronym class="acronym">DESTDIR</acronym> está
        definida mientras se ejecuta <span class="emphasis"><em>make world</em></span> o
        <span class="emphasis"><em>make install</em></span>, los binarios creados
        nuevamente seran depositados en un árbol de directorios
        idéntico al instalado, y a partir de
        <span class="emphasis"><em>${DESTDIR}</em></span>.  Algunas combinaciones aleatorias
        de modificaciones de librerías compartidas y programas pueden
        causar que falle el <span class="emphasis"><em>make world</em></span>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68943824"></a><a id="idp68944080"></a><p><strong>14.5.</strong></p></td><td align="left" valign="top"><p>Cuando mi sistema arranca, dice (bus speed defaulted).</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Las controladoras SCSI Adaptec 1542 permiten al usuario configurar
        su velocidad de acceso al bus en software. Versiones anteriores del
        driver de la 1542 intentaban determinar la velocidad más alta
        factible y configurar la Adaptec a esta. Nos hemos encontrado con que esto
        hace fallar el sistema de algunos usuarios, por lo que tienes que
        definir la opción de configuración del kernel
        <span class="symbol">TUNE_1542</span> para que esto ocurra. En algunos sistemas puede
        que puede hacer que los discos vayan más rápidos, pero en
        otros puede que los datos queden corrompidos.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68946128"></a><a id="ctm"></a><p><strong>14.6.</strong></p></td><td align="left" valign="top"><p>?Puedo seguir la rama current con acceso limitado a Internet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sí, puedes hacerlo <span class="emphasis"><em>sin</em></span> bajarte
        todo el código fuente usando la
        utilidad <a class="link" href="../../handbook/synching.html#CTM" target="_top">CTM.</a></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68953296"></a><a id="idp68953552"></a><p><strong>14.7.</strong></p></td><td align="left" valign="top"><p>?Cómo partir la distribución en archivos de 240k?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Los sistemas BSD más modernos tienen una opción
        <code class="option">-b</code> para partir que les permite partir los archivos en
        tamaños arbitrarios.</p><p>Aqui hay un ejemplo de <code class="filename">/usr/src/Makefile</code>.</p><p>
        </p><div class="literallayout"><p>        bin-tarball:<br />
        (cd ${DISTDIR}; \<br />
        tar cf - . \<br />
        gzip --no-name -9 -c | \<br />
        split -b 240640 - \<br />
        ${RELEASEDIR}/tarballs/bindist/bin_tgz.)<br />
        </p></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68957264"></a><a id="idp68957520"></a><p><strong>14.8.</strong></p></td><td align="left" valign="top"><p>?He escrito una extensión del kernel, a quien la
        envío?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por favor, mira en
        <a class="link" href="../../handbook/contrib.html" target="_top">como enviar código.</a></p><p>Y gracias por pensar en nosotros!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68959952"></a><a id="idp68960208"></a><p><strong>14.9.</strong></p></td><td align="left" valign="top"><p>?Cómo se detectan e inicializan las tarjetas ISA y PnP?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Brevemente, hay unos cuantos puertos de entrada/salida a los que
        todas las tarjetas PnP responden cuando el computador pregunta si hay
        alguien ahí. Así, cuando comienza la rutina de prueba
        de PnP, pregunta si hay alguna tarjeta PnP presente y todas las
        tarjetas responden con su número de modelo a una lectura I/O
        del mismo puerto. Así el código de prueba puede conocer
        el ID de cada tarjeta (asignado por Microsoft/Intel).</p><p>Los ID's son dos campos de 32 bits (2^64) + 8 bits de
        checksum. Los primeros 32 bits son el identificador del fabricante.
        No se ha dicho publicamente, pero parece estar asumido que diferentes
        tipos de tarjeta del mismo fabricante pueden tener diferentes id's de
        fabricante. La idea de necesitar 32 bits sólo para los
        fabricantes parece un poco excesiva.</p><p>La parte baja de 32 bits son un número de serie,
        dirección ethernet, algo que haga a la tarjeta única. El
        fabricante no debe producir nunca una segunda tarjeta que tenga los
        mismos 32 bits de la parte baja, aunque los 32 bits de la parte alta sean
        diferentes. Así puedes tener múltiples tarjetas del mismo
        tipo en la misma máquina y los 64 bits serán únicos
        para cada tarjeta.</p><p>Los grupos de 32 bits nunca pueden ser todos cero. Esto permite
        mostrar todos los bits no-cero durante la búsqueda binaria
        inicial.</p><p>Una vez el sistema ha identificado todos los ID's de las tarjetas
        presentes, reactivaráa cada tarjeta, una tras otra (a
        través de los mismos puertos I/O), y encontrará los
        recursos que cada tarjeta necesita, que opciones de interrupción
        están disponibles, etc. Se realiza un escaneo sobre todas y cada
        una de las tarjetas presentes para conocer esta información.</p><p>Esta información se combina con la información de los
        archivos ECU del disco y con las BIOS MLB. El soporte PnP de ECU y las
        BIOS para hardware en el MLB usualmente es sintético, y los
        periféricos no hacen PnP genuino. De todas maneras, examinando
        la información del BIOS más la información
        ECU, la rutina de prueba puede causar que los dispositivos que no son
        PnP puedan evitar a esos dispositivos que el código de prueba
        no puede volver a posicionar.</p><p>Así, los dispositivos PnP son visitados una vez más
        y se les asigna su I/O, DMA, IRQ, direcciones del mapa de memoria. Los
        dispositivos aparecerán en esas direcciones y permanecerán
        en ellas hasta que se vuelva a reinicializar la máquina.</p><p>Todo el proceso se ha simplificado mucho, pero espero que hayas podido
        hacerte una idea del proceso.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68964816"></a><a id="idp68965072"></a><p><strong>14.10.</strong></p></td><td align="left" valign="top"><p>?Soporta FreeBSD arquitecturas diferentes a x86?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Diferentes grupos de personas han expresado su interés en
        trabajar en un port multi-arquitectura de FreeBSD y FreeBSD/AXP
        (ALPHA) es un ejemplo de ese esfuerzo realizado, ahora disponible en
        forma de 3.0 SNAPshot release en
        <a class="link" href="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/" target="_top">ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</a>.
        El port de ALPHA funciona actualmente en diferentes tipos de máquinas ALPHA,
        entre ellas, AlphaStation, AXPpci, PC164, Miata y Multia. Este port
        todavía no se considera una release completa y no lo será
        hasta que exista una colección completa de herramientas de
        instalación y una distribución completa en cdrom para
        instalació, incluyendo un número razonable de ports y
        packages funcionales. FreeBSD/AXP debe considerarse software de
        calidad BETA en estos momentos. Para más información del
        proyecto, subscríbete a la
        <code class="email">&lt;<a xmlns="" class="email" href="mailto:FreeBSD-alpha@FreeBSD.org">FreeBSD-alpha@FreeBSD.org</a>&gt;</code>
        <a class="link" href="introduction.html#mailing" title="1.14.">lista de correo</a>.</p><p>También se ha expresado interés en un port de FreeBSD para
        arquitectura SPARC. Subscríbete a
        <code class="email">&lt;<a xmlns="" class="email" href="mailto:FreeBSD-sparc@FreeBSD.org">FreeBSD-sparc@FreeBSD.org</a>&gt;</code>
        <a class="link" href="introduction.html#mailing" title="1.14.">la lista</a> si estás interesado en
        participar en el proyecto. Para discusiones generales en nuevas
        arquitecturas, participa en
        <a class="link" href="introduction.html#mailing" title="1.14.">la lista</a>
        <code class="email">&lt;<a xmlns="" class="email" href="mailto:FreeBSD-platforms@FreeBSD.org">FreeBSD-platforms@FreeBSD.org</a>&gt;</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68974544"></a><a id="idp68974800"></a><p><strong>14.11.</strong></p></td><td align="left" valign="top"><p>Necesito un numero de dispositivo para un driver propio</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esto depende de si quieres hacer que el driver esté
        públicamente disponible. Si la respuesta es afirmativa, por favor,
        envianos una copia del código fuente del driver y las
        modificaciones apropiadas del archivo <span class="emphasis"><em>files.i386</em></span>,
        un ejemplo de configuración y el código apropiado de
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV" target="_top">MAKEDEV</a> para
        crear cualquier archivo especial que use tu dispositivo. Puedes enviar
        todo lo necesario a <code class="email">&lt;<a xmlns="" class="email" href="mailto:FreeBSD-hackers@FreeBSD.org">FreeBSD-hackers@FreeBSD.org</a>&gt;</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68978000"></a><a id="idp68978256"></a><p><strong>14.12.</strong></p></td><td align="left" valign="top"><p>Alternativas a la política de directorios</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>En respuesta a esta pregunta de políticas alternativas
        para los directorios, el esquema que está actualmente en uso
        no ha cambiado desde que lo escribí en 1983. Escribí esa
        política para el sistema de archivos rápido original, y
        nunca se ha revisado. Trabaja bién manteniendo los grupos de
        cilindros. Como muchos de vosotros habreis notado, el rendimiento es
        muy pobre con "find". Muchos sistemas de archivos son creados desde
        archivos que fueron creados por una primera búsqueda en
        profundidad (también conocido como ftw). Estos directorios
        terminan esparcidos a través de los grupos de cilindros. Si
        conociesemos el número total de directorios a crear, la
        solución sería  crear (total / fs_ncg) por grupo de
        cilindros antes de moverlos. Obviamente, tendriamos que crear
        algún tipo de heurística para adivinar este número.
        Usando un número pequeño fijo (como puede ser
        10) haría de orden de magnitud. Para diferencial restores de
        operaciones normales (cuando el algoritmo actual es probablemente
        más sensible), podrís usar el clustering hasta 10 si
        fueran todos hechos dentro de una ventana de diez segundos. De cualquier
        manera, mi conclusión es que este es un área para la
        experimentación.</p><p>Kirk McKusick, Septiembre 1998</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68980304"></a><a id="idp68980560"></a><p><strong>14.13.</strong></p></td><td align="left" valign="top"><p>Obtener todo lo posible de un "kernel panic"</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="emphasis"><em>[Esta sección fue extraida de un mensaje escrito
        por <a class="link" href="mailto:wpaul@FreeBSD.org" target="_top">Bill Paul</a> en la
        <a class="link" href="introduction.html#mailing" title="1.14.">lista</a> FreeBSD-current por
        <a class="link" href="mailto:des@FreeBSD.org" target="_top">Dag-Erling Coïdan Smørgrav</a>,
        quién a fijado algunos errores y añadido algunos comentarios
        entre corchetes]</em></span></p><p>
        </p><div class="literallayout"><p>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;<br />
        Subject: Re: the fs fun never stops<br />
        To: ben@rosengart.com<br />
        Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)<br />
        Cc: current@FreeBSD.org<br />
        </p></div><p>
        </p><p><span class="emphasis"><em>[&lt;ben@rosengart.com&gt; envió el siguiente
        panic]</em></span>
        </p><div class="literallayout"><p>&gt; Fatal trap 12: page fault while in kernel mode<br />
        &gt; fault virtual address   = 0x40<br />
        &gt; fault code              = supervisor read, page not present<br />
        &gt; instruction pointer     = 0x8:0xf014a7e5<br />
                                        ^^^^^^^^^^<br />
        &gt; stack pointer           = 0x10:0xf4ed6f24<br />
        &gt; frame pointer           = 0x10:0xf4ed6f28<br />
        &gt; code segment            = base 0x0, limit 0xfffff, type 0x1b<br />
        &gt;                         = DPL 0, pres 1, def32 1, gran 1<br />
        &gt; processor eflags        = interrupt enabled, resume, IOPL = 0<br />
        &gt; current process         = 80 (mount)<br />
        &gt; interrupt mask          =<br />
        &gt; trap number             = 12<br />
        &gt; panic: page fault<br />
        </p></div><p>
        </p><p>[Cuando] ves un mensaje como este, no es suficiente con solo
        reproducirlo y enviarlo. El valor del puntero de instrucciones que
        he marcado arriba es importante; desafortunadamente, depende de la
        configuración. En otras palabras, el valor varía
        dependiendo de la imáden de kernel exacta que se use. Si
        estás usando el kernel GENERIC de uno de los snapshots, entonces
        es posible que alguien pueda seguir la función
        problemática, pero si estás usando un kernel
        personalizado, entonces solo <span class="emphasis"><em>tú</em></span> puedes decirnos donde
        ha ocurrido el fallo.</p><p>Tendrías que hacer lo siguiente:</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Anotar el valor del puntero de la instrucción. Ten en
            cuenta la parte <code class="literal">0x8:</code> al inicio no es significante
            en este caso: es la parte <code class="literal">0xf0xxxxxx</code> la que queremos.</p></li><li class="listitem"><p>Cuando el sistema rearranca, haz lo siguiente:
            </p><div class="literallayout"><p><br />
              % nm /kernel.that.caused.the.panic | grep f0xxxxxx<br />
            </p></div><p>

            donde <code class="literal">f0xxxxxx</code> es el valor del puntero de la
            instrucción. El problema es que no obtendrás una
            búsqueda exacta ya que los símbolos en la tabla de
            símbolos del kernel son para los puntos de entrada de las
            funciones y la dirección
            del puntero de la instrucción estará en algún
            lugar dentro de una función, no al principio. Si no obtienes
            un resultado exacto, omite el último dígito del valor
            del puntero de la instrucción e intentalo otra vez, por
            ejemplo:
            </p><div class="literallayout"><p><br />
              % nm /kernel.that.caused.the.panic | grep f0xxxxx<br />
            </p></div><p>

            Si esto no da ningún resultado, elimina otro dígito.
            Repite la operación hasta que obtengas algún tipo de
            salida. El resultado será una lista de posibles funciones
            que causan el panic. Este no es un sistema muy exacto de
            búsqueda de errores, pero es mejor que nada.</p></li></ul></div><p>
        </p><p>Veo gente que constantemente envía mensajes de panics como
        este, pero raramente veo que alguien se tome el tiempo de buscar
        la coincidencia entre el puntero de instrucción y una
        función en la tabla de símbolos del kernel.</p><p>La mejor manera de hacer el seguimiento de la causa de un panic es
        capturar un "crash dump", usando <code class="command">gdb(1)</code> para hacer una traza del
        "crash dump". Por supuesto, esto depende de que <code class="command">gdb(1)</code> funcione
        correctamente en -current, lo que no puedo garantizar (recuerdo que
        alguien ha comentado que el nuevo <code class="command">gdb(1)</code> en formato ELF no
        manejaba bién los "dumps" de un crash del kernel; alguién
        debería mirar esto antes de que la 3.0 salga del estado beta).</p><p>En cualquier caso, el método que normalmente uso es este:</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Crear un archivo de configuración de kernel, opcionalmente
            añadiendo 'options DDB' si piensas que necesitas el debugger
            del kernel por algún motivo. (Uso esto principalmente para
            configurar puntos de salida si sospecho que existe alguna
            condición que crea un loop infinito).</p></li><li class="listitem"><p>Usar <code class="command">config -g KERNELCONFIG</code> para crear el directorio
            de configuración del kernel.</p></li><li class="listitem"><p><code class="command">cd /sys/compile/KERNELCONFIG; make</code></p></li><li class="listitem"><p>Esperar a que el kernel termine de compilar.</p></li><li class="listitem"><p><span class="emphasis"><em>cp kernel kernel.debug</em></span></p></li><li class="listitem"><p><code class="command">strip -d kernel</code></p></li><li class="listitem"><p><span class="emphasis"><em>mv </em></span>kernel /kernel.orig/</p></li><li class="listitem"><p><code class="command">cp kernel /</code></p></li><li class="listitem"><p>reboot</p></li></ul></div><p>
        </p><p><span class="emphasis"><em>[Nota: ahora que los kernels de FreeBSD 3.x son ELF por defecto
        debes usar <code class="command">strip -g</code> en lugar de <code class="command">strip -d</code>.
        Si por algún motivo tu kernel es aún a.out, usa
        <code class="command">strip -aout -d</code>.]</em></span></p><p>Ten en cuenta que TU <acronym class="acronym">NO</acronym> QUIERES ARRANCAR CON UN
        KERNEL QUE TIENE TODOS LOS SIMBOLOS DE DEBUG EN EL. Un kernel compilado
        con <code class="option">-g</code> puede llegar facilmente a los 10MB de tamaño.
        No tienes que arrancar esta imán masiva, solo lo necesitas para poder usar
        después <code class="command">gdb(1)</code> (<code class="command">gdb(1)</code> quiere
        la tabla de símbolos). Al contrario, quieres mantener una copia de la
        imágen completa y crear una segunda imágen con los
        símbolos de debug desactivados usando <code class="command">strip -d</code>. Es esta
        segunda imágen la que quieres arrancar.</p><p>Para asegurarte de capturar un "crash dump", necesitas editar el
        archivo <code class="filename">/etc/rc.conf</code> y apuntar
        <span class="emphasis"><em>dumpdev</em></span> a tu
        partición de swap. Esto hará que el script <code class="command">rc(8)</code>
        use el comando <code class="command">dumpon(8)</code> para activar los "crash dumps".
        También puedes ejecutar manualmente <code class="command">dumpon(8)</code>.
        Después de un panic, el "crash dump" puede ser recuperado usando
        <code class="command">savecore(8)</code>; si <span class="emphasis"><em>dumpdev</em></span>
        está en <code class="filename">/etc/rc.conf</code>, el script
        <code class="command">rc(8)</code> ejecutará <code class="command">savecore(8)</code>
        automaticamente y pondrá el "crash dump" en
        <code class="filename">/var/crash</code>.</p><p>NOTA: los "crash dumps" de FreeBSD suelen tener el mismo
        tamaño que la cantidad total de memoria física del
        sistema. Esto significa que si tienes 64MB de RAM, obtendrás
        un "crash dump" de 64MB. Debido a esto, tienes que asegurarte de tener
        suficiente espacio libre en <code class="filename">/var/crash</code>.
        Alternativamente puedes ejecutar <code class="command">savecore(8)</code>
        manualmente y hacer la recuparación en otro directorio donde
        tengas más espacio libre. Es posible limitar el tamaño
        del "crash dump" usando <code class="literal">options MAXMEM=(foo)</code>
        para indicar la cantidad de memoria que el kernel puede ocupar. Por
        ejemplo, si tienes 128MB de RAM, puedes limitar el uso de memoria del
        kernel a 16MB para que el "crash dump" sea de 16MB y no de 128MB.</p><p>Una vez hayas recuperado el "crash dump", puedes obtener una traza
        del stack con <code class="command">gdb(1)</code> de la manera siguiente:</p><p>
        </p><div class="literallayout"><p><br />
          % gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0<br />
          (gdb) where<br />
        </p></div><p>
        </p><p>Es posible que aparezcan muchas líneas de información:
        es una buena idea usar el comando <code class="command">script(1)</code> para capturarlas
        todas. Usando la imágen del kernel con todos los símbolos
        de debug deberí mostrar la línea exacta de código
        fuente del kernel donde ha ocurrido el panic. Normalmente, tienes que
        leer la traza del stack de abajo hacia arriba para poder conocer la
        secuencia exacta de eventos que han provocado el crash. También
        puedes usar <code class="command">gdb(1)</code> para mostrar los contenidos de las diferentes
        variables o estructuras para examinar el estado del sistema en el
        momento del crash.</p><p>Ahora, si eres realmente curioso y tienes un segundo computador,
        puedes configurar <code class="command">gdb(1)</code> para hacer un debug remoto de manera
        que puedes usar <code class="command">gdb(1)</code> en un sistema para revisar el kernel
        de otro sistema, de la misma manera que lo harías en la
        máquina local.</p><p><span class="emphasis"><em>[Bill añade: "Olvidé mencionar una cosa: si tienes
        DDB activado, puedes forzar un panic (y un crash dump)  tecleando
        "panic" en el prompt del ddb. Es posible que el debugger se pare
        durante la fase del panic. Si esto ocurre, teclea "continue" y el
        crash dump finalizará"]</em></span></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69043152"></a><a id="idp69043408"></a><p><strong>14.14.</strong></p></td><td align="left" valign="top"><p>dlsym() no funciona con ejecutables ELF!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Las herramientas ELF no hacen por defecto que los símbolos
        definidos en un ejecutable sean visibles por el linker dinámico.
        Consecuentemente, <code class="function">dlsym()</code> buscará en datos
        obtenidos desde llamadas a <span class="emphasis"><em>dlopen(NULL, flags)</em></span>,
        lo que provoca que no se encuentren esos símbolos.</p><p>Si quieres buscar, usando <code class="function">dlsym()</code> símbolos
        presentes en el ejecutable principal de un proceso, necesitas linkar el
        ejecutable usando la opción <code class="option">-export-dynamic</code> en el
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ld" target="_top">linkador ELF</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69051984"></a><a id="idp69052240"></a><p><strong>14.15.</strong></p></td><td align="left" valign="top"><p>Incrementando o reduciendo el espacio de direcciones del kernel</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por defecto, el espacio de direcciones del kernel es de 256MB en
        FreeBSD 3.x y 1GB en FreeBSD 4.x. Si gestionas un servidor de red
        muy cargado (por ejemplo, servidores FTP o HTTP con mucho
        tráfico), es posible que notes que 256MB no es
        suficiente.</p><p>Así que... como incremento el espacio de direcciones?. Hay
        dos aspectos a tener en cuenta. Primero, necesitas indicarle al kernel
        que reserve una mayor parte del espacio de direcciones para él
        mismo. Segundo, ya que el kernel se carga al inicio del espacio de
        direcciones, necesitas disminuir la dirección de carga.</p><p>El primer aspecto lo solucionamos incrementando el valor de
        <acronym class="acronym">NKPDE</acronym> en <code class="filename">src/sys/i386/include/pmap.h</code>.
        Esta es una entrada de ejemplo para 1GB de espacio de direcciones:</p><p>
        </p><div class="literallayout"><p><br />
          #ifndef NKPDE<br />
          #ifdef SMP<br />
          #define NKPDE                   254     /* addressable number of page tables/pde's */<br />
          #else<br />
          #define NKPDE                   255     /* addressable number of page tables/pde's */<br />
          #endif  /* SMP */<br />
          #endif<br />
        </p></div><p>
        </p><p>Para encontrar el valor correcto de <acronym class="acronym">NKPDE</acronym>,
        divide el espacio de direcciones deseado (en megabytes) por cuatro,
        después resta uno por UP y dos por SMP.</p><p>Para solucionar el segundo aspecto, necesitas calcular la
        dirección correcta de carga: simplemente resta el tamaño
        del espacio de direcciones (en bytes) de 0x100100000; el resultado
        es 0xc0100000 para 1GB de espacio de direcciones. Ajusta
        <span class="symbol">LOAD_ADDRESS</span> en
        <code class="filename">src/sys/i386/conf/Makefile.i386</code> a ese
        valor; a continuación pon el contador al inicio de la
        sección listado en <code class="filename">src/sys/i386/conf/kernel.script</code>
        al mismo valor, como sigue:</p><p>
        </p><div class="literallayout"><p><br />
          OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")<br />
          OUTPUT_ARCH(i386)<br />
          ENTRY(btext)<br />
          SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-FreeBSDelf/lib);<br />
          SECTIONS<br />
          {<br />
            /* Read-only sections, merged into text segment: */<br />
            . = 0xc0100000 + SIZEOF_HEADERS;<br />
            .interp     : { *(.interp)    }<br />
        </p></div><p>
        </p><p>Reconfigura y compila el kernel. Probablemente tengas problemas con
        <code class="command">top(1)</code>, <code class="command">ps(1)</code> y programas así
        haciendo un <span class="emphasis"><em>make world</em></span> deberín
        solucionarse esos problemas (o una recompilación manual de
        <span class="emphasis"><em>libkvm</em></span>, <span class="emphasis"><em>ps</em></span> y
        <span class="emphasis"><em>top</em></span> después de copiar el
        <code class="filename">pmap.h</code> parcheado a <code class="filename">/usr/include/vm/</code>.
        </p><p>NOTA: el tamaño del espacio de direcciones debe ser un
        múltiplo de cuatro megabytes.</p><p><span class="emphasis"><em>[<a class="link" href="mailto:dg@FreeBSD.org" target="_top">David Greenman</a>
        añade: </em></span>Pienso que el espacio de direcciones del kernel
        necesita ser una potencia de 2, pero no estoy totalmente seguro.]</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="misc.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="acknowledgments.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 13. Preguntas varias </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Capítulo 15. AGRADECIMIENTOS</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Puede descargar éste y muchos otros documentos desde
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Si tiene dudas sobre FreeBSD consulte la
    <a href="http://www.FreeBSD.org/docs.html">documentación</a> antes de escribir a la lista
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Envíe sus preguntas sobre la documentación a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>