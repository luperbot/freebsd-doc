<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>1.5. boot2阶段</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 系统结构手册" /><link rel="up" href="boot.html" title="第 1 章 引导过程与内核初始化" /><link rel="prev" href="boot-boot0.html" title="1.4. boot0阶段" /><link rel="next" href="boot-loader.html" title="1.6. loader阶段" /><link rel="copyright" href="trademarks.html" title="法律声明" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.5. <code class="literal">boot2</code>阶段</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="boot-boot0.html">上一页</a> </td><th width="60%" align="center">第 1 章 引导过程与内核初始化</th><td width="20%" align="right"> <a accesskey="n" href="boot-loader.html">下一页</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="boot-boot2"></a>1.5. <code class="literal">boot2</code>阶段</h2></div></div></div><p>也许你想知道，为什么<code class="literal">boot2</code>是在
      <code class="literal">boot0</code>之后，而不是在boot1之后。事实上，
      也有一个512字节的文件<code class="filename">boot1</code>存放在目录
      <code class="filename">/boot</code>里，那是用来从一张软盘引导系统的。
      从软盘引导时，<code class="filename">boot1</code>起着
      <code class="filename">boot0</code>对硬盘引导相同的作用:它找到
      <code class="filename">boot2</code>并运行之。</p><p>你可能已经看到有一文件<code class="filename">/boot/mbr</code>。
      这是<code class="filename">boot0</code>的简化版本。
      <code class="filename">mbr</code>中的代码不会显示菜单让用户选择，
      而只是简单的引导被标志的分区。</p><p>实现<code class="filename">boot2</code>的代码存放在目录
      <code class="filename">sys/boot/i386/boot2/</code>里，对应的可执行文件在
      <code class="filename">/boot</code>里。在<code class="filename">/boot</code>里的文件
      <code class="filename">boot0</code>和<code class="filename">boot2</code>不会在引导过程中使用，
      只有<span class="application">boot0cfg</span>这样的工具才会使用它们。
      <code class="filename">boot0</code>的内容应在MBR中才能生效。
      <code class="filename">boot2</code>位于可引导的FreeBSD分区的开始。
      这些位置不受文件系统控制，所以它们不可用<span class="application">ls</span>
      之类的命令查看。</p><p><code class="literal">boot2</code>的主要任务是装载文件
      <code class="filename">/boot/loader</code>，那是引导过程的第三阶段。
      在<code class="literal">boot2</code>中的代码不能使用诸如
      <code class="function">open()</code>和<code class="function">read()</code>
      之类的例程函数,因为内核还没有被加载。而应当扫描硬盘，
      读取文件系统结构，找到文件<code class="filename">/boot/loader</code>，
      用BIOS的功能将它读入内存，然后从其入口点开始执行之。</p><p>除此之外，<code class="literal">boot2</code>还可提示用户进行选择，
      loader可以从其它磁盘、系统单元、分区装载。</p><p><code class="literal">boot2</code> 的二进制代码用特殊的方式产生：</p><pre class="programlisting"><code class="filename">sys/boot/i386/boot2/Makefile</code>
boot2: boot2.ldr boot2.bin ${BTX}/btx/btx
	btxld -v -E ${ORG2} -f bin -b ${BTX}/btx/btx -l boot2.ldr \
		-o boot2.ld -P 1 boot2.bin</pre><a id="idp63802448" class="indexterm"></a><p>这个Makefile片断表明<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btxld&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">btxld</span>(8)</span></a>被用来链接二进制代码。
      BTX表示引导扩展器(BooT eXtender)是给程序(称为客户(client)
      提供保护模式环境、并与客户程序相链接的一段代码。所以
      <code class="literal">boot2</code>是一个BTX客户，使用BTX提供的服务。</p><a id="idp63815888" class="indexterm"></a><p>工具<span class="application">btxld</span>是链接器，
      它将两个二进制代码链接在一起。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btxld&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">btxld</span>(8)</span></a>和<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>
      的区别是<span class="application">ld</span>通常将两个目标文件
      链接成一个动态链接库或可执行文件，而<span class="application">btxld</span>
      则将一个目标文件与BTX链接起来，产生适合于放在分区首部的二进制代码，
      以实现系统引导。</p><p><code class="literal">boot0</code>执行跳转至BTX的入口点。
      然后，BTX将处理器切换至保护模式，并准备一个简单的环境，
      然后调用客户。这个环境包括：</p><a id="idp63825104" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>虚拟8086模式。这意味着BTX是虚拟8086的监视程序。
        实模式指令，如pushf, popf, cli, sti, if，均可被客户调用。</p></li><li class="listitem"><p>建立中断描述符表(Interrupt Descriptor Table, IDT)，
        使得所有的硬件中断可被缺省的BIOS程序处理。
        建立中断0x30，这是系统调用关口。</p></li><li class="listitem"><p>两个系统调用<code class="function">exec</code>和
        <code class="function">exit</code>的定义如下:</p><pre class="programlisting"><code class="filename">sys/boot/i386/btx/lib/btxsys.s:</code>
		.set INT_SYS,0x30		# 中断号
#
# System call: exit
#
__exit: 	xorl %eax,%eax			# BTX系统调用0x0
		int $INT_SYS			#
#
# System call: exec
#
__exec: 	movl $0x1,%eax			# BTX系统调用0x1
		int $INT_SYS			# </pre></li></ul></div><p>BTX建立全局描述符表(Global Descriptor Table, GDT):</p><pre class="programlisting"><code class="filename">sys/boot/i386/btx/btx/btx.s:</code>
gdt:		.word 0x0,0x0,0x0,0x0		# 以空为入口
		.word 0xffff,0x0,0x9a00,0xcf	# SEL_SCODE
		.word 0xffff,0x0,0x9200,0xcf	# SEL_SDATA
		.word 0xffff,0x0,0x9a00,0x0	# SEL_RCODE
		.word 0xffff,0x0,0x9200,0x0	# SEL_RDATA
		.word 0xffff,MEM_USR,0xfa00,0xcf# SEL_UCODE
		.word 0xffff,MEM_USR,0xf200,0xcf# SEL_UDATA
		.word _TSSLM,MEM_TSS,0x8900,0x0 # SEL_TSS</pre><p>客户的代码和数据始于地址MEM_USR(0xa000)，选择符(selector)
      SEL_UCODE指向客户的数据段。选择符 SEL_UCODE 拥有第3级描述符权限
      (Descriptor Privilege Level, DPL)，这是最低级权限。但是
      <code class="literal">INT 0x30</code> 指令的处理程序存储于另一个段里，
      这个段的选择符SEL_SCODE (supervisor code)由有着管理级权限。
      正如代码建立IDT(中断描述符表)时进行的操作那样:</p><pre class="programlisting">		mov $SEL_SCODE,%dh		# 段选择符
init.2: 	shr %bx				# 是否处理这个中断？
		jnc init.3			# 否
		mov %ax,(%di)			# 设置处理程序偏移量
		mov %dh,0x2(%di)		# 设置处理程序选择符
		mov %dl,0x5(%di)		# 设置 P:DPL:type
		add $0x4,%ax			# 下一个中断处理程序</pre><p>所以，当客户调用 <code class="function">__exec()</code>时，代码将被以最高权限执行。
      这使得内核可以修改保护模式数据结构，如分页表(page tables)、全局描述符表(GDT)、
      中断描述符表(IDT)等。</p><p><code class="literal">boot2</code> 定义了一个重要的数据结构：
      <code class="literal">struct bootinfo</code>。这个结构由
      <code class="literal">boot2</code> 初始化，然后被转送到loader，之后又被转入内核。
      这个结构的部分项目由<code class="literal">boot2</code>设定，其余的由loader设定。
      这个结构中的信息包括内核文件名、BIOS提供的硬盘柱面/磁头/扇区数目信息、
      BIOS提供的引导设备的驱动器编号，可用的物理内存大小，<code class="literal">envp</code>
      指针(环境指针)等。定义如下：</p><pre class="programlisting"><code class="filename">/usr/include/machine/bootinfo.h</code>
struct bootinfo {
	u_int32_t	bi_version;
	u_int32_t	bi_kernelname;		/* 用一个字节表示 * */
	u_int32_t	bi_nfs_diskless;	/* struct nfs_diskless * */
		/* 以上为常备项 */
#define	bi_endcommon	bi_n_bios_used
	u_int32_t	bi_n_bios_used;
	u_int32_t	bi_bios_geom[N_BIOS_GEOM];
	u_int32_t	bi_size;
	u_int8_t	bi_memsizes_valid;
	u_int8_t	bi_bios_dev;		/* 引导设备的BIOS单元编号 */
	u_int8_t	bi_pad[2];
	u_int32_t	bi_basemem;
	u_int32_t	bi_extmem;
	u_int32_t	bi_symtab;		/* struct symtab * */
	u_int32_t	bi_esymtab;		/* struct symtab * */
		/* 以下项目仅高级bootloader提供 */
	u_int32_t	bi_kernend;		/* 内核空间末端 */
	u_int32_t	bi_envp;		/* 环境 */
	u_int32_t	bi_modulep;		/* 预装载的模块 */
};</pre><p><code class="literal">boot2</code> 进入一个循环等待用户输入，然后调用
    <code class="function">load()</code>。如果用户不做任何输入，循环将在一段时间后结束，
    <code class="function">load()</code> 将会装载缺省文件(<code class="filename">/boot/loader</code>)。
    函数 <code class="function">ino_t lookup(char *filename)</code>和
    <code class="function">int xfsread(ino_t inode, void *buf, size_t nbyte)</code>
    用来将文件内容读入内存。<code class="filename">/boot/loader</code>是一个ELF格式二进制文件，
    不过它的头部被换成了a.out格式中的<code class="literal">struct exec</code>结构。
    <code class="function">load()</code>扫描loader的ELF头部，装载<code class="filename">/boot/loader</code>
    至内存，然后跳转至入口执行之：</p><pre class="programlisting"><code class="filename">sys/boot/i386/boot2/boot2.c:</code>
    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),
	   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),
	   0, 0, 0, VTOP(&amp;bootinfo));</pre></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="boot-boot0.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="boot.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="boot-loader.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">1.4. <code class="literal">boot0</code>阶段 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 1.6. <span class="application">loader</span>阶段</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文档和其它文档可从这里下载：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>如果对于FreeBSD有问题，请先阅读
    <a href="http://www.FreeBSD.org/docs.html">文档</a>，如不能解决再联系
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    关于本文档的问题请发信联系
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>