<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>26.5. The IPFILTER (IPF) Firewall</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Podrêcznik FreeBSD" /><link rel="up" href="firewalls.html" title="Rozdzia³ 26. Firewalls" /><link rel="prev" href="firewalls-pf.html" title="26.4. The OpenBSD Packet Filter (PF) and ALTQ" /><link rel="next" href="firewalls-ipfw.html" title="26.6. IPFW" /><link rel="copyright" href="legalnotice.html" title="Informacja Prawna" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">26.5. The IPFILTER (IPF) Firewall</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="firewalls-pf.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia³ 26. Firewalls</th><td width="20%" align="right"> <a accesskey="n" href="firewalls-ipfw.html">Nastêpny</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="firewalls-ipf"></a>26.5. The IPFILTER (IPF) Firewall</h2></div></div></div><a id="idp95025744" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">This section is work in progress.  The contents might
	not be accurate at all times.</p></div><p>The author of IPFILTER is Darren Reed.  IPFILTER is not
      operating system dependent: it is an open source application and
      has been ported to FreeBSD, NetBSD, OpenBSD, <span class="trademark">SunOS</span>TM, HP/UX, and
      <span class="trademark">Solaris</span>TM operating systems.  IPFILTER is actively being
      supported and maintained, with updated versions being released
      regularly.</p><p>IPFILTER is based on a kernel-side firewall and
      <acronym class="acronym">NAT</acronym> mechanism that can be controlled and
      monitored by userland interface programs.  The firewall rules can
      be set or deleted with the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipf</span>(8)</span></a> utility.  The
      <acronym class="acronym">NAT</acronym> rules can be set or deleted with the
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ipnat</span>(1)</span></a> utility.  The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> utility can print
      run-time statistics for the kernel parts of IPFILTER.  The
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipmon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipmon</span>(8)</span></a> program can log IPFILTER actions to the system log
      files.</p><p>IPF was originally written using a rule processing logic of
      <span class="quote">"<span class="quote">the last matching rule wins</span>"</span> and used only
      stateless type of rules.  Over time IPF has been enhanced to
      include a <span class="quote">"<span class="quote">quick</span>"</span> option and a stateful <span class="quote">"<span class="quote">keep
	state</span>"</span> option which drastically modernized the rules
      processing logic.  IPF's official documentation covers the legacy
      rule coding parameters and the legacy rule file processing
      logic.  The modernized functions are only included as additional
      options, completely understating their benefits in producing a
      far superior secure firewall.</p><p>The instructions contained in this section are based on
      using rules that contain the <span class="quote">"<span class="quote">quick</span>"</span> option and the
      stateful <span class="quote">"<span class="quote">keep state</span>"</span> option.  This is the basic
      framework for coding an inclusive firewall rule set.</p><p>An inclusive firewall only allows packets matching the rules
      to pass through.  This way you can control what services can
      originate behind the firewall destined for the public Internet
      and also control the services which can originate from the
      public Internet accessing your private network.  Everything else
      is blocked and logged by default design.  Inclusive firewalls are
      much, much more secure than exclusive firewall rule sets and is
      the only rule set type covered herein.</p><p>For detailed explanation of the legacy rules processing
      method see: <code class="uri"><a class="uri" href="http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1" target="_top">http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1</a></code>
      and <code class="uri"><a class="uri" href="http://coombs.anu.edu.au/~avalon/ip-filter.html" target="_top">http://coombs.anu.edu.au/~avalon/ip-filter.html</a></code>.</p><p>The IPF FAQ is at <code class="uri"><a class="uri" href="http://www.phildev.net/ipf/index.html" target="_top">http://www.phildev.net/ipf/index.html</a></code>.</p><p>A searchable archive of the open-source IPFilter mailing list is
      available at <code class="uri"><a class="uri" href="http://marc.theaimsgroup.com/?l=ipfilter" target="_top">http://marc.theaimsgroup.com/?l=ipfilter</a></code>.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95043920"></a>26.5.1. Enabling IPF</h3></div></div></div><a id="idp95044560" class="indexterm"></a><p>IPF is included in the basic FreeBSD install as a separate run
	time loadable module.  The system will dynamically load the IPF
	kernel loadable module when the rc.conf statement
	<code class="literal">ipfilter_enable="YES"</code> is used.  The loadable
	module was created with logging enabled and the
	<code class="literal">default pass all</code> options.  You do not need
	to compile IPF into the FreeBSD kernel just to change the default
	to <code class="literal">block all</code>, you can do that by just coding
	a block all rule at the end of your rule set.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95047376"></a>26.5.2. Kernel options</h3></div></div></div><a id="idp95048016" class="indexterm"></a><a id="idp95049296" class="indexterm"></a><a id="idp95050448" class="indexterm"></a><a id="idp95051600" class="indexterm"></a><p>It is not a mandatory requirement that you enable IPF by
	compiling the following options into the FreeBSD kernel.  It is
	only presented here as background information.  Compiling IPF
	into the kernel causes the loadable module to never be
	used.</p><p>Sample kernel config IPF option statements are in the
	<code class="filename">/usr/src/sys/conf/NOTES</code> kernel source
	and are reproduced here:</p><pre class="programlisting">options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</pre><p><code class="literal">options IPFILTER</code> enables support for the
	<span class="quote">"<span class="quote">IPFILTER</span>"</span> firewall.</p><p><code class="literal">options IPFILTER_LOG</code> enables the option
	to have IPF log traffic by writing to the
	<code class="filename">ipl</code> packet logging pseudo-device
	for every rule that has the <code class="literal">log</code>
	keyword.</p><p><code class="literal">options IPFILTER_DEFAULT_BLOCK</code> changes
	the default behavior so any packet not matching a firewall
	<code class="literal">pass</code> rule gets blocked.</p><p>These settings will take effect only after you have built
	and installed a kernel with them set.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95066576"></a>26.5.3. Available rc.conf Options</h3></div></div></div><p>You need the following statements in
	<code class="filename">/etc/rc.conf</code> to activate IPF at boot
	time:</p><pre class="programlisting">ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre><p>If you have a LAN behind this firewall that uses the
	reserved private IP address ranges, then you need to add the
	following to enable <acronym class="acronym">NAT</acronym>
	functionality:</p><pre class="programlisting">gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95069648"></a>26.5.4. IPF</h3></div></div></div><a id="idp95070288" class="indexterm"></a><p>The ipf command is used to load your rules file.  Normally
	you create a file containing your custom rules and use this
	command to replace in mass the currently running firewall
	internal rules:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipf -Fa -f /etc/ipf.rules</code></strong></pre><p><code class="option">-Fa</code> means flush all internal rules
	tables.</p><p><code class="option">-f</code> means this is the file to read for the
	rules to load.</p><p>This gives you the ability to make changes to your custom
	rules file, run the above IPF command, and thus update the
	running firewall with a fresh copy of all the rules without
	having to reboot the system.  This method is very convenient
	for testing new rules as the procedure can be executed as many
	times as needed.</p><p>See the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipf</span>(8)</span></a> manual page for details on the other
	flags available with this command.</p><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipf</span>(8)</span></a> command expects the rules file to be a
	standard text file.  It will not accept a rules file written as
	a script with symbolic substitution.</p><p>There is a way to build IPF rules that utilizes the power
	of script symbolic substitution.  For more information, see
	<a class="xref" href="firewalls-ipf.html#firewalls-ipf-rules-script" title="26.5.9. Building the Rule Script with Symbolic Substitution">Sekcja 26.5.9, "Building the Rule Script with Symbolic
	Substitution"</a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95077328"></a>26.5.5. IPFSTAT</h3></div></div></div><a id="idp95077968" class="indexterm"></a><a id="idp95078608" class="indexterm"></a><p>The default behavior of <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> is to retrieve and
	display the totals of the accumulated statistics gathered as a
	result of applying the user coded rules against packets going
	in and out of the firewall since it was last started, or since
	the last time the accumulators were reset to zero by the
	<code class="command">ipf -Z</code> command.</p><p>See the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> manual page for details.</p><p>The default <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> command output will look
	something like this:</p><pre class="screen">input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 <acronym class="acronym">TCP</acronym> RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 <acronym class="acronym">TCP</acronym> cksum fails(in): 0 (out): 0
 Packet log flags set: (0)</pre><p>When supplied with either <code class="option">-i</code> for inbound
	or <code class="option">-o</code> for outbound, it will retrieve and
	display the appropriate list of filter rules currently
	installed and in use by the kernel.</p><p><code class="command">ipfstat -in</code> displays the inbound
	internal rules table with rule number.</p><p><code class="command">ipfstat -on</code> displays the outbound
	internal rules table with the rule number.</p><p>The output will look something like this:</p><pre class="screen">@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</pre><p><code class="command">ipfstat -ih</code> displays the inbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</p><p><code class="command">ipfstat -oh</code> displays the outbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</p><p>The output will look something like this:</p><pre class="screen">2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</pre><p>One of the most important functions of the
	<code class="command">ipfstat</code> command is the <code class="option">-t</code>
	flag which displays the state table in a way similar to the way
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> shows the FreeBSD running process table.  When your
	firewall is under attack this function gives you the ability to
	identify, drill down to, and see the attacking packets.  The
	optional sub-flags give the ability to select the destination
	or source IP, port, or protocol that you want to monitor in
	real time.  See the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfstat&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipfstat</span>(8)</span></a> manual page for
	details.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95101520"></a>26.5.6. IPMON</h3></div></div></div><a id="idp95102160" class="indexterm"></a><a id="idp95102800" class="indexterm"></a><p>In order for <code class="command">ipmon</code> to work properly, the
	kernel option IPFILTER_LOG must be turned on.  This command has
	two different modes that it can be used in.  Native mode is the
	default mode when you type the command on the command line
	without the <code class="option">-D</code> flag.</p><p>Daemon mode is for when you want to have a continuous
	system log file available so that you can review logging of
	past events.  This is how FreeBSD and IPFILTER are configured to
	work together. FreeBSD has a built in facility to automatically
	rotate system logs.  That is why outputting the log information
	to syslogd is better than the default of outputting to a
	regular file.  In the default <code class="filename">rc.conf</code> file
	you see the ipmon_flags statement uses the <code class="option">-Ds</code>
	flags:</p><pre class="programlisting">ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre><p>The benefits of logging are obvious.  It provides the
	ability to review, after the fact, information such as which
	packets had been dropped, what addresses they came from and
	where they were going.  These all give you a significant edge
	in tracking down attackers.</p><p>Even with the logging facility enabled, IPF will not
	generate any rule logging on its own.  The firewall
	administrator decides what rules in the rule set he wants to
	log and adds the log keyword to those rules.  Normally only
	deny rules are logged.</p><p>It is very customary to include a default deny everything
	rule with the log keyword included as your last rule in the
	rule set.  This way you get to see all the packets that did not
	match any of the rules in the rule set.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95112144"></a>26.5.7. IPMON Logging</h3></div></div></div><p><span class="application">Syslogd</span> uses its own special
	method for segregation of log data.  It uses special groupings
	called <span class="quote">"<span class="quote">facility</span>"</span> and <span class="quote">"<span class="quote">level</span>"</span>.  IPMON
	in <code class="option">-Ds</code> mode uses <code class="literal">security</code>
	as the <span class="quote">"<span class="quote">facility</span>"</span>
	name.  All IPMON logged data goes to <code class="literal">security</code>
	The following levels can be
	used to further segregate the logged data if desired:</p><pre class="screen">LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short</pre><p>To setup IPFILTER to log all data to
	<code class="filename">/var/log/ipfilter.log</code>, you will need to
	create the file.  The following command will do that:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>touch /var/log/ipfilter.log</code></strong></pre><p>The syslog function is controlled by definition statements
	in the <code class="filename">/etc/syslog.conf</code> file.  The
	<code class="filename">syslog.conf</code> file offers considerable
	flexibility in how syslog will deal with system messages issued
	by software applications like IPF.</p><p>Add the following statement to
	<code class="filename">/etc/syslog.conf</code>:</p><pre class="programlisting">security.* /var/log/ipfilter.log</pre><p>Or add the following statement to
        <code class="filename">/etc/syslog.conf</code>.</p><p>The <code class="literal">security.*</code>
	means to write all the logged messages to the coded
	file location.</p><p>To activate the changes to <code class="filename">/etc/syslog.conf
	</code> you can reboot or bump the syslog task into
	re-reading <code class="filename">/etc/syslog.conf</code> by running
	<code class="command">/etc/rc.d/syslogd reload</code></p><p>Do not forget to change
	<code class="filename">/etc/newsyslog.conf</code> to rotate the new log
	you just created above.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95124432"></a>26.5.8. The Format of Logged Messages</h3></div></div></div><p>Messages generated by <code class="command">ipmon</code> consist of
	data fields separated by white space.  Fields common to all
	messages are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The date of packet receipt.</p></li><li class="listitem"><p>The time of packet receipt.  This is in the form
	    HH:MM:SS.F, for hours, minutes, seconds, and fractions of a
	    second (which can be several digits long).</p></li><li class="listitem"><p>The name of the interface the packet was processed on,
	    e.g. <code class="filename">dc0</code>.</p></li><li class="listitem"><p>The group and rule number of the rule, e.g.
	    <code class="literal">@0:17</code>.</p></li></ol></div><p>These can be viewed with <code class="command">ipfstat
	-in</code>.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The action: p for passed, b for blocked, S for a short
	    packet, n did not match any rules, L for a log rule.  The
	    order of precedence in showing flags is: S, p, b, n, L.  A
	    capital P or B means that the packet has been logged due to
	    a global logging setting, not a particular rule.</p></li><li class="listitem"><p>The addresses.  This is actually three fields: the
	    source address and port (separated by a comma), the -&gt;
	    symbol, and the destination address and port.
	    209.53.17.22,80 -&gt; 198.73.220.17,1722.</p></li><li class="listitem"><p><code class="literal">PR</code> followed by the protocol name or
	    number, e.g. PR tcp.</p></li><li class="listitem"><p><code class="literal">len</code> followed by the header length
	    and total length of the packet, e.g. len 20 40.</p></li></ol></div><p>If the packet is a <acronym class="acronym">TCP</acronym> packet, there
	will be an additional field starting with a hyphen followed by
	letters corresponding to any flags that were set.  See the
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipmon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipmon</span>(8)</span></a> manual page for a list of letters and their
	flags.</p><p>If the packet is an ICMP packet, there will be two fields
	at the end, the first always being <span class="quote">"<span class="quote">ICMP</span>"</span>, and the
	next being the ICMP message and sub-message type, separated by
	a slash, e.g. ICMP 3/3 for a port unreachable message.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="firewalls-ipf-rules-script"></a>26.5.9. Building the Rule Script with Symbolic
	Substitution</h3></div></div></div><p>Some experienced IPF users create a file containing the
	rules and code them in a manner compatible with running them as
	a script with symbolic substitution.  The major benefit of
	doing this is that you only have to change the value associated
	with the symbolic name and when the script is run all the rules
	containing the symbolic name will have the value substituted in
	the rules.  Being a script, you can use symbolic substitution
	to code frequently used values and substitute them in multiple
	rules.  You will see this in the following example.</p><p>The script syntax used here is compatible with the sh, csh,
	and tcsh shells.</p><p>Symbolic substitution fields are prefixed with a dollar
	sign: <code class="literal">$</code>.</p><p>Symbolic fields do not have the $ prefix.</p><p>The value to populate the symbolic field must be enclosed
	with double quotes (<code class="literal">"</code>).</p><p>Start your rule file with something like this:</p><pre class="programlisting">############# Start of IPF rules script ########################

oif="dc0"            # name of the outbound interface
odns="192.0.2.11"    # ISP's DNS server IP address
myip="192.0.2.7"     # my static IP address from ISP
ks="keep state"
fks="flags S keep state"

# You can choose between building /etc/ipf.rules file
# from this script or running this script "as is".
#
# Uncomment only one line and comment out another.
#
# 1) This can be used for building /etc/ipf.rules:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) This can be used to run script "as is":
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Allow out access to my ISP's Domain name server.
pass out quick on $oif proto tcp from any to $odns port = 53 $fks
pass out quick on $oif proto udp from any to $odns port = 53 $ks

# Allow out non-secure standard www function
pass out quick on $oif proto tcp from $myip to any port = 80 $fks

# Allow out secure www function https over TLS SSL
pass out quick on $oif proto tcp from $myip to any port = 443 $fks
EOF
################## End of IPF rules script ########################</pre><p>That is all there is to it.  The rules are not important in
	this example; how the symbolic substitution fields are
	populated and used are.  If the above example was in a file
	named <code class="filename">/etc/ipf.rules.script</code>, you could
	reload these rules by entering the following command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sh /etc/ipf.rules.script</code></strong></pre><p>There is one problem with using a rules file with embedded
	symbolics: IPF does not understand symbolic substitution, and
	cannot read such scripts directly.</p><p>This script can be used in one of two ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Uncomment the line that begins with
	    <code class="literal">cat</code>, and comment out the line that
	    begins with <code class="literal">/sbin/ipf</code>.  Place
	    <code class="literal">ipfilter_enable="YES"</code> into
	    <code class="filename">/etc/rc.conf</code> as usual, and run script
	    once after each modification to create or update
	    <code class="filename">/etc/ipf.rules</code>.</p></li><li class="listitem"><p>Disable IPFILTER in system startup scripts by adding
	    <code class="literal">ipfilter_enable="NO"</code> (this is default
	    value) into <code class="filename">/etc/rc.conf</code> file.</p><p>Add a script like the following to your
	    <code class="filename">/usr/local/etc/rc.d/</code> startup
	    directory.  The script should have an obvious name like
	    <code class="filename">ipf.loadrules.sh</code>.  The
	    <code class="filename">.sh</code> extension is mandatory.</p><pre class="programlisting">#!/bin/sh
sh /etc/ipf.rules.script</pre><p>The permissions on this script file must be read,
	    write, execute for owner <code class="systemitem">root</code>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</code></strong></pre></li></ul></div><p>Now, when your system boots, your IPF rules will be
	loaded.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95161424"></a>26.5.10. IPF Rule Sets</h3></div></div></div><p>A rule set is a group of ipf rules coded to pass or block
	packets based on the values contained in the packet.  The
	bi-directional exchange of packets between hosts comprises a
	session conversation.  The firewall rule set processes the
	packet two times, once on its arrival from the public Internet
	host and again as it leaves for its return trip back to the
	public Internet host.  Each TCP/IP service (i.e. telnet, www,
	mail, etc.) is predefined by its protocol, source and
	destination IP address, or the source and destination port
	number.  This is the basic selection criteria used to create
	rules which will pass or block services.</p><a id="idp95162704" class="indexterm"></a><p>IPF was originally written using a rules processing logic
	of <span class="quote">"<span class="quote">the last matching rule wins</span>"</span> and used only
	stateless rules.  Over time IPF has been enhanced to include a
	<span class="quote">"<span class="quote">quick</span>"</span> option and a stateful <span class="quote">"<span class="quote">keep
	  state</span>"</span> option which drastically modernized the rule
	processing logic.</p><p>The instructions contained in this section are based on
	using rules that contain the <span class="quote">"<span class="quote">quick</span>"</span> option and
	the stateful <span class="quote">"<span class="quote">keep state</span>"</span> option.  This is the
	basic framework for coding an inclusive firewall rule
	set.</p><p>An inclusive firewall only allows services matching the
	rules through.  This way you can control what services can
	originate behind the firewall destined for the public Internet
	and also control the services which can originate from the
	public Internet accessing your private network.  Everything
	else is blocked and logged by default design.  Inclusive
	firewalls are much, much securer than exclusive firewall rule
	sets and is the only rule set type covered herein.</p><div xmlns="" class="warning"><h3 class="admontitle">Ostrze¿enie: </h3><p xmlns="http://www.w3.org/1999/xhtml">When working with the firewall rules, be <span class="emphasis"><em>very
	    careful</em></span>.  Some configurations <span class="emphasis"><em>will
	    lock you out</em></span> of the server.  To be on the safe
	  side, you may wish to consider performing the initial
	  firewall configuration from the local console rather than
	  doing it remotely e.g. via
	  <span class="application">ssh</span>.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95198032"></a>26.5.11. Rule Syntax</h3></div></div></div><a id="idp95198672" class="indexterm"></a><p>The rule syntax presented here has been simplified to only
	address the modern stateful rule context and <span class="quote">"<span class="quote">first
	matching rule wins</span>"</span> logic.  For the complete legacy rule
	syntax description see the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ipf</span>(8)</span></a> manual page.</p><p>A <code class="literal">#</code> character is used to mark the start
	of a comment and may appear at the end of a rule line or on its
	own line.  Blank lines are ignored.</p><p>Rules contain keywords.  These keywords have to be coded in
	a specific order from left to right on the line.  Keywords are
	identified in bold type.  Some keywords have sub-options which
	may be keywords themselves and also include more sub-options.
	Each of the headings in the below syntax has a bold section
	header which expands on the content.</p><p><em class="replaceable"><code>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO
	  SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
	  STATEFUL</code></em></p><p><em class="replaceable"><code>ACTION</code></em> = block | pass</p><p><em class="replaceable"><code>IN-OUT</code></em> = in | out</p><p><em class="replaceable"><code>OPTIONS</code></em> = log | quick | on
	  interface-name</p><p><em class="replaceable"><code>SELECTION</code></em> = proto value |
	  source/destination IP | port = number | flags
	  flag-value</p><p><em class="replaceable"><code>PROTO</code></em> = tcp/udp | udp | tcp |
	  icmp</p><p><em class="replaceable"><code>SRC_ADD,DST_ADDR</code></em> = all | from
	  object to object</p><p><em class="replaceable"><code>OBJECT</code></em> = IP address | any</p><p><em class="replaceable"><code>PORT_NUM</code></em> = port number</p><p><em class="replaceable"><code>TCP_FLAG</code></em> = S</p><p><em class="replaceable"><code>STATEFUL</code></em> = keep state</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95214160"></a>26.5.11.1. ACTION</h4></div></div></div><p>The action indicates what to do with the packet if it
	  matches the rest of the filter rule.  Each rule
	  <span class="emphasis"><em>must</em></span> have a action.  The following
	  actions are recognized:</p><p><code class="literal">block</code> indicates that the packet should
	  be dropped if the selection parameters match the
	  packet.</p><p><code class="literal">pass</code> indicates that the packet should
	  exit the firewall if the selection parameters match the
	  packet.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95217104"></a>26.5.11.2. IN-OUT</h4></div></div></div><p>A mandatory requirement is that each filter rule
	  explicitly state which side of the I/O it is to be used on.
	  The next keyword must be either in or out and one or the
	  other has to be coded or the rule will not pass syntax
	  checks.</p><p><code class="literal">in</code> means this rule is being applied
	  against an inbound packet which has just been received on the
	  interface facing the public Internet.</p><p><code class="literal">out</code> means this rule is being applied
	  against an outbound packet destined for the interface facing
	  the public Internet.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95219664"></a>26.5.11.3. OPTIONS</h4></div></div></div><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">These options must be used in the order shown
	  here.</p></div><p><code class="literal">log</code> indicates that the packet header
	  will be written to

	

	  the <code class="filename">ipl</code> log (as described in the
	  LOGGING section below) if the selection parameters match the
	  packet.</p><p><code class="literal">quick</code> indicates that if the selection
	  parameters match the packet, this rule will be the last rule
	  checked, allowing a <span class="quote">"<span class="quote">short-circuit</span>"</span> path to avoid processing
	  any following rules for this packet.  This option is a
	  mandatory requirement for the modernized rules processing
	  logic.</p><p><code class="literal">on</code> indicates the interface name to be
	  incorporated into the selection parameters.  Interface names
	  are as displayed by <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ifconfig&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ifconfig</span>(8)</span></a>.  Using this option, the
	  rule will only match if the packet is going through that
	  interface in the specified direction (in/out).  This option
	  is a mandatory requirement for the modernized rules
	  processing logic.</p><p>When a packet is logged, the headers of the packet are
	  written to the IPL packet logging pseudo-device.
	  Immediately following the log keyword, the following
	  qualifiers may be used (in this order):</p><p><code class="literal">body</code> indicates that the first 128
	  bytes of the packet contents will be logged after the
	  headers.</p><p><code class="literal">first</code> If the <code class="literal">log</code>
	  keyword is being used in conjunction with a <span class="quote">"<span class="quote">keep
	    state</span>"</span> option, it is recommended that this option is
	  also applied so that only the triggering packet is logged and
	  not every packet which thereafter matches the <span class="quote">"<span class="quote">keep
	    state</span>"</span> information.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95240400"></a>26.5.11.4. SELECTION</h4></div></div></div><p>The keywords described in this section are used to
	  describe attributes of the packet to be interrogated when
	  determining whether rules match or not.  There is a
	  keyword subject, and it has sub-option keywords, one of
	  which has to be selected.  The following general-purpose
	  attributes are provided for matching, and must be used in
	  this order:</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95241552"></a>26.5.11.5. PROTO</h4></div></div></div><p><code class="literal">proto</code> is the subject keyword and must
	  be coded along with one of its corresponding keyword
	  sub-option values.  The value allows a specific protocol to
	  be matched against.  This option is a mandatory requirement
	  for the modernized rules processing logic.</p><p><code class="literal">tcp/udp | udp | tcp | icmp</code> or any
	  protocol names found in <code class="filename">/etc/protocols</code>
	  are recognized and may be used.  The special protocol keyword
	  <code class="literal">tcp/udp</code> may be used to match either a
	  <acronym class="acronym">TCP</acronym> or a UDP packet, and has been added as
	  a convenience to save duplication of otherwise identical
	  rules.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95248976"></a>26.5.11.6. SRC_ADDR/DST_ADDR</h4></div></div></div><p>The <code class="literal">all</code> keyword is essentially a
	  synonym for <span class="quote">"<span class="quote">from any to any</span>"</span> with no other
	  match parameters.</p><p><code class="literal">from src to dst</code>: the from and to
	  keywords are used to match against IP addresses.  Rules must
	  specify BOTH source and destination parameters.
	  <code class="literal">any</code> is a special keyword that matches any
	  IP address.  Examples of use: <span class="quote">"<span class="quote">from any to any</span>"</span>
	  or <span class="quote">"<span class="quote">from 0.0.0.0/0 to any</span>"</span> or <span class="quote">"<span class="quote">from any to
	    0.0.0.0/0</span>"</span> or <span class="quote">"<span class="quote">from 0.0.0.0 to any</span>"</span> or
	  <span class="quote">"<span class="quote">from any to 0.0.0.0</span>"</span>.</p><p>IP addresses may be specified as a dotted IP address
	  numeric form/mask-length, or as single dotted IP address
	  numeric form.</p><p>There is no way to match ranges of IP addresses which
	  do not express themselves easily as mask-length.  See this
	  web page for help on writing mask-length: <code class="uri"><a class="uri" href="http://jodies.de/ipcalc" target="_top">http://jodies.de/ipcalc</a></code>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95255376"></a>26.5.11.7. PORT</h4></div></div></div><p>If a port match is included, for either or both of source
	  and destination, then it is only applied to
	  <acronym class="acronym">TCP</acronym> and UDP packets.  When composing port
	  comparisons, either the service name from
	  <code class="filename">/etc/services</code> or an integer port number
	  may be used.  When the port appears as part of the from
	  object, it matches the source port number; when it appears
	  as part of the to object, it matches the destination port
	  number.  The use of the port option with the
	  <code class="literal">to</code> object is a mandatory requirement for
	  the modernized rules processing logic.  Example of use:
	  <span class="quote">"<span class="quote">from any to any port = 80</span>"</span></p><p>Port comparisons may be done in a number of forms, with
	  a number of comparison operators, or port ranges may be
	  specified.</p><p>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" |
	  "eq" | "ne" | "lt" | "gt" | "le" | "ge".</p><p>To specify port ranges, port "&lt;&gt;" |
	  "&gt;&lt;"</p><div xmlns="" class="warning"><h3 class="admontitle">Ostrze¿enie: </h3><p xmlns="http://www.w3.org/1999/xhtml">Following the source and destination matching
	    parameters, the following two parameters are mandatory
	    requirements for the modernized rules processing
	    logic.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95280720"></a>26.5.11.8. <acronym class="acronym">TCP</acronym>_FLAG</h4></div></div></div><p>Flags are only effective for <acronym class="acronym">TCP</acronym>
	  filtering.  The letters represents one of the possible flags
	  that can be interrogated in the <acronym class="acronym">TCP</acronym> packet
	  header.</p><p>The modernized rules processing logic uses the
	  <code class="literal">flags S</code> parameter to identify the tcp
	  session start request.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95283664"></a>26.5.11.9. STATEFUL</h4></div></div></div><p><code class="literal">keep state</code> indicates that on a pass
	  rule, any packets that match the rules selection parameters
	  should activate the stateful filtering facility.</p><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">This option is a mandatory requirement for the
	    modernized rules processing logic.</p></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95290192"></a>26.5.12. Stateful Filtering</h3></div></div></div><a id="idp95290832" class="indexterm"></a><p>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session conversation.  When
	activated, keep-state dynamically generates internal rules for
	each anticipated packet being exchanged during the
	bi-directional session conversation.  It has the interrogation
	abilities to determine if the session conversation between the
	originating sender and the destination are following the valid
	procedure of bi-directional packet exchange.  Any packets that
	do not properly fit the session conversation template are
	automatically rejected as impostors.</p><p>Keep state will also allow ICMP packets related to a
	<acronym class="acronym">TCP</acronym> or UDP session through.  So if you get
	ICMP type 3 code 4 in response to some web surfing allowed out
	by a keep state rule, they will be automatically allowed in.
	Any packet that IPF can be certain is part of an active
	session, even if it is a different protocol, will be let
	in.</p><p>What happens is:</p><p>Packets destined to go out the interface connected to the
	public Internet are first checked against the dynamic state
	table, if the packet matches the next expected packet
	comprising in a active session conversation, then it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table, the remaining packets get
	checked against the outbound rule set.</p><p>Packets coming in to the interface connected to the public
	Internet are first checked against the dynamic state table, if
	the packet matches the next expected packet comprising a
	active session conversation, then it exits the firewall and
	the state of the session conversation flow is updated in the
	dynamic state table, the remaining packets get checked against
	the inbound rule set.</p><p>When the conversation completes it is removed from the
	dynamic state table.</p><p>Stateful filtering allows you to focus on blocking/passing
	new sessions.  If the new session is passed, all its subsequent
	packets will be allowed through automatically and any impostors
	automatically rejected.  If a new session is blocked, none of
	its subsequent packets will be allowed through.  Stateful
	filtering has technically advanced interrogation abilities
	capable of defending against the flood of different attack
	methods currently employed by attackers.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95295440"></a>26.5.13. Inclusive Rule Set Example</h3></div></div></div><p>The following rule set is an example of how to code a very
	secure inclusive type of firewall.  An inclusive firewall only
	allows services matching pass rules through and blocks all
	other by default.  All firewalls have at the minimum two
	interfaces which have to have rules to allow the firewall to
	function.</p><p>All <span class="trademark">UNIX</span>(R) flavored systems including FreeBSD are designed to
	use interface <code class="filename">lo0</code> and IP address
	<code class="systemitem">127.0.0.1</code> for internal
	communication within the operating system.  The firewall rules
	must contain rules to allow free unmolested movement of these
	special internally used packets.</p><p>The interface which faces the public Internet is the one
	where you place your rules to authorize and control access out
	to the public Internet and access requests arriving from the
	public Internet.  This can be your user PPP
	<code class="filename">tun0</code> interface or your NIC that is
	connected to your DSL or cable modem.</p><p>In cases where one or more NICs are cabled to private LANs
	behind the firewall, those interfaces must have a rule coded to
	allow free unmolested movement of packets originating from
	those LAN interfaces.</p><p>The rules should be first organized into three major
	sections: all the free unmolested interfaces, the public
	interface outbound, and the public interface inbound.</p><p>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</p><p>The Outbound section in the following rule set only
	contains 'pass' rules which contain selection values that
	uniquely identify the service that is authorized for public
	Internet access.  All the rules have the 'quick', 'on',
	'proto', 'port', and 'keep state' option coded.  The 'proto
	tcp' rules have the 'flag' option included to identify the
	session start request as the triggering packet to activate the
	stateful facility.</p><p>The Inbound section has all the blocking of undesirable
	packets first, for two different reasons.  The first is that
	these things being blocked may be part of an otherwise valid
	packet which may be allowed in by the later authorized service
	rules.  The second reason is that by having a rule that
	explicitly blocks selected packets that I receive on an
	infrequent basis and that I do not want to see in the log, they
	will not be caught by the last rule in the section which blocks
	and logs all packets which have fallen through the rules.  The
	last rule in the section which blocks and logs all packets is
	how you create the legal evidence needed to prosecute the
	people who are attacking your system.</p><p>Another thing you should take note of, is there is no
	response returned for any of the undesirable stuff, their
	packets just get dropped and vanish.  This way the attacker
	has no knowledge if his packets have reached your system.  The
	less the attackers can learn about your system, the more
	time they must invest before actually doing something bad.
	The inbound 'nmap OS fingerprint' attempts rule I log

	

	the first occurrence because this is something a attacker
	would do.</p><p>Any time you see log messages on a rule with 'log first'.
	You should do an <code class="command">ipfstat -hio</code> command to see
	the number of times the rule has been matched so you know if
	you are being flooded, i.e. under attack.</p><p>When you log packets with port numbers you do not
	recognize, look it up in <code class="filename">/etc/services</code> or
	go to <code class="uri"><a class="uri" href="http://www.securitystats.com/tools/portsearch.php" target="_top">http://www.securitystats.com/tools/portsearch.php</a></code>
	and do a port number lookup to find what the purpose of that
	port number is.</p><p>Check out this link for port numbers used by Trojans <code class="uri"><a class="uri" href="http://www.simovits.com/trojans/trojans.html" target="_top">http://www.simovits.com/trojans/trojans.html</a></code>.</p><p>The following rule set is a complete very secure
	'inclusive' type of firewall rule set that I have used on my
	system.  You can not go wrong using this rule set for your own.
	Just comment out any pass rules for services that you do not
	want to authorize.</p><p>If you see messages in your log that you want to stop
	seeing just add a block rule in the inbound section.</p><p>You have to change the <code class="filename">dc0</code>
	interface name in every rule to the interface name of the Nic
	card that connects your system to the public Internet.  For
	user PPP it would be <code class="filename">tun0</code>.</p><p>Add the following statements to
	<code class="filename">/etc/ipf.rules</code>:</p><pre class="programlisting">#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the
# firewall on the private network
# or from this gateway server destine for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym class="acronym">NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out non-secure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FBSD CVSUP function
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois for LAN PC to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule enforces the block all by default logic.
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Interrogate packets originating from the public Internet
# destine for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it's the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence stops a .denial of service. attack targeted
# at filling up your log file space.
# This rule enforces the block all by default logic.
block in log first quick on dc0 all
################### End of rules file #####################################</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95312848"></a>26.5.14. <acronym class="acronym">NAT</acronym></h3></div></div></div><a id="idp95313616" class="indexterm"></a><a id="idp95314128" class="indexterm"></a><a id="idp95315280" class="indexterm"></a><p><acronym class="acronym">NAT</acronym> stands for Network Address
	Translation.  To those familiar with <span class="trademark">Linux</span>(R), this concept is
	called IP Masquerading; <acronym class="acronym">NAT</acronym> and IP
	Masquerading are the same thing.  One of the many things the
	IPF <acronym class="acronym">NAT</acronym> function enables is the ability to
	have a private Local Area Network (LAN) behind the firewall
	sharing a single ISP assigned IP address on the public
	Internet.</p><p>You may ask why would someone want to do this.  ISPs
	normally assign a dynamic IP address to their non-commercial
	users.  Dynamic means that the IP address can be different each
	time you dial in and log on to your ISP, or for cable and DSL
	modem users when you power off and then power on your modems
	you can get assigned a different IP address.  This IP address
	is how you are known to the public Internet.</p><p>Now lets say you have five PCs at home and each one needs
	Internet access.  You would have to pay your ISP for an
	individual Internet account for each PC and have five phone
	lines.</p><p>With <acronym class="acronym">NAT</acronym> you only need a single account
	with your ISP, then cable your other four PCs to a switch and
	the switch to the NIC in your FreeBSD system which is going to
	service your LAN as a gateway. <acronym class="acronym">NAT</acronym> will
	automatically translate the private LAN IP address for each
	separate PC on the LAN to the single public IP address as it
	exits the firewall bound for the public Internet.  It also does
	the reverse translation for returning packets.</p><p><acronym class="acronym">NAT</acronym> is most often accomplished without
	the approval, or knowledge, of your ISP and in most cases is
	grounds for your ISP terminating your account if found out.
	Commercial users pay a lot more for their Internet connection
	and usually get assigned a block of static IP address which
	never change.  The ISP also expects and consents to their
	Commercial customers using <acronym class="acronym">NAT</acronym> for their
	internal private LANs.</p><p>There is a special range of IP addresses reserved for
	<acronym class="acronym">NAT</acronym>ed private LAN IP address.  According to
	RFC 1918, you can use the following IP ranges for private nets
	which will never be routed directly to the public
	Internet:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /><col /></colgroup><tbody><tr><td>Start IP <code class="systemitem">10.0.0.0</code></td><td>-</td><td>Ending IP <code class="systemitem">10.255.255.255</code></td></tr><tr><td>Start IP <code class="systemitem">172.16.0.0</code></td><td>-</td><td>Ending IP <code class="systemitem">172.31.255.255</code></td></tr><tr><td>Start IP <code class="systemitem">192.168.0.0</code></td><td>-</td><td>Ending IP <code class="systemitem">192.168.255.255</code></td></tr></tbody></table></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95368912"></a>26.5.15. IP<acronym class="acronym">NAT</acronym></h3></div></div></div><a id="idp95369808" class="indexterm"></a><a id="idp95370960" class="indexterm"></a><p><acronym class="acronym">NAT</acronym> rules are loaded by using the
	<code class="command">ipnat</code> command.  Typically the
	<acronym class="acronym">NAT</acronym> rules are stored in
	<code class="filename">/etc/ipnat.rules</code>.  See <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ipnat</span>(1)</span></a> for
	details.</p><p>When changing the <acronym class="acronym">NAT</acronym> rules after
	<acronym class="acronym">NAT</acronym> has been started, make your changes to
	the file containing the NAT rules, then run ipnat command with
	the <code class="option">-CF</code> flags to delete the internal in use
	<acronym class="acronym">NAT</acronym> rules and flush the contents of the
	translation table of all active entries.</p><p>To reload the <acronym class="acronym">NAT</acronym> rules issue a command
	like this:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -CF -f /etc/ipnat.rules</code></strong></pre><p>To display some statistics about your
	<acronym class="acronym">NAT</acronym>, use this command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -s</code></strong></pre><p>To list the <acronym class="acronym">NAT</acronym> table's current
	mappings, use this command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -l</code></strong></pre><p>To turn verbose mode on, and display information relating
	to rule processing and active rules/table entries:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ipnat -v</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95390928"></a>26.5.16. IP<acronym class="acronym">NAT</acronym> Rules</h3></div></div></div><p><acronym class="acronym">NAT</acronym> rules are very flexible and can
	accomplish many different things to fit the needs of commercial
	and home users.</p><p>The rule syntax presented here has been simplified to what
	is most commonly used in a non-commercial environment.  For a
	complete rule syntax description see the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipnat&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ipnat</span>(5)</span></a> manual
	page.</p><p>The syntax for a <acronym class="acronym">NAT</acronym> rule looks
	something like this:</p><pre class="programlisting">map <em class="replaceable"><code>IF</code></em> <em class="replaceable"><code>LAN_IP_RANGE</code></em> -&gt; <em class="replaceable"><code>PUBLIC_ADDRESS</code></em></pre><p>The keyword <code class="literal">map</code> starts the rule.</p><p>Replace <em class="replaceable"><code>IF</code></em> with the external
	interface.</p><p>The <em class="replaceable"><code>LAN_IP_RANGE</code></em> is what your
	internal clients use for IP Addressing, usually this is
	something like <code class="systemitem">192.168.1.0/24</code>.</p><p>The <em class="replaceable"><code>PUBLIC_ADDRESS</code></em> can either
	be the external IP address or the special keyword
	<code class="literal">0/32</code>, which means to use the IP address
	assigned to <em class="replaceable"><code>IF</code></em>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95400656"></a>26.5.17. How <acronym class="acronym">NAT</acronym> works</h3></div></div></div><p>A packet arrives at the firewall from the LAN with a public
	destination.  It passes through the outbound filter rules,
	<acronym class="acronym">NAT</acronym> gets his turn at the packet and applies
	its rules top down, first matching rule wins.
	<acronym class="acronym">NAT</acronym> tests each of its rules against the
	packets interface name and source IP address.  When a packets
	interface name matches a <acronym class="acronym">NAT</acronym> rule then the
	[source IP address, i.e. private LAN IP address] of the packet
	is checked to see if it falls within the IP address range
	specified to the left of the arrow symbol on the
	<acronym class="acronym">NAT</acronym> rule.  On a match the packet has its
	source IP address rewritten with the public IP address
	obtained by the <code class="literal">0/32</code> keyword.
	<acronym class="acronym">NAT</acronym> posts a entry in its internal
	<acronym class="acronym">NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95413456"></a>26.5.18. Enabling IP<acronym class="acronym">NAT</acronym></h3></div></div></div><p>To enable IP<acronym class="acronym">NAT</acronym> add these statements to
	<code class="filename">/etc/rc.conf</code>.</p><p>To enable your machine to route traffic between
	interfaces:</p><pre class="programlisting">gateway_enable="YES"</pre><p>To start IP<acronym class="acronym">NAT</acronym> automatically each
	time:</p><pre class="programlisting">ipnat_enable="YES"</pre><p>To specify where to load the IP<acronym class="acronym">NAT</acronym> rules
	from:</p><pre class="programlisting">ipnat_rules="/etc/ipnat.rules"</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95418704"></a>26.5.19. <acronym class="acronym">NAT</acronym> for a very large LAN</h3></div></div></div><p>For networks that have large numbers of PC's on the LAN or
	networks with more than a single LAN, the process of funneling
	all those private IP addresses into a single public IP address
	becomes a resource problem that may cause problems with the
	same port numbers being used many times across many
	<acronym class="acronym">NAT</acronym>ed LAN PC's, causing collisions.  There
	are two ways to relieve this resource problem.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95420368"></a>26.5.19.1. Assigning Ports to Use</h4></div></div></div><p>A normal NAT rule would look like:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 0/32</pre><p>In the above rule the packet's source port is unchanged
	  as the packet passes through IP<acronym class="acronym">NAT</acronym>.  By
	  adding the portmap keyword you can tell
	  IP<acronym class="acronym">NAT</acronym> to only use source ports in a range.
	  For example the following rule will tell
	  IP<acronym class="acronym">NAT</acronym> to modify the source port to be
	  within that range:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre><p>Additionally we can make things even easier by using the
	  <code class="literal">auto</code> keyword to tell
	  IP<acronym class="acronym">NAT</acronym> to determine by itself which ports
	  are available to use:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95426000"></a>26.5.19.2. Using a pool of public addresses</h4></div></div></div><p>In very large LANs there comes a point where there are just too
	  many LAN addresses to fit into a single public address.  If a block
	  of public IP addresses is available, you can use these addresses as
	  a <span class="quote">"<span class="quote">pool</span>"</span>, and let IP<acronym class="acronym">NAT</acronym> pick one of
	  the public IP addresses as packet-addresses are mapped on their way
	  out.</p><p>For example, instead of mapping all packets through a single
	  public IP address, as in:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 204.134.75.1</pre><p>A range of public IP addresses can be specified either with a
	  netmask:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</pre><p>or using CIDR notation:</p><pre class="programlisting">map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95430480"></a>26.5.20. Port Redirection</h3></div></div></div><p>A very common practice is to have a web server, email
	server, database server and DNS server each segregated to a
	different PC on the LAN.  In this case the traffic from these
	servers still have to be <acronym class="acronym">NAT</acronym>ed, but there
	has to be some way to direct the inbound traffic to the
	correct LAN PCs.  IP<acronym class="acronym">NAT</acronym> has the redirection
	facilities of <acronym class="acronym">NAT</acronym> to solve this problem.
	Lets say you have your web server on LAN address <code class="systemitem">10.0.10.25</code> and your single public IP
	address is <code class="systemitem">20.20.20.5</code> you would
	code the rule like this:</p><pre class="programlisting">rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre><p>or:</p><pre class="programlisting">rdr dc0 0/32 port 80 -&gt; 10.0.10.25 port 80</pre><p>or for a LAN DNS Server on LAN address of <code class="systemitem">10.0.10.33</code> that needs to receive
	  public DNS requests:</p><pre class="programlisting">rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95436240"></a>26.5.21. FTP and <acronym class="acronym">NAT</acronym></h3></div></div></div><p>FTP is a dinosaur left over from the time before the
	Internet as it is known today, when research universities were
	leased lined together and FTP was used to share files among
	research Scientists.  This was a time when data security was
	not a consideration.  Over the years the FTP protocol became
	buried into the backbone of the emerging Internet and its
	username and password being sent in clear text was never
	changed to address new security concerns.  FTP has two flavors,
	it can run in active mode or passive mode.  The difference is
	in how the data channel is acquired.  Passive mode is more
	secure as the data channel is acquired be the ordinal ftp
	session requester.  For a real good explanation of FTP and the
	different modes see <code class="uri"><a class="uri" href="http://www.slacksite.com/other/ftp.html" target="_top">http://www.slacksite.com/other/ftp.html</a></code>.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95438160"></a>26.5.21.1. IP<acronym class="acronym">NAT</acronym> Rules</h4></div></div></div><p>IP<acronym class="acronym">NAT</acronym> has a special built in FTP proxy
	  option which can be specified on the <acronym class="acronym">NAT</acronym>
	  map rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing only the port number
	  really in use for the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to from
	  having large ranges of high order port numbers open.</p><p>This rule will handle all the traffic for the internal
	  LAN:</p><pre class="programlisting">map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</pre><p>This rule handles the FTP traffic from the
	  gateway:</p><pre class="programlisting">map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</pre><p>This rule handles all non-FTP traffic from the internal
	  LAN:</p><pre class="programlisting">map dc0 10.0.10.0/29 -&gt; 0/32</pre><p>The FTP map rule goes before our regular map rule.  All
	  packets are tested against the first rule from the top.
	  Matches on interface name, then private LAN source IP
	  address, and then is it a FTP packet.  If all that matches
	  then the special FTP proxy creates temp filter rules to let
	  the FTP session packets pass in and out, in addition to also
	  <acronym class="acronym">NAT</acronym>ing the FTP packets.  All LAN packets
	  that are not FTP do not match the first rule and fall
	  through to the third rule and are tested, matching on
	  interface and source IP, then are
	  <acronym class="acronym">NAT</acronym>ed.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95443920"></a>26.5.21.2. IP<acronym class="acronym">NAT</acronym> FTP Filter Rules</h4></div></div></div><p>Only one filter rule is needed for FTP if the
	  <acronym class="acronym">NAT</acronym> FTP proxy is used.</p><p>Without the FTP Proxy you will need the following three
	  rules:</p><pre class="programlisting"># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95450832"></a>26.5.21.3. FTP <acronym class="acronym">NAT</acronym> Proxy Bug</h4></div></div></div><p>As of IPFILTER version 3.4.31
	  the FTP proxy works as documented during the FTP session
	  until the session is told to close.  When the close happens
	  packets returning from the remote FTP server are blocked and
	  logged coming in on port 21.  The <acronym class="acronym">NAT</acronym>
	  FTP/proxy appears to remove its temp rules prematurely,
	  before receiving the response from the remote FTP server
	  acknowledging the close.  A problem report was posted to the
	  IPF mailing list.</p><p>The solution is to add a filter rule to get rid of these
	  unwanted log messages or do nothing and ignore FTP inbound
	  error messages in your log.  Most people do not use outbound
	  FTP too often.</p><pre class="programlisting">block in quick on rl0 proto tcp from any to any port = 21</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="firewalls-pf.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="firewalls.html">Pocz±tek rozdzia³u</a></td><td width="40%" align="right"> <a accesskey="n" href="firewalls-ipfw.html">Nastêpny</a></td></tr><tr><td width="40%" align="left" valign="top">26.4. The OpenBSD Packet Filter (PF) and
      <acronym class="acronym">ALTQ</acronym> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre¶ci</a></td><td width="40%" align="right" valign="top"> 26.6. IPFW</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>