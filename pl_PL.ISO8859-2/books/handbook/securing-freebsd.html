<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>14.3. Securing FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Podrêcznik FreeBSD" /><link rel="up" href="security.html" title="Rozdzia³ 14. Security" /><link rel="prev" href="security-intro.html" title="14.2. Introduction" /><link rel="next" href="crypt.html" title="14.4. DES, MD5, and Crypt" /><link rel="copyright" href="legalnotice.html" title="Informacja Prawna" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.3. Securing FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia³ 14. Security</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Nastêpny</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>14.3. Securing FreeBSD</h2></div></div></div><a id="idp85826512" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Command vs. Protocol: </h3><p xmlns="http://www.w3.org/1999/xhtml">Throughout this document, we will use
       <span class="application">bold</span> text to refer to an
       application, and a <code class="command">monospaced</code> font to refer
       to specific commands.  Protocols will use a normal font.  This
       typographical distinction is useful for instances such as ssh,
       since it is
       a protocol as well as command.</p></div><p>The sections that follow will cover the methods of securing your
      FreeBSD system that were mentioned in the <a class="link" href="security-intro.html" title="14.2. Introduction">last section</a> of this chapter.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>14.3.1. Securing the <code class="systemitem">root</code> Account and
	Staff Accounts</h3></div></div></div><a id="idp85831888" class="indexterm"></a><p>First off, do not bother securing staff accounts if you have
	not secured the <code class="systemitem">root</code> account.
	Most systems have a password assigned to the <code class="systemitem">root</code>
	account.  The first thing you do is assume
	that the password is <span class="emphasis"><em>always</em></span> compromised.
	This does not mean that you should remove the password.  The
	password is almost always necessary for console access to the
	machine.  What it does mean is that you should not make it
	possible to use the password outside of the console or possibly
	even with the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> command.  For example, make sure that
	your ptys are specified as being insecure in the
	<code class="filename">/etc/ttys</code> file so that direct
	<code class="systemitem">root</code> logins
	via <code class="command">telnet</code> or <code class="command">rlogin</code> are
	disallowed.  If using other login services such as
        <span class="application">sshd</span>, make sure that direct
	<code class="systemitem">root</code> logins are disabled there as well.
	You can do this by editing
        your <code class="filename">/etc/ssh/sshd_config</code> file, and making
        sure that <code class="literal">PermitRootLogin</code> is set to
        <code class="literal">NO</code>.  Consider every access method -
        services such as FTP often fall through the cracks.
	Direct <code class="systemitem">root</code> logins should only be allowed
	via the system console.</p><a id="idp85839696" class="indexterm"></a><p>Of course, as a sysadmin you have to be able to get to
	<code class="systemitem">root</code>, so we open up a few holes.
	But we make sure these holes require additional password
	verification to operate.  One way to make <code class="systemitem">root</code>
	accessible is to add appropriate staff accounts to the
	<code class="systemitem">wheel</code> group (in
	<code class="filename">/etc/group</code>).  The staff members placed in the
	<code class="systemitem">wheel</code> group are allowed to
	<code class="command">su</code> to <code class="systemitem">root</code>.
	You should never give staff
	members native <code class="systemitem">wheel</code> access by putting them in the
	<code class="systemitem">wheel</code> group in their password entry.  Staff
	accounts should be placed in a <code class="systemitem">staff</code> group, and
	then added to the <code class="systemitem">wheel</code> group via the
	<code class="filename">/etc/group</code> file.  Only those staff members
	who actually need to have <code class="systemitem">root</code> access
	should be placed in the
	<code class="systemitem">wheel</code> group.  It is also possible, when using
	an authentication method such as Kerberos, to use Kerberos'
	<code class="filename">.k5login</code> file in the <code class="systemitem">root</code>
	account to allow a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> to <code class="systemitem">root</code>
	without having to place anyone at all in the
	<code class="systemitem">wheel</code> group.  This may be the better solution
	since the <code class="systemitem">wheel</code> mechanism still allows an
	intruder to break <code class="systemitem">root</code> if the intruder
	has gotten hold of your
	password file and can break into a staff account.  While having
	the <code class="systemitem">wheel</code> mechanism is better than having
	nothing at all, it is not necessarily the safest option.</p><p>An indirect way to secure staff accounts, and ultimately
        <code class="systemitem">root</code> access is to use an alternative
	login access method and
        do what is known as <span class="quote">"<span class="quote">starring</span>"</span> out the encrypted
        password for the staff accounts.  Using the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vipw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">vipw</span>(8)</span></a>
        command, one can replace each instance of an encrypted password
        with a single <span class="quote">"<span class="quote"><code class="literal">*</code></span>"</span> character.
	This command will update the <code class="filename">/etc/master.passwd</code>
	file and user/password database to disable password-authenticated
        logins.</p><p>A staff account entry such as:</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Should be changed to this:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>This change will prevent normal logins from occurring,
        since the encrypted password will never match
        <span class="quote">"<span class="quote"><code class="literal">*</code></span>"</span>.  With this done,
	staff members must use
        another mechanism to authenticate themselves such as
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kerberos&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kerberos</span>(1)</span></a> or <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> using a public/private key
        pair.  When using something like Kerberos, one generally must
        secure the machines which run the Kerberos servers and your
        desktop workstation.  When using a public/private key pair
        with ssh, one must generally secure
        the machine used to login <span class="emphasis"><em>from</em></span> (typically
        one's workstation).  An additional layer of protection can be
        added to the key pair by password protecting the key pair when
        creating it with <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh-keygen</span>(1)</span></a>.  Being able to
        <span class="quote">"<span class="quote">star</span>"</span> out the passwords for staff accounts also
        guarantees that staff members can only login through secure
        access methods that you have set up.  This forces all staff
        members to use secure, encrypted connections for all of their
        sessions, which closes an important hole used by many
        intruders: sniffing the network from an unrelated,
        less secure machine.</p><p>The more indirect security mechanisms also assume that you are
	logging in from a more restrictive server to a less restrictive
	server.  For example, if your main box is running all sorts of
	servers, your workstation should not be running any.  In order for
	your workstation to be reasonably secure you should run as few
	servers as possible, up to and including no servers at all, and
	you should run a password-protected screen blanker.  Of course,
	given physical access to a workstation an attacker can break any
	sort of security you put on it.  This is definitely a problem that
	you should consider, but you should also consider the fact that the
	vast majority of break-ins occur remotely, over a network, from
	people who do not have physical access to your workstation or
	servers.</p><a id="idp85870160" class="indexterm"></a><p>Using something like Kerberos also gives you the ability to
	disable or change the password for a staff account in one place,
	and have it immediately affect all the machines on which the staff
	member may have an account.  If a staff member's account gets
	compromised, the ability to instantly change his password on all
	machines should not be underrated.  With discrete passwords,
	changing a password on N machines can be a mess.  You can also
	impose re-passwording restrictions with Kerberos:  not only can a
	Kerberos ticket be made to timeout after a while, but the Kerberos
	system can require that the user choose a new password after a
	certain period of time (say, once a month).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85871184"></a>14.3.2. Securing Root-run Servers and SUID/SGID Binaries</h3></div></div></div><a id="idp85871824" class="indexterm"></a><a id="idp85872720" class="indexterm"></a><a id="idp85877840" class="indexterm"></a><a id="idp85878736" class="indexterm"></a><a id="idp85879504" class="indexterm"></a><a id="idp85880400" class="indexterm"></a><a id="idp85881296" class="indexterm"></a><a id="idp85882192" class="indexterm"></a><p>The prudent sysadmin only runs the servers he needs to, no
	more, no less.  Be aware that third party servers are often the
	most bug-prone.  For example, running an old version of
	<span class="application">imapd</span> or
	<span class="application">popper</span> is like giving a universal
	<code class="systemitem">root</code> ticket out to the entire world.
	Never run a server that you have not checked out carefully.
	Many servers do not need to be run as <code class="systemitem">root</code>.
	For example, the <span class="application">ntalk</span>,
	<span class="application">comsat</span>, and
	<span class="application">finger</span> daemons can be run in special
	user <em class="firstterm">sandboxes</em>.  A sandbox is not perfect,
	unless you go through a large amount of trouble, but the onion
	approach to security still stands: If someone is able to break
	in through a server running in a sandbox, they still have to
	break out of the sandbox.  The more layers the attacker must
	break through, the lower the likelihood of his success.  Root
	holes have historically been found in virtually every server
	ever run as <code class="systemitem">root</code>, including basic system servers.
	If you are running a machine through which people only login via
	<span class="application">sshd</span> and never login via
	<span class="application">telnetd</span> or
	<span class="application">rshd</span> or
	<span class="application">rlogind</span>, then turn off those
	services!</p><p>FreeBSD now defaults to running
	<span class="application">ntalkd</span>,
	<span class="application">comsat</span>, and
	<span class="application">finger</span> in a sandbox.  Another program
	which may be a candidate for running in a sandbox is <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.
	<code class="filename">/etc/defaults/rc.conf</code> includes the arguments
	necessary to run <span class="application">named</span> in a sandbox in a
	commented-out form.  Depending on whether you are installing a new
	system or upgrading an existing system, the special user accounts
	used by these sandboxes may not be installed.  The prudent
	sysadmin would research and implement sandboxes for servers
	whenever possible.</p><a id="idp85892048" class="indexterm"></a><p>There are a number of other servers that typically do not run
	in sandboxes: <span class="application">sendmail</span>,
	<span class="application">popper</span>,
	<span class="application">imapd</span>, <span class="application">ftpd</span>,
	and others.  There are alternatives to some of these, but
	installing them may require more work than you are willing to
	perform (the convenience factor strikes again).  You may have to
	run these servers as <code class="systemitem">root</code> and rely on other
	mechanisms to detect break-ins that might occur through them.</p><p>The other big potential <code class="systemitem">root</code> holes in a
	system are the
	suid-root and sgid binaries installed on the system.  Most of
	these binaries, such as <span class="application">rlogin</span>, reside
	in <code class="filename">/bin</code>, <code class="filename">/sbin</code>,
	<code class="filename">/usr/bin</code>, or <code class="filename">/usr/sbin</code>.
	While nothing is 100% safe, the system-default suid and sgid
	binaries can be considered reasonably safe.  Still,
	<code class="systemitem">root</code> holes are occasionally found in these
	binaries.  A <code class="systemitem">root</code> hole was found in
	<code class="literal">Xlib</code> in 1998 that made
	<span class="application">xterm</span> (which is typically suid)
	vulnerable.  It is better to be safe than sorry and the prudent
	sysadmin will restrict suid binaries, that only staff should run,
	to a special group that only staff can access, and get rid of
	(<code class="command">chmod 000</code>) any suid binaries that nobody uses.
	A server with no display generally does not need an
	<span class="application">xterm</span> binary.  Sgid binaries can be
	almost as dangerous.  If an intruder can break an sgid-kmem binary,
	the intruder might be able to read <code class="filename">/dev/kmem</code>
	and thus read the encrypted password file, potentially compromising
	any passworded account.  Alternatively an intruder who breaks
	group <code class="literal">kmem</code> can monitor keystrokes sent through
	ptys, including ptys used by users who login through secure
	methods.  An intruder that breaks the <code class="systemitem">tty</code>
	group can write to
	almost any user's tty.  If a user is running a terminal program or
	emulator with a keyboard-simulation feature, the intruder can
	potentially generate a data stream that causes the user's terminal
	to echo a command, which is then run as that user.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>14.3.3. Securing User Accounts</h3></div></div></div><p>User accounts are usually the most difficult to secure.  While
	you can impose Draconian access restrictions on your staff and
	<span class="quote">"<span class="quote">star</span>"</span> out their passwords, you may not be able to
	do so with any general user accounts you might have.  If you do
	have sufficient control, then you may win out and be able to secure
	the user accounts properly.  If not, you simply have to be more
	vigilant in your monitoring of those accounts.  Use of
	ssh and Kerberos for user accounts is
	more problematic, due to the extra administration and technical
	support required, but still a very good solution compared to a
	crypted password file.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85912528"></a>14.3.4. Securing the Password File</h3></div></div></div><p>The only sure fire way is to <code class="literal">*</code> out as many
	passwords as you can and use ssh or
	Kerberos for access to those accounts.  Even though the encrypted
	password file (<code class="filename">/etc/spwd.db</code>) can only be read
	by <code class="systemitem">root</code>, it may be possible for an intruder
	to obtain read access to that file even if the attacker cannot
	obtain root-write access.</p><p>Your security scripts should always check for and report
	changes to the password file (see the <a class="link" href="securing-freebsd.html#security-integrity" title="14.3.6. Checking File Integrity: Binaries, Configuration Files, Etc.">Checking file integrity</a> section
	below).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85915984"></a>14.3.5. Securing the Kernel Core, Raw Devices, and
	File systems</h3></div></div></div><p>If an attacker breaks <code class="systemitem">root</code> he can do
        just about anything, but
	there are certain conveniences.  For example, most modern kernels
	have a packet sniffing device driver built in.  Under FreeBSD it
	is called the <code class="filename">bpf</code> device.  An intruder
	will commonly attempt to run a packet sniffer on a compromised
	machine.  You do not need to give the intruder the capability and
	most systems do not have the need for the
	<code class="filename">bpf</code> device compiled in.</p><a id="idp85918416" class="indexterm"></a><p>But even if you turn off the <code class="filename">bpf</code>
	device, you still have
	<code class="filename">/dev/mem</code> and
	<code class="filename">/dev/kmem</code>
	to worry about.  For that matter, the intruder can still write to
	raw disk devices.  Also, there is another kernel feature called
	the module loader, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.  An enterprising intruder can
	use a KLD module to install his own <code class="filename">bpf</code>
	device, or other sniffing
	device, on a running kernel.  To avoid these problems you have to
	run the kernel at a higher secure level, at least securelevel 1.
	The securelevel can be set with a <code class="command">sysctl</code> on
	the <code class="varname">kern.securelevel</code> variable.  Once you have
	set the securelevel to 1, write access to raw devices will be
	denied and special <code class="command">chflags</code> flags,
	such as <code class="literal">schg</code>,
	will be enforced.  You must also ensure that the
	<code class="literal">schg</code> flag is set on critical startup binaries,
	directories, and script files - everything that gets run up
	to the point where the securelevel is set.  This might be overdoing
	it, and upgrading the system is much more difficult when you
	operate at a higher secure level.  You may compromise and run the
	system at a higher secure level but not set the
	<code class="literal">schg</code> flag for every system file and directory
	under the sun.  Another possibility is to simply mount
	<code class="filename">/</code> and <code class="filename">/usr</code> read-only.
	It should be noted that being too Draconian in what you attempt to
	protect may prevent the all-important detection of an
	intrusion.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>14.3.6. Checking File Integrity: Binaries, Configuration Files,
	Etc.</h3></div></div></div><p>When it comes right down to it, you can only protect your core
	system configuration and control files so much before the
	convenience factor rears its ugly head.  For example, using
	<code class="command">chflags</code> to set the <code class="literal">schg</code> bit
	on most of the files in <code class="filename">/</code> and
	<code class="filename">/usr</code> is probably counterproductive, because
	while it may protect the files, it also closes a detection window.
	The last layer of your security onion is perhaps the most
	important - detection.  The rest of your security is pretty
	much useless (or, worse, presents you with a false sense of
	safety) if you cannot detect potential incursions.  Half the job
	of the onion is to slow down the attacker, rather than stop him, in
	order to give the detection side of the equation a chance to catch
	him in the act.</p><p>The best way to detect an incursion is to look for modified,
	missing, or unexpected files.  The best way to look for modified
	files is from another (often centralized) limited-access system.
	Writing your security scripts on the extra-secure limited-access
	system makes them mostly invisible to potential attackers, and this
	is important.  In order to take maximum advantage you generally
	have to give the limited-access box significant access to the
	other machines in the business, usually either by doing a
	read-only NFS export of the other machines to the limited-access
	box, or by setting up ssh key-pairs to
	allow the limited-access box to ssh to
	the other machines.  Except for its network traffic, NFS is the
	least visible method - allowing you to monitor the
	file systems on each client box virtually undetected.  If your
	limited-access server is connected to the client boxes through a
	switch, the NFS method is often the better choice.  If your
	limited-access server is connected to the client boxes through a
	hub, or through several layers of routing, the NFS method may be
	too insecure (network-wise) and using
	ssh may be the better choice even with
	the audit-trail tracks that ssh
	lays.</p><p>Once you give a limited-access box, at least read access to the
	client systems it is supposed to monitor, you must write scripts
	to do the actual monitoring.  Given an NFS mount, you can write
	scripts out of simple system utilities such as <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> and
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>.  It is best to physically md5 the client-box files
	at least once a day, and to test control files such as those
	found in <code class="filename">/etc</code> and
	<code class="filename">/usr/local/etc</code> even more often.  When
	mismatches are found, relative to the base md5 information the
	limited-access machine knows is valid, it should scream at a
	sysadmin to go check it out.  A good security script will also
	check for inappropriate suid binaries and for new or deleted files
	on system partitions such as <code class="filename">/</code> and
	<code class="filename">/usr</code>.</p><p>When using ssh rather than NFS,
	writing the security script is much more difficult.   You
	essentially have to <code class="command">scp</code> the scripts to the client
	box in order to
	run them, making them visible, and for safety you also need to
	<code class="command">scp</code> the binaries (such as find) that those
	scripts use.  The <span class="application">ssh</span> client on the
	client box may already be compromised.  All in all, using
	ssh may be necessary when running over
	insecure links, but it is also a lot harder to deal with.</p><p>A good security script will also check for changes to user and
	staff members access configuration files:
	<code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
	<code class="filename">.ssh/authorized_keys</code> and so forth...
	files that might fall outside the purview of the
	<code class="literal">MD5</code> check.</p><p>If you have a huge amount of user disk space, it may take too
	long to run through every file on those partitions.  In this case,
	setting mount flags to disallow suid binaries and devices on those
	partitions is a good idea.  The <code class="literal">nodev</code> and
	<code class="literal">nosuid</code> options (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>) are what you
	want to look into.  You should probably scan them anyway, at least
	once a week, since the object of this layer is to detect a break-in
	whether or not the break-in is effective.</p><p>Process accounting (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) is a relatively
	low-overhead feature of the operating system which might help
	as a post-break-in evaluation mechanism.  It is especially
	useful in tracking down how an intruder has actually broken into
	a system, assuming the file is still intact after the break-in
	occurs.</p><p>Finally, security scripts should process the log files, and the
	logs themselves should be generated in as secure a manner as
	possible - remote syslog can be very useful.  An intruder
	tries to cover his tracks, and log files are critical to the
	sysadmin trying to track down the time and method of the initial
	break-in.  One way to keep a permanent record of the log files is
	to run the system console to a serial port and collect the
	information on a continuing basis through a secure machine
	monitoring the consoles.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85947472"></a>14.3.7. Paranoia</h3></div></div></div><p>A little paranoia never hurts.  As a rule, a sysadmin can add
	any number of security features, as long as they do not affect
	convenience, and can add security features that
	<span class="emphasis"><em>do</em></span> affect convenience with some added thought.
	Even more importantly, a security administrator should mix it up a
	bit - if you use recommendations such as those given by this
	document verbatim, you give away your methodologies to the
	prospective attacker who also has access to this document.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85949008"></a>14.3.8. Denial of Service Attacks</h3></div></div></div><a id="idp85949648" class="indexterm"></a><p>This section covers Denial of Service attacks.  A DoS attack
	is typically a packet attack.  While there is not much you can do
	about modern spoofed packet attacks that saturate your network,
	you can generally limit the damage by ensuring that the attacks
	cannot take down your servers.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Limiting server forks.</p></li><li class="listitem"><p>Limiting springboard attacks (ICMP response attacks, ping
	    broadcast, etc.).</p></li><li class="listitem"><p>Kernel Route Cache.</p></li></ol></div><p>A common DoS attack is against a forking server that attempts
	to cause the server to eat processes, file descriptors, and memory,
	until the machine dies.  <span class="application">inetd</span>
	(see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>) has several
	options to limit this sort of attack.  It should be noted that
	while it is possible to prevent a machine from going down, it is
	not generally possible to prevent a service from being disrupted
	by the attack.  Read the <span class="application">inetd</span> manual
	page carefully and pay
	specific attention to the <code class="option">-c</code>, <code class="option">-C</code>,
	and <code class="option">-R</code> options.  Note that spoofed-IP attacks
	will circumvent the <code class="option">-C</code> option to
	<span class="application">inetd</span>, so
	typically a combination of options must be used.  Some standalone
	servers have self-fork-limitation parameters.</p><p><span class="application">Sendmail</span> has its
	<code class="option">-OMaxDaemonChildren</code> option, which tends to work
	much better than trying to use sendmail's load limiting options
	due to the load lag.  You should specify a
	<code class="literal">MaxDaemonChildren</code> parameter, when you start
	<span class="application">sendmail</span>, high enough to handle your
	expected load, but not so high that the computer cannot handle that
	number of <span class="application">sendmails</span> without falling on
	its face.  It is also prudent to run sendmail in queued mode
	(<code class="option">-ODeliveryMode=queued</code>) and to run the daemon
	(<code class="command">sendmail -bd</code>) separate from the queue-runs
	(<code class="command">sendmail -q15m</code>).  If you still want real-time
	delivery you can run the queue at a much lower interval, such as
	<code class="option">-q1m</code>, but be sure to specify a reasonable
	<code class="literal">MaxDaemonChildren</code> option for
	<span class="emphasis"><em>that</em></span> sendmail to prevent cascade failures.</p><p><span class="application">Syslogd</span> can be attacked directly
	and it is strongly recommended that you use the <code class="option">-s</code>
	option whenever possible, and the <code class="option">-a</code> option
	otherwise.</p><p>You should also be fairly careful with connect-back services
	such as <span class="application">TCP Wrapper</span>'s reverse-identd,
	which can be attacked directly.  You generally do not want to use
	the reverse-ident feature of
	<span class="application">TCP Wrapper</span> for this reason.</p><p>It is a very good idea to protect internal services from
	external access by firewalling them off at your border routers.
	The idea here is to prevent saturation attacks from outside your
	LAN, not so much to protect internal services from network-based
	<code class="systemitem">root</code> compromise.
	Always configure an exclusive firewall, i.e.,
	<span class="quote">"<span class="quote">firewall everything <span class="emphasis"><em>except</em></span> ports A, B,
	C, D, and M-Z</span>"</span>.  This way you can firewall off all of your
	low ports except for certain specific services such as
	<span class="application">named</span> (if you are primary for a zone),
	<span class="application">ntalkd</span>,
	<span class="application">sendmail</span>, and other Internet-accessible
	services.  If you try to configure the firewall the other way
	- as an inclusive or permissive firewall, there is a good
	chance that you will forget to <span class="quote">"<span class="quote">close</span>"</span> a couple of
	services, or that you will add a new internal service and forget
	to update the firewall.  You can still open up the high-numbered
	port range on the firewall, to allow permissive-like operation,
	without compromising your low ports.  Also take note that FreeBSD
	allows you to control the range of port numbers used for dynamic
	binding, via the various <code class="varname">net.inet.ip.portrange</code>
	<code class="command">sysctl</code>'s (<code class="command">sysctl -a | fgrep
	portrange</code>), which can also ease the complexity of your
	firewall's configuration.  For example, you might use a normal
	first/last range of 4000 to 5000, and a hiport range of 49152 to
	65535, then block off everything under 4000 in your firewall
	(except for certain specific Internet-accessible ports, of
	course).</p><p>Another common DoS attack is called a springboard attack
	- to attack a server in a manner that causes the server to
	generate responses which overloads the server, the local
	network, or some other machine.  The most common attack of this
	nature is the <span class="emphasis"><em>ICMP ping broadcast attack</em></span>.
	The attacker spoofs ping packets sent to your LAN's broadcast
	address with the source IP address set to the actual machine they
	wish to attack.  If your border routers are not configured to
	stomp on ping's to broadcast addresses, your LAN winds up
	generating sufficient responses to the spoofed source address to
	saturate the victim, especially when the attacker uses the same
	trick on several dozen broadcast addresses over several dozen
	different networks at once.  Broadcast attacks of over a hundred
	and twenty megabits have been measured.  A second common
	springboard attack is against the ICMP error reporting system.
	By constructing packets that generate ICMP error responses, an
	attacker can saturate a server's incoming network and cause the
	server to saturate its outgoing network with ICMP responses.  This
	type of attack can also crash the server by running it out of
	mbuf's, especially if the server cannot drain the ICMP responses
	it generates fast enough.
	Use the <span class="application">sysctl</span>
	variable <code class="literal">net.inet.icmp.icmplim</code> to limit these attacks.
	The last major class of springboard
	attacks is related to certain internal
	<span class="application">inetd</span> services such as the
	udp echo service.  An attacker simply spoofs a UDP packet with the
	source address being server A's echo port, and the destination
	address being server B's echo port, where server A and B are both
	on your LAN.  The two servers then bounce this one packet back and
	forth between each other.  The attacker can overload both servers
	and their LANs simply by injecting a few packets in this manner.
	Similar problems exist with the internal
	<span class="application">chargen</span> port.  A
	competent sysadmin will turn off all of these inetd-internal test
	services.</p><p>Spoofed packet attacks may also be used to overload the kernel
	route cache.  Refer to the <code class="varname">net.inet.ip.rtexpire</code>,
	<code class="varname">rtminexpire</code>, and <code class="varname">rtmaxcache</code>
	<code class="command">sysctl</code> parameters.  A spoofed packet attack
	that uses a random source IP will cause the kernel to generate a
	temporary cached route in the route table, viewable with
	<code class="command">netstat -rna | fgrep W3</code>.  These routes
	typically timeout in 1600 seconds or so.  If the kernel detects
	that the cached route table has gotten too big it will dynamically
	reduce the <code class="varname">rtexpire</code> but will never decrease it
	to less than <code class="varname">rtminexpire</code>.  There are two
	problems:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The kernel does not react quickly enough when a lightly
	    loaded server is suddenly attacked.</p></li><li class="listitem"><p>The <code class="varname">rtminexpire</code> is not low enough for
	    the kernel to survive a sustained attack.</p></li></ol></div><p>If your servers are connected to the Internet via a T3 or
        better, it may be prudent to manually override both
	<code class="varname">rtexpire</code> and <code class="varname">rtminexpire</code>
	via <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  Never set either parameter to zero (unless
	you want to crash the machine).  Setting both
	parameters to 2 seconds should be sufficient to protect the route
	table from attack.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85983184"></a>14.3.9. Access Issues with Kerberos and SSH</h3></div></div></div><a id="idp85983824" class="indexterm"></a><a id="idp85984464" class="indexterm"></a><p>There are a few issues with both Kerberos and
	ssh that need to be addressed if
	you intend to use them.  Kerberos V is an excellent
	authentication protocol, but there are bugs in the kerberized
	<span class="application">telnet</span> and
	<span class="application">rlogin</span> applications that make them
	unsuitable for dealing with binary streams.  Also, by default
	Kerberos does not encrypt a session unless you use the
	<code class="option">-x</code> option.  <span class="application">ssh</span>
	encrypts everything by default.</p><p>ssh works quite well in every
	respect except that it forwards encryption keys by default.  What
	this means is that if you have a secure workstation holding keys
	that give you access to the rest of the system, and you
	ssh to an insecure machine, your keys
	are usable.  The actual keys themselves are not exposed, but
	ssh installs a forwarding port for the
	duration of your login, and if an attacker has broken
	<code class="systemitem">root</code> on the
	insecure machine he can utilize that port to use your keys to gain
	access to any other machine that your keys unlock.</p><p>We recommend that you use ssh in
	combination with Kerberos whenever possible for staff logins.
	<span class="application">ssh</span> can be compiled with Kerberos
	support.  This reduces your reliance on potentially exposed
	ssh keys while at the same time
	protecting passwords via Kerberos.  ssh
	keys should only be used for automated tasks from secure machines
	(something that Kerberos is unsuited to do).  We also recommend that
	you either turn off key-forwarding in the
	ssh configuration, or that you make use
	of the <code class="literal">from=IP/DOMAIN</code> option that
	ssh allows in its
	<code class="filename">authorized_keys</code> file to make the key only
	usable to entities logging in from specific machines.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Pocz±tek rozdzia³u</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Nastêpny</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Introduction </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre¶ci</a></td><td width="40%" align="right" valign="top"> 14.4. DES, MD5, and Crypt</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>