<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>18. fejezet - Témák haladóknak</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="up" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="prev" href="funnies.html" title="17. fejezet - Mókás dolgok a FreeBSD-vel kapcsolatban" /><link rel="next" href="acknowledgments.html" title="19. fejezet - Köszönetnyilvánítás" /><link rel="copyright" href="legalnotice.html" title="Jogi közlemény" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">18. fejezet - Témák haladóknak</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="funnies.html">Vissza</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="acknowledgments.html">Elõre</a></td></tr></table><hr /></div><div xml:lang="hu" class="chapter" lang="hu"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="advanced"></a>18. fejezet - Témák haladóknak</h1></div></div></div><div class="qandaset"><a id="idp79287888"></a><dl><dt>18.1. <a href="advanced.html#idp79288144">Honnan lehet többet megtudni a FreeBSD belsõ
	    felépítésérõl?</a></dt><dt>18.2. <a href="advanced.html#idp79301456">Hogyan lehet bekapcsolódni a FreeBSD
	    fejlesztésébe?</a></dt><dt>18.3. <a href="advanced.html#idp79304272">Mik azok a pillanatkiadások és
	    kiadások?</a></dt><dt>18.4. <a href="advanced.html#idp79317200">Hogyan lehet saját kiadást
	    készíteni?</a></dt><dt>18.5. <a href="advanced.html#idp79319760">A make world
	    parancs miért írja felül a
	    korábban telepített binárisokat?</a></dt><dt>18.6. <a href="advanced.html#idp79328720">Miért nem forgó ("round
	    robin") névfeloldással lehet
	    elérni a CVSup szervereket
	    és így megosztani köztük a
	    terhelést?</a></dt><dt>18.7. <a href="advanced.html#idp79333584">A -CURRENT forrásait
	    korlátozott interneteléréssel is lehet
	    követni?</a></dt><dt>18.8. <a href="advanced.html#idp79337040">Hogyan lehet 1392 KB-os darabokra felosztani az
	    egyes terjesztéseket?</a></dt><dt>18.9. <a href="advanced.html#idp79341392">Hova lehet küldeni a rendszermaghoz írt
	    kiegészítéseket?</a></dt><dt>18.10. <a href="advanced.html#idp79348560">A rendszer hogyan érzékeli és
	    inicializálja a Plug and Play ISA
	    kártyákat?</a></dt><dt>18.11. <a href="advanced.html#idp79365328">Hogyan lehet fõeszközazonosítót
	    rendelni egy általunk fejlesztett
	    meghajtóhoz?</a></dt><dt>18.12. <a href="advanced.html#idp79368400">A könyvtárakra vonatkozóan milyen
	    más kiosztási házirendek léteznek
	    még?</a></dt><dt>18.13. <a href="advanced.html#idp79372112">Hogyan lehet kinyerni a legtöbb
	    információt a rendszermag
	    összeomlásából?</a></dt><dt>18.14. <a href="advanced.html#idp79434960">A dlsym() függvény
	    miért nem mûködik már az ELF
	    állományokra?</a></dt><dt>18.15. <a href="advanced.html#idp79440080">Hogyan növelhetõ vagy csökkenthetõ a
	    rendszermag címtere i386TM
	    architektúrán?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp79288144"></a><a id="learn-advanced"></a><p><strong>18.1.</strong></p></td><td align="left" valign="top"><p>Honnan lehet többet megtudni a FreeBSD belsõ
	    felépítésérõl?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Jelen pillanatban csak egyetlen mû foglalkozik az
	    operációs rendszerek
	    felépítésével a FreeBSD
	    szemszögébõl, név szerint a Marshall
	    Kirk McKusick és George V.  Neville-Neil által
	    írt <span class="quote">"<span class="quote">The Design and Implementation of the
	    FreeBSD Operating System</span>"</span> címû könyv
	    (ISBN 0-201-70245-2), amely a FreeBSD
	    5.<em class="replaceable"><code>X</code></em> változatára
	    koncentrál.</p><p>Emellett a <span class="trademark">UNIX</span>(R) típusú rendszerek
	    használatával kapcsolatos ismeret remekül
	    alkalmazható a FreeBSD esetén is.</p><p>A témához tartozó többi
	    könyvet a kézikönyv <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/bibliography-osinternals.html" target="_top">Az
	      operációs rendszerek belsõ
	      mûködésével</a>
	    foglalkozó irodalomjegyzékben
	    találhatjuk meg.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79301456"></a><a id="how-to-contribute"></a><p><strong>18.2.</strong></p></td><td align="left" valign="top"><p>Hogyan lehet bekapcsolódni a FreeBSD
	    fejlesztésébe?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Pontosabb tanácsokat akkor kapunk, ha elolvassuk
	    a <a class="link" href="../../../../doc/en_US.ISO8859-1/articles/contributing/article.html" target="_top">FreeBSD
	    fejlesztésérõl szóló
	    cikket</a>.  Nagyon is számítunk mindenki
	    segítségére!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79304272"></a><a id="define-snap-release"></a><p><strong>18.3.</strong></p></td><td align="left" valign="top"><p>Mik azok a pillanatkiadások és
	    kiadások?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Jelenleg három aktív és
	    félig aktív ág van a FreeBSD <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top">CVS
	    repositoryjában</a>.  (A korábbi
	    ágakat már csak nagyon ritkán
	    módosítják, ezért is csak
	    három aktív fejlesztési ágon
	    fejlesztenek):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">RELENG_7</code> avagy
		  <span class="emphasis"><em>7-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">RELENG_8</code> avagy
		  <span class="emphasis"><em>8-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">HEAD</code> avagy
		  <span class="emphasis"><em>-CURRENT</em></span> avagy
		  <span class="emphasis"><em>9-CURRENT</em></span></p></li></ul></div><p>A <code class="literal">HEAD</code> nem olyan ág, mint a
	    másik kettõ.  Ez egyszerûen csak
	    <span class="quote">"<span class="quote"><span class="emphasis"><em>a jelenlegi, még el nem
	    ágaztatott fejlesztési
	    irány</em></span></span>"</span> jelentéssel
	    bír, amire pedig sokszor röviden csak
	    <span class="emphasis"><em>-CURRENT</em></span> néven
	    hivatkoznak.</p><p>Jelen pillanatban a <span class="emphasis"><em>-CURRENT</em></span> a
	    9.<em class="replaceable"><code>X</code></em> fejlesztési
	    irányát képviseli; az
	    <code class="literal">6-STABLE</code> ág, a
	    <span class="symbol">RELENG_6</span>, 2005 novemberében, a
	    <code class="literal">7-STABLE</code> ág, a
	    <span class="symbol">RELENG_7</span>, 2008 februárjában,
	    míg a <code class="literal">8-STABLE</code> ág, a
	    <span class="symbol">RELENG_8</span>, 2009 novemberében
	    vált le a <span class="quote">"<span class="quote">-CURRENT</span>"</span>
	    ágból.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79317200"></a><a id="custrel"></a><p><strong>18.4.</strong></p></td><td align="left" valign="top"><p>Hogyan lehet saját kiadást
	    készíteni?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Olvassuk el a <a class="link" href="../../../../doc/en_US.ISO8859-1/articles/releng/article.html" target="_top">kiadások
	      készítésérõl
	      szóló</a> cikket.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79319760"></a><a id="makeworld-clobbers"></a><p><strong>18.5.</strong></p></td><td align="left" valign="top"><p>A <code class="command">make world</code>
	    parancs miért írja felül a
	    korábban telepített binárisokat?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Mert alapvetõen ez lenne a cél: ahogy a neve
	    is sugallja, a rendszer újrafordítása,
	    vagyis a
	    <code class="command">make world</code>
	    parancs feladata a rendszerben található
	    összes bináris
	    újrafordítása, aminek
	    eredményeképpen egy tiszta és
	    összefüggõ környezetet kapunk
	    (ezért is tart ilyen sokáig).</p><p>Ha a <code class="command">make
	    world</code> vagy a <code class="command">make
	    install</code> parancs
	    futtatása elõtt megadjuk a
	    <code class="envar">DESTDIR</code> környezeti
	    változót, akkor a frissen létrehozott
	    binárisok az általa mutatott
	    könyvtárba fognak kerülni pontosan
	    úgy, ahogy az eredeti rendszer.  Az osztott
	    könyvtárak bizonyos
	    módosításai és egyes programok
	    fordítása azonban könnyen térdre
	    kényszerítheti a <code class="command">make
	    world</code>
	    futását.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79328720"></a><a id="cvsup-round-robin"></a><p><strong>18.6.</strong></p></td><td align="left" valign="top"><p>Miért nem forgó (<span class="quote">"<span class="quote">round
	    robin</span>"</span>) névfeloldással lehet
	    elérni a <span class="application">CVSup</span> szervereket
	    és így megosztani köztük a
	    terhelést?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Habár a <span class="application">CVSup</span>
	    tükrözések óránként
	    frissítik magukat a központi
	    <span class="application">CVSup</span> szerverrõl, maga a
	    frissítés azonban bármikor
	    megtörténhet.  Ennek
	    következményeképpen egyes szervereken
	    frissebb kód található, miközben a
	    többin még az egy órával
	    ezelõtti állapot szerepel.  Ha a <code class="systemitem">cvsup.FreeBSD.org</code> forgó
	    névfeloldással mûködne, akkor a
	    felhasználók mindig egy
	    véletlenszerûen választott
	    <span class="application">CVSup</span> szervert kapnának,
	    és ezért a <span class="application">CVSup</span>
	    egymás utáni futtatásakor könnyen
	    elõfordulhatna, hogy a rendszer régebbi
	    forrásait kapjuk vissza.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79333584"></a><a id="ctm"></a><p><strong>18.7.</strong></p></td><td align="left" valign="top"><p>A <span class="emphasis"><em>-CURRENT</em></span> forrásait
	    korlátozott interneteléréssel is lehet
	    követni?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Igen, ezt a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/synching.html#CTM" target="_top">CTM</a>
	    használatával
	    <span class="emphasis"><em>anélkül</em></span> is megtudjuk tenni,
	    hogy le kellene töltenünk az egész
	    forrásfát.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79337040"></a><a id="split-1392k"></a><p><strong>18.8.</strong></p></td><td align="left" valign="top"><p>Hogyan lehet 1392 KB-os darabokra felosztani az
	    egyes terjesztéseket?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az újabb BSD alapú rendszerekben a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=split&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">split</span>(1)</span></a> parancsnak már van egy
	    <code class="option">-b</code> paramétere, amellyel
	    tetszõleges méretûre fel tudunk darabolni
	    állományokat.</p><p>Íme erre egy példa a
	    <code class="filename">/usr/src/release/Makefile</code>
	    állományból:</p><pre class="programlisting">ZIPNSPLIT=              gzip --no-name -9 -c | split -b 1392k -</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79341392"></a><a id="submitting-kernel-extensions"></a><p><strong>18.9.</strong></p></td><td align="left" valign="top"><p>Hova lehet küldeni a rendszermaghoz írt
	    kiegészítéseket?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Erre vonatkozóan vessünk egy
	    pillantást a <a class="link" href="../../../../doc/en_US.ISO8859-1/articles/contributing/article.html" target="_top">FreeBSD továbbfejlesztésérõl szóló</a>
	    cikkre.</p><p>Köszönjük, hogy gondolt
	    ránk!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79348560"></a><a id="pnp-initialize"></a><p><strong>18.10.</strong></p></td><td align="left" valign="top"><p>A rendszer hogyan érzékeli és
	    inicializálja a Plug and Play ISA
	    kártyákat?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Frank Durda IV
	    (<code class="email">&lt;<a xmlns="" class="email" href="mailto:uhclem@nemesis.lonestar.org">uhclem@nemesis.lonestar.org</a>&gt;</code>)
	    válasza:</p><p>Dióhéjban úgy tudnám ezt
	    elmagyarázni, hogy van néhány I/O port,
	    amelyet lekérdezve a PnP kártya képes
	    válaszolni, hogy elérhetõ-e.
	    Ezért a PnP eszközök keresése azzal
	    kezdõdik, hogy a rendszer felteszi a
	    kérdést, van-e PnP kártya a
	    számítógépben.  Erre
	    aztán a különbözõ
	    kártyák a típusuk
	    megjelölésével válaszolnak,
	    amelyet ugyanezen az I/O porton kell visszaolvasni,
	    így ha már legalább egy bitet
	    beállít valaki, akkor folytatható a
	    keresés.  Ezután a keresést
	    végzõ kódrész letiltja az
	    <code class="literal">X</code> alatti (a <span class="trademark">Microsoft</span>(R) és az
	    <span class="trademark">Intel</span>(R) által kiosztott) azonosítóval
	    rendelkezõ kártyákat, majd ismét
	    megnézi, hogy valaki továbbra is
	    válaszol-e.  Amennyiben a válasz
	    <code class="literal">0</code>, az arra utal, hogy már nincs
	    aktív kártya az <code class="literal">X</code>
	    azonosító felett.  Ezt követõen a
	    rendszer megpróbálkozik az
	    <code class="literal">X</code> alatti azonosítók
	    lekérdezésével.  Végül
	    folytatja az <code class="literal">X</code> alatti keresést az
	    <code class="literal">X -(korlát / 4)</code>
	    feletti azonosítók letiltásával,
	    majd megismétli az iménti
	    kérdést.  Ezzel a félig-meddig
	    bináris keresési módszerrel
	    aztán képes 2<sup>64</sup>
	    lépésnél jóval kevesebbõl
	    felderíteni a rendszerünkben
	    megtalálható PnP
	    kártyákat.</p><p>Az azonosítók két 32 bit
	    hosszúságú mezõbõl
	    (ezért írtunk az elõbb
	    2<sup>64</sup> lépést)
	    és egy 8 bites
	    ellenõrzõösszegbõl állnak.  Az
	    elsõ 32 bit a gyártót
	    azonosítja.  Ugyan soha nem vallják be, de
	    úgy tûnik, hogy még ugyanannak a
	    gyártónak is lehetnek eltérõ
	    gyártóazonosítóval
	    rendelkezõ kártyái.  A
	    gyártók számára fenntartott
	    32 bites mezõ ezért valamennyire
	    túlzás.</p><p>A második 32 bit lehet a kártya
	    sorozatszáma vagy bárki más, amely
	    alapján egyértelmûen
	    beazonosítható.  A gyártó
	    ugyanazzal a 32 bites értékkel nem
	    gyárthat egy másik kártyát, csak
	    abban az esetben, ha a másik 32 bit is
	    eltér.  Ennek köszönhetõen egy
	    gépen belül még az azonos
	    típusú kártyák is el fognak
	    térni 64 biten.</p><p>Az iménti 32 bites csoportok nem lehetnek
	    teljesen nullák, ezért lehetséges, hogy a
	    bináris keresés során a
	    válaszban legalább egy bit mindig aktív
	    lesz.</p><p>Miután a rendszer sikeresen beazonosította
	    a rendelkezésre álló
	    kártyákat, egyenként újra
	    elindítja ezeket (ugyanazon az I/O porton
	    keresztül), és megpróbálja
	    kitalálni, hogy az adott eszközöknek milyen
	    erõforrásokra van szüksége, milyen
	    megszakítást akarnak használni stb.  Az
	    összes kártyától lekérdezi
	    ezeket az információkat.</p><p>Az így megszerzett információkat
	    aztán még kiegészíti a
	    merevlemezen vagy az MLB BIOS-ban található
	    ECU állományok tartalmával.  Az ECU
	    és az MLB BIOS PnP támogatása
	    általában viszont nem valódi, és
	    az ilyen eszközök igazából nem is
	    állítanak be semmit maguktól.  A BIOS
	    és az ECU átvizsgálása azonban
	    segít a felderítést végzõ
	    rutinnak értesíteni a tényleges PnP
	    eszközöket, hogy ne foglaljanak el olyan
	    erõforrásokat, amelyeket a rendszer nem tud
	    áthelyezni.</p><p>Ezután a PnP eszközöket a kód
	    még egyszer végigjárja és
	    átadja nekik a
	    mûködésükhöz
	    szükséges I/O, DMA, IRQ és
	    memóracímek hozzárendeléseit.
	    Az eszközök ekkor a megadott helyeken
	    elérhetõvé válnak és
	    úgy is maradnak a rendszer következõ
	    indításáig, de igazából
	    semmi sem rögzíti ezeket.</p><p>Talán túlságosan is
	    egyszerûsítettem a fentieket, de szerintem
	    már ennyi is elegendõ az alapok
	    megértéséhez.</p><p>A <span class="trademark">Microsoft</span>(R) néhány elsõdleges
	    nyomtatási állapotot jelzõ portot
	    átrakott PnP-re, azzal a címszóval,
	    hogy egyik kártya sem kódolta át ezeket
	    a címeket az ellenkezõ I/O ciklusok
	    számára.  Találtam is egy eredeti IBM
	    nyomtatókártyát, amely valóban
	    át tudta írni az állapotjelzõ
	    portot a PnP kezdeti változataiban, de arra a
	    <span class="trademark">Microsoft</span>(R) csak annyit mondott, hogy
	    <span class="quote">"<span class="quote">fogós</span>"</span>.  Ezért a
	    nyomtatási állapotot jelzõ portot a
	    címek beállítására
	    használja, illetve még a
	    <code class="literal">0x800</code>-as portot és egy harmadik
	    I/O portot valahol a <code class="literal">0x200</code> és a
	    <code class="literal">0x3ff</code>
	    környékén.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79365328"></a><a id="major-numbers"></a><p><strong>18.11.</strong></p></td><td align="left" valign="top"><p>Hogyan lehet fõeszközazonosítót
	    rendelni egy általunk fejlesztett
	    meghajtóhoz?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>2003 februárja óta a FreeBSD képes
	    dinamikusan és önmûködõen
	    futás közben lefoglalni
	    fõeszközazonosítókat a
	    meghajtóknak (lásd <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devfs&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">devfs</span>(5)</span></a>),
	    ezért erre tulajdonképpen már nincs
	    szükség.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79368400"></a><a id="alternate-directory-layout"></a><p><strong>18.12.</strong></p></td><td align="left" valign="top"><p>A könyvtárakra vonatkozóan milyen
	    más kiosztási házirendek léteznek
	    még?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A könyvtárak más fajta
	    kiosztására vonatkozóan annyit tudok
	    válaszolni, hogy a jelenleg is alkalmazott
	    sémát az 1983-ban megalkotott változata
	    óta változatlanul használjuk.
	    Eredetileg a gyors állományrendszerhez
	    készítettem, de soha nem ragaszkodtam
	    hozzá.  Remekül megoldja a cilindercsoportok
	    betelésének problémáját,
	    azonban sokan megjegyezték már, hogy a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> esetén gyengén mûködik.
	    A legtöbb állományrendszert
	    mélységi bejárással
	    hozzák létre, így a
	    könyvtárak szétszóródnak a
	    cilindercsoportok közt és ezzel a
	    késõbbi mélységi keresések
	    számára a lehetõ legrosszabb helyzetet
	    alakítják ki.  Ha valaki például
	    tudja elõre a létrehozni kívánt
	    könyvtárak számát, akkor ezt
	    úgy lehet megoldani, ha a mûvelet során
	    <code class="literal">(összes / cilindercsoportok)</code>
	    mennyiségû könyvtárat hozunk
	    létre az egyes cilindercsoportokban.  Ennek
	    meghatározására
	    nyilvánvalóan lehet adni valamilyen
	    heurisztikát.  Már egy kisebb elõre
	    rögzített szám, mint
	    például a 10 kiválasztása is
	    legalább egy nagyságrendnyi javulást
	    jelent.  Ha szeretnénk
	    megkülönböztetni az
	    állományrendszerek
	    visszaállítását a
	    hagyományos mûködéstõl (amire a
	    jelenlegi algoritmus sokkal érzékenyebb),
	    akkor érdemes tizes csoportokba összefogni a
	    könyvtárakat, feltéve, hogy
	    10 másodpercen belül hoztuk létre
	    ezeket.  Mindenesetre elmondható, hogy ezzel
	    nyugodtan lehet kísérletezni.</p><p>Kirk McKusick, 1998 szeptembere</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79372112"></a><a id="kernel-panic-troubleshooting"></a><p><strong>18.13.</strong></p></td><td align="left" valign="top"><p>Hogyan lehet kinyerni a legtöbb
	    információt a rendszermag
	    összeomlásából?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Általában így néz ki a
	    rendszermag összeomlása:</p><pre class="programlisting">Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault</pre><p>Amikor egy ilyen üzenetet látunk, akkor nem
	    elegendõ újra elõcsalni a hibát
	    és beküldeni.  Az
	    utasításszámláló
	    (<span class="quote">"<span class="quote">instruction pointer</span>"</span>) értéke
	    ugyan nagyon fontos, de sajnos konfigurációk
	    szerint eltérhet.  Más szóval
	    úgy fogalmazhatnék, hogy ennek az
	    értéke a használatban levõ
	    rendszermag értékétõl
	    függõen változhat.  Ha a
	    <code class="filename">GENERIC</code> rendszermagot használjuk
	    valamelyik kiadásból, akkor viszont már
	    elképzelhetõ, hogy valaki más is le tudja
	    nyomozni a hibát okozó függvényt.
	    Ha viszont egy saját
	    beállításokkal rendelkezõ
	    rendszermagot használunk, akkor egyedül csak
	    <span class="emphasis"><em>mi</em></span> vagyunk képesek megmondani a
	    hiba pontos helyét.</p><p>Ezért a javaslatom a következõ:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Jegyezzük le az
		  utasításszámláló
		  értékét.  A
		  <code class="literal">0x8:</code> rész ebben az esetben
		  annyira nem fontos, egyedül csak a
		  <code class="literal">0xf0xxxxxx</code> részre van
		  szükségünk.</p></li><li class="step"><p>A rendszer újraindításakor
		  írjuk be a következõt:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /a.hibát.okozó.rendszermag | grep f0xxxxxx</code></strong></pre><p>ahol az <code class="literal">f0xxxxxx</code> az
		  utasításszámláló
		  értéke.  Könnyen elõfordulhat,
		  hogy ilyenkor még nem találunk
		  egyezést, mivel a rendszermag
		  szimbólumtáblájában csak
		  az egyes függvények belépési
		  pontjai találhatóak, és ha az
		  utasításszámláló
		  általában valamelyikük
		  belsejébe mutat, nem az elejükre.  Ha
		  tehát nem még látunk semmit,
		  akkor egyszerûen hagyjuk el az utolsó
		  számjegyet és
		  próbálkozzunk így:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /a.hibát.okozó.rendszermag | grep f0xxxxx</code></strong></pre><p>Ha még ez sem hoz eredményt, akkor
		  vágjunk le a végérõl egy
		  újabb számjegyet.  Egészen addig
		  csináljuk, amíg nem kapunk valami
		  értékelhetõ eredményt.
		  Ilyennek tekintjük például azokat a
		  függvényeket, amelyek a hibát
		  okozhatták.  Ez ugyan egy nem annyira pontos
		  felderítési eszköz, viszont
		  még ez is jobb a semminél.</p></li></ol></div><p>A legjobb viszont mégis az, amikor sikerül
	    lementeni a hiba bekövetkezésekor a memória
	    tartalmát, majd a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a>
	    használatával elõbányászni
	    belõle egy hívási láncot.</p><p>Ehhez többnyire a következõ
	    módszer javasolt:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>A rendszermag konfigurációs
		állományába
		(<code class="filename">/usr/src/sys/arch/conf/RENDSZERMAGKONFIG</code>)
		vegyük fel a következõ sort:</p><pre class="programlisting">makeoptions     DEBUG=-g          # A rendszermag fordítása gdb(1) szimbólumokkal</pre></li><li class="step"><p>Lépjünk be a <code class="filename">/usr/src</code>
		könyvtárba:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src</code></strong></pre></li><li class="step"><p>Fordítsuk le a rendszermagot:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>make buildkernel KERNCONF=RENDSZERMAGKONFIG</code></strong></pre></li><li class="step"><p>Várjuk meg, amíg a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a>
		befejezi a fordítást.</p></li><li class="step"><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>make installkernel KERNCONF=RENDSZERMAGKONFIG</code></strong></pre></li><li class="step"><p>Indítsuk újra a gépet.</p></li></ol></div><div xmlns="" class="note"><h3 class="admontitle">Megjegyzés: </h3><p xmlns="http://www.w3.org/1999/xhtml">A <code class="varname">KERNCONF</code> használata
	      nélkül a <code class="filename">GENERIC</code>
	      rendszermag fordul és
	      telepítõdik.</p></div><p>A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> programnak a folyamat
	  végeredményeként két rendszermagot
	    kell készítenie: a
	    <code class="filename">/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel</code>
	    és a
	    <code class="filename">/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel.debug</code>.
	    Ezek közül a <code class="filename">kernel</code>
	    <code class="filename">/boot/kernel/kernel</code> néven
	    mentõdik el, miközben a
	    <code class="filename">kernel.debug</code> használható
	    nyomonkövetésre a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a>
	    programmal.</p><p>A rendszer csak akkor fogja elmenteni
	    összeomláskor a memória tartalmát,
	    ha az <code class="filename">/etc/rc.conf</code>
	    állományban beállítjuk a
	    <code class="varname">dumpdev</code> értékét a
	    lapozóállományt tároló
	    partícióra (vagy az <code class="literal">AUTO</code>
	    értékre).  Ennek hatására az
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> szkriptek a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> paranccsal
	    képesek engedélyezni a memória
	    lementését.  A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a>
	    természetesen manuálisan is
	    elindítható.  Az összeomlást
	    követõen a memória lementett
	    tartalmához a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> programmal
	    férhetünk hozzá.  Amikor viszont az
	    <code class="filename">/etc/rc.conf</code> állományban
	    megadjuk a <code class="varname">dumpdev</code>
	    értékét, az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> szkriptek
	    maguktól lefuttatják a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
	    parancsot és átrakják a mentést
	    a <code class="filename">/var/crash</code>
	    könyvtárba.</p><div xmlns="" class="note"><h3 class="admontitle">Megjegyzés: </h3><p xmlns="http://www.w3.org/1999/xhtml">A FreeBSD által létrehozott
		memóriamentések mérete
		általában a
		számítógépünkben
		levõ fizikai memória
		mennyiségével egyezik meg.  Tehát
		ha 512 MB RAM van a gépünkben, akkor
		egy 512 MB méretû mentést fogunk
		kapni.  Ezért gondoskodjunk róla, hogy a
		<code class="filename">/var/crash</code> könyvtárban
		mindig legyen elegendõ hely az
		állomány tárolásához.
		A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> kézzel is lefuttathazó,
		és ilyenkor a memóriát akár
		egy másik könyvtárba is
		menthetjük.  A mentés méretét
		<code class="literal">options
		MAXMEM=N</code>
		beállítással is
		korlátozhatjuk, ahol az
		<em class="replaceable"><code>N</code></em> értéke a
		rendszermag által használható
		memória mérete KB-okban.
		Például, ha 1 GB RAM van a
		gépünkben, de a rendszermag által
		használható memóriát
		lekorlátozzuk 128 MB-ra, akkor a
		mentés mérete sem 1 GB lesz, hanem
		csak 128 MB.</p></div><p>Ahogy sikerült hozzájutnunk a
	    memóriamentéshez, azonnal is
	    kérhetünk a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a>
	    használatával egy hívási
	    láncot belõle:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>kgdb /usr/obj/usr/sys/RENDSZERMAGKONFIG/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(kgdb)</code> <strong class="userinput"><code>backtrace</code></strong></pre><p>Elõfordulhat, hogy ilyenkor több oldalnyi
	    információ özönlik hirtelen a
	    képernyõre, ezért javasolt ezeket
	    lementeni a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> programmal.  A
	    nyomkövetési szimbólumokat is
	    tartalmazó rendszermag esetén még
	    akár azt a sort is megkapjuk a rendszermagon
	    belül, ahol a hiba történt.  A
	    hívási láncot általában
	    alulról felfelé kell olvasni, és
	    ebbõl deríthetõ, hogy pontosan milyen
	    események is vezettek az összeomláshoz.
	    A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> használatával még a
	    különbözõ változók
	    és struktúrák értékeit is
	    meg tudjuk vizsgálni, így még
	    többet megtudhatunk a rendszer
	    állapotáról az összeomlás
	    pillanatában.</p><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml">Ha az iméntiek mentén nagyon
	      fellelkesültünk volna és van egy
	      másik
	      számítógépünk is, akkor a
	      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> akár távoli
	      nyomkövetésre is
	      beállítható, aminek
	      köszönhetõen a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a>
	      használatával az egyik rendszeren meg tudjuk
	      állítani a másikon futó
	      rendszermagot, ellenõrizhetjük a
	      viselkedését, akárcsak
	      bármelyik más felhasználói
	      program esetében.</p></div><p>Ha netalán engedélyeztük volna a
	    <code class="literal">DDB</code> beállítást,
	    és a rendszermag beleáll a
	    nyomkövetõbe, akkor a rendszert mi magunk is
	    össze tudjuk omlasztani (és így a
	    memóriát elmenteni) a <code class="literal">ddb</code>
	    parancssorában a <code class="literal">panic</code> parancs
	    kiadásával.  Ilyenkor a nyomkövetõ
	    általában még egyszer megáll az
	    összeomláskor.  Ekkor a
	    <code class="literal">continue</code> paranccsal fejeztethetjük
	    be a memória lementését.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79434960"></a><a id="dlsym-failure"></a><p><strong>18.14.</strong></p></td><td align="left" valign="top"><p>A <code class="function">dlsym()</code> függvény
	    miért nem mûködik már az ELF
	    állományokra?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az ELF állományokhoz tartozó
	    segédprogramok alapértelmezés szerint nem
	    teszik láthatóvá a dinamikus linker
	    számára a végrehajtható
	    állományban definiált
	    szimbólumokat.  Ennek eredményeképpen a
	    <code class="function">dlsym()</code> a <code class="function">dlopen(NULL,
	    flags)</code> függvénytõl kapott
	    információk alapján nem találja
	    meg a keresett szimbólumokat.</p><p>Ha szükségünk lenne ilyen
	    keresésekre a <code class="function">dlsym()</code>
	    használata során a program
	    végrehajtható állományán
	    belül, akkor az adott programot a
	    <code class="option">--export-dynamic</code> opció
	    megadásával kell linkelni (lásd
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79440080"></a><a id="change-kernel-address-space"></a><p><strong>18.15.</strong></p></td><td align="left" valign="top"><p>Hogyan növelhetõ vagy csökkenthetõ a
	    rendszermag címtere <span class="trademark">i386</span>TM
	    architektúrán?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az <span class="trademark">i386</span>TM platformon a rendszermag címtere
	    alapértelmezés szerint 1 GB
	    (<acronym class="acronym">PAE</acronym> esetén 2 GB).  Ha
	    komolyabb hálózati forgalmat
	    bonyolító szerverünk van
	    (például egy nagyobb FTP vagy HTTP szerver)
	    vagy rendszerükön használni akarjuk a ZFS
	    állományrendszert, akkor könnyen
	    kifuthatunk a címtérbõl.</p><p>A címtér méretének
	    megváltoztatásához vegyük fel a
	    következõ sort a rendszermag
	    konfigurációs
	    állományába, majd fordítsuk
	    újra a rendszermagot:</p><pre class="programlisting">options KVA_PAGES=<em class="replaceable"><code>N</code></em></pre><p>Az <em class="replaceable"><code>N</code></em> megfelelõ
	    értékének
	    megállapításához osszuk el a
	    beállítani kívánt
	    címtér (MB-okban megadott)
	    méretét néggyel.  (Tehát
	    például 2 GB esetén ez
	    <code class="literal">512</code> lesz.)</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="funnies.html">Vissza</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="acknowledgments.html">Elõre</a></td></tr><tr><td width="40%" align="left" valign="top">17. fejezet - Mókás dolgok a FreeBSD-vel kapcsolatban </td><td width="20%" align="center"><a accesskey="h" href="index.html">Fõoldal</a></td><td width="40%" align="right" valign="top"> 19. fejezet - Köszönetnyilvánítás</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ha kérdése van a FreeBSD-vel kapcsolatban, a
    következõ címre írhat (angolul):
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Ha ezzel a dokumentummal kapcsolatban van kérdése, kérjük erre a címre írjon:
    &lt;<a href="mailto:gabor@FreeBSD.org">gabor@FreeBSD.org</a>&gt;.</small></p></body></html>