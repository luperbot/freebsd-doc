<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>14.3. A FreeBSD védelme</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD kézikönyv" /><link rel="up" href="security.html" title="14. fejezet - Biztonság" /><link rel="prev" href="security-intro.html" title="14.2. Bevezetés" /><link rel="next" href="crypt.html" title="14.4. DES, Blowfish, MD5 és a Crypt" /><link rel="copyright" href="legalnotice.html" title="Jogi közlemény" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.3. A FreeBSD védelme</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Vissza</a> </td><th width="60%" align="center">14. fejezet - Biztonság</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Elõre</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>14.3. A FreeBSD védelme</h2></div></div></div><a id="idp86691920" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Parancs kontra protokoll: </h3><p xmlns="http://www.w3.org/1999/xhtml">A dokumentumban a
	<span class="application">félkövéren</span> fogjuk
	szedni az alkalmazásokat, és
	<code class="command">egyenszélességû</code>
	betûkkel pedig az adott parancsokra hivatkozunk.  A
	protokollokat nem különböztetjük meg.  Ez a
	tipográfiai elkülönítés hasznos
	például az ssh egyes vonatkozásainak
	esetén, mivel ez egyben egy protokoll és egy
	parancs is.</p></div><p>A most következõ szakaszok a FreeBSD
      védelmének azon módszereit ismertetik,
      amelyekrõl a fejezet <a class="link" href="security-intro.html" title="14.2. Bevezetés">elõzõ szakaszában</a>
      már írtunk.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>14.3.1. A rendszergazda és a személyzet
	hozzáférésének
	védelme</h3></div></div></div><a id="idp86705104" class="indexterm"></a><p>Elõször is: ne törjük magunkat a
	személyzeti fiókok biztonságossá
	tételével, ha még a rendszergazda
	hozzáférését sem tettük
	eléggé biztonságossá.  A
	legtöbb rendszerben a <code class="systemitem">root</code>
	hozzáféréshez tartozik egy jelszó.
	Elsõként fel kell tennünk, hogy ez a
	jelszó <span class="emphasis"><em>mindig</em></span> megszerezhetõ.
	Ez természetesen nem arra utal, hogy el kellene
	távolítanunk.  A jelszó szinte mindig
	szükséges a számítógép
	konzolon keresztüli eléréséhez.
	Valójában arra szeretnénk
	rávilágítani, hogy a konzolon
	kívül sehol máshol ne lehessen
	használni ezt a jelszót, még a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a>
	paranccsal sem.  Például gondoskodjunk
	róla, hogy az <code class="filename">/etc/ttys</code>
	állományban megadott pszeudó
	terminálokat <span class="quote">"<span class="quote">insecure</span>"</span> (nem
	biztonságos) típusúnak
	állítottuk be, és így a
	<code class="command">telnet</code> vagy az <code class="command">rlogin</code>
	parancsokon keresztül nem lehet rendszergazdaként
	bejelentkezni.  Ha más szolgáltatáson
	keresztül jelentkezünk be, például az
	<span class="application">sshd</span>
	segítségével, akkor ebben az esetben is
	gondoskodjunk róla, hogy letiltottuk a közvetlen
	rendszergazdai bejelentkezés
	lehetõségét.  Ezt úgy tudjuk megtenni,
	ha megnyitjuk az <code class="filename">/etc/ssh/sshd_config</code>
	állományt és a
	<code class="literal">PermitRootLogin</code> paramétert
	átállítjuk a <code class="literal">no</code>
	értékre.  Vegyünk számba minden
	lehetséges hozzáférési módot
	- az FTP és a hozzá hasonló
	módok gyakran átszivárognak a
	repedéseken.  A rendszergazdának csak a
	rendszerkonzolon keresztül szabad tudnia
	bejelentkeznie.</p><a id="idp86719440" class="indexterm"></a><p>Természetesen egy rendszergazdának valahogy el
	kell érnie a <code class="systemitem">root</code>
	hozzáférést, ezért ezzel felnyitunk
	néhány biztonsági rést.  De
	gondoskodjunk róla, hogy ezek a rések
	további jelszavakat igényelnek a
	mûködésükhöz.  A
	<code class="systemitem">root</code> hozzáférés
	eléréséhez érdemes felvenni
	tetszõleges személyzeti (staff)
	hozzáféréseket a
	<code class="systemitem">wheel</code> csoportba (az
	<code class="filename">/etc/group</code> állományban).  Ha
	a személyzet tagjait a <code class="systemitem">wheel</code>
	csoportba rakjuk, akkor innen a <code class="command">su</code> paranccsal
	fel tudjuk venni a <code class="systemitem">root</code>
	felhasználó jogait.  A személyzet tagjait
	létrehozásukkor közvetlenül sose
	vegyük fel a <code class="systemitem">wheel</code> csoportba!  A
	személyzet tagjai elõször kerüljenek egy
	<code class="systemitem">staff</code> csoportba, és majd csak
	ezután az <code class="filename">/etc/group</code>
	állományon keresztül a
	<code class="systemitem">wheel</code> csoportba.  A személyzetnek
	csak azon tagjait tegyük ténylegesen a
	<code class="systemitem">wheel</code> csoportba, akiknek valóban
	szükségük van a <code class="systemitem">root</code>
	felhasználó
	hozzáférésére.  Ha
	például a Kerberost használjuk
	hitelesítésre, akkor megcsinálhatjuk azt
	is, hogy a Kerberos <code class="filename">.k5login</code>
	állományában engedélyezzük a
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> parancson keresztül a <code class="systemitem">root</code>
	hozzáférés elérését a
	<code class="systemitem">wheel</code> csoport alkalmazása
	nélkül.  Ez a megoldás talán
	még jobb is, mivel a <code class="systemitem">wheel</code>
	használata esetén a behatolónak még
	mindig lehetõsége van hozzájutni a
	<code class="systemitem">root</code>
	hozzáféréséhez olyankor, amikor a
	kezében van a jelszavakat tároló
	állomány és meg tudja szerezni a
	személyzet valamelyik tagjának
	hozzáférését.  A
	<code class="systemitem">wheel</code> csoport által
	felkínált megoldás ugyan jobb, mint a
	semmi, de kétségtelenül nem a
	legbiztonságosabb.</p><p>A hozzáférések teljes körû
	letiltásához a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> parancsot érdemes
	használni:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pw lock személyzet</code></strong></pre><p>Ezzel meg tudjuk akadályozni, hogy a
	felhasználó akármilyen módon,
	beleértve az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> használatát is,
	hozzá tudjon férni a
	rendszerünkhöz.</p><p>A hozzáférések
	blokkolásának másik ilyen módszere a
	titkosított jelszó átírása
	egyetlen <span class="quote">"<span class="quote"><code class="literal">*</code></span>"</span> karakterre.  Mivel
	ez a karakter egyetlen titkosított jelszóra sem
	illeszkedik, ezért a felhasználó nem lesz
	képes bejelentkezni.  Ahogy például a
	személyzet alábbi tagja sem:</p><pre class="programlisting">izemize:R9DT/Fa1/LV9U:1000:1000::0:0:Ize-Mize:/home/izemize:/usr/local/bin/tcsh</pre><p>Erre cseréljük ki:</p><pre class="programlisting">izemize:*:1000:1000::0:0:Ize-Mize:/home/izemize:/usr/local/bin/tcsh</pre><p>Ezzel megakadályozzuk, hogy az
	<code class="systemitem">izemize</code> nevû felhasználó
	a hagyományos módszerekkel be tudjon jelentkezni.
	Ez a megoldás azonban a
	<span class="application">Kerberos</span>t alkalmazó rendszerek
	esetén nem mûködik, illetve olyan helyezetekben
	sem, amikor a felhasználó az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a>
	paranccsal már létrehozott magának
	kulcsokat.</p><p>Az ilyen védelmi mechanizmusok esetében mindig
	egy szigorúbb biztonsági szintû
	géprõl jelentkezünk be egy
	kevésbé biztonságosabb gépre.
	Például, ha a szerverünk mindenféle
	szolgáltatásokat futtat, akkor a
	munkaállomásunknak egyetlen egyet sem lenne
	szabad.  A munkaállomásunk
	biztonságossá tételéhez a
	lehetõ legkevesebb szolgáltatást szabad csak
	futtatnunk, de ha lehet, egyet sem, és mindig
	jelszóval védett
	képernyõvédõt használjuk.
	Természetesen ha a támadó képes
	fizikailag hozzáférni a
	munkaállomásunkhoz, akkor szinte bármilyen
	mélységû védelmet képes
	áttörni.  Ezt mindenképpen
	számításba kell vennünk, azonban ne
	felejtsük el, hogy a legtöbb betörési
	kísérlet távolról,
	hálózaton keresztülrõl érkezik
	olyan emberektõl, akik fizikailag nem férnek
	hozzá a munkaállomásunkhoz vagy a
	szervereinkhez.</p><a id="idp86742864" class="indexterm"></a><p>A Kerberos és a hozzá hasonló
	rendszerek használatával egyszerre tudjuk a
	személyzet tagjainak jelszavát letiltani vagy
	megváltoztatni, ami egybõl
	érvényessé válik minden olyan
	gépen, ahová az adott felhasználónak
	bármilyen hozzáférése is volt.  Nem
	szabad lebecsülnünk ezt a gyors
	jelszóváltási lehetõséget abban
	az esetben, ha a személyzet valamelyik tagjának
	hozzáférését megszerezték.
	Hagyományos jelszavak használatával a
	jelszavak megváltoztatása N gépen igazi
	káosz.  A Kerberosban jelszóváltási
	megszorításokat is felállíthatunk:
	nem csak a Kerberos által adott jegyek járnak le
	idõvel, hanem a Kerberos rendszer meg is követelheti a
	felhasználóktól, hogy egy adott idõ
	(például egy hónap) után
	változtasson jelszót.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86743888"></a>14.3.2. A rendszergazdai jogokkal futó szerverek és
	SUID/SGID engedélyekkel rendelkezõ programok
	védelme</h3></div></div></div><a id="idp86744528" class="indexterm"></a><a id="idp86745168" class="indexterm"></a><a id="idp86750032" class="indexterm"></a><a id="idp86750672" class="indexterm"></a><a id="idp86751184" class="indexterm"></a><a id="idp86751824" class="indexterm"></a><a id="idp86752464" class="indexterm"></a><a id="idp86753104" class="indexterm"></a><p>A bölcs rendszergazda mindig csak akkor futtat
	szervereket, amikor szüksége van rá, se
	többet, se kevesebbet.  Az egyéb
	fejlesztõktõl származó szerverekkel
	bánjunk különösen óvatosan, mivel
	gyakran hajlamosak hibákat tartalmazni.
	Például az <span class="application">imapd</span> vagy a
	<span class="application">popper</span> használata olyan,
	mintha az egész világnak ingyenjegyet
	osztogatnánk a rendszerünk <code class="systemitem">root</code>
	hozzáféréséhez.  Soha ne futtassunk
	olyan szervert, amelyet nem vizsgáltunk át
	kellõ alapossággal.  Sok szervert nem is
	feltétlenül kell <code class="systemitem">root</code>
	felhasználóként futtatni.
	Például az <span class="application">ntalk</span>,
	<span class="application">comsat</span> és
	<span class="application">finger</span> démonok egy
	speciális
	<em class="firstterm">járókában</em> (sandbox)
	futnak.  Ezek a járókák sem teljesen
	tökéletesek, hacsak erre külön figyelmet
	nem fordítunk.  Ilyenkor a többvonalas
	védelem eszménye még mindig él: ha
	valakinek sikerült betörnie a
	járókába, akkor onnan ki is tud törni.
	Minél több védelmi vonalat húzunk a
	támadó elé, annál jobban
	csökken a sikerének
	valószínûsége.  A
	történelem során lényegében
	minden <code class="systemitem">root</code> jogokkal futó
	szerverben, beleértve az alapvetõ
	rendszerszintû szervereket is, találtak már
	biztonsági jellegû hibát.  Ha a
	gépünkre csak az <span class="application">sshd</span>
	szolgáltatáson keresztül tudnak
	belépni, és soha nem használja senki a
	<span class="application">telnetd</span>,
	<span class="application">rshd</span> vagy
	<span class="application">rlogind</span>
	szolgáltatásokat, akkor kapcsoljuk is ki
	ezeket!</p><p>A FreeBSD most már alapértelmezés szerint
	járókában futtatja az
	<span class="application">ntalkd</span>,
	<span class="application">comsat</span> és
	<span class="application">finger</span>
	szolgáltatásokat.  Másik ilyen program,
	amely szintén esélyes lehet erre, az a
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.  Az <code class="filename">/etc/defaults/rc.conf</code>
	megjegyzésben tartalmazza a
	<span class="application">named</span> járókában
	futtatásához szükséges
	paramétereket.  Attól függõen, hogy egy
	új rendszert telepítünk vagy
	frissítjük a már meglévõ
	rendszerünket, a járókákhoz
	tartozó speciális felhasználói
	hozzáférések nem feltétlenül
	jönnek létre.  Amikor csak lehetséges, az
	elõrelátó rendszergazda
	kikísérletez és létrehoz ilyen
	járókákat.</p><a id="idp86762704" class="indexterm"></a><p>Vannak más olyan szerverek, amelyek tipikusan nem
	járókákban futnak.  Ilyen többek
	közt a <span class="application">sendmail</span>,
	<span class="application">popper</span>,
	<span class="application">imapd</span>,
	<span class="application">ftpd</span> és még sokan
	mások.  Léteznek rájuk
	alternatívák, de a telepítésük
	valószínûleg több munkát
	igényel, mint amennyit megérné
	számunkra veszõdni velük (és itt megint
	lesújt a kényelmi tényezõ).  Ezeket a
	szervereket többnyire <code class="systemitem">root</code>
	felhasználóként kell futtatnunk és a
	rajtuk keresztül érkezõ betörési
	kísérleteket más módokra
	támaszkodva kell észlelnünk.</p><p>A <code class="systemitem">root</code> felhasználó
	keltette biztonsági rések másik nagy
	csoportja azok a végrehajtható
	állományok a rendszerben, amelyek a suid és
	sgid engedélyekkel rendelkeznek, futtatásuk
	rendszergazdai jogokkal történik.  Az ilyen
	binárisok többsége, mint
	például az <span class="application">rlogin</span>, a
	<code class="filename">/bin</code> és <code class="filename">/sbin</code>, <code class="filename">/usr/bin</code> vagy <code class="filename">/usr/sbin</code> könyvtárakban
	található meg.  Habár semmi sem
	biztonságos 100%-ig, a rendszerben
	alapértelmezetten suid és sgid engedéllyel
	rendelkezõ binárisok ebbõl a szempontból
	meglehetõsen megbízhatónak tekinhetõek.
	Alkalmanként azonban találnak a
	<code class="systemitem">root</code> felhasználót
	veszélyeztetõ lyukakat az ilyen binárisokban
	is.  Például 1998-ban az
	<code class="literal">Xlib</code>-ben volt egy olyan rendszergazdai
	szintû hiba, amellyel az <span class="application">xterm</span>
	(ez általában suid engedéllyel rendelkezik)
	sebezhetõvé vált.  Mivel jobb félni,
	mint megijedni, ezért az elõretekintõ
	rendszergazda mindig igyekszik úgy csökkenteni az
	ilyen engedélyekkel rendelkezõ binárisok
	körét, hogy csak a személyzet tagjai legyenek
	képesek ezeket futtatni.  Ezt egy olyan speciális
	csoport létrehozásával oldhatjuk meg,
	amelyhez csak a személyzet tagjai férhetnek
	hozzá.  Az olyan suid binárisoktól pedig,
	amelyeket senki sem használ, igyekszik teljesen
	megszabadulni (<code class="command">chmod 000</code>).  A monitorral nem
	rendelkezõ szervereknek általában nincs
	szükségük az <span class="application">xterm</span>
	mûködtetésére.  Az sgid
	engedéllyel rendelkezõ binárisok is
	legalább ugyanennyire veszélyesek.  Ha a
	behatoló képes feltörni egy
	<code class="systemitem">kmem</code> csoporthoz tartozó sgid
	binárist, akkor képes lesz olvasni a
	<code class="filename">/dev/kmem</code> állomány
	tartalmát, ezáltal hozzájut a
	titkosított jelszavakhoz és így
	megszerezheti magának akármelyik
	hozzáférést.  Sõt, a
	<code class="systemitem">kmem</code> csoportot megszerzõ
	behatolók figyelni tudják a pszeudó
	terminálokon keresztül érkezõ
	billentyûleütéseket, még abban az
	esetben is, amikor a felhasználók
	egyébként biztonságos módszereket
	használnak.  A <code class="systemitem">tty</code> csoportot
	bezsebelõ támadók szinte bármelyik
	felhasználó termináljára
	képesek írni.  Ha a felhasználó
	valamilyen terminál programot vagy terminál
	emulátort használ a billentyûzet
	szimulációjával, akkor a behatoló
	tud olyan adatokat generálni, amivel a
	felhasználó nevében adhat ki
	parancsokat.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>14.3.3. A felhasználói
	hozzáférések védelme</h3></div></div></div><p>A felhasználók
	hozzáféréseit szinte a legnehezebb
	megvédeni.  Míg a személyzet tagjaival
	szemben lehetünk kíméletlenül
	szigorúak és <span class="quote">"<span class="quote">ki is csillagozhatjuk</span>"</span>
	a jelszavukat, addig a felhasználók
	hozzáféréseivel
	általánosságban véve ezt nem
	tehetjük meg.  Ha a kezünkben van a megfelelõ
	mértékû irányítás, akkor
	még gyõzhetünk és kényelmesen
	biztonságba helyezethetjük a
	felhasználók
	hozzáférését.  Ha nincs, akkor nem
	tehetünk mást, mint állandóan
	õrködünk a hozzáférések
	felett.  Az ssh és Kerberos használata a
	felhasználók esetén sokkalta
	problematikusabb, mivel ilyenkor jóval több
	adminisztrációra és mûszaki
	segítségnyújtásra van
	szükség, de még mindig jobb megoldás a
	titkosított jelszavakhoz képest.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86787024"></a>14.3.4. A jelszavakat tároló állomány
	védelme</h3></div></div></div><p>Az a legbiztosabb, ha minél több jelszót
	kicsillagozunk és a hozzáférések
	hitelesítésére ssh-t vagy Kerberost
	használunk.  Igaz, a titkosított jelszavakat
	tároló állományt
	(<code class="filename">/etc/spwd.db</code>) csak a
	<code class="systemitem">root</code> képes olvasni, de a
	támadó meg tudja szerezni ezt a jogot még
	olyankor is, ha <code class="systemitem">root</code>
	felhasználóként nem feltétlenül
	tud írni.</p><p>A rendszerünkben futó biztonsági
	szkripteknek a jelszavakat tároló
	állomány változását
	folyamatosan tudnia kell figyelnie és jelentie
	(lásd lentebb a <a class="link" href="securing-freebsd.html#security-integrity" title="14.3.6. Az állományok sértetlenségének ellenõrzése: binárisok, konfigurációs állományok stb.">Az
	állományok sértetlenségének
	ellenõrzése</a> címû
	fejezetet).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86790480"></a>14.3.5. A rendszermag belsejének, a nyers eszközök
	és az állományrendszerek
	védelme</h3></div></div></div><p>Ha a támadó megszerzi a
	<code class="systemitem">root</code>
	hozzáférését, akkor szinte
	bármit képes megtenni, de vannak bizonyos
	elõnyei.  Például a mostanság
	fejlesztett legtöbb rendszermag tartalmaz valamilyen
	beépített csomaglehallgatót, amit FreeBSD
	alatt a <code class="filename">bpf</code> eszköz
	valósít meg.  A támadók szinte
	mindig megpróbálnak valamilyen
	csomaglehallgatót használni a feltört
	gépen.  A legtöbb rendszeren azonban nem kell
	feltétlenül megadnunk ezt az örömet,
	ezért nem is kell beépítenünk a
	rendszermagba a <code class="filename">bpf</code>
	eszközt.</p><a id="idp86792784" class="indexterm"></a><p>De ha még ki is iktatjuk a
	<code class="filename">bpf</code> eszközt, még
	aggódhatunk a <code class="filename">/dev/mem</code> és
	<code class="filename">/dev/kmem</code> miatt.  Egyébként
	ami azt illeti, a behatoló még így is
	képes írni a nyers eszközökre.
	Sõt, a rendszermagba képesek vagyunk modulokat is
	betölteni a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a> használatával.  A
	vállalkozó kedvû támadó a
	rendszermag moduljaként képes telepíteni
	és használni a saját
	<code class="filename">bpf</code> eszközét vagy
	bármilyen más, a csomagok
	lehallgatására alkalmas eszközt.  Az ilyen
	problémák elkerülése
	érdekében a rendszermagot a legmagasabb
	védelmi szinten kell üzemeltetni, tehát
	legalább egyes szinten.</p><p>A rendszermag védelmi szintjét több
	különbözõ módon lehet
	állítani.  A védelmi szintet úgy
	lehet a legegyszerûbben növelni, ha a
	<code class="command">sysctl</code> paranccsal beállítjuk a
	<code class="varname">kern.securelevel</code> nevû,
	rendszerszintû változó
	értékét:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel=1</code></strong></pre><p>A FreeBSD rendszermag alapértelmezés szerint a
	<code class="literal">-1</code> védelmi szinten indul.  Ez
	egészen addig <code class="literal">-1</code> marad, amíg a
	rendszergazda vagy valamelyik <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> során
	hívott rendszerindító szkript ezt meg nem
	változtatja.  A rendszer indítása
	során úgy tudjuk beállítani a
	megfelelõ védelmi szintet, ha az
	<code class="filename">/etc/rc.conf</code> állományban
	megadjuk a <code class="varname">kern_securelevel_enable</code>
	változót a <code class="literal">YES</code>
	értékkel, illetve
	<code class="varname">kern_securelevel</code>
	értékeként a kívánt
	védelmi szintet.</p><p>A FreeBSD alapértelmezett védelmi szintje
	közvetlenül a rendszerindító szkriptek
	lefutása után <code class="literal">-1</code>.  Ezt
	<span class="quote">"<span class="quote">nem biztonságos módnak</span>"</span> nevezik,
	mivel az állományok
	írásáért felelõs
	állományjelzõk nem feltétlenül
	mûködnek, mindegyik eszköz írható,
	olvasható és a többi.</p><p>Miután a védelmi szintet <code class="literal">1</code>
	vagy annál magasabb értékre
	állítottuk, akkor a rendszer figyelembe veszi a
	csak hozzáfûzést (append-only) és
	módosíthatatlanságot (immutable)
	megszorító állományjelzõket,
	nem engedélyezi a tiltásukat és az
	eszközök közvetlenül nem
	érhetõek el.  A különbözõ
	védelmi szintek részletesebb
	bemutatását a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=security&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">security</span>(7)</span></a> man oldalon
	olvashatjuk (vagy a FreeBSD 7.0 elõtti változataiban a
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> man oldalon).</p><div xmlns="" class="note"><h3 class="admontitle">Megjegyzés: </h3><p xmlns="http://www.w3.org/1999/xhtml">Az <code class="literal">1</code> és az afeletti
	  védelmi szinteken többek közt az X11 nem
	  feltétlenül lesz futtatható (mivel a
	  <code class="filename">/dev/io</code> eszköz elérése
	  blokkolt), illetve a rendszer frissítése is
	  akadályokba fog ütközni (a
	  <code class="buildtarget">installworld</code> futtatása
	  során ideiglenesen ki kell kapcsolni az append-only
	  és immutable állományjelzõket).  Az
	  X11 esetében ezt valahogy még ki lehet
	  kerülni úgy, hogy ha az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> démont
	  még a rendszerindítás elején
	  aktiváljuk (amikor a védelmi szint még
	  kellõen alacsony).  Az összes védelmi szint
	  és megszorítás esetén azonban nem
	  mindig adható ilyen jellegû javaslat, ezért
	  ilyenkor mindig érdemes elõre tervezni egy
	  keveset.  Emellett fontos alaposan megismerni a
	  különbözõ védelmi
	  megszorításokat, mivel jelentõs
	  mértékben visszafoghatják a rendszer
	  használhatóságát.  Ez segít
	  az adott helyzetben az egyszerûbb megoldást
	  választani és ezáltal elkerülni a
	  kellemetlen meglepetéseket.</p></div><p>Ha a rendszermag védelmi szintjét az
	<code class="literal">1</code> érték vagy afelé
	emeljük, akkor hasznos lehet a fontosabb
	(lényegében minden olyan programnak, amely a
	védelmi szint helyes
	beállítódása elõtt lefut)
	programoknak, könyvtáraknak és szkripteknek
	beállítani az <code class="literal">schg</code>
	állományjelzõt.  Ilyenkor azonban vegyük
	figyelembe, hogy a rendszer frissítése is
	nehezebbé válik a magasabb védelmi
	szinteken.  Egy mûködõképesebb
	megoldás lehet, ha rendszerünket egy magasabb
	védelmi szinten használjuk, de nem
	állítjuk be mindegyik rendszerszintû
	állományra az <code class="literal">schg</code>
	állományjelzõt.  Másik
	lehetõség még a <code class="filename">/</code> és <code class="filename">/usr</code> partíciók
	írásvédett csatlakoztatása.  Ne
	felejtsük el azonban, hogy ha túlságosan
	szigorúak vagyunk magunkhoz, akkor azzal egyúttal
	a behatolás észlelését is meg tudjuk
	nehezíteni!</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>14.3.6. Az állományok
	sértetlenségének ellenõrzése:
	binárisok, konfigurációs
	állományok stb.</h3></div></div></div><p>Ha arról van szó, csak a legfontosabb
	rendszerszintû konfigurációs- és
	vezérlõállományokat tudjuk
	megvédeni, még mielõtt a korábban
	emlegetett kényelmi tényezõ kimutatná
	a foga fehérjét.  Például, ha a
	<code class="command">chflags</code> paranccsal beállítjuk
	az <code class="literal">schg</code> állományjelzõt a
	<code class="filename">/</code> és <code class="filename">/usr</code>
	állományrendszereken található
	legtöbb állományra, akkor az minden bizonnyal
	csökkenti a hatékonyságunkat, hiszen az
	állományok védelmének
	növekedésével csökken az
	észlelés lehetõsége.  A védelmi
	vonalaink közül ugyanis az utolsó talán
	az egyik legfontosabb - a detektálás.  A
	felépített biztonsági rendszerünk
	legnagyobb része szinte teljesen hasztalan (vagy ami
	még rosszabb, a biztonság hamis
	érzetét kelti), ha nem vagyunk képesek
	észrevenni a betörési
	kísérleteket.  A védelmi rendszer egyik
	részére nem a támadó
	megállításához, hanem a
	lelassításához van szükség,
	hogy így majd munka közben érhessük
	tetten.</p><p>A betörés tényét legjobban a
	megváltozott, hiányzó vagy éppen
	váratlanul felbukkanó állományok
	utáni kutatással tudjuk felismerni.  A
	módosított állományokat
	általában egy másik (gyakran
	központosított) korlátozott
	hozzáférésû rendszerbõl
	ellenõrizhetjük a legjobban.  Fontos, hogy ha egy
	korlátozott hozzáférésû,
	kiemelten védett rendszeren írjuk a
	védelemért felelõs szkripteket, akkor azok
	szinte teljesen láthatlanok lesznek a
	támadó számára.  A legjobb
	kihasználás érdekében a
	korlátozott hozzáférésû
	gépnek jelentõs mértékû
	rálátással kell rendelkeznie az összes
	többi gépre, amit írásvédett
	NFS exportok vagy ssh kulcspárok
	felhasználásával érhetünk el.
	A hálózati forgalmat leszámítva az
	NFS látszik a legkevésbé -
	segítségével lényegében
	észrevétlenül tudjuk figyelni az egyes
	gépek állományrendszereit.  Ha a
	megfigyelésre használt szerver a kliensekhez
	switchen keresztül csatlakozik, akkor az NFS gyakran jobb
	választásnak bizonyul.  Ha a szerver hubon vagy
	több hálózati elemen keresztül
	éri el a megfigyelni kívánt klienseket,
	akkor az NFS nem eléggé biztonságos
	(és hatékony), ezért ilyen esetekben az ssh
	választása lehet a kedvezõ még az ssh
	által hagyott nyomokkal együtt is.</p><p>Miután a korlátozott
	hozzáférésû gépünk
	legalább látja a hozzá tartozó
	kliensek rendszereit, el kell készítenünk a
	tényleges monitorozást végzõ
	szkripteket.  Ha NFS csatlakozást tételezünk
	fel, akkor az olyan egyszerû rendszereszközökkel,
	mint például a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> és <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>
	képesek vagyunk összerakni ezeket.  A szemmel
	tartott kliensek állományait naponta
	legalább egyszer érdemes ellenõrizni md5-tel,
	valamint még ennél gyakrabban is tesztelni az
	<code class="filename">/etc</code> és <code class="filename">/usr/local/etc</code>
	könyvtárakban található
	konfigurációs és
	vezérlõállományokat.  Ha valamilyen
	eltérést tapasztal az ellenõrzést
	végzõ szerverünk és a rajta levõ
	md5 információk is helyesek, akkor
	értesítenie kell a rendszergazdát.  Egy
	jó védelmi szkript képes megkeresni az oda
	nem illõ suid binárisokat, valamint az új
	vagy törölt állományokat a <code class="filename">/</code> és a <code class="filename">/usr</code>
	partíciókon.</p><p>A védelmi szkriptek megírása valamivel
	nehezebb feladat, ha ssh-t használunk az NFS helyett.  A
	futtatásukhoz a szkripteket és az általuk
	használt eszközöket (például
	find) az <code class="command">scp</code> paranccsal
	lényegében át kell másolni a
	kliensekre, amivel így láthatóvá
	válnak.  Ne feledjük továbbá, hogy az
	<span class="application">ssh</span> kliens már eleve
	feltört lehet.  Szó, ami szó, ha nem
	megbízható
	összeköttetésekrõl beszélünk,
	akkor az ssh használata elkerülhetetlen, de nem
	feltétlenül egyszerû.</p><p>Egy jó védelmi szkript észreveszi a
	felhasználók és a személyzet
	tagjainak hozzáférését
	vezérlõ állományokban, mint
	például az <code class="filename">.rhosts</code>,
	<code class="filename">.shosts</code>,
	<code class="filename">.ssh/authorized_keys</code> és
	társaiban keletkezett változásokat is,
	amelyek esetleg elkerülhetik egy <code class="literal">MD5</code>
	alapú ellenõrzés figyelmét.</p><p>Ha netalán órási mennyiségû
	tárterületettel rendelkeznénk, akkor
	eltarthat egy ideig, amíg végigsöprünk
	az összes partíció összes
	állományán.  Ebben az esetben
	érdemes olyan beállításokat megadni
	az állományrendszerek
	csatlakoztatásánál, amivel le tudjuk
	tiltani a suid engedéllyel rendelkezõ
	binárisok futtatását.  Ezzel kapcsolatban a
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a> parancs <code class="literal">nosuid</code>
	opcióját nézzük meg.  Hetente
	legalább egyszer azért mégis érdemes
	átnézni az ilyen partíciókat is,
	mivel ez a réteg a betörési
	kísérletek felderítésével
	foglalkozik, függetlenül a
	sikerességüktõl.</p><p>A futó programok nyilvántartása
	(lásd <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) egy olyan viszonylag kevés
	költséggel járó lehetõség
	az operációs rendszerben, ami
	segítségünkre lehet a betörés
	utáni események
	kiértékelésében.
	Különösen hasznos olyankor, amikor
	megpróbáljuk modellezni, miképp is
	sikerült a támadónak bejutnia a
	rendszerünkbe, természetesen feltételezve,
	hogy az ehhez felhasznált feljegyzések a
	betörés után is érintetlenek
	maradtak.</p><p>Végül a védelmet ellátó
	szkripteknek javasolt feldolgozni a
	naplóállományokat is, valamint a
	naplókat magukat is a lehetõ
	legbiztonságosabb formában generálni
	- ilyenkor nagyon hasznos lehet, ha egy távoli
	gépre naplózunk.  A behatoló
	megpróbálja majd eltüntetni a nyomait, a
	naplóállományok viszont nagyon fontosak a
	rendszergazda számára a betörési
	kísérletek idejének és
	módjának
	megállapításában.  A naplókat
	úgy tudjuk tartósan rögzíteni, ha a
	rendszerkonzol üzeneteit soros porton keresztül
	gyûjtjük össze a konzolok
	felügyeletéért felelõs
	biztonságos gépen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86856400"></a>14.3.7. Állandó paranoia</h3></div></div></div><p>Egy kis paranoia sosem árt.  Elmondható, hogy
	a rendszergazda tetszõleges számú
	biztonsági intézkedéssel élhet
	egészen addig, amíg az nincs hatással a
	kényelmére, és a kényelmet
	<span class="emphasis"><em>befolyásoló</em></span> biztonsági
	intézkedéseket pedig megfelelõ
	mérlegelés mellett tegye meg.  Ami még
	ennél is fontosabb, hogy mindig változtassunk
	valamit a biztonsági hálónkon - mivel
	ha egy az egyben követjük a dokumentumban
	leírtakat, akkor ezzel együtt kiadjuk a
	bejutás receptjét annak a leendõ
	támadónknak, aki szintén elolvasta
	ugyanezt.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86857936"></a>14.3.8. A szolgáltatások
	mûködésképtelenné
	tételét célzó
	támadások</h3></div></div></div><a id="idp86858576" class="indexterm"></a><p>Ez a szakasz a szolgáltatások
	mûködésképtelenségét
	elérni kívánó, más
	néven <span class="quote">"<span class="quote">Denial of Service</span>"</span>
	típusú támadásokkal foglalkozik.
	Noha nem tudunk túlságosan sokat tenni a
	manapság felbukkanó álcázott, a
	hálózatunk totális
	leterhelését célbavevõ
	támadások ellen, akadnak olyan
	általános érvényû
	eszközök, amelyekkel elejét vehetjük a
	szervereink szétbomzásának:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A létjövõ
	    szerverpéldányok
	    korlátozása.</p></li><li class="listitem"><p>Az ugródeszkaszerû támadások
	    (támadás ICMP-válasszal,
	    pingszórás stb.)
	    korlátozása.</p></li><li class="listitem"><p>A rendszermag útválasztási
	    gyorsítótárának
	    túlterhelése.</p></li></ol></div><p>A DoS támadások egyik jellemzõ
	sémája szerint egy sokszorozódni
	képes szervert támadnak meg, amelynek igyekeznek
	minél több példányát
	legyártatni, míg végül az ezt
	futtató rendszer ki nem fogy a
	memóriából,
	állományleíróból
	satöbbibõl és megállásra nem
	kényszerül.  Az <span class="application">inetd</span>
	(lásd <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>) számos
	lehetõséget kínál fel ennek
	megakadályozására.  Ezzel kapcsolatban
	szeretnénk megjegyezni, hogy bár ezzel el tudjuk
	kerülni a gépünk
	leállását, semmilyen garanciát nem
	ad arra, hogy a szolgáltatás a
	támadás során is zavartalanul üzemel
	tovább.  Alaposan olvassuk el az
	<span class="application">inetd</span> man oldalát és
	legyünk különös tekintettel a
	<code class="option">-c</code>, <code class="option">-C</code> és
	<code class="option">-R</code> kapcsolóira.  Vigyázzunk, hogy
	az <span class="application">inetd</span> <code class="option">-C</code>
	kapcsolóját képesek kijátszani az
	álcázott IP-vel érkezõ
	támadások, ezért inkább az
	elõbbi kapcsolók valamilyen
	kombinációja az ajánlott.  Egyes
	szerverprogramoknál be lehet állítani a
	példányainak maximális
	számát.</p><p>A <span class="application">Sendmail</span> rendelkezik egy
	<code class="option">-OMaxDaemonChildren</code>
	beállítással, ami a terhelésben
	levõ késleltetése miatt néha mintha
	jobban beválna, mint a
	<span class="application">Sendmail</span>
	terheléskorlátozó paraméterei.  A
	<span class="application">Sendmail</span> indításakor
	tehát a <code class="literal">MaxDaemonChildren</code>
	paramétert javasolt megadni egy olyan
	értékkel, amely elegendõ a
	<span class="application">Sendmail</span> számára
	betervezett terhelés kiszolgálására,
	de még kevés ahhoz, hogy a
	<span class="application">Sendmail</span> fûbe harapjon
	tõle.  Továbbá bölcs dolog a
	<span class="application">Sendmail</span>t várakozási
	sorral (<code class="option">-ODeliveryMode=queued</code>) és
	démonként (<code class="command">sendmail -bd</code>),
	külön feldolgozási menetekkel
	(<code class="command">sendmail -q15m</code>) futtatni.  Ha
	továbbra is valós idejû
	kézbesítést akarunk, akkor a
	feldolgozást kisebb idõközökkel is
	lefuttathatjuk (például <code class="option">-q1m</code>), de
	arra <span class="emphasis"><em>mindig ügyeljünk</em></span>, hogy a
	<code class="literal">MaxDaemonChildren</code>
	beállítása ne okozzon
	kaszkádosítási hibákat a
	<span class="application">Sendmail</span>
	mûködésében.</p><p>A <span class="application">Syslogd</span> közvetlenül
	is támadható, ezért határozottan
	javasoljuk a <code class="option">-s</code> használatát,
	amikor csak lehet, minden más esetben pedig a
	<code class="option">-a</code> beállítást.</p><p>Fordítsunk kellõ figyelmet a TCP kapcsolatok
	burkolását végzõ <span class="application">TCP
	Wrapper</span> <span class="quote">"<span class="quote">reverse-ident</span>"</span>
	lehetõségére, ami szintén
	közvetlenül támadható.  Ebbõl az
	okból kifolyólag valószínûleg
	nem is akarjuk a <span class="application">TCP Wrapper</span>
	által felkínált reverse-ident-et
	használni.</p><p>Jól járunk el abban az esetben, ha a
	belsõ szolgáltatásainkat az
	útválasztóink mentén tûzfal
	segítségével védjük meg a
	külsõ hozzáféréstõl.  Ezzel
	lényegében a helyi hálózatunkat
	kívülrõl fenyegetõ támadások
	ellen védekezünk, de ez nem nyújt
	elegendõ védelmet a belsõ
	szolgáltatásaink esetén a
	<code class="systemitem">root</code> hozzáférés
	megszerzésére irányuló
	kísérletek ellen.  Mindig egy exkluzív,
	tehát zárt tûzfalat állítsunk
	be, vagyis <span class="quote">"<span class="quote">tûzfalazzunk mindent
	<span class="emphasis"><em>kivéve</em></span> az A, B, C, D és M-Z
	portokat</span>"</span>.  Ezen a módon ki tudjuk szûrni az
	összes alacsonyabb portot, kivéve bizonyos eseteket,
	mint például a <span class="application">named</span>
	(ha az adott zónában ez az elsõdleges
	gép), <span class="application">ntalkd</span>,
	<span class="application">sendmail</span> vagy más interneten
	keresztül elérhetõ
	szolgáltatásokat.  Ha másképpen
	állítjuk a tûzfalat - inkluzív,
	nyílt avagy megengedõ módon, akkor jó
	eséllyel elfelejtünk <span class="quote">"<span class="quote">lezárni</span>"</span>
	egy csomó szolgáltatást, vagy úgy
	adunk hozzá egy új belsõ
	szolgáltatást, hogy közben elfelejtjük
	frissíteni a tûzfalat.  Ennél még azon
	is jobb, ha a tûzfalon nyitunk egy magasabb
	portszámú tartományt, és ott
	valósítjuk meg ezt a megengedõ jellegû
	mûködést, az alacsonyabb portok
	veszélybe sodrása nélkül.  Vegyük
	azt is számításba, hogy a FreeBSD-ben a
	kiosztott portokat dinamikusan állíthatjuk a
	<code class="varname">net.inet.ip.portrange</code> sysctl
	változókon keresztül (<code class="command">sysctl -a |
	fgrep portrange</code>), ami nagyságrendekkel
	megkönnyíti a tûzfal
	beállítását.  Ennek megfelelõen
	például meg tudjuk adni, hogy a 4000-tõl
	5000-ig terjedõ porttartomány a 49152-tõl
	65535-ig húzódó tartományba
	kerüljön át, majd a 4000 alatti összes
	portot blokkoljuk (természetesen az internetrõl
	szándékosan hozzáférhetõ portok
	kivételével).</p><p>A DoS támadások másik elterjedt
	fajtája az ún.  <span class="quote">"<span class="quote">ugródeszka
	támadás</span>"</span> - ilyenkor a szervert
	úgy próbálják túlterhelni,
	hogy folyamatosan válaszokat kérnek tõle a
	helyi hálózatról vagy egy másik
	számítógéprõl.  Az ilyen
	természetû támadások közül
	is a legnépszerûbb az <span class="emphasis"><em>ICMP
	pingszórásos támadás</em></span>.  A
	támadó olyan ping csomagokat küld szét
	a helyi hálózaton, amelyek
	forrásának azt a gépet jelöli meg,
	amelyiket meg akarja támadni.  Ha a
	hálózatokat elválasztó
	útválasztók nem fogják meg a
	pingszórást, akkor a helyi
	hálózatról összes gépe
	nekilát válaszolgatni a meghamisított
	forrás címére, amivel így teljesen
	leterhelik az áldozatot.  Ez különösen
	akkor hatásos, amikor a támadó ugyanezt a
	trükköt eljátssza egyszerre több tucat
	különbözõ hálózatban is.  Az
	üzenetszórással járó
	támadások akár százhúsz
	megabitnyi forgalmat is képesek generálni
	másodpercenként.  A második legelterjedtebb
	ugródeszkás támadás az ICMP
	hiba-visszajelzési rendszere ellen irányul.
	Ilyenkor a támadó ICMP hibaüzeneteket
	kiváltó csomagok
	készítésével képes
	eltömíteni egy szerver bejövõ
	hálózati kapcsolatát és az ICMP
	válaszokkal pedig a szerver maga dugítja el a
	kimenõ hálózati kapcsolatát.  Ez a
	fajtájú támadás képes
	kinyomni az összes memóriát a szerverbõl
	és ezzel összeomlasztani, különösen
	olyankor, amikor a szerver nem tudja elég gyorsan
	elnyelni az általa generált ICMP
	válaszokat.  A <code class="varname">net.inet.icmp.icmplim</code>
	sysctl változóval tudunk gátat szabni a
	támadások ezen fajtájának.  Az
	ugródeszkás támadások utolsó
	nagyobb osztálya az <span class="application">inetd</span>
	olyan szolgáltatásait szemeli ki, mint
	például az udp echo.  A támadó
	ilyenkor egyszerûen küld a helyi
	hálózatunkon található A és B
	szerverünknek egy olyan UDP csomagot, ahol
	forrásként az A szerver echo portját adja
	meg, célnak pedig a B szerver echo portját.
	Ezután a két szerver elkezdi egymás
	között passzolgatni ezt az egyetlen csomagot.  A
	támadó még több ilyen csomag
	befecskendezésével pillanatok alatt képes
	leterhelni a két szervert és helyi
	hálózatot.  Hasonló problémák
	vannak a belsõ <span class="application">chargen</span>
	portjával is.  Egy hozzáértõ
	rendszergazda ezért kikapcsolja az összes ilyen
	inetd-alapú belsõ tesztelõ
	szolgáltatást.</p><p>Az álcázott csomagok
	felhasználhatóak a rendszermag
	útválasztó
	gyorsítótárának
	túlterhelésére is.  Ezzel kapcsolatban
	nézzük meg a
	<code class="varname">net.inet.ip.rtexpire</code>,
	<code class="varname">rtminexpire</code> és
	<code class="varname">rtmaxcache</code> sysctl változókat.
	A véletlenszerû IP-címekkel megcímzett
	álcázott csomagok hatására a
	rendszermag létrehoz mindegyikõjükhöz egy
	ideiglenesen pufferelt utat az útválasztó
	táblázatában, amelyet a <code class="command">netstat
	-rna | fgrep W3</code> paranccsal tudunk lekérdezni.
	Az ilyen útvonalak nagyjából 1600
	másodperc múlva elévülnek.  Ha a
	rendszermag észleli, hogy a
	gyorsítótárazott
	útválasztási táblázat
	mérete túlságosan megnövekedett, akkor
	automatikusan csökkenti az <code class="varname">rtexpire</code>
	értékét, de soha nem megy a
	<code class="varname">rtminexpire</code> alá.  Ebbõl
	két probléma adódik:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A rendszermag nem reagál elég gyorsan
	    amikor egy alig terhelt szervert hirtelen
	    megtámadnak.</p></li><li class="listitem"><p>Az <code class="varname">rtminexpire</code> nem elég kicsi
	    ahhoz, hogy a rendszermag túléljen egy
	    tartósabb rohamot.</p></li></ol></div><p>Ha a szervereink az internethez T3 (kb.  45 Mbit/s) vagy
	gyorsabb összeköttetésen keresztül
	csatlakoznak, akkor határozottan javasolt kézileg
	behangolni a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> segítségével az
	<code class="varname">rtexpire</code> és az
	<code class="varname">rtminexpire</code> értékeket.  Soha ne
	állítsuk egyiket sem nullára (hacsak nem
	akarjuk összeomlasztani a gépünket).  Ha
	például mind a kettõt 2 másodpercre
	állítjuk, akkor az többnyire elegendõ az
	útválasztási táblázat
	megvédéséhez.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86930640"></a>14.3.9. Hozzáférés Kerberosszal és
	SSH-val</h3></div></div></div><a id="idp86931280" class="indexterm"></a><a id="idp86931920" class="indexterm"></a><p>Van néhány dolog, amit a Kerberos és az
	ssh esetén ajánlatos tisztázni,
	mielõtt használjuk ezeket.  A Kerberos 5 egy
	kifogástalan hitelesítési protokoll.  A
	<span class="application">telnet</span> és
	<span class="application">rlogin</span> Kerberos által
	módosított változatában vannak olyan
	hibák, amelyek alkalmatlanná teszik ezeket a
	bináris adatfolyamok helyes kezelésére.
	Sõt, alapértelmezés szerint a Kerberos nem
	titkosítja a kapcsolatot, csak ha megadjuk neki a
	<code class="option">-x</code> kapcsolót.  Az
	<span class="application">ssh</span> alapértelmezés
	szerint mindent titkosít.</p><p>Az ssh minden szempontból nagyon jól
	teljesít kivéve, hogy alapértelmezés
	szerint átküldi a kulcsokat is.  Ez azt jelenti,
	hogy ha van egy olyan biztonságos
	munkaállomásunk, ahol a rendszer többi
	részéhez tartozó kulcsainkat tartjuk
	és egy nem biztonságos gépre akarunk vele
	ssh-n keresztül belépni, akkor a kulcsaink
	használatóvá válnak.  A
	tényleges kulcsokat ugyan nem látja senki, de a
	bejelentkezés során az ssh megnyit egy
	közvetítéshez használt portot, amit a
	nem biztonságos gépen a támadó egy
	feltört <code class="systemitem">root</code>
	hozzáférés birtokában ki tud
	használni úgy, hogy a kulcsaink
	segítségével hozzá tudjon
	férni egy másik olyan géphez, amelyet a
	kulcsok nyitnak.</p><p>Ha lehetséges, akkor a személyzet
	bejelentkeztetéséhez az ssh-t és Kerberost
	együttesen használjuk.  Az
	<span class="application">ssh</span> lefordíható
	Kerberos támogatással.  Ezzel
	csökkentjük a potenciálisan
	kiszivárgó ssh kulcsok esélyét,
	miközben jelszavainkat a Kerberosszal védjük.
	Az ssh kulcsokat csak biztonságos gépekrõl
	és csak automatizált feladatok esetén
	használjuk (amire a Kerberos lényegében nem
	alkalmas).  Emellett javasoljuk azt is, hogy az ssh
	beállításai között tiltsuk le a
	kulcsok átküldését (key forwarding)
	vagy használjuk az <code class="literal">from=IP/DOMAIN</code>
	opciót, amivel az ssh csak a megadott
	gépekrõl engedi az
	<code class="filename">authorized_keys</code> állomány
	és a így benne levõ kulcsok
	használatát.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Vissza</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Fel</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Elõre</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Bevezetés </td><td width="20%" align="center"><a accesskey="h" href="index.html">Fõoldal</a></td><td width="40%" align="right" valign="top"> 14.4. DES, Blowfish, MD5 és a Crypt</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ha kérdése van a FreeBSD-vel kapcsolatban, a
    következõ címre írhat (angolul):
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Ha ezzel a dokumentummal kapcsolatban van kérdése, kérjük erre a címre írjon:
    &lt;<a href="mailto:gabor@FreeBSD.org">gabor@FreeBSD.org</a>&gt;.</small></p></body></html>