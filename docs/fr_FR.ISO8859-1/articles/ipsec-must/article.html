<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Vérification indépendante du fonctionnement d'IPSec sous FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="Vous avez installé IPSec et cela semble fonctionner. Comment pouvez-vous en être sûr? Je décris une méthode pour vérifier expérimentalement le fonctionnement d'IPSec. Version française de Marc Fonvieille blackend@FreeBSD.org." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="fr" class="article" lang="fr"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp61401168"></a>Vérification indépendante du fonctionnement d'IPSec sous
      FreeBSD</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Honig</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:honig@sprynet.com">honig@sprynet.com</a>&gt;</code></p></div></div></div></div><div>Version: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD is a registered trademark of
  the FreeBSD Foundation.</p><p>Motif, OSF/1, and UNIX are
  registered trademarks and IT DialTone and The Open Group are
  trademarks of The Open Group in the United States and other
  countries.</p><p>Many of the designations used by
  manufacturers and sellers to distinguish their products are claimed
  as trademarks.  Where those designations appear in this document,
  and the FreeBSD Project was aware of the trademark claim, the
  designations have been followed by the <span class="quote">« <span class="quote">&#8482;</span> »</span> or the
  <span class="quote">« <span class="quote">®</span> »</span> symbol.</p></div></div><div>  3 Mai 1999 par .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Résumé</div><p>Vous avez installé IPSec et cela semble fonctionner.
	Comment pouvez-vous en être sûr?  Je décris
	une méthode pour vérifier expérimentalement
	le fonctionnement d'IPSec.</p><p><span class="emphasis"><em>Version française de Marc Fonvieille
  <code class="email">&lt;<a xmlns="" class="email" href="mailto:blackend@FreeBSD.org">blackend@FreeBSD.org</a>&gt;</code>.</em></span></p></div></div></div><hr /></div><div class="toc"><div class="toc-title">Table des matières</div><dl class="toc"><dt><span class="sect1"><a href="#idp61765584">1. Le problème</a></span></dt><dt><span class="sect1"><a href="#idp61782224">2. La solution</a></span></dt><dt><span class="sect1"><a href="#idp61820752">3. L'expérience</a></span></dt><dt><span class="sect1"><a href="#caveat">4. Mise en garde</a></span></dt><dt><span class="sect1"><a href="#IPsec">5. IPSec - Définition</a></span></dt><dt><span class="sect1"><a href="#ipsec-install">6. Installation d'IPSec</a></span></dt><dt><span class="sect1"><a href="#kernel">7. src/sys/i386/conf/KERNELNAME</a></span></dt><dt><span class="sect1"><a href="#code">8. Test statistique universel de Maurer (pour une longueur de
	bloc=8 bits)</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="idp61765584"></a>1. Le problème</h2></div></div></div><p>Tout d'abord, supposons que vous avez <a class="link" href="#ipsec-install" title="6. Installation d'IPSec">installé
      <span class="emphasis"><em>IPSec</em></span></a>.
      Comment savez-vous si cela <a class="link" href="#caveat" title="4. Mise en garde">fonctionne</a>?
      Bien sûr, votre connexion ne fonctionnera pas si elle est mal
      configurée, et fonctionnera quand vous l'aurez enfin
      correctement configurée.  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> le fera
      apparaître.  Mais pouvez-vous le confirmer
      de façon indépendante?</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="idp61782224"></a>2. La solution</h2></div></div></div><p>Tout d'abord, quelques informations théoriques relatives
      à la cryptographie:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Les données chiffrées sont
	  uniformément distribuées, i.e., ont une entropie
	  maximale par symbole;</p></li><li class="listitem"><p>Les données brutes, non compressées sont en
	  générale redondantes, i.e., n'ont pas une
	  entropie maximale.</p></li></ol></div><p>Supposez que vous pourriez mesurer l'entropie des
      données à destination et en provenance de votre
      interface réseau.  Alors vous pourriez voir la
      différence entre données non-chiffées et
      données chiffrées.  Cela serait vrai même si
      certaines des données en &#8220;mode chiffré&#8221;
      n'étaient pas chiffrées --- comme l'en-tête IP
      externe, si le paquet doit être routable.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="MUST"></a>2.1. MUST</h3></div></div></div><p>L'&#8220;Universal Statistical Test for Random
	Bit Generators&#8221;(<a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/universal.pdf" target="_top">
	<acronym class="acronym">MUST</acronym></a>) d'Ueli Maurer, ou encore le
	&#8220;test statistique universel pour les générateurs
	aléatoires de bits&#8221;, mesure rapidement l'entropie d'un
	échantillon.  Il utilise une sorte d'algorithme de compression.
	<a class="link" href="#code" title="8. Test statistique universel de Maurer (pour une longueur de bloc=8 bits)">Le code est donné ci-dessous</a> pour
	une variante qui mesure les morceaux (environ un quart de
	mégaoctet) successifs d'un fichier.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="tcpdump"></a>2.2. Tcpdump</h3></div></div></div><p>Nous avons également besoin d'une manière de
	capturer les données réseau brutes.  Un programme
	appelé <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a> vous permet de faire cela, si vous
	avez activé l'interface
	<span class="emphasis"><em>Berkeley Packet Filter</em></span> (Filtre de Paquet de
	Berkeley) dans votre <a class="link" href="#kernel" title="7. src/sys/i386/conf/KERNELNAME">fichier de
	configuration du noyau</a>.</p><p>La commande</p><pre class="screen"><strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w dumpfile.bin</code></strong></pre><p>capturera 4000 paquets bruts dans le fichier
	<em class="replaceable"><code>dumpfile.bin</code></em>.  Dans cet exemple
	jusqu'à 10000 octets par paquets seront
	capturés.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="idp61820752"></a>3. L'expérience</h2></div></div></div><p>Voici l'expérience:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Ouvrez une fenêtre sur un hôte IPSec et une
	  autre sur un hôte non sécurisé.</p></li><li class="step"><p>Maintenant commencez à <a class="link" href="#tcpdump" title="2.2. Tcpdump">capturer
	  les paquets</a>.</p></li><li class="step"><p>Dans la fenêtre &#8220;sécurisée&#8221;,
	  lancez la commande <span class="trademark">UNIX</span>® <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=yes&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">yes</span>(1)</span></a>, qui fera défiler
	  le caractère <code class="literal">y</code>.  Au bout d'un moment,
	  arrêtez cela.  Passez à la fenêtre non
	  sécurisée, et faites de même.  Au bout
	  d'un moment, arrêtez.</p></li><li class="step"><p>Maintenant lancez <a class="link" href="#code" title="8. Test statistique universel de Maurer (pour une longueur de bloc=8 bits)">MUST</a> sur les
	  paquets capturés.  Vous devriez voir quelque chose de
	  semblable à ce qui suit.  Ce qui est important de noter est
	  que la connexion non sécurisée a 93% (6,7) de valeurs
	  attendues (7,18), et la connexion &#8220;normale&#8221; a 29%
	  (2,1) de valeurs attendues.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w ipsecdemo.bin</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>uliscan ipsecdemo.bin</code></strong>

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre></li></ol></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="caveat"></a>4. Mise en garde</h2></div></div></div><p>Cette expérience montre qu'IPSec <span class="emphasis"><em>semble</em></span>
      distribuer les données utiles
      <span class="emphasis"><em>uniformément</em></span> comme un chiffrement
      le devrait.  Cependant, l'expérience décrite
      ici <span class="emphasis"><em>ne peut pas</em></span> détecter les
      problèmes possibles dans un système.  Ceux-ci
      peuvent être la génération ou l'échange
      d'une clé faible, des données ou clés visibles
      par d'autres, l'utilisation d'algorithmes faibles, code du noyau
      modifié, etc...
      Etudiez les sources, maîtrisez le code.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="IPsec"></a>5. IPSec - Définition</h2></div></div></div><p>Extensions de sécurité au protocole internet
      IPv4, requises pour l'IPv6.  Un protocole pour le chiffrement et
      l'authentification au niveau IP (hôte à hôte).
      SSL sécurise uniquement une socket d'application;
      <span class="application">SSH</span> sécurise seulement une session;
      <span class="application">PGP</span> sécurise uniquement un fichier
      spécifique ou un message.  IPSec chiffre tout entre deux
      hôtes.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ipsec-install"></a>6. Installation d'IPSec</h2></div></div></div><p>La plupart des versions récentes de FreeBSD ont le support
      IPSec dans leurs sources de base.  Aussi vous devrez probablement
      ajouter l'option <code class="option">IPSEC</code> dans votre configuration de noyau
      et, après la compilation et l'installation du noyau, configurer
      les connexions IPSec en utilisant la commande
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=setkey&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">setkey</span>(8)</span></a>.</p><p>Un guide complet sur l'utilisation d'IPSec sous FreeBSD est
      fourni dans le <a class="link" href="../../books/handbook/ipsec.html" target="_top">Manuel
      de Freebsd</a>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel"></a>7. src/sys/i386/conf/KERNELNAME</h2></div></div></div><p>Ce qui suit doit être présent dans le fichier de
      configuration du noyau afin de pouvoir capturer les données
      réseau avec <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Soyez-sûr de lancer
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=config&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">config</span>(8)</span></a> après avoir rajouté la ligne
      ci-dessous, et de recompiler et réinstaller.</p><pre class="programlisting">device	bpf</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="code"></a>8. Test statistique universel de Maurer (pour une longueur de
	bloc=8 bits)</h2></div></div></div><p>Vous pouvez trouver le même code source <a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/uliscanc.txt" target="_top">
          ici</a>.</p><pre class="programlisting">/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1&lt;&lt;L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc &lt; 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i &lt; V; i++) {
    table[i] = 0;
  }

  for (i = 0; i &lt; Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run &amp;&amp; i &lt; Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b &lt; 0)
          run = 0;

        if (run) {
          if (table[b] &gt; j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i &lt; (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i &lt; Q; i++) {
        b = fgetc(fptr);
        if (b &lt; 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}</pre></div></div></body></html>