<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>10.8. Ma connexion se termine au bout de 3 minutes</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Questions Fréquemment Posées sur FreeBSD 2.X, 3.X et 4.X" /><link rel="up" href="network.html" title="Chapitre 10. Réseaux. **Mise à jour en cours**" /><link rel="prev" href="ch10s07.html" title="10.7.  Je n'arrive pas à faire marcher ppp. Où me suis-je trompé ?" /><link rel="next" href="ch10s09.html" title="10.9.  Pourquoi ppp tente de se connecter sans raison em mode -auto ?" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.8. Ma connexion se termine au bout de 3 minutes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10s07.html">Précédent</a> </td><th width="60%" align="center">Chapitre 10. Réseaux. **Mise à jour en cours**</th><td width="20%" align="right"> <a accesskey="n" href="ch10s09.html">Suivant</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="idp67869520"></a>10.8. Ma connexion se termine au bout de 3 minutes</h2></div></div></div><p>
La limite de temps (timeout) par défaut de ppp est de 3 minutes. Cela peut-être
ajusté avec les lignes :

        </p><pre class="programlisting">
set timeout NNN
        </pre><p>

        </p><p>
où <span class="emphasis"><em>NNN</em></span> est le nombre de secondes d'inactivité avant que la connexion ne
soit fermée.
Si <span class="emphasis"><em>NNN</em></span> est égal à zero, la connexion ne sera jamais fermée pour cause
de limite de temps écoulée.

Il est possible de mettre cette commande dans le fichier
<span class="emphasis"><em>ppp.conf</em></span>, ou de la taper à l'invite en mode interactif.
Il est également possible de l'ajuster au vol alors que la ligne est
active, en se connectant à la socket du serveur <span class="emphasis"><em>ppp</em></span>
en utilisant
<a class="link" href="http://www.freebsd.org/cgi/man.cgi?telnet" target="_top">telnet</a> ou
<a class="link" href="http://www.freebsd.org/cgi/man.cgi?pppctl" target="_top">pppctl</a>.
Se réferer à  la page de manuel de
<a class="link" href="http://www.freebsd.org/cgi/man.cgi?ppp" target="_top">ppp</a>
pour plus de détails.

      </p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67874896"></a>10.8.1. Ma connexion se termine lors de gros chargements.</h3></div></div></div><p>
Si vous avez activé le report de la qualité de connexion (Link Quality Reporting (LQR)),
il est possible ce soit parce que que trop de paquets LQR sont perdus entre la machine
et son interlocuteur. PPP en déduit que la ligne doit être trop
mauvaise, et se déconnecte. Avant la version 2.2.5 de FreeBSD,
LQR était activé par défaut.
Il est maintenant désactivé par défaut.
LQR peut-être désactivé avec la ligne suivante :

        </p><pre class="programlisting">
disable lqr
        </pre><p>

      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67888848"></a>10.8.2.  Ma connexion se termine après un certain temps aléatoire.  </h3></div></div></div><p>
Parfois, sur une ligne de téléphone avec des parasites, ou même
sur une ligne avec des attentes d'appels activées, le modem peut se
suspendre parce qu'il pense (de manière erronée) qu'il y a une perte du
support de connexion (lost carrier)

        </p><p>
Il y a un réglage sur la plupart des modems qui déterminent le degré de
tolérance sur la perte temporaire de la ligne porteuse. Sur un
USR Sportster par exemple, cela est mesuré par le registre S10 en
dixième de secondes. Pour rendre votre modem plus tolérant, vous
pouvez ajouter la séquence envoi-attente suivante à votre chaîne de
connexion :

        </p><pre class="programlisting">
set dial "...... ATS10=10 OK ......"
        </pre><p>

        </p><p>
Se référer au manuel de votre modem pour plus de détails.

      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67891152"></a>10.8.3.  Rien ne se passe après le message Login Ok!  </h3></div></div></div><p>
Avant la version 2.2.5 de FreeBSD, une fois la ligne établie,
<a class="link" href="http://www.freebsd.org/cgi/man.cgi?ppp" target="_top">ppp</a> devait attendre que ce soit l'autre parti (peer)
qui initialise le protocole de
contrôle de ligne (Line Control Protocol (LCP).
Or, plusieurs ISPs ne débuteront pas la négociation et attendront du client
qu'il le fasse. Pour forcer <span class="emphasis"><em>ppp</em></span>
à initialiser le LCP, utiliser la ligne suivante :

        </p><pre class="programlisting">
set openmode active
        </pre><p>

        </p><p>
<span class="emphasis"><em>Note</em></span>:
Cela ne fait pas de dégats si chacun des deux parties initialisent tous les deux
la connexion, c'est pourquoi openmode est à présent activé par défaut.
Quoiqu'il en soit, la prochaine section expliquera quand est-ce ce que
cela peut gêner.

      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67894608"></a>10.8.4.  Je n'arrête pas de voir des erreurs à propos de magic being the same </h3></div></div></div><p>
De temps en temps, juste après la connexion, vous pouvez voir des
messages dans le log qui dit "magic is the same".
Parfois ces messages sont sans conséquences, et parfois l'un ou l'autre des
partis quitte.
La plupart des implémentations ppp ne peuvent survivre à ce problème, et
même si la ligne semble venir, vous verrez régulièrement des demandes de
configuration et des accusés de réception de configuration dans le
fichier log à moins que ppp abandonne et ne ferme la connexion.
        </p><p>
Cela apparaît normallement sur les machines serveurs avec des disques
lents qui diffusent un getty sur le port, et qui exécute ppp depuis un
script ou programme de login après le login.
J'ai aussi eu vent de cela arrivant lorsqu'on utilise slirp.
La raison est qu'entre le temps où getty quitte et que ppp commence,
le ppp côté-client commence par envoyer des paquets
Line Control Protocol (LCP). Parce que l'ECHO est toujours actif
sur les ports du côté serveur, le client ppp verra ces paquets qui lui
seront "reflèté".

        </p><p>
Une partie de la négociation LCP est d'établir un nombre magique
(magic number)
de chaque côté de la ligne, ceci afin que les "réflexions" soient
détectées. Le protocole dit que lorsque  l'autre parti essaye de
négocier le même nombre magique, un NAK devrait être envoyé et un
nouveau nombre magique choisi.
Durand la période où le serveur où le port serveur a l'ECHO activé, le
client ppp envoie des paquets LCP, voit le même nombre magique dans les
paquets reflètés et il le "NAK".
Il voit aussi les reflexions de NAK (qui veut aussi dire que ppp devrait
changer son nombre magique). Cela produit potentiellement un énorme
nombre de nombre magiques à changer, chacun d'entre eux tous
s'empilant joyeusement dans le buffer stty du serveur.
Aussitôt que ppp démarre sur le serveur, il est innondé par des
changement de nombre magique et souvent décide qu'il a assez essayé
de négociation LCP et abandonne.
Pendant ce temps, le client qui ne voit alors plus de réflexions,
se réjouit juste le temps de voir que le serveur l'a déconnecté.

        </p><p>
Cela peut-être évité en autorisant l'autre parti à démarrer la
négociation avec la ligne suivante dans le fichier ppp.conf

        </p><pre class="programlisting">
set openmode passive
        </pre><p>

        </p><p>
Cela dit à ppp d'attendre que le serveur débute la négociation LCP.
Certains serveurs toutefois peuvent ne jamais initier la négociation. Si
cela est le cas, vous pouvez faire quelque chose du genre :

        </p><pre class="programlisting">
set openmode active 3
        </pre><p>

        </p><p>
Cela dit à ppp de rester passif pendant 3 secondes, et puis commencer à
envoyer les requêtes LCP/ Si l'autre parti commence à envoyer des
requêtes durant cette période, ppp répondra immédiatement plutôt qu'en
attendant que la période des 3 secondes se termine.
      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67898576"></a>10.8.5.  Les négociations LCP continuent jusqu'à ce que la connexion soit fermée.  </h3></div></div></div><p>
Cela est pour l'instant un défaut d'implémentation dans
<span class="emphasis"><em>ppp</em></span> où il n'associe pas les réponses
LCP, CCP &amp; IPCP  avec leur requête originale.
Comme conséquence, si l'une des implémentations
<span class="emphasis"><em>ppp</em></span> est  6 secondes plus lente que
l'autre côté, l'autre côté enverra 2 requêtes de configuration LCP
supplémentaire. Cela est fatal.

Soient 2 implémentations, <span class="emphasis"><em>A</em></span> et
<span class="emphasis"><em>B</em></span>.  <span class="emphasis"><em>A</em></span>
commence à envoyer des requêtes LCP immédiatement après s'être connecté
et <span class="emphasis"><em>B</em></span> met 7 secondes à démarer.
Quand <span class="emphasis"><em>B</em></span> démarre,
<span class="emphasis"><em>A</em></span> a envoyé 3 requêtes LCP.
Nous supposons que la ligne a désactivée l'ECHO, car dans le cas
contraire nous verrions des problèmes de nombres magiques comme décrit
dans la section précédente.

<span class="emphasis"><em>B</em></span> envoi un REQ, puis un ACK au premier
REQ de  <span class="emphasis"><em>A</em></span>.
Le résultat est que <span class="emphasis"><em>A</em></span> entre
dans l'état  <span class="emphasis"><em>OPENED</em></span> et envoie un ACK
(le premier) en retour à <span class="emphasis"><em>B</em></span>.
Pendant ce temps, <span class="emphasis"><em>B</em></span> renvoi 2 ACK de plus
en réponse au 2 REQ supplémentaires envoyés par
<span class="emphasis"><em>A</em></span> avant
<span class="emphasis"><em>B</em></span> que B n'ait commencé.
<span class="emphasis"><em>B</em></span> reçoit alors le premier ACK
de <span class="emphasis"><em>A</em></span> et entre dans l'état
<span class="emphasis"><em>OPENED</em></span>.
<span class="emphasis"><em>A</em></span> reçoit le deuxième ACK de
<span class="emphasis"><em>B</em></span> et revient à l'état
<span class="emphasis"><em>REQ-SENT</em></span>, et envoie un autre (quatrième)
REQ comme décrit dans la RFC.
Il envoie alors un troisième ACK et entre dans l'état
<span class="emphasis"><em>OPENED</em></span>.
Durant ce moment, <span class="emphasis"><em>B</em></span>
reçoit le quatrième REQ de  <span class="emphasis"><em>A</em></span>,
par conséquent, revient dans l'état
<span class="emphasis"><em>ACK-SENT</em></span> et envoie un autre (second)
REQ et (quatrième) ACK as per the RFC.
<span class="emphasis"><em>A</em></span> reçoit le REQ, va dans l'état
<span class="emphasis"><em>REQ-SENT</em></span> et envoie un autre REQ.
Il reçoit alors immédiatement le ACK suivant et entre dans l'état
<span class="emphasis"><em>OPENED</em></span>.
        </p><p>
Cela continue tant qu'un des partis ne s'aperçoive qu'ils n'iront
nulle part comme cela et abandonne.

        </p><p>
La meilleure façon d'éviter cela est de configurer un côté comme étant
<span class="emphasis"><em>passif</em></span> - cela fait,
faire de telle sorte qu'un des côtés attende que l'autre commence la
négociation. Cela peut-être fait par la commande :

        </p><pre class="programlisting">
set openmode passive
        </pre><p>
Faire attention avec cette option, vous devriez aussi utiliser
la commande
        </p><pre class="programlisting">
set stopped N
        </pre><p>
afin de limiter la durée avant que
<span class="emphasis"><em>ppp</em></span> attende de l'autre parti de
commencer la négociation.
D'une autre façon, la commande
        </p><pre class="programlisting">
set openmode active N
        </pre><p>

(où <span class="emphasis"><em>N</em></span> est le nombre de secondes
qu'il faut attendre avant que le démarrage de la négociation ne soit
faite). Regardez les pages de manuels pour plus de détails.
      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67918416"></a>10.8.6.  Ppp se verrouille peu après la connexion.  </h3></div></div></div><p>
Avant la version 2.2.5 de FreeBSD, il était possible que votre
ligne soit désactivée peu après la connexion, dûe à
une mauvaise négociation de compression Predictor1 de
<span class="emphasis"><em>ppp</em></span>

Cela ne devrait arriver que si
deux côtés essayent de négocier des protocoles de
contrôle de compression (
Compression Control Protocols (CCP) différents.
Ce problème est à présent résolu, mais si vous utilisez toujours une
vieille version de
<span class="emphasis"><em>ppp</em></span>,
le problème peut-être sauté avec la ligne

        </p><pre class="programlisting">
disable pred1
        </pre><p>

      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67925200"></a>10.8.7.  Ppp se verrouille quand je "shell" pour le tester.  </h3></div></div></div><p>
Quand vous exécutez le <span class="emphasis"><em>shell</em></span> ou la
commande <span class="emphasis"><em>!</em></span>,
<span class="emphasis"><em>ppp</em></span> exécute un shell (ou si vous avez
passé des arguments, <span class="emphasis"><em>ppp</em></span>
exécutera ces arguments). Ppp attendra que la commande se termine avant
de continuer. Si vous avez l'intention d'utiliser la connexion ppp
pendant que vous lancez la commande, la connexion apparaîtra
alors comme ayant été gelée.
Cela parce que <span class="emphasis"><em>ppp</em></span> attend que la
commande se termine.

        </p><p>
Si vous voulez exécuter des commandes comme cela, utilisez  plutôt la
commande <span class="emphasis"><em>!bg</em></span>.
Cela exécutera la commande en arrière plan, et ppp
pourra continuer de servir la connexion.

      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp67929808"></a>10.8.8.  Ppp sur un null-modem ne quitte jamais.  </h3></div></div></div><p>
Il n'y a aucune manière pour que <span class="emphasis"><em>ppp</em></span>
détermine automatiquement qu'une connexion directe
s'est achevée. Cela est dû aux lignes utilisées dans un câble série
null-modem. Quand on utilise cette sorte de connexion, LQR devrait
être toujours activé avec la ligne :

        </p><pre class="programlisting">
enable lqr
        </pre><p>

        </p><p>
LQR est accepté pas défaut si négocié par l'autre parti.

      </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s07.html">Précédent</a> </td><td width="20%" align="center"><a accesskey="u" href="network.html">Niveau supérieur</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10s09.html">Suivant</a></td></tr><tr><td width="40%" align="left" valign="top">10.7.  Je n'arrive pas à faire marcher ppp. Où me suis-je trompé ?   </td><td width="20%" align="center"><a accesskey="h" href="index.html">Sommaire</a></td><td width="40%" align="right" valign="top"> 10.9.  Pourquoi ppp tente de se connecter sans raison em mode -auto ?  </td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ce document, ainsi que d'autres peut être téléchargé sur
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Pour toutes questions à propos de FreeBSD, lisez la
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> avant de contacter
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Pour les questions sur cette documentation, contactez
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>