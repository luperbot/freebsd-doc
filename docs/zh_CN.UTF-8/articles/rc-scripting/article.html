<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>BSD rc.d脚本编程实战</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="初学者可能会发现，难以通过正式的文档， 基于 BSD 的 rc.d 框架，编写一些实际任务的 rc.d 脚本。 本文中，我们采用了一些复杂性不断增加的典型案例， 来展示适合每个案例的 rc.d 特性， 并探讨其中的工作原理。 这样的实验为大家进一步研究设计有效的 rc.d 应用程序提供了一些参考点。" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="zh_cn" class="article" lang="zh_cn"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp61171536"></a>BSD rc.d脚本编程实战</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">Yar</span> <span class="surname">Tikhiy</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:yar@FreeBSD.org">yar@FreeBSD.org</a>&gt;</code></p></div></div></div></div><div>修订: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2005-2006, 2012 The FreeBSD Project</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD 是 FreeBSD 基金会的注册商标</p><p>NetBSD是 NetBSD Foundation的注册商标。</p><p>许多制造商和经销商使用一些称为商标的图案或文字设计来彰显自己的产品。
  本文档中出现的， 为 FreeBSD Project 所知晓的商标，后面将以 <span class="quote">“<span class="quote">™</span>”</span> 或
  <span class="quote">“<span class="quote">®</span>”</span> 符号来标注。</p></div></div><div>   由 .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">摘要</div><p>初学者可能会发现，难以通过正式的文档，
        基于 BSD 的 <code class="filename">rc.d</code>
        框架，编写一些实际任务的 <code class="filename">rc.d</code> 脚本。
        本文中，我们采用了一些复杂性不断增加的典型案例，
        来展示适合每个案例的 <code class="filename">rc.d</code> 特性，
        并探讨其中的工作原理。
        这样的实验为大家进一步研究设计有效的
        <code class="filename">rc.d</code> 应用程序提供了一些参考点。</p></div></div></div><hr /></div><div class="toc"><div class="toc-title">目录</div><dl class="toc"><dt><span class="sect1"><a href="#rcng-intro">1. 简介</a></span></dt><dt><span class="sect1"><a href="#rcng-task">2. 任务描述</a></span></dt><dt><span class="sect1"><a href="#rcng-dummy">3. 虚拟的脚本</a></span></dt><dt><span class="sect1"><a href="#rcng-confdummy">4. 可配置的虚拟脚本</a></span></dt><dt><span class="sect1"><a href="#rcng-daemon">5. 启动并停止简单守护进程</a></span></dt><dt><span class="sect1"><a href="#rcng-daemon-adv">6. 启动并停止高级守护进程</a></span></dt><dt><span class="sect1"><a href="#rcng-hookup">7. 链接脚本到 rc.d 框架</a></span></dt><dt><span class="sect1"><a href="#rcng-args">8. 给予 rc.d 脚本更多的灵活性</a></span></dt><dt><span class="sect1"><a href="#rcng-furthur">9. 进一步阅读</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-intro"></a>1. 简介</h2></div></div></div><p>历史上 BSD 曾有过一个单一的启动脚本，
      <code class="filename">/etc/rc</code>。 该脚本在系统启动的时候被
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> 程序所引导，并执行所有多用户操作所需求的用户级任务：
      检查并挂载文件系统，设置网络，启动守护进程，等等。
      在每个系统中实际的任务清单也并不相同；
      管理员需要根据需求自定义这样的任务清单。在一些特殊的情况中，
      还不得不去修改 <code class="filename">/etc/rc</code> 文件，
      一些真正的黑客乐此不疲。</p><p>单一脚本启动方法的真正问题是它没有提供对从
      <code class="filename">/etc/rc</code> 启动的单个组件的控制。
      拿一个例子来说吧，<code class="filename">/etc/rc</code>
      不能够重新启动某个单独的守护进程。
      系统管理员不得不手动找出守护进程，并杀掉它，
      等待它真正退出后，再通过浏览 <code class="filename">/etc/rc</code>
      得到该守护进程的标识，最终输入全部命令来再次启动守护进程。
      如果重新启动的服务包括不止一个守护进程或需要更多动作的话，
      该任务将变得更加困难以及容易出错。简而言之，
      单一脚本在实现我们这样的目的上是不成功的：
      让系统管理员的生活更轻松。</p><p>再后来，为了将最重要的一些子系统独立出来，
      便尝试将部分的内容从 <code class="filename">/etc/rc</code> 分离出来了。
      最广为人知的例子就是用来启动联网的 <code class="filename">/etc/netstart</code>
      文件。它容许从单用户模式访问网络，
      但由于它的部分代码需要和一些与联网完全无关的动作交互，
      所以它并没有完美地结合到自启动的进程中。那便是为何
      <code class="filename">/etc/netstart</code> 被演变成
      <code class="filename">/etc/rc.network</code> 的原因了。
      后者不再是一个普通的脚本；它包括了庞大的，由
      <code class="filename">/etc/rc</code> 在不同的系统启动级别中调用的凌乱的
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 函数。然而，当启动任务变得多样化以及久经更改，
      <span class="quote">“<span class="quote">类模块化</span>”</span> 方法变得比曾经的整体
      <code class="filename">/etc/rc</code> 更缓慢费事。</p><p>由于没有一个干净和易于设计的框架，
      启动脚本不得不全力更改以满足飞速开发中基于 BSD 的操作系统的需求。
      它逐渐变得明朗并经过许多必要的步骤最终变成一个具有细密性和扩展性的
      <code class="filename">rc</code> 系统。BSD <code class="filename">rc.d</code>
      就这样诞生了。Luke Mewburn 和 NetBSD 社区是公认的
      <code class="filename">rc.d</code> 之父。再之后它被引入到了 FreeBSD 中。
      它的名字引用为系统单独的服务脚本的位置，也就是
      <code class="filename">/etc/rc.d</code>下面的那些脚本。
      之后我们将学习到更多的 <code class="filename">rc.d</code>
      系统的组件并看看单个脚本是如何被调用的。</p><p>BSD <code class="filename">rc.d</code>
      背后的基本理念是 <span class="emphasis"><em>良好</em></span> 的模块化和代码重用性。
      <span class="emphasis"><em>良好</em></span> 的模块化意味着每个基本
      <span class="quote">“<span class="quote">服务</span>”</span> 就象系统守护进程或原始启动任务那样，
      通过属于它们的可启动该服务的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 脚本，来停止服务，
      重载服务，检查服务的状态。具体动作由脚本的命令行参数所决定。
      <code class="filename">/etc/rc</code> 脚本仍然掌管着系统的启动，
      但现在它仅仅是使用 <code class="option">start</code> 参数来一个个调用那些小的脚本。
      这便于用 <code class="option">stop</code> 来对运行中的同样的脚本很好地执行停止任务，
      这是被 <code class="filename">/etc/rc.shutdown</code>
      脚本所完成的。看，这是多么好地体现了 Unix 的哲学：
      拥有一组小的专用的工具，每个工具尽可能好地完成自己的任务。
      <span class="emphasis"><em>代码重用</em></span> 意味着所有的通用操作由
      <code class="filename">/etc/rc.subr</code> 中的一些 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 函数所实现。
      现在一个典型的脚本只需要寥寥几行的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 代码。最终，
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 成为了 <code class="filename">rc.d</code> 框架中重要的一部分，
      它用来帮助 <code class="filename">/etc/rc</code>
      处理小脚本之间的依赖关系并有次序地运行它们。它同样帮助
      <code class="filename">/etc/rc.shutdown</code> 做类似的事情，
      因为正确的关闭次序是相对于启动的次序的。</p><p>BSD <code class="filename">rc.d</code> 的设计在
      <a class="link" href="#lukem"> Luke Mewburn 的原文 </a> 中有记录，
      以及 <code class="filename">rc.d</code> 组件也被充分详细地记录在各自的
      <a class="link" href="#manpages">联机手册</a> 中。然而，
      它可能没能清晰展现给一个 <code class="filename">rc.d</code>
      新手，如何将无数的块和片进行关联来为具体的任务创建一个好风格的脚本。
      因此本文将试着以不同的方式来讲述 <code class="filename">rc.d</code>。
      它将展示在某些典型情况中应该使用哪些特性，并阐述了为何如此。
      注意这并不是一篇 how-to 文档，我们的目的不是给出现成的配方，
      而是在展示一些简单的进入 <code class="filename">rc.d</code> 的范围的门路。
      本文也不是相关联机手册的替代品。
      阅读本文时记得同时参考联机手册以获取更完整正规的文档。</p><p>理解本文需要一些先决条件。首先，你需要熟悉
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 脚本编程语言以掌握 <code class="filename">rc.d</code>，
      还有，你需要知道系统是如何执行用户级的启动和停止任务，这些在
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 中都有说明。</p><p>本文关注的是 <code class="filename">rc.d</code> 的 FreeBSD 分支。
      不过，它可能对 NetBSD 的开发者也同样有用，因为 BSD
      <code class="filename">rc.d</code> 的两个分支不只是共享了同样的设计，
      还保留了对脚本编写者都可见的类似观点。</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-task"></a>2. 任务描述</h2></div></div></div><p>在开始打开 <code class="envar">$EDITOR</code>（编辑器）
      之前进行小小的思考不是坏事。为了给一个系统服务写一个
      <span class="quote">“<span class="quote">听话的</span>”</span> <code class="filename">rc.d</code> 脚本，
      我们首先应该能回答以下问题：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>该服务是必须性的还是可选性的？</p></li><li class="listitem"><p>脚本将为单个程序服务，如一个守护进程，还是执行更复杂的动作？</p></li><li class="listitem"><p>我们的服务依赖哪些服务？反过来哪些服务依赖我们的服务？</p></li></ul></div><p>从下面的例子中我们将看到，为什么说知道这些问题的答案是很重要的。</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-dummy"></a>3. 虚拟的脚本</h2></div></div></div><p>下面的脚本是用来在每次系统启动时发出一个信息：</p><div class="informalexample"><pre class="programlisting">#!/bin/sh<a id="rcng-dummy-shebang"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>

. /etc/rc.subr<a id="rcng-dummy-include"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>

name="dummy"<a id="rcng-dummy-name"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span>
start_cmd="${name}_start"<a id="rcng-dummy-startcmd"></a><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span>
stop_cmd=":"<a id="rcng-dummy-stopcmd"></a><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span>

dummy_start()<a id="rcng-dummy-startfn"></a><span><img src="./imagelib/callouts/6.png" alt="6" border="0" /></span>
{
	echo "Nothing started."
}

load_rc_config $name<a id="rcng-dummy-loadconfig"></a><span><img src="./imagelib/callouts/7.png" alt="7" border="0" /></span>
run_rc_command "$1"<a id="rcng-dummy-runcommand"></a><span><img src="./imagelib/callouts/8.png" alt="8" border="0" /></span></pre></div><p>需要注意的是：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-shebang"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>一个解释性的脚本应该以一行魔幻的
          <span class="quote">“<span class="quote">shebang</span>”</span> 行开头。
          该行指定了脚本的解析程序。由于 shebang 行的作用，
          假如再有可执行位的设置，
          脚本就能象一个二进制程序一样被精确地调用执行。
          （请参考 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a>。） 例如，
          一个系统管理员可以从命令行手动运行我们的脚本：</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy start</code></strong></pre><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">为了使 <code class="filename">rc.d</code> 框架正确地管理脚本，
            它的脚本需要用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 语言编写。
            如果你的某个服务或 port 套件使用了二进制控制程序或是用其它语言编写的例程，
            请将其组件安装到 <code class="filename">/usr/sbin</code>（相对于系统）
            或 <code class="filename">/usr/local/sbin</code>（相对于ports），
            然后从合适的 <code class="filename">rc.d</code> 目录的某个
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 脚本调用它。</p></div><div xmlns="" class="tip"><h3 class="admontitle">提示: </h3><p xmlns="http://www.w3.org/1999/xhtml">如果你想知道为什么 <code class="filename">rc.d</code>
            脚本必须用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 语言编写的细节，先看下
            <code class="filename">/etc/rc</code> 是如何依靠
            <code class="function">run_rc_script</code> 调用它们，
            然后再去学习 <code class="filename">/etc/rc.subr</code>
            下 <code class="function">run_rc_script</code>
            的相关实现。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-include"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>在 <code class="filename">/etc/rc.subr</code> 下，
          有许多定义过的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 函数可供每个
          <code class="filename">rc.d</code> 脚本使用。这些函数在
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 中都有说明。尽管理论上可以完全不使用
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 来编写一个 <code class="filename">rc.d</code>
          脚本，但它的函数已经证明了它真的很方便，
          并且能使任务更加的简单。所以所有人在编写
          <code class="filename">rc.d</code> 脚本时都会求助于
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 也不足为奇了。当然我们也不例外。</p><p>一个 <code class="filename">rc.d</code> 脚本在其调用
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 函数之前必须先 <span class="quote">“<span class="quote">source</span>”</span>
          <code class="filename">/etc/rc.subr</code>（用
          <span class="quote">“<span class="quote"><code class="command">.</code></span>”</span>将其包含进去），
          而使 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 程序有机会来获悉那些函数。
          首选风格是在脚本的最开始 source
          <code class="filename">/etc/rc.subr</code> 文件。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">某些有用的与联网有关的函数由另一个被包含进来的文件提供，
            <code class="filename">/etc/network.subr</code> 文件。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-name"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p><a id="name-var"></a>强制的变量
            <code class="envar">name</code> 指定我们脚本的名字。
            这是 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 所强调的。也就是，
            每个 <code class="filename">rc.d</code> 脚本在调用
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 的函数之前必须设置
            <code class="envar">name</code> 变量。</p><p>现在是时候来为我们的脚本一次性选择一个独一无二的名字了。
          在编写这个脚本的时我们将在许多地方用到它。在开始之前，
          我们来给脚本文件也取个相同的名字。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">当前的 <code class="filename">rc.d</code>
            脚本风格是把值放在双引号中来给变量赋值。
            请记住这只是个风格问题，可能并不总是这样。
            你可以在只是简单的并不包括 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
            元字符的词句中放心地省略掉引号，
            而在某些情况下你将需要使用单引号以防止
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 对任何的变量的解释。
            程序员是可以灵巧地由风格惯例获悉其语法以及使用的。
          </p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-startcmd"><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 背后主要的构思是
          <code class="filename">rc.d</code> 脚本提供处理程序，或者方法，来让
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 调用。特别是，<code class="option">start</code>，
          <code class="option">stop</code>，以及其它的 <code class="filename">rc.d</code>
          脚本参数都是这样被处理的。方法是存储在一个以
          <code class="envar"><em class="replaceable"><code>argument_cmd</code></em></code>
          形式命名的变量中的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 表达式，该
          <em class="replaceable"><code>argument</code></em>
          对应着脚本命令行中所特别指定的参数。我们稍后将看到
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 是如何为标准参数提供默认方法的。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">为了让 <code class="filename">rc.d</code> 中的代码更加统一，
            常见的是在任何适合的地方都使用 <code class="envar">${name}</code> 形式。
            这样一来，可以轻松地将一些代码从一个脚本拷贝到另一个中使用。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-stopcmd"><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span></a> </p></td><td valign="top" align="left"><p>我们应谨记 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 为标准参数提供了默认的方法。
          因此，如果希望它什么都不做的话，我们必须使用无操作的
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 表达式来改写标准的方法。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-startfn"><span><img src="./imagelib/callouts/6.png" alt="6" border="0" /></span></a> </p></td><td valign="top" align="left"><p>比较复杂的方法主体可以用函数来实现。
          在能够保证函数名有意义的情况下，这是个很不错的想法。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">强烈推荐给我们脚本中所定义的所有函数名都添加类似
            <code class="envar">${name}</code> 这样的前缀，以使它们永远不会和
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 或其它公用包含文件中的函数冲突。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-loadconfig"><span><img src="./imagelib/callouts/7.png" alt="7" border="0" /></span></a> </p></td><td valign="top" align="left"><p>这是在请求 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 载入 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量。
          尽管我们这个脚本中使用的变量并没有被其它地方使用，但由于
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 自身所控制着的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
          变量存在的原因，仍然推荐脚本去装载 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-dummy-runcommand"><span><img src="./imagelib/callouts/8.png" alt="8" border="0" /></span></a> </p></td><td valign="top" align="left"><p>通常这是 <code class="filename">rc.d</code> 脚本的最后一个命令。
          它调用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
          体系使用我们脚本所提供的变量和方法来执行相应的请求动作。</p></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-confdummy"></a>4. 可配置的虚拟脚本</h2></div></div></div><p>现在我们来给我们的虚拟脚本增加一些控制参数吧。正如你所知，
      <code class="filename">rc.d</code> 脚本是由 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 所控制的。
      幸运的是，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 隐藏了所有复杂化的东西。
      下面这个脚本使用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 通过 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
      来查看它是否在第一个地方被启用，并获取一条信息在启动时显示。
      事实上这两个任务是相互独立的。一方面，<code class="filename">rc.d</code>
      脚本要能够支持启动和禁用它的服务。另一方面，
      <code class="filename">rc.d</code> 脚本必须能具备配置信息变量。
      我们将通过下面同一脚本来演示这两方面的内容：</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

. /etc/rc.subr

name=dummy
rcvar=dummy_enable<a id="rcng-confdummy-rcvar"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>

start_cmd="${name}_start"
stop_cmd=":"

load_rc_config $name<a id="rcng-confdummy-loadconfig"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
eval "${rcvar}=\${${rcvar}:-'NO'}"<a id="rcng-confdummy-enable"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span>
dummy_msg=${dummy_msg:-"Nothing started."}<a id="rcng-confdummy-opt"></a><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span>

dummy_start()
{
	echo "$dummy_msg"<a id="rcng-confdummy-msg"></a><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span>
}

run_rc_command "$1"</pre></div><p>在这个样例中改变了什么？</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-confdummy-rcvar"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>变量 <code class="envar">rcvar</code> 指定了 ON/OFF
          开关变量的名字。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-confdummy-loadconfig"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>现在 <code class="function">load_rc_config</code> 在任何
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量被访问之前就在脚本中被预先调用。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">检查 <code class="filename">rc.d</code> 脚本时，切记 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
            会把函数延迟到其被调用时才对其中的表达式进行求值运算。
            因此尽可能晚地在 <code class="function">run_rc_command</code>
            之前调用 <code class="function">load_rc_config</code>，
            以及仍然访问从方法函数输出到
            <code class="function">run_rc_command</code> 的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
            变量并不是一个错误。这是因为方法函数将在
            <code class="function">load_rc_config</code> <span class="emphasis"><em>之后</em></span>，
            被调用的 <code class="function">run_rc_command</code> 调用。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-confdummy-enable"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>如果自身设置了 <code class="envar">rcvar</code>，
          但指示开关变量却未被设置，那么 <code class="function">run_rc_command</code>
          将发出一个警告。如果你的 <code class="filename">rc.d</code>
          脚本是为基本系统所用的，你应当在
          <code class="filename">/etc/defaults/rc.conf</code>
          中给开关变量添加一个默认的设置并将其标注在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 中。
          否则的话你的脚本应该给开关变量提供一个默认设置。
          范例中演示了一个可移植接近于后者情况的案例。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">你可以通过将开关变量设置为 ON 来使 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 有效，
            使用 <code class="literal">one</code> 或 <code class="literal">force</code>
            为脚本的参数加前缀，如 <code class="literal">onestart</code> 或
            <code class="literal">forcestop</code> 这样，会忽略其当前的设置。
            切记 <code class="literal">force</code>
            在我们下面要提到的情况下有额外的危险后果，那就是当用
            <code class="literal">one</code> 改写了 ON/OFF 开关变量。例如，
            假定 <code class="envar">dummy_enable</code> 是 <code class="literal">OFF</code>
            的，而下面的命令将忽略系统设置而强行运行
            <code class="option">start</code>方法：</p><pre xmlns="http://www.w3.org/1999/xhtml" class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy onestart</code></strong></pre></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-confdummy-opt"><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p>现在启动时显示的信息不再是硬编码在脚本中的了。
          它是由一个命名为 <code class="envar">dummy_msg</code> 的
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量所指定的。这就是 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
          变量如何来控制 <code class="filename">rc.d</code>
          脚本的一个小例子。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">我们的脚本所独占使用的所有 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量名，
            都必须具有同样的前缀：<code class="envar">${name}</code>。
            例如：<code class="envar">dummy_mode</code>，
            <code class="envar">dummy_state_file</code>，等等。</p></div><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">当可以内部使用一个简短的名字时，如 <code class="envar">msg</code>
            这样，为我们的脚本所引进的全部的共用名添加唯一的前缀
            <code class="envar">${name}</code>，能够避免我们与 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
            命名空间冲突的可能。</p><p xmlns="http://www.w3.org/1999/xhtml">只要一个 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量与其内部等同值是相同的，
            我们就能够使用一个更加兼容的表达式来设置默认值：</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">: ${dummy_msg:="Nothing started."}</pre><p xmlns="http://www.w3.org/1999/xhtml">尽管目前的风格是使用了更详细的形式。</p><p xmlns="http://www.w3.org/1999/xhtml">通常，基本系统的 <code class="filename">rc.d</code>
            脚本不需要为它们的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量提供默认值，
            因为默认值应该是在 <code class="filename">/etc/defaults/rc.conf</code>
            设置过了。但另一方面，为 ports 所用的 <code class="filename">rc.d</code>
            脚本应提供如范例所示的默认设置。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-confdummy-msg"><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span></a> </p></td><td valign="top" align="left"><p>这里我们使用 <code class="envar">dummy_msg</code>
          来实际地控制我们的脚本，即，发一个变量信息。</p></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-daemon"></a>5. 启动并停止简单守护进程</h2></div></div></div><p>我们早先说过 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 是能够提供默认方法的。
      显然，这些默认方法并不是太通用的。
      它们都是适用于大多数情况下来启动和停止一个简单的守护进程况。
      我们来假设现在需要为一个叫做 <code class="command">mumbled</code>
      的守护进程编写一个 <code class="filename">rc.d</code>脚本，
      在这里：</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command="/usr/sbin/${name}"<a id="rcng-daemon-basic-cmd"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>

load_rc_config $name
run_rc_command "$1"</pre></div><p>感到很简单吧，不是么？我们来检查下我们这个小脚本。
      只需要注意下面的这些新知识点：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-basic-cmd"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>这个 <code class="envar">command</code> 变量对于
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 来说是有意义的。当它被设置时，
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 将根据提供传统守护进程的情形而生效。
          特别是，将为这些参数提供默认的方法：
          <code class="option">start</code>，<code class="option">stop</code>，
          <code class="option">restart</code>，<code class="option">poll</code>，
          以及 <code class="option">status</code>。</p><p>该守护进程将会由运行中的 <code class="envar">$command</code>
          配合由 <code class="envar">$mumbled_flags</code> 所指定的命令行标帜来启动。
          因此，对默认的 <code class="option">start</code> 方法来说，
          所有的输入数据在我们脚本变量集合中都可用。与
          <code class="option">start</code> 不同的是，
          其他方法可能需要与进程启动相关的额外信息。举个例子，
          <code class="option">stop</code> 必须知道进程的 PID 号来终结进程。
          在目前的情况中，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 将扫描全部进程的清单，
          查找一个名字等同于 <code class="envar">$procname</code> 的进程。
          后者是另一个对 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 有意义的变量，
          并且默认它的值跟 <code class="envar">command</code> 一样。
          换而言之，当我们给 <code class="envar">command</code> 设置值后，
          <code class="envar">procname</code> 实际上也设置了同样的值。
          这启动我们的脚本来杀死守护进程并检查它是否正在第一个位置运行。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">某些程序实际上是可执行的脚本。
            系统启动脚本的解释器以传递脚本名为命令行参数的形式来运行脚本。
            然后被映射到进程列表中，这会使 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 迷惑。因此，当
            <code class="envar">$command</code> 是一个脚本的时，你应该额外地设置
            <code class="envar">command_interpreter</code> 来让 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
            知晓进程的实际名字。</p><p xmlns="http://www.w3.org/1999/xhtml">对每个 <code class="filename">rc.d</code> 脚本而言，
            有一个可选的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量给
            <code class="envar">command</code> 指示其优先级。
            它的名字是下面这样的形式：<code class="envar">${name}_program</code>，
            <code class="envar">name</code> 是我们 <a class="link" href="#name-var">之前</a>
            讨论过的必须性变量。如，在这个案例中它应该命名为
            <code class="envar">emumbled_program</code>。这其实是 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
            分配 <code class="envar">${name}_program</code> 来改写
            <code class="envar">command</code> 的。</p><p xmlns="http://www.w3.org/1999/xhtml">当然，即使 <code class="envar">command</code> 未被设置，
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 也将允许你从 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 或自身来设置
            <code class="envar">${name}_program</code>。在那种情况下，
            <code class="envar">${name}_program</code> 的特定属性丢失了，
            并且它成为了一个能供你的脚本用于其自身目的的普通变量。
            然而，单独使用 <code class="envar">${name}_program</code>
            是并不是我们所寄望的，因为同时使用它和 <code class="envar">command</code>
            已成为了 <code class="filename">rc.d</code> 脚本编程的一个惯用的约定。</p></div><p>关于默认方法的更详细的信息，请参考
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>。</p></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-daemon-adv"></a>6. 启动并停止高级守护进程</h2></div></div></div><p>我们来给之前的 <span class="quote">“<span class="quote">骨架</span>”</span>
      脚本加点 <span class="quote">“<span class="quote">血肉</span>”</span>，并让它更复杂更富有特性吧。
      默认的方法已能够为我们做很好的工作了，
      但是我们可能会需要它们一些方面的调整。
      现在我们将学习如何调整默认方法来符合我们的需要。</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command="/usr/sbin/${name}"
command_args="mock arguments &gt; /dev/null 2&gt;&amp;1"<a id="rcng-daemon-adv-args"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>

pidfile="/var/run/${name}.pid"<a id="rcng-daemon-adv-pid"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>

required_files="/etc/${name}.conf /usr/share/misc/${name}.rules"<a id="rcng-daemon-adv-reqfiles"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span>

sig_reload="USR1"<a id="rcng-daemon-adv-sig"></a><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span>

start_precmd="${name}_prestart"<a id="rcng-daemon-adv-precmd"></a><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span>
stop_postcmd="echo Bye-bye"<a id="rcng-daemon-adv-postcmd"></a><span><img src="./imagelib/callouts/6.png" alt="6" border="0" /></span>

extra_commands="reload plugh xyzzy"<a id="rcng-daemon-adv-extra"></a><span><img src="./imagelib/callouts/7.png" alt="7" border="0" /></span>

plugh_cmd="mumbled_plugh"<a id="rcng-daemon-adv-methods"></a><span><img src="./imagelib/callouts/8.png" alt="8" border="0" /></span>
xyzzy_cmd="echo 'Nothing happens.'"

mumbled_prestart()
{
	if checkyesno mumbled_smart; then<a id="rcng-daemon-adv-yn"></a><span><img src="./imagelib/callouts/9.png" alt="9" border="0" /></span>
		rc_flags="-o smart ${rc_flags}"<a id="rcng-daemon-adv-rcflags"></a><span><img src="./imagelib/callouts/10.png" alt="10" border="0" /></span>
	fi
	case "$mumbled_mode" in
	foo)
		rc_flags="-frotz ${rc_flags}"
		;;
	bar)
		rc_flags="-baz ${rc_flags}"
		;;
	*)
		warn "Invalid value for mumbled_mode"<a id="rcng-daemon-adv-warn"></a><span><img src="./imagelib/callouts/11.png" alt="11" border="0" /></span>
		return 1<a id="rcng-daemon-adv-preret"></a><span><img src="./imagelib/callouts/12.png" alt="12" border="0" /></span>
		;;
	esac
	run_rc_command xyzzy<a id="rcng-daemon-adv-run"></a><span><img src="./imagelib/callouts/13.png" alt="13" border="0" /></span>
	return 0
}

mumbled_plugh()<a id="rcng-daemon-adv-plugh"></a><span><img src="./imagelib/callouts/14.png" alt="14" border="0" /></span>
{
	echo 'A hollow voice says "plugh".'
}

load_rc_config $name
run_rc_command "$1"</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-args"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>附加给 <code class="envar">$command</code> 的参数在
          <code class="envar">command_args</code> 中进行传递。它们在
          <code class="envar">$mumbled_flags</code> 之后将被添加到命令行。
          其实际的执行便是此后最终的命令行传递给
          <code class="command">eval</code> 运算，输入和输出以及重定向都可以在
          <code class="envar">command_args</code> 中指定。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml"><span class="emphasis"><em>永远不要</em></span> 在
            <code class="envar">command_args</code> 包含破折号选项，
            类似 <code class="option">-X</code> 或 <code class="option">--foo</code>
            这样的。<code class="envar">command_args</code>
            的内容将出现在最终命令行的末尾，因此它们可能是紧接在
            <code class="envar">${name}_flags</code> 中所列出的参数后面；
            但大多的命令将不能识别出普通参数后的破折号选项。
            更好的传递附加给 <code class="envar">$command</code>
            的选项的方式是添加它们到 <code class="envar">${name}_flags</code>
            的起始处。另一种方法是像后文所示的那样来修改
            <code class="envar">rc_flags</code>。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-pid"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>一个得体的守护进程会创建一个
          <span class="emphasis"><em>pidfile</em></span> 进程文件，
          以使其进程能够更容易更可靠地被找到。如果设置了
          <code class="envar">pidfile</code> 变量，告诉 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
          哪里能找到供其默认方法所使用的
          <code class="envar">pidfile</code> 进程文件。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">事实上，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
            在启动一个守护进程前还会使用 pidfile
            进程文件来查看它是否已经在运行。使用了
            <code class="option">faststart</code> 参数可以跳过这个检查步骤。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-reqfiles"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>如果守护进程只有在确定的文件存在的情况下才可以运行，
          那就将它们列到 <code class="envar">required_files</code> 中，而
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 将在启动守护进程之前检查那些文件是否存在。
          还有相关的分别用来检查目录和环境变量的
          <code class="envar">required_dirs</code> 和 <code class="envar">required_vars</code>
          可供使用。它们都在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 中有详细的说明。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">来自 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 的默认方法，通过使用
            <code class="option">forcestart</code> 作为脚本的参数，
            可以强制性地跳过预先需要的检查。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-sig"><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p>我们可以在守护进程有异常的时候，自定义发送给守护进程的信号。
          特别是，<code class="envar">sig_reload</code>
          指定了使守护进程重新装载其配置的信号；默认情况也就是
          <span class="symbol">SIGHUP</span> 信号。
          另一个信号是发送给守护进程以停止该进程；默认情况下是
          <span class="symbol">SIGTERM</span> 信号，但这是可以通过设置
          <code class="envar">sig_stop</code> 来进行适当更改的。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">信号名称应当以不包含 <code class="literal">SIG</code>
            前缀的形式指定给 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>，就如范例中所示的那样。
            FreeBSD 版本的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> 程序能够识别出
            <code class="literal">SIG</code> 前缀，不过其它系统版本的就不一定了。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-precmd"><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span></a> <a href="#rcng-daemon-adv-postcmd"><span><img src="./imagelib/callouts/6.png" alt="6" border="0" /></span></a> </p></td><td valign="top" align="left"><p>在默认的方法前面或后面执行附加任务是很容易的。
          对于我们脚本所支持的每条命令参数而言，我们可以定义
          <code class="envar"><em class="replaceable"><code>argument</code></em>_precmd</code> 和
          <code class="envar"><em class="replaceable"><code>argument</code></em>_postcmd</code>
          来完成。这些 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 命令分别在它们各自的方法前后被调用，
          显然，从它们各自的名字就能看出来。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">如果我们需要的话，用自定义的
            <code class="envar"><em class="replaceable"><code>argument</code></em>_cmd</code>
            改写默认的方法，并不妨碍我们仍然使用
            <code class="envar"><em class="replaceable"><code>argument</code></em>_precmd</code> 和
            <code class="envar"><em class="replaceable"><code>argument</code></em>_postcmd</code>。
            特别是，前者便于检查自定义的方法，
            以及执行自身命令之前所遇到更严密的条件。于是，将
            <code class="envar"><em class="replaceable"><code>argument</code></em>_precmd</code> 和
            <code class="envar"><em class="replaceable"><code>argument</code></em>_cmd</code>
            一起使用，使我们合理地将检查从动作中独立了出来。</p><p xmlns="http://www.w3.org/1999/xhtml">别忘了你可以将任意的有效的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
            表达式插入到方法和你定义的 pre- 与 post-commands 命令中。
            在大部分情况下，调用函数使实际任务有好的风格，
            但千万不要让风格限制了你对其幕后到底是怎么回事的思考。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-extra"><span><img src="./imagelib/callouts/7.png" alt="7" border="0" /></span></a> </p></td><td valign="top" align="left"><p>如果我们愿意实现一些自定义参数，
          这些参数也可被认作为我们脚本的 <span class="emphasis"><em>命令</em></span>，我们需要在
          <code class="envar">extra_commands</code> 中将它们列出并提供方法以处理它们。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml"><code class="option">reload</code> 是个特别的命令。一方面，
            它有一个在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 中预置的方法。另一方面，
            <code class="option">reload</code> 命令默认是不被提供的。
            理由是并非所有的守护进程都使用同样的重载方法，
            并且有些守护进程根本没有任何东西可重载的。所以显而易见，
            我们需要去询问都提供了哪些的内建功能。我们可以通过
            <code class="envar">extra_commands</code> 来这样做。</p><p xmlns="http://www.w3.org/1999/xhtml">我们从 <code class="option">reload</code> 的默认方法得到了什么呢？
            守护进程常常在收到一个信号后重新载入它们的配置 ──
            一般来说，也就是 <span class="symbol">SIGHUP</span> 信号。因此
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 尝试发送一个信号给守护进程来重载它。
            该信号一般预设为 <span class="symbol">SIGHUP</span>，
            但是如果必要的话可以通过 <code class="envar">sig_reload</code>
            变量来自定义它。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-methods"><span><img src="./imagelib/callouts/8.png" alt="8" border="0" /></span></a> <a href="#rcng-daemon-adv-plugh"><span><img src="./imagelib/callouts/14.png" alt="14" border="0" /></span></a> </p></td><td valign="top" align="left"><p>我们的脚本提供了两个非标准的命令，
          <code class="option">plugh</code> 和 <code class="option">xyzzy</code>。
          我们看到它们在 <code class="envar">extra_commands</code> 中被列出来了，
          并且现在是时候给它们提供方法了。<code class="option">xyzzy</code>
          的方法是内联的而 <code class="option">plugh</code> 的是以
          <code class="function">mumbled_plugh</code> 形式完成的函数。</p><p>非标准命令在启动或停止的时候不被调用。
          通常它们是为了系统管理员的方便。它们还能被其它的子系统所使用，
          例如，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>，前提是 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">devd.conf</span>(5)</span></a> 中已经指定了。</p><p>全部可用命令的列表，当脚本不加参数地调用时，在
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 打印出的使用方法中能够找到。例如，
          这就是供学习的脚本用法的内容：</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/mumbled</code></strong>
Usage: /etc/rc.d/mumbled [fast|force|one](start|stop|restart|rcvar|reload|plugh|xyzzy|status|poll)</pre></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-run"><span><img src="./imagelib/callouts/13.png" alt="13" border="0" /></span></a> </p></td><td valign="top" align="left"><p>如果脚本需要的话，它可以调用自己的标准或非标准的命令。
          这可能看起来有点像函数的调用，但我们知道，命令和 shell
          函数并非一直都是同样的东西。举个例子，<code class="command">xyzzy</code>
          在这里不是以函数来实现的。另外，还有应该被有序调用的
          pre-command 预置命令和 post-command 后置命令。
          所以脚本运行自己命令的合适方式就是利用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>，
          就像范例中展示的那样。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-yn"><span><img src="./imagelib/callouts/9.png" alt="9" border="0" /></span></a> </p></td><td valign="top" align="left"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 提供了一个方便的函数叫做
          <code class="function">checkyesno</code>。
          它以一个变量名作为参数并返回一个为零的退出值，
          当且仅当该变量设置为 <code class="literal">YES</code>，或
          <code class="literal">TRUE</code>，或 <code class="literal">ON</code>，或
          <code class="literal">1</code>，区分大小写；否则返回一个非零的退出值。
          在第二种情况中，函数测试变量的设置为 <code class="literal">NO</code>，
          <code class="literal">FALSE</code>，<code class="literal">OFF</code>，或
          <code class="literal">0</code>，区分大小写；
          如果变量包含别的内容的话它打印一条警告信息，例如，垃圾。</p><p>切记对 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 而言零值意味着真而非零值意味着假。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml"><code class="function">checkyesno</code> 函数使用一个
            <span class="emphasis"><em>变量名</em></span>。不要扩大含义将变量的
            <span class="emphasis"><em>值</em></span> 传递给它；
            否则它不会如你预期那样的工作。</p><p xmlns="http://www.w3.org/1999/xhtml">下面是 <code class="function">checkyesno</code>
            的合理使用范围：</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">if checkyesno mumbled_enable; then
        foo
fi</pre><p xmlns="http://www.w3.org/1999/xhtml">相反地，以下面的方式调用 <code class="function">checkyesno</code>
            是不会工作的 -- 至少是不会如你预期的那样：</p><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting">if checkyesno "${mumbled_enable}"; then
        foo
fi</pre></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-rcflags"><span><img src="./imagelib/callouts/10.png" alt="10" border="0" /></span></a> </p></td><td valign="top" align="left"><p>我们可以通过修改 <code class="envar">$start_precmd</code> 中的
          <code class="envar">rc_flags</code> 来影响传递到
          <code class="envar">$command</code> 的标帜。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-warn"><span><img src="./imagelib/callouts/11.png" alt="11" border="0" /></span></a> </p></td><td valign="top" align="left"><p>某种情况下我们可能需要发出一条重要的信息，那样的话
          <span class="application">syslog</span> 可以很好地记录日志。
          这可以使用下列 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 函数来轻松完成：
          <code class="function">debug</code>，<code class="function">info</code>，
          <code class="function">warn</code>，以及 <code class="function">err</code>。
          后者以指定的代码值退出脚本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-daemon-adv-preret"><span><img src="./imagelib/callouts/12.png" alt="12" border="0" /></span></a> </p></td><td valign="top" align="left"><p>方法的退出值和它们的 pre-commands 预命令不只是默认被忽略掉。如果
          <code class="envar"><em class="replaceable"><code>argument</code></em>_precmd</code>
          返回了一个非零退出值，主方法将不会被执行。依次地是，
          <code class="envar"><em class="replaceable"><code>argument</code></em>_postcmd</code>
          将不会被调用，除非主方法返回的是一个为零的退出值。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">然而，当给一个参数使用 <code class="literal">force</code>
            前缀的时候，如 <code class="option">forcestart</code>，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
            会听从命令行指示而忽略那些退出值最后仍然调用所有的命令。</p></div></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-hookup"></a>7. 链接脚本到 rc.d 框架</h2></div></div></div><p>当编写好了一个脚本，它需要被整合到 <code class="filename">rc.d</code> 中去。
      一个重要的步骤就是安装脚本到 <code class="filename">/etc/rc.d</code>
      （对基本系统而言）或 <code class="filename">/usr/local/etc/rc.d</code>
      （对ports而言）中去。在 &lt;<code class="filename">bsd.prog.mk</code>&gt; 和
      &lt;<code class="filename">bsd.port.mk</code>&gt; 中都为此提供了方便的接口，
      通常你不必担心适当的所有权限和模式。系统脚本应当是通过可以在
      <code class="filename">src/etc/rc.d</code> 找到的 <code class="filename">Makefile</code>
      安装的。Port 脚本可以像
      <a class="link" href="../../../../doc/en_US.ISO8859-1/books/porters-handbook/rc-scripts.html" target="_top">Porter's Handbook</a>
      中描述那样通过使用 <code class="varname">USE_RC_SUBR</code> 来被安装。</p><p>不过，我们应该预先考虑到我们脚本在系统启动顺序中的位置。
      我们的脚本所处理的服务可能依赖于其它的服务。举个例子，
      没有网络接口和路由选择的启用运行的话，一个网络守护进程是不起作用的。
      即使一个服务看似什么都不需要，在基本文件系统检查挂载完毕之前也很难启动。</p><p>之前我们曾提到过 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a>。现在是时候来密切地关注下它了。
      笼统地说，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 处理一组文件，检验它们的内容，
      并从文件集合打印一个文件列表的依赖顺序到 <code class="varname">stdout</code>
      标准输出。这点是用于保持文件内部的依赖信息，
      而每个文件只能说明自己的依赖。一个文件可以指定如下信息：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>它 <span class="emphasis"><em>提供</em></span> 的 <span class="quote">“<span class="quote">条件</span>”</span>
          的名字（意味着我们服务的名字）；</p></li><li class="listitem"><p>它 <span class="emphasis"><em>需求</em></span> 的
          <span class="quote">“<span class="quote">条件</span>”</span> 的名字；</p></li><li class="listitem"><p>应该 <span class="emphasis"><em>先</em></span> 运行的文件的
          <span class="quote">“<span class="quote">条件</span>”</span>的名字；</p></li><li class="listitem"><p>能用于从全部文件集合中选择一个子集的额外
          <span class="emphasis"><em>关键字</em></span>（ <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a>
          可通过选项而被指定来包括或省去由特殊关键字所列出的文件。）</p></li></ul></div><p>并不奇怪的是，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 只能处理接近 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
      语法的文本文件。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 所解读的特殊行看起来类似
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 的注释。这种特殊文本行的语法相当严格地简化了其处理。
      请查阅 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 以获取更详细的信息。</p><p>除使用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 的特殊行以外，
      脚本可以坚持将其依赖的其它服务强制性启动。当其它服务是可选的，
      并因系统管理员错误地在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
      中禁用掉该服务而使其不能自行启动时，会需要这一点。</p><p>将这些谨记在心，我们来考虑下简单结合了依赖信息增强的守护进程脚本：</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

# PROVIDE: mumbled oldmumble <a id="rcng-hookup-provide"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
# REQUIRE: DAEMON cleanvar frotz<a id="rcng-hookup-require"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
# BEFORE:  LOGIN<a id="rcng-hookup-before"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span>
# KEYWORD: nojail shutdown<a id="rcng-hookup-keyword"></a><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span>

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command="/usr/sbin/${name}"
start_precmd="${name}_prestart"

mumbled_prestart()
{
	if ! checkyesno frotz_enable &amp;&amp; \
	    ! /etc/rc.d/frotz forcestatus 1&gt;/dev/null 2&gt;&amp;1; then
		force_depend frotz || return 1<a id="rcng-hookup-force"></a><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span>
	fi
	return 0
}

load_rc_config $name
run_rc_command "$1"</pre></div><p>跟前面一样，做如下详细分析：</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-hookup-provide"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>该行声明了我们脚本所提供的 <span class="quote">“<span class="quote">条件</span>”</span> 的名字。
          现在其它脚本可以用那些名字来标明我们脚本的依赖。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">通常脚本指定一个单独的已提供的条件。然而，
            并没有什么妨碍我们从列出的那些条件中指定，例如，
            为了兼容性的目的。</p><p xmlns="http://www.w3.org/1999/xhtml">在其它情况，主要的名称，或者说唯一的，
            <code class="literal">PROVIDE:</code> 条件应该与
            <code class="envar">${name}</code> 相同。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-hookup-require"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> <a href="#rcng-hookup-before"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>因此我们的脚本指示了其依赖于别的脚本所提供的
          <span class="quote">“<span class="quote">条件</span>”</span>。根据这些行的信息，脚本请示
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 以将其放在一个或多个提供
          <code class="filename">DAEMON</code> 和 <code class="filename">cleanvar</code>
          的脚本后面，但在提供 <code class="filename">LOGIN</code> 的脚本前面。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml"><code class="literal">BEFORE:</code>
            这一行不可以在其它脚本不完整的依赖关系列表中滥用。
            适合使用 <code class="literal">BEFORE:</code>
            的情况是当其它脚本不关心我们的脚本，
            但是我们的脚本如果在另一个之前运行的话能够更好地执行任务。
            一个典型的实例是网络接口和防火墙：
            虽然接口不依赖防火墙来完成自己的工作，
            但是系统安全将因一切网络流量之前启动的防火墙而受益。</p><p xmlns="http://www.w3.org/1999/xhtml">除了条件相对应的每个单独服务，脚本使用元条件和它们的
            <span class="quote">“<span class="quote">占位符</span>”</span> 来保证某个操作组在其它之前被执行。
            这些是由 <code class="filename">UPPERCASE</code>
            大写名字所表示的。它们的列表和用法可以在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 中找到。</p><p xmlns="http://www.w3.org/1999/xhtml">切记将一个服务名称放进 <code class="literal">REQUIRE:</code>
            行不能保证实际的服务会在我们的脚本启动的时候运行。
            所需求的服务可能会启动失败或在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 中被禁掉了。
            显然，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 是无法追踪这些细节的，并且
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 也不会去追踪。所以，
            脚本启动的应用程序应当能够应付任何所需求的服务的不可用情况。
            某些情况下，我们可以用 <a class="link" href="#forcedep">下面</a>
            所讨论的方式来协助脚本。</p></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-hookup-keyword"><span><img src="./imagelib/callouts/4.png" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p><a id="keywords"></a>如我们从上述文字所记起的，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a>
            关键字可以用来选择或省略某些脚本。即任何 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a>
            用户可以通过指定 <code class="option">-k</code> 和 <code class="option">-s</code>
            选项来分别指定 <span class="quote">“<span class="quote">保留清单（keep list）</span>”</span> 和
            <span class="quote">“<span class="quote">跳过清单（skip list）</span>”</span>。
            从全部文件到按依赖关系排列的清单，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a>
            将只是挑出保留清单（除非是空的）
            中那些带关键字的以及从跳过清单中挑出不带关键字的文件。</p><p>在 FreeBSD 中，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 被
          <code class="filename">/etc/rc</code> 和
          <code class="filename">/etc/rc.shutdown</code> 所使用。
          这两个脚本定义了 FreeBSD 中 <code class="filename">rc.d</code>
          关键字以及它们的意义的标准列表如下：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">nojail</code></span></dt><dd><p>该服务不适用于 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=jail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">jail</span>(8)</span></a> 环境。
                如果是在 jail 的内部的话，自动启动和关闭程序将忽略该脚本。</p></dd><dt><span class="term"><code class="literal">nostart</code></span></dt><dd><p>该服务只能手动启动否则将不会启动。
                自动启动程序将忽略此脚本。结合 <code class="literal">shutdown</code>
                关键字的话，这可以用来编写只在系统关闭时执行一些任务的脚本。</p></dd><dt><span class="term"><code class="literal">shutdown</code></span></dt><dd><p>这个关键字 <span class="emphasis"><em>明确</em></span>
                地列出了需要在系统关闭前停止的服务。</p><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">当系统即将关闭的时候，
                  <code class="filename">/etc/rc.shutdown</code> 在运行。
                  它假定认为大部分的 <code class="filename">rc.d</code>
                  脚本在那刻什么都不做。因此，
                  <code class="filename">/etc/rc.shutdown</code>
                  选择性地调用带有 <code class="literal">shutdown</code>
                  关键字的 <code class="filename">rc.d</code> 脚本，
                  有效地忽略其余的脚本。为了更快的关闭，
                  <code class="filename">/etc/rc.shutdown</code> 传递
                  <code class="option">faststop</code> 命令给其运行的脚本，
                  以跳过预置的检查，例如，进程文件 pidfile 的检查。
                  正如依赖性服务应该在其所依赖的服务之前停止，
                  <code class="filename">/etc/rc.shutdown</code>
                  以相反的依赖次序来运行这些脚本。</p><p xmlns="http://www.w3.org/1999/xhtml">如果写一个真正的 <code class="filename">rc.d</code> 脚本的话，
                  你应当考虑到其是否与系统关闭时有关系。例如，
                  如果你的脚本只通过响应 <code class="option">start</code>
                  命令来运行任务，那么你不需要包含这个关键字。然而，
                  如果你的脚本管理着一个服务，那么，在系统进入 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=halt&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">halt</span>(8)</span></a>
                  中所描述的其本身关闭顺序的最终阶段之前停止该脚本，
                  可能是个不错的主意。特别是，
                  你显然是应该关闭一个需要相当长时间，
                  或需要特定的动作才能干净地关闭的服务。
                  数据库引擎就是这样一个典型的例子。</p></div></dd></dl></div></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-hookup-force"><span><img src="./imagelib/callouts/5.png" alt="5" border="0" /></span></a> </p></td><td valign="top" align="left"><p><a id="forcedep"></a>以
            <code class="function">force_depend</code>
            起始的行应被用于更谨慎的情况。通常，用于修正相互关联的
            <code class="filename">rc.d</code>
            脚本分层结构的配置文件时会更加稳妥。</p><p>如果你仍不能完成不含 <code class="function">force_depend</code> 的脚本，
          范例提供了一个如何有条件地调用它的习惯用法。在范例中，我们的
          <code class="command">mumbled</code> 守护进程需求另一个以高级方式启动的进程，
          <code class="command">frotz</code>。但 <code class="command">frotz</code> 也是可选的；
          而且 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 对这些信息是一无所知的。幸运的是，
          我们的脚本已访问到全部的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 变量。如果
          <code class="envar">frotz_enable</code> 为真，我们希望的最好结果是依靠
          <code class="filename">rc.d</code> 已经启动了 <code class="command">frotz</code>。
          否则我们强制检查 <code class="command">frotz</code> 的状态。最终，
          如果 <code class="command">frotz</code> 依赖的服务没有找到或运行的话，
          我们将强制其运行。这时 <code class="function">force_depend</code>
          将发出一条警告信息，因为它只应该在检查到配置信息丢失的情况下被调用。</p></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-args"></a>8. 给予 rc.d 脚本更多的灵活性</h2></div></div></div><p>当进行启动或停止的调用时，<code class="filename">rc.d</code>
      脚本应该作用于其所负责的整个子系统。例如，
      <code class="filename">/etc/rc.d/netif</code> 应该启动或停止
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 中所描述的全部网络接口。每个任务都唯一地听从一个如
      <code class="option">start</code> 或 <code class="option">stop</code>
      这样的单独命令参数的指示。在启动和停止之间的时间，
      <code class="filename">rc.d</code> 脚本帮助管理员控制运行中的系统，
      并其在需要的时候它将产生更多的灵活性和精确性。举个例子，
      管理员可能想在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 中添加一个新网络接口的配置信息，
      然后在不妨碍其它已存在接口的情况下将其启动。
      在下次管理员可能需要关闭一个单独的网络接口。在魔幻的命令行中，
      对应的 <code class="filename">rc.d</code> 脚本调用一个额外的参数，
      网络接口名即可。</p><p>幸运的是，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 允许传递任意多（取决于系统限制）的参数给脚本的方法。
      由于这个原因，脚本自身的改变可以说是微乎其微。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 如何访问到附加的命令行参数呢？直接获取么？
      并非是无所不用其极的。首先，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
      函数没有访问到调用者的定位参数，而 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>
      只是这些函数的容器。其次，<code class="filename">rc.d</code>
      指令的一个好的风格是由主函数来决定将哪些参数传递给它的方法。</p><p>所以 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 提供了如下的方法：
      <code class="function">run_rc_command</code>
      传递其所有参数但将第一个参数逐字传递到各自的方法。首先，
      发出以方法自身为名字的参数：<code class="option">start</code>，
      <code class="option">stop</code>，等等。这会被
      <code class="function">run_rc_command</code> 移出，
      这样命令行中原本 <code class="envar">$2</code> 的内容将作为
      <code class="envar">$1</code> 来提供给方法，等等。</p><p>为了说明这点，我们来修改原来的虚拟脚本，
      这样它的信息将取决于所提供的附加参数。从这里出发：</p><div class="informalexample"><pre class="programlisting">#!/bin/sh

. /etc/rc.subr

name="dummy"
start_cmd="${name}_start"
stop_cmd=":"
kiss_cmd="${name}_kiss"
extra_commands="kiss"

dummy_start()
{
        if [ $# -gt 0 ]; then<a id="rcng-args-start"></a><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span>
                echo "Greeting message: $*"
        else
                echo "Nothing started."
        fi
}

dummy_kiss()
{
        echo -n "A ghost gives you a kiss"
        if [ $# -gt 0 ]; then<a id="rcng-args-kiss"></a><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span>
                echo -n " and whispers: $*"
        fi
        case "$*" in
        *[.!?])
                echo
                ;;
        *)
                echo .
                ;;
        esac
}

load_rc_config $name
run_rc_command "$@"<a id="rcng-args-all"></a><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></pre></div><p>能注意到脚本里发生了那些实质性改变么？</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-args-start"><span><img src="./imagelib/callouts/1.png" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>你输入的所有在 <code class="option">start</code>
          之后的参数可以被当作各自方法的定位参数一样被终结。
          我们可以根据我们的任务、技巧和想法来以任何方式使用他们。
          在当前的例子中，我们只是以下行中字符串的形式传递参数给
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=echo&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">echo</span>(1)</span></a> 程序 ── 注意 <code class="envar">$*</code>
          是有双引号的。这里是脚本如何被调用的：</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy start</code></strong>
Nothing started.
<code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy start Hello world!</code></strong>
Greeting message: Hello world!</pre></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-args-kiss"><span><img src="./imagelib/callouts/2.png" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>同样用于我们脚本提供的任何方法，并不仅限于标准的方法。
          我们已经添加了一个自定义的叫做 <code class="option">kiss</code> 的方法，
          并且它给附加参数带来的戏耍决不亚于 <code class="option">start</code>。
          例如：</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy kiss</code></strong>
A ghost gives you a kiss.
<code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/dummy kiss Once I was Etaoin Shrdlu...</code></strong>
A ghost gives you a kiss and whispers: Once I was Etaoin Shrdlu...</pre></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#rcng-args-all"><span><img src="./imagelib/callouts/3.png" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>如果我们只是传递所有附加参数给任意的方法，
          我们只需要在脚本的最后一行我们调用
          <code class="function">run_rc_command</code> 的地方，
          用 <code class="literal">"$@</code> 代替 <code class="literal">"$1"</code> 即可。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">一个 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a> 程序员应该是可以理解
            <code class="envar">$*</code> 和 <code class="envar">$@</code>
            的微妙区别只是指定全部定位参数的不同方法。
            关于此更深入的探讨，可以参考这个很好的 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sh</span>(1)</span></a>
            脚本编程手册。在你完全理解这些表达式的意义之前请不要使用它们，
            因为误用它们将给脚本引入缺陷和不安全的弊端。</p></div><div xmlns="" class="note"><h3 class="admontitle">注意: </h3><p xmlns="http://www.w3.org/1999/xhtml">现在 <code class="function">run_rc_command</code> 可能有个缺陷，
            它将影响保持参数之间的原本边界。也就是，
            带有嵌入空白的参数可能不会被正确处理。该缺陷是由于对
            <code class="envar">$*</code> 的误用。</p></div></td></tr></table></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rcng-furthur"></a>9. 进一步阅读</h2></div></div></div><p><a id="lukem"></a><a class="link" href="http://www.mewburn.net/luke/papers/rc.d.pdf" target="_top">
          Luke Mewburn 的原始文章</a> 中讲述了
        <code class="filename">rc.d</code> 的基本概要，
        并详细阐述了其设计方案的原理。该文章提供了深入了解整个
        <code class="filename">rc.d</code> 框架以及其所在的现代 BSD
        操作系统的内容。</p><p><a id="manpages"></a>在 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>，<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a>，
        还有 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcorder&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rcorder</span>(8)</span></a> 的联机手册中，对
        <code class="filename">rc.d</code> 组件做了非常详细的记载。
        在你写脚本时，如果不去学习和参考这些联机手册的话，
        你是无法完全发挥出 <code class="filename">rc.d</code> 的能量的。</p><p>工作中实际范例的主要来源就是运行的系统中的
      <code class="filename">/etc/rc.d</code> 目录。
      它的内容可读性非常好，因为大部分的枯燥的内容都深藏在
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.subr&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc.subr</span>(8)</span></a> 中了。切记 <code class="filename">/etc/rc.d</code>
      的脚本也不是神仙写出来的，
      所以它们可能也存在着代码缺陷以及低级的设计方案。
      但现在你可以来改进它们了！</p></div></div></body></html>