<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>3.3. 使用Kobj</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 系统结构手册" /><link rel="up" href="kernel-objects.html" title="第 3 章 内核对象" /><link rel="prev" href="kernel-objects-operation.html" title="3.2. Kobj的工作流程" /><link rel="next" href="jail.html" title="第 4 章 Jail子系统" /><link rel="copyright" href="trademarks.html" title="法律声明" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. 使用Kobj</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kernel-objects-operation.html">上一页</a> </td><th width="60%" align="center">第 3 章 内核对象</th><td width="20%" align="right"> <a accesskey="n" href="jail.html">下一页</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel-objects-using"></a>3.3. 使用Kobj</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64627408"></a>3.3.1. 结构</h3></div></div></div><pre class="programlisting">struct kobj_method</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64630608"></a>3.3.2. 函数</h3></div></div></div><pre class="programlisting">void kobj_class_compile(kobj_class_t cls);
void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);
void kobj_class_free(kobj_class_t cls);
kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);
void kobj_init(kobj_t obj, kobj_class_t cls);
void kobj_delete(kobj_t obj, struct malloc_type *mtype);</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64662480"></a>3.3.3. 宏</h3></div></div></div><pre class="programlisting">KOBJ_CLASS_FIELDS
KOBJ_FIELDS
DEFINE_CLASS(name, methods, size)
KOBJMETHOD(NAME, FUNC)</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64664528"></a>3.3.4. 头文件</h3></div></div></div><pre class="programlisting">&lt;sys/param.h&gt;
&lt;sys/kobj.h&gt;</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64667600"></a>3.3.5. 建立一个接口的模板</h3></div></div></div><a id="idp64669392" class="indexterm"></a><p>使用Kobj的第一步是建立一个接口。建立接口包括建立模板的工作。
       建立模板可用脚本<code class="filename">src/sys/kern/makeobjops.pl</code>完成，
       它会产生申明方法的头文件和代码，脚本还会生成方法查找函数。</p><p>在这个模板中如下关键词会被使用:
        <code class="literal">#include</code>, <code class="literal">INTERFACE</code>,
        <code class="literal">CODE</code>, <code class="literal">METHOD</code>,
        <code class="literal">STATICMETHOD</code>, 和
        <code class="literal">DEFAULT</code>.</p><p><code class="literal">#include</code>语句的整行内容将被一字不差的
        复制到被生成的代码文件的头部。</p><p>例如:</p><pre class="programlisting">#include &lt;sys/foo.h&gt;</pre><p>关键词<code class="literal">INTERFACE</code>用来定义接口名。
        这个名字将与每个方法名接合在一起，形成 [interface name]_[method name]。
        语法是：INTERFACE [接口名];</p><p>例如:</p><pre class="programlisting">INTERFACE foo;</pre><p>关键词<code class="literal">CODE</code>会将它的参数一字不差的复制到代码文件中。
      语法是<code class="literal">CODE { [任何代码] };</code></p><p>例如:</p><pre class="programlisting">CODE {
	struct foo * foo_alloc_null(struct bar *)
	{
		return NULL;
}
};</pre><p>关键词<code class="literal">METHOD</code>用来描述一个方法。语法是:
      <code class="literal">METHOD [返回值类型] [方法名] { [对象 [,
      参数若干]] };</code></p><p>例如:</p><pre class="programlisting">METHOD int bar {
	struct object *;
	struct foo *;
	struct bar;
};</pre><p>关键词<code class="literal">DEFAULT</code>跟在关键词<code class="literal">METHOD</code>之后，
        是对关键词<code class="literal">METHOD</code>的补充。它给这个方法补充上缺省函数。语法是：
        <code class="literal">METHOD [返回值类型] [方法名] {
        [对象; [其它参数]] }DEFAULT [缺省函数];
                  </code></p><p>例如:</p><pre class="programlisting">METHOD int bar {
	struct object *;
	struct foo *;
	int bar;
} DEFAULT foo_hack;</pre><p>关键词<code class="literal">STATICMETHOD</code>类似关键词<code class="literal">METHOD</code>。
        对于每个Kobj对象，一般其头部都有一些Kobj专有的数据。
        <code class="literal">METHOD</code>定义的方法就假设这些专有数据位于对象头部；
        假如对象头部没有这些专有数据，这些方法对这个对象的访问就可能出错。
        而<code class="literal">STATICMETHOD</code>定义的对象可以不受这个限制：
        这样描述出的方法，其操作的数据不由这个类的某个对象实例给出，
        而是全都由调用这个方法时的操作数(译者注:即参数)给出。
        这也对于在某个类的方法表之外调用这个方法有用。
	</p><div xmlns="" class="tip"><h3 class="admontitle">译者注: </h3><p xmlns="http://www.w3.org/1999/xhtml">这一段的语言与原文相比调整很大。
        静态方法是不依赖于对象实例的方法。
        参看C++类中的“静态函数”的概念。</p></div><p>其它完整的例子:</p><pre class="programlisting">src/sys/kern/bus_if.m
src/sys/kern/device_if.m</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64718672"></a>3.3.6. 建立一个类</h3></div></div></div><a id="idp64719824" class="indexterm"></a><p>使用Kobj的第二步是建立一个类。一个类的组有名字、方法表；
        假如使用了Kobj的“对象管理工具”(Object Handling Facilities)，
        类中还包含对象的大小。建立类时使用宏<code class="function">DEFINE_CLASS()</code>。
        建立方法表时，须建立一个kobj_method_t数组，用NULL项结尾。
        每个非NULL项可用宏<code class="function">KOBJMETHOD()</code>建立。</p><p>例如:</p><pre class="programlisting">DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));

kobj_method_t foomethods[] = {
	KOBJMETHOD(bar_doo, foo_doo),
	KOBJMETHOD(bar_foo, foo_foo),
	{ NULL, NULL}
};</pre><p>类须被<span class="quote">“<span class="quote">编译</span>”</span>。根据该类被初始化时系统的状态，
        将要用到一个静态分配的缓存和<span class="quote">“<span class="quote">操作数表</span>”</span>(ops table，
        译者注：即<span class="quote">“<span class="quote">参数表</span>”</span>)。这些操作可通过声明一个结构体
        <code class="varname">struct kobj_ops</code>并使用
        <code class="function">kobj_class_compile_static()</code>，
        或是只使用<code class="function">kobj_class_compile()</code>来完成。</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64742096"></a>3.3.7. 建立一个对象</h3></div></div></div><a id="idp64743120" class="indexterm"></a><p>使用Kobj的第三步是定义对象。Kobj对象建立程序假定Kobj
        专有数据在一个对象的头部。如果不是如此，应当先自行分配对象，
        再使用<code class="function">kobj_init()</code>初始化对象中的Kobj专有数据；
        其实可以使用<code class="function">kobj_create()</code>分配对象，
        并自动初始化对象中的Kobj专有内容。<code class="function">kobj_init()</code>
        也可以用来改变一个对象所使用的类。</p><p>将Kobj的数据集成到对象中要使用宏KOBJ_FIELDS。</p><p>例如</p><pre class="programlisting">struct foo_data {
	KOBJ_FIELDS;
	foo_foo;
	foo_bar;
};</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64752848"></a>3.3.8. 调用方法</h3></div></div></div><p>使用Kobj的最后一部就是通过生成的函数调用对象类中的方法。
        调用时，接口名与方法名用'_'接合，而且全部使用大写字母。</p><p>例如，接口名为foo，方法为bar，调用就是:</p><pre class="programlisting">[返回值 = ] FOO_BAR(对象 [, 其它参数]);</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64757712"></a>3.3.9. 善后处理</h3></div></div></div><p>当一个用<code class="function">kobj_create()</code>不再需要被使用时，
        可对这个对象调用<code class="function">kobj_delete()</code>。
        当一个类不再需要被使用时，
        可对这个类调用<code class="function">kobj_class_free()</code>。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kernel-objects-operation.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="kernel-objects.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="jail.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. Kobj的工作流程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 4 章 Jail子系统</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文档和其它文档可从这里下载：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>如果对于FreeBSD有问题，请先阅读
    <a href="http://www.FreeBSD.org/docs.html">文档</a>，如不能解决再联系
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    关于本文档的问题请发信联系
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>