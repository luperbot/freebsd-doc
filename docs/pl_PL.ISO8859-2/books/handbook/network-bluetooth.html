<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>27.4. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Podrêcznik FreeBSD" /><link rel="up" href="advanced-networking.html" title="Rozdzia³ 27. Advanced Networking" /><link rel="prev" href="network-wireless.html" title="27.3. Wireless Networking" /><link rel="next" href="network-bridging.html" title="27.5. Bridging" /><link rel="copyright" href="legalnotice.html" title="Informacja Prawna" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">27.4. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-wireless.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia³ 27. Advanced Networking</th><td width="20%" align="right"> <a accesskey="n" href="network-bridging.html">Nastêpny</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>27.4. Bluetooth</h2></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pav</span> <span class="surname">Lucistnik</span></span>. </span></div></div></div><a id="idp96111696" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96112208"></a>27.4.1. Introduction</h3></div></div></div><p>Bluetooth is a wireless technology for creating personal networks
        operating in the 2.4 GHz unlicensed band, with a range of 10 meters.
        Networks are usually formed ad-hoc from portable devices such as
        cellular phones, handhelds and laptops. Unlike the other popular
        wireless technology, Wi-Fi, Bluetooth offers higher level service
        profiles, e.g. FTP-like file servers, file pushing, voice transport,
        serial line emulation, and more.</p><p>The Bluetooth stack in FreeBSD is implemented using the Netgraph
        framework (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a>). A broad variety of Bluetooth USB
        dongles is supported by the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a> driver. The Broadcom BCM2033
        chip based Bluetooth devices are supported via the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ubtbcmfw</span>(4)</span></a> and
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a> drivers. The 3Com Bluetooth PC Card 3CRWB60-A is
        supported by the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a> driver. Serial and UART based
        Bluetooth devices are supported via <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a>
        and <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>. This section describes the use of the USB
        Bluetooth dongle.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96124112"></a>27.4.2. Plugging in the Device</h3></div></div></div><p>By default Bluetooth device drivers are available as kernel modules.
        Before attaching a device, you will need to load the driver into the
        kernel:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>If the Bluetooth device is present in the system during system
        startup, load the module from
        <code class="filename">/boot/loader.conf</code>:</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>Plug in your USB dongle. The output similar to the following will
        appear on the console (or in syslog):</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">The Bluetooth stack has to be started manually on FreeBSD 6.0, and
	  on FreeBSD 5.X before 5.5.  It is done automatically from <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>
	  on FreeBSD 5.5, 6.1 and newer.</p><p xmlns="http://www.w3.org/1999/xhtml">Copy
        <code class="filename">/usr/share/examples/netgraph/bluetooth/rc.bluetooth</code>
        into some convenient place, like <code class="filename">/etc/rc.bluetooth</code>.
        This script is used to start and stop the Bluetooth stack. It is a good
        idea to stop the stack before unplugging the device, but it is not
        (usually) fatal. When starting the stack, you will receive output similar
        to the following:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96136016"></a>27.4.3. Host Controller Interface (HCI)</h3></div></div></div><a id="idp96136656" class="indexterm"></a><p>Host Controller Interface (HCI) provides a command interface to the
        baseband controller and link manager, and access to hardware status and
        control registers. This interface provides a uniform method of accessing
        the Bluetooth baseband capabilities. HCI layer on the Host exchanges
        data and commands with the HCI firmware on the Bluetooth hardware.
        The Host Controller Transport Layer (i.e. physical bus) driver provides
        both HCI layers with the ability to exchange information with each
        other.</p><p>A single Netgraph node of type <span class="emphasis"><em>hci</em></span> is
        created for a single Bluetooth device. The HCI node is normally
        connected to the Bluetooth device driver node (downstream) and
        the L2CAP node (upstream). All HCI operations must be performed
        on the HCI node and not on the device driver node. Default name
        for the HCI node is <span class="quote">"<span class="quote">devicehci</span>"</span>.
        For more details refer to the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a> manual page.</p><p>One of the most common tasks is discovery of Bluetooth devices in
        RF proximity. This operation is called <span class="emphasis"><em>inquiry</em></span>.
        Inquiry and other HCI related operations are done with the
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a> utility. The example below shows how to find out
        which Bluetooth devices are in range. You should receive the list of
        devices in a few seconds. Note that a remote device will only answer
        the inquiry if it put into <span class="emphasis"><em>discoverable</em></span>
        mode.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> is unique address of a Bluetooth
        device, similar to MAC addresses of a network card. This address
        is needed for further communication with a device. It is possible
        to assign human readable name to a BD_ADDR.
        The <code class="filename">/etc/bluetooth/hosts</code> file contains information
        regarding the known Bluetooth hosts. The following example shows how
        to obtain human readable name that was assigned to the remote
        device:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>If you perform an inquiry on a remote Bluetooth device, it will
        find your computer as <span class="quote">"<span class="quote">your.host.name (ubt0)</span>"</span>. The name
        assigned to the local device can be changed at any time.</p><p>The Bluetooth system provides a point-to-point connection (only two
        Bluetooth units involved), or a point-to-multipoint connection. In the
        point-to-multipoint connection the connection is shared among several
        Bluetooth devices. The following example shows how to obtain the list
        of active baseband connections for the local device:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p>A <span class="emphasis"><em>connection handle</em></span> is useful when termination
        of the baseband connection is required. Note, that it is normally not
        required to do it by hand. The stack will automatically terminate
        inactive baseband connections.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>Refer to <code class="command">hccontrol help</code> for a complete listing
        of available HCI commands. Most of the HCI commands do not require
        superuser privileges.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96149584"></a>27.4.4. Logical Link Control and Adaptation Protocol (L2CAP)</h3></div></div></div><a id="idp96158544" class="indexterm"></a><p>Logical Link Control and Adaptation Protocol (L2CAP) provides
        connection-oriented and connectionless data services to upper layer
        protocols with protocol multiplexing capability and segmentation and
        reassembly operation. L2CAP permits higher level protocols and
        applications to transmit and receive L2CAP data packets up to 64
        kilobytes in length.</p><p>L2CAP is based around the concept of <span class="emphasis"><em>channels</em></span>.
        Channel is a logical connection on top of baseband connection. Each
        channel is bound to a single protocol in a many-to-one fashion. Multiple
        channels can be bound to the same protocol, but a channel cannot be
        bound to multiple protocols. Each L2CAP packet received on a channel is
        directed to the appropriate higher level protocol. Multiple channels
        can share the same baseband connection.</p><p>A single Netgraph node of type <span class="emphasis"><em>l2cap</em></span> is
        created for a single Bluetooth device. The L2CAP node is normally
        connected to the Bluetooth HCI node (downstream) and Bluetooth sockets
        nodes (upstream). Default name for the L2CAP node is
        <span class="quote">"<span class="quote">devicel2cap</span>"</span>. For more details refer to the
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a> manual page.</p><p>A useful command is <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a>, which can be used to ping
        other devices. Some Bluetooth implementations might not return all of
        the data sent to them, so <code class="literal">0 bytes</code> in the following
        example is normal.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> utility is used to perform various operations
        on L2CAP nodes. This example shows how to obtain the list of logical
        connections (channels) and the list of baseband connections for the
        local device:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p>Another diagnostic tool is <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a>. It does a job
        similar to as <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> does, but for Bluetooth network-related
        data structures. The example below shows the same logical connection as
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> above.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96171728"></a>27.4.5. RFCOMM Protocol</h3></div></div></div><a id="idp96172368" class="indexterm"></a><p>The RFCOMM protocol provides emulation of serial ports over the
        L2CAP protocol. The protocol is based on the ETSI standard TS 07.10.
        RFCOMM is a simple transport protocol, with additional provisions for
        emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports. The
        RFCOMM protocol supports up to 60 simultaneous connections (RFCOMM
        channels) between two Bluetooth devices.</p><p>For the purposes of RFCOMM, a complete communication path involves
        two applications running on different devices (the communication
        endpoints) with a communication segment between them. RFCOMM is intended
        to cover applications that make use of the serial ports of the devices
        in which they reside. The communication segment is a Bluetooth link from
        one device to another (direct connect).</p><p>RFCOMM is only concerned with the connection between the devices in
        the direct connect case, or between the device and a modem in the
        network case. RFCOMM can support other configurations, such as modules
        that communicate via Bluetooth wireless technology on one side and
        provide a wired interface on the other side.</p><p>In FreeBSD the RFCOMM protocol is implemented at the Bluetooth sockets
        layer.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96174672"></a>27.4.6. Pairing of Devices</h3></div></div></div><a id="idp96175312" class="indexterm"></a><p>By default, Bluetooth communication is not authenticated, and any
        device can talk to any other device. A Bluetooth device (for example,
        cellular phone) may choose to require authentication to provide a
        particular service (for example, Dial-Up service). Bluetooth
        authentication is normally done with <span class="emphasis"><em>PIN codes</em></span>.
        A PIN code is an ASCII string up to 16 characters in length. User is
        required to enter the same PIN code on both devices. Once user has
        entered the PIN code, both devices will generate a
        <span class="emphasis"><em>link key</em></span>. After that the link key can be stored
        either in the devices themselves or in a persistent storage. Next time
        both devices will use previously generated link key. The described
        above procedure is called <span class="emphasis"><em>pairing</em></span>. Note that if
        the link key is lost by any device then pairing must be repeated.</p><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> daemon is responsible for handling of all
        Bluetooth authentication requests. The default configuration file is
        <code class="filename">/etc/bluetooth/hcsecd.conf</code>. An example section for
        a cellular phone with the PIN code arbitrarily set to
        <span class="quote">"<span class="quote">1234</span>"</span> is shown below:</p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>There is no limitation on PIN codes (except length). Some devices
        (for example Bluetooth headsets) may have a fixed PIN code built in.
        The <code class="option">-d</code> switch forces the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> daemon to stay
        in the foreground, so it is easy to see what is happening. Set the
        remote device to receive pairing and initiate the Bluetooth connection
        to the remote device. The remote device should say that pairing was
        accepted, and request the PIN code. Enter the same PIN code as you
        have in <code class="filename">hcsecd.conf</code>. Now your PC and the remote
        device are paired. Alternatively, you can initiate pairing on the remote
        device.</p><p>On FreeBSD 5.5, 6.1 and newer, the following line can be added to the
	<code class="filename">/etc/rc.conf</code> file to have
	<span class="application">hcsecd</span> started automatically on system
	start:</p><pre class="programlisting">hcsecd_enable="YES"</pre><p>The following is a sample of the
        <span class="application">hcsecd</span> daemon output:</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96188880"></a>27.4.7. Service Discovery Protocol (SDP)</h3></div></div></div><a id="idp96189520" class="indexterm"></a><p>The Service Discovery Protocol (SDP) provides the means for client
        applications to discover the existence of services provided by server
        applications as well as the attributes of those services. The attributes
        of a service include the type or class of service offered and the
        mechanism or protocol information needed to utilize the service.</p><p>SDP involves communication between a SDP server and a SDP client.
        The server maintains a list of service records that describe the
        characteristics of services associated with the server. Each service
        record contains information about a single service. A client may
        retrieve information from a service record maintained by the SDP server
        by issuing a SDP request. If the client, or an application associated
        with the client, decides to use a service, it must open a separate
        connection to the service provider in order to utilize the service.
        SDP provides a mechanism for discovering services and their attributes,
        but it does not provide a mechanism for utilizing those services.</p><p>Normally, a SDP client searches for services based on some desired
        characteristics of the services. However, there are times when it is
        desirable to discover which types of services are described by an SDP
        server's service records without any a priori information about the
        services. This process of looking for any offered services is called
        <span class="emphasis"><em>browsing</em></span>.</p><p>The Bluetooth SDP server <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> and command line client
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> are included in the standard FreeBSD installation.
        The following example shows how to perform a SDP browse query.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec browse</code></strong>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</pre><p>... and so on. Note that each service has a list of attributes
        (RFCOMM channel for example). Depending on the service you might need to
        make a note of some of the attributes. Some Bluetooth implementations do
        not support service browsing and may return an empty list. In this case
        it is possible to search for the specific service. The example below
        shows how to search for the OBEX Object Push (OPUSH) service:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></strong></pre><p>Offering services on FreeBSD to Bluetooth clients is done with the
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> server. On FreeBSD 5.5, 6.1 and newer, the following line can
	be added to the <code class="filename">/etc/rc.conf</code> file:</p><pre class="programlisting">sdpd_enable="YES"</pre><p>Then the <span class="application">sdpd</span> daemon can be started with:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/sdpd start</code></strong></pre><p>On FreeBSD 6.0, and on FreeBSD 5.X before 5.5,
	<span class="application">sdpd</span> is not integrated into the system
	startup scripts.  It has to be started manually with:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpd</code></strong></pre><p>The local server application that wants to provide Bluetooth
        service to the remote clients will register service with the local
        SDP daemon. The example of such application is <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.
        Once started it will register Bluetooth LAN service with the local
        SDP daemon.</p><p>The list of services registered with the local SDP server can be
        obtained by issuing SDP browse query via local control channel:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpcontrol -l browse</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96208080"></a>27.4.8. Dial-Up Networking (DUN) and Network Access with PPP (LAN)
        Profiles</h3></div></div></div><p>The Dial-Up Networking (DUN) profile is mostly used with modems
        and cellular phones. The scenarios covered by this profile are the
        following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>use of a cellular phone or modem by a computer as
          a wireless modem for connecting to a dial-up Internet access server,
          or using other dial-up services;</p></li><li class="listitem"><p>use of a cellular phone or modem by a computer to
          receive data calls.</p></li></ul></div><p>Network Access with PPP (LAN) profile can be used in the following
        situations:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>LAN access for a single Bluetooth device;
           </p></li><li class="listitem"><p>LAN access for multiple Bluetooth devices;
          </p></li><li class="listitem"><p>PC to PC (using PPP networking over serial cable
          emulation).</p></li></ul></div><p>In FreeBSD both profiles are implemented with <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> and
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> - a wrapper that converts RFCOMM Bluetooth
        connection into something PPP can operate with. Before any profile
        can be used, a new PPP label in the <code class="filename">/etc/ppp/ppp.conf</code>
        must be created. Consult <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> manual page for examples.
      </p><p>In the following example <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> will be used to open
        RFCOMM connection to remote device with BD_ADDR 00:80:37:29:19:a4 on
        DUN RFCOMM channel. The actual RFCOMM channel number will be obtained
        from the remote device via SDP. It is possible to specify RFCOMM channel
        by hand, and in this case <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> will not perform SDP
        query. Use <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> to find out RFCOMM
        channel on the remote device.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>In order to provide Network Access with PPP (LAN) service the
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> server must be running. A new entry for LAN clients must
        be created in the <code class="filename">/etc/ppp/ppp.conf</code> file. Consult
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> manual page for examples. Finally, start RFCOMM PPP
        server on valid RFCOMM channel number. The RFCOMM PPP server will
        automatically register Bluetooth LAN service with the local SDP daemon.
        The example below shows how to start RFCOMM PPP server.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96227024"></a>27.4.9. OBEX Object Push (OPUSH) Profile</h3></div></div></div><a id="idp96227664" class="indexterm"></a><p>OBEX is a widely used protocol for simple file transfers between
        mobile devices. Its main use is in infrared communication, where it is
        used for generic file transfers between notebooks or PDAs,
        and for sending business cards or calendar entries between cellular
        phones and other devices with PIM applications.</p><p>The OBEX server and client are implemented as a third-party package
        <span class="application">obexapp</span>, which is available as
	<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/obexapp/pkg-descr">comms/obexapp</a> port.</p><p>OBEX client is used to push and/or pull objects from the OBEX server.
        An object can, for example, be a business card or an appointment.
        The OBEX client can obtain RFCOMM channel number from the remote device
        via SDP. This can be done by specifying service name instead of RFCOMM
        channel number. Supported service names are: IrMC, FTRN and OPUSH.
        It is possible to specify RFCOMM channel as a number. Below is an
        example of an OBEX session, where device information object is pulled
        from the cellular phone, and a new object (business card) is pushed
        into the phone's directory.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>In order to provide OBEX Object Push service,
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> server must be running. A root folder, where all incoming
        objects will be stored, must be created. The default path to the root
        folder is <code class="filename">/var/spool/obex</code>. Finally, start OBEX
        server on valid RFCOMM channel number. The OBEX server will
        automatically register OBEX Object Push service with the local SDP
        daemon. The example below shows how to start OBEX server.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96233808"></a>27.4.10. Serial Port Profile (SPP)</h3></div></div></div><p>The Serial Port Profile (SPP) allows Bluetooth devices to perform
        RS232 (or similar) serial cable emulation. The scenario covered by this
        profile deals with legacy applications using Bluetooth as a cable
        replacement, through a virtual serial port abstraction.</p><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> utility implements the Serial Port profile.
        A pseudo tty is used as a virtual serial port abstraction. The example
        below shows how to connect to a remote device Serial Port service.
        Note that you do not have to specify a RFCOMM channel -
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> can obtain it from the remote device via SDP.
        If you would like to override this, specify a RFCOMM channel on the
        command line.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>Once connected, the pseudo tty can be used as serial port:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96247504"></a>27.4.11. Troubleshooting</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96248144"></a>27.4.11.1. A remote device cannot connect</h4></div></div></div><p>Some older Bluetooth devices do not support role switching.
          By default, when FreeBSD is accepting a new connection, it tries to
          perform a role switch and become master. Devices, which do not
          support this will not be able to connect. Note that role switching is
          performed when a new connection is being established, so it is not
          possible to ask the remote device if it does support role switching.
          There is a HCI option to disable role switching on the local
          side:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp96250192"></a>27.4.11.2. Something is going wrong, can I see what exactly is happening?</h4></div></div></div><p>Yes, you can.  Use the third-party package
          <span class="application">hcidump</span>, which is available as
	  <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/hcidump/pkg-descr">comms/hcidump</a> port.
          The <span class="application">hcidump</span> utility is similar to
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>. It can be used to display the content of the Bluetooth
          packets on the terminal and to dump the Bluetooth packets to a
          file.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-wireless.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Pocz±tek rozdzia³u</a></td><td width="40%" align="right"> <a accesskey="n" href="network-bridging.html">Nastêpny</a></td></tr><tr><td width="40%" align="left" valign="top">27.3. Wireless Networking </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre¶ci</a></td><td width="40%" align="right" valign="top"> 27.5. Bridging</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>