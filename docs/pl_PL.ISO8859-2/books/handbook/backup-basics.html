<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>17.12. Backup Basics</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Podrêcznik FreeBSD" /><link rel="up" href="disks.html" title="Rozdzia³ 17. Storage" /><link rel="prev" href="backup-strategies.html" title="17.11. Backup Strategies" /><link rel="next" href="disks-virtual.html" title="17.13. Network, Memory, and File-Backed File Systems" /><link rel="copyright" href="legalnotice.html" title="Informacja Prawna" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">17.12. Backup Basics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="backup-strategies.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia³ 17. Storage</th><td width="20%" align="right"> <a accesskey="n" href="disks-virtual.html">Nastêpny</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="backup-basics"></a>17.12. Backup Basics</h2></div></div></div><p>The three major backup programs are
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a>,
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a>,
      and
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cpio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cpio</span>(1)</span></a>.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88927568"></a>17.12.1. Dump and Restore</h3></div></div></div><a id="idp88928208" class="indexterm"></a><a id="idp88929488" class="indexterm"></a><a id="idp88930128" class="indexterm"></a><p>The traditional <span class="trademark">UNIX</span>(R) backup programs are
	<code class="command">dump</code> and <code class="command">restore</code>.  They
	operate on the drive as a collection of disk blocks, below the
	abstractions of files, links and directories that are created by
	the file systems. <code class="command">dump</code> backs up an entire
	file system on a device.  It is unable to backup only part of a
	file system or a directory tree that spans more than one
	file system.  <code class="command">dump</code> does not write files and
	directories to tape, but rather writes the raw data blocks that
	comprise files and directories.</p><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">If you use <code class="command">dump</code> on your root directory, you
        would not back up <code class="filename">/home</code>,
        <code class="filename">/usr</code> or many other directories since
        these are typically mount points for other file systems or
        symbolic links into those file systems.</p></div><p><code class="command">dump</code> has quirks that remain from its early days in
	Version 6 of AT&amp;T UNIX (circa 1975).  The default
	parameters are suitable for 9-track tapes (6250 bpi), not the
	high-density media available today (up to 62,182 ftpi).  These
	defaults must be overridden on the command line to utilize the
	capacity of current tape drives.</p><a id="idp88935632" class="indexterm"></a><p>It is also possible to backup data across the network to a
        tape drive attached to another computer with <code class="command">rdump</code> and
        <code class="command">rrestore</code>.  Both programs rely upon <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rcmd&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">rcmd</span>(3)</span></a> and
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ruserok&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">ruserok</span>(3)</span></a> to access the remote tape drive.  Therefore,
	the user performing the backup must be listed in the
	<code class="filename">.rhosts</code> file on the remote computer.  The
        arguments to <code class="command">rdump</code> and <code class="command">rrestore</code> must be suitable
        to use on the remote computer.  When
        <code class="command">rdump</code>ing from a FreeBSD computer to an
        Exabyte tape drive connected to a Sun called
        <code class="systemitem">komodo</code>, use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</code></strong></pre><p>Beware: there are security implications to
        allowing <code class="filename">.rhosts</code> authentication.  Evaluate your
        situation carefully.</p><p>It is also possible to use <code class="command">dump</code> and
        <code class="command">restore</code> in a more secure fashion over
        <code class="command">ssh</code>.</p><div class="example"><a id="idp88952528"></a><div class="example-title">Przyk³ad 17.1. Using <code class="command">dump</code> over <span class="application">ssh</span></div><div class="example-contents"><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</code></strong></pre></div></div><br class="example-break" /><p>Or using <code class="command">dump</code>'s built-in method,
        setting the environment variable <code class="envar">RSH</code>:</p><div class="example"><a id="idp88956112"></a><div class="example-title">Przyk³ad 17.2. Using <code class="command">dump</code> over <span class="application">ssh</span> with <code class="envar">RSH</code> set</div><div class="example-contents"><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</code></strong></pre></div></div><br class="example-break" /></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88959056"></a>17.12.2. <code class="command">tar</code></h3></div></div></div><a id="idp88959824" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> also dates back to Version 6 of AT&amp;T UNIX
	(circa 1975).  <code class="command">tar</code> operates in cooperation
	with the file system; it writes files and
	directories to tape. <code class="command">tar</code> does not support the
	full range of options that are available from <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cpio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cpio</span>(1)</span></a>, but
	it does not require the unusual command
	pipeline that <code class="command">cpio</code> uses.</p><a id="idp88968272" class="indexterm"></a><p>On FreeBSD 5.3 and later, both GNU <code class="command">tar</code>
        and the default <code class="command">bsdtar</code> are available.  The
        GNU version can be invoked with <code class="command">gtar</code>.  It
        supports remote devices using the same syntax as
        <code class="command">rdump</code>.  To <code class="command">tar</code> to an
        Exabyte tape drive connected to a Sun called
        <code class="systemitem">komodo</code>, use:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</code></strong></pre><p>The same could be accomplished with
	<code class="command">bsdtar</code> by using a pipeline and
	<code class="command">rsh</code> to send the data to a remote tape
	drive.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>tar cf - . | rsh hostname dd of=tape-device obs=20b</code></strong></pre><p>If you are worried about the security of backing up over a
	network you should use the <code class="command">ssh</code> command
	instead of <code class="command">rsh</code>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88980048"></a>17.12.3. <code class="command">cpio</code></h3></div></div></div><a id="idp88980816" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cpio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cpio</span>(1)</span></a> is the original <span class="trademark">UNIX</span>(R) file interchange tape
	program for magnetic media.  <code class="command">cpio</code> has options
	(among many others) to perform byte-swapping, write a number of
	different archive formats, and pipe the data to other programs.
	This last feature makes <code class="command">cpio</code> an excellent
	choice for installation media.  <code class="command">cpio</code> does not
	know how to walk the directory tree and a list of files must be
	provided through <code class="filename">stdin</code>.</p><a id="idp88985168" class="indexterm"></a><p><code class="command">cpio</code> does not support backups across
	the network.  You can use a pipeline and <code class="command">rsh</code>
	to send the data to a remote tape drive.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>for f in directory_list; do</code></strong>
<strong class="userinput"><code>find $f &gt;&gt; backup.list</code></strong>
<strong class="userinput"><code>done</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cpio -v -o --format=newc &lt; backup.list | ssh user@host "cat &gt; backup_device"</code></strong></pre><p>Where <em class="replaceable"><code>directory_list</code></em> is the list of
	directories you want to back up,
	<em class="replaceable"><code>user</code></em>@<em class="replaceable"><code>host</code></em> is the
	user/hostname combination that will be performing the backups, and
	<em class="replaceable"><code>backup_device</code></em> is where the backups should
	be written to (e.g., <code class="filename">/dev/nsa0</code>).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88995920"></a>17.12.4. <code class="command">pax</code></h3></div></div></div><a id="idp88996688" class="indexterm"></a><a id="idp88997968" class="indexterm"></a><a id="idp88998736" class="indexterm"></a><a id="idp88999248" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pax&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pax</span>(1)</span></a> is IEEE/<span class="trademark">POSIX</span>(R)'s answer to
	<code class="command">tar</code> and <code class="command">cpio</code>.  Over the
	years the various versions of <code class="command">tar</code> and
	<code class="command">cpio</code> have gotten slightly incompatible.  So
	rather than fight it out to fully standardize them, <span class="trademark">POSIX</span>(R)
	created a new archive utility. <code class="command">pax</code> attempts
	to read and write many of the various <code class="command">cpio</code>
	and <code class="command">tar</code> formats, plus new formats of its own.
	Its command set more resembles <code class="command">cpio</code> than
	<code class="command">tar</code>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="backups-programs-amanda"></a>17.12.5. <span class="application">Amanda</span></h3></div></div></div><a id="idp89006288" class="indexterm"></a><a id="idp89011792" class="indexterm"></a><p><span class="application">Amanda</span> (Advanced Maryland
        Network Disk Archiver) is a client/server backup system,
        rather than a single program.  An <span class="application">Amanda</span> server will backup to
        a single tape drive any number of computers that have <span class="application">Amanda</span>
        clients and a network connection to the <span class="application">Amanda</span> server.  A
        common problem at sites with a number of large disks is
        that the length of time required to backup to data directly to tape
        exceeds the amount of time available for the task.  <span class="application">Amanda</span>
        solves this problem.  <span class="application">Amanda</span> can use a <span class="quote">"<span class="quote">holding disk</span>"</span> to
        backup several file systems at the same time.  <span class="application">Amanda</span> creates
        <span class="quote">"<span class="quote">archive sets</span>"</span>: a group of tapes used over a period of time to
        create full backups of all the file systems listed in <span class="application">Amanda</span>'s
        configuration file.  The <span class="quote">"<span class="quote">archive set</span>"</span> also contains nightly
        incremental (or differential) backups of all the file systems.
        Restoring a damaged file system requires the most recent full
        backup and the incremental backups.</p><p>The configuration file provides fine control of backups and the
	network traffic that <span class="application">Amanda</span> generates.  <span class="application">Amanda</span> will use any of the
	above backup programs to write the data to tape.  <span class="application">Amanda</span> is available
	as either a port or a package, it is not installed by default.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89019088"></a>17.12.6. Do Nothing</h3></div></div></div><p><span class="quote">"<span class="quote">Do nothing</span>"</span> is not a computer program, but it is the
	most widely used backup strategy.  There are no initial costs.  There
	is no backup schedule to follow.  Just say no.  If something happens
	to your data, grin and bear it!</p><p>If your time and your data is worth little to nothing, then
	<span class="quote">"<span class="quote">Do nothing</span>"</span> is the most suitable backup program for your
	computer.  But beware, <span class="trademark">UNIX</span>(R) is a useful tool, you may find that within
	six months you have a collection of files that are valuable to
	you.</p><p><span class="quote">"<span class="quote">Do nothing</span>"</span> is the correct backup method for
	<code class="filename">/usr/obj</code> and other directory trees that can be
	exactly recreated by your computer.  An example is the files that
	comprise the HTML or <span class="trademark">PostScript</span>(R) version of this Handbook.
	These document formats have been created from SGML input
	files.  Creating backups of the HTML or <span class="trademark">PostScript</span>(R) files is
	not necessary.  The SGML files are backed up regularly.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89024080"></a>17.12.7. Which Backup Program Is Best?</h3></div></div></div><a id="idp89024720" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> <span class="emphasis"><em>Period.</em></span> Elizabeth D. Zwicky
	torture tested all the backup programs discussed here.  The clear
	choice for preserving all your data and all the peculiarities of <span class="trademark">UNIX</span>(R)
	file systems is <code class="command">dump</code>.  Elizabeth created file systems containing
	a large variety of unusual conditions (and some not so unusual ones)
	and tested each program by doing a backup and restore of those
	file systems.  The peculiarities included: files with holes, files with
	holes and a block of nulls, files with funny characters in their
	names, unreadable and unwritable files, devices, files that change
	size during the backup, files that are created/deleted during the
	backup and more.  She presented the results at LISA V in Oct. 1991.
	See <a class="link" href="http://berdmann.dyndns.org/zwicky/testdump.doc.html" target="_top">torture-testing
	  Backup and Archive Programs</a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89028560"></a>17.12.8. Emergency Restore Procedure</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89029200"></a>17.12.8.1. Before the Disaster</h4></div></div></div><p>There are only four steps that you need to perform in
	  preparation for any disaster that may occur.</p><a id="idp89030224" class="indexterm"></a><p>First, print the bsdlabel from each of your disks
	  (e.g. <code class="command">bsdlabel da0 | lpr</code>), your file system table
	  (<code class="filename">/etc/fstab</code>) and all boot messages,
	  two copies of
	  each.</p><a id="idp89032272" class="indexterm"></a><p>Second, determine that the boot and fix-it floppies
	  (<code class="filename">boot.flp</code> and <code class="filename">fixit.flp</code>)
	  have all your devices.  The easiest way to check is to reboot your
	  machine with the boot floppy in the floppy drive and check the boot
	  messages.  If all your devices are listed and functional, skip on to
	  step three.</p><p>Otherwise, you have to create two custom bootable
	  floppies which have a kernel that can mount all of your disks
	  and access your tape drive.  These floppies must contain:
	  <code class="command">fdisk</code>, <code class="command">bsdlabel</code>,
	  <code class="command">newfs</code>, <code class="command">mount</code>, and
	  whichever backup program you use.  These programs must be
	  statically linked.  If you use <code class="command">dump</code>, the
	  floppy must contain <code class="command">restore</code>.</p><p>Third, create backup tapes regularly.  Any changes that you make
	  after your last backup may be irretrievably lost.  Write-protect the
	  backup tapes.</p><p>Fourth, test the floppies (either <code class="filename">boot.flp</code>
	  and <code class="filename">fixit.flp</code> or the two custom bootable
	  floppies you made in step two.) and backup tapes.  Make notes of the
	  procedure.  Store these notes with the bootable floppy, the
	  printouts and the backup tapes.  You will be so distraught when
	  restoring that the notes may prevent you from destroying your backup
	  tapes (How? In place of <code class="command">tar xvf /dev/sa0</code>, you
	  might accidentally type <code class="command">tar cvf /dev/sa0</code> and
	  over-write your backup tape).</p><p>For an added measure of security, make bootable floppies and two
	  backup tapes each time.  Store one of each at a remote location.  A
	  remote location is NOT the basement of the same office building.  A
	  number of firms in the World Trade Center learned this lesson the
	  hard way.  A remote location should be physically separated from
	  your computers and disk drives by a significant distance.</p><div class="example"><a id="idp89047632"></a><div class="example-title">Przyk³ad 17.3. A Script for Creating a Bootable Floppy</div><div class="example-contents"><pre class="programlisting">#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
bsdlabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &lt;&lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init &gt; /mnt/sbin/init
gzip -c -best /sbin/fsck &gt; /mnt/sbin/fsck
gzip -c -best /sbin/mount &gt; /mnt/sbin/mount
gzip -c -best /sbin/halt &gt; /mnt/sbin/halt
gzip -c -best /sbin/restore &gt; /mnt/sbin/restore

gzip -c -best /bin/sh &gt; /mnt/bin/sh
gzip -c -best /bin/sync &gt; /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &gt; /mnt/etc/fstab &lt;&lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat &gt; /mnt/etc/passwd &lt;&lt;EOM
root:*:0:0:Charlie &amp;:/root:/bin/sh
EOM

cat &gt; /mnt/etc/master.passwd &lt;&lt;EOM
root::0:0::0:0:Charlie &amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."</pre></div></div><br class="example-break" /></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89048912"></a>17.12.8.2. After the Disaster</h4></div></div></div><p>The key question is: did your hardware survive?  You have been
	  doing regular backups so there is no need to worry about the
	  software.</p><p>If the hardware has been damaged, the parts should be replaced
	  before attempting to use the computer.</p><p>If your hardware is okay, check your floppies.  If you are using
	  a custom boot floppy, boot single-user (type <code class="literal">-s</code>
	  at the <code class="prompt">boot:</code> prompt).  Skip the following
	  paragraph.</p><p>If you are using the <code class="filename">boot.flp</code> and
	  <code class="filename">fixit.flp</code> floppies, keep reading.  Insert the
	  <code class="filename">boot.flp</code> floppy in the first floppy drive and
	  boot the computer.  The original install menu will be displayed on
	  the screen.  Select the <code class="literal">Fixit--Repair mode with CDROM or
	    floppy.</code> option.  Insert the
	  <code class="filename">fixit.flp</code> when prompted.
	  <code class="command">restore</code> and the other programs that you need are
	  located in <code class="filename">/mnt2/rescue</code>
	  (<code class="filename">/mnt2/stand</code> for
	  FreeBSD versions older than 5.2).</p><p>Recover each file system separately.</p><a id="idp89055568" class="indexterm"></a><a id="idp89056464" class="indexterm"></a><a id="idp89056976" class="indexterm"></a><a id="idp89057872" class="indexterm"></a><p>Try to <code class="command">mount</code> (e.g. <code class="command">mount /dev/da0a
	    /mnt</code>)  the root partition of your first disk.  If the
	  bsdlabel was damaged, use <code class="command">bsdlabel</code> to re-partition and
	  label the disk to match the label that you printed and saved.  Use
	    <code class="command">newfs</code> to re-create the file systems.  Re-mount the root
	  partition of the floppy read-write (<code class="command">mount -u -o rw
	    /mnt</code>).  Use your backup program and backup tapes to
	  recover the data for this file system (e.g. <code class="command">restore vrf
	    /dev/sa0</code>).  Unmount the file system (e.g. <code class="command">umount
	    /mnt</code>). Repeat for each file system that was
	  damaged.</p><p>Once your system is running, backup your data onto new tapes.
	  Whatever caused the crash or data loss may strike again.  Another
	  hour spent now may save you from further distress later.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-strategies.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="disks.html">Pocz±tek rozdzia³u</a></td><td width="40%" align="right"> <a accesskey="n" href="disks-virtual.html">Nastêpny</a></td></tr><tr><td width="40%" align="left" valign="top">17.11. Backup Strategies </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre¶ci</a></td><td width="40%" align="right" valign="top"> 17.13. Network, Memory, and File-Backed File Systems</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>