<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>19.9. Using Vinum for the Root Filesystem</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Podrêcznik FreeBSD" /><link rel="up" href="vinum-vinum.html" title="Rozdzia³ 19. The Vinum Volume Manager" /><link rel="prev" href="vinum-config.html" title="19.8. Configuring Vinum" /><link rel="next" href="l10n.html" title="Rozdzia³ 20. Localization - I18N/L10N Usage and Setup" /><link rel="copyright" href="legalnotice.html" title="Informacja Prawna" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">19.9. Using Vinum for the Root Filesystem</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="vinum-config.html">Poprzedni</a> </td><th width="60%" align="center">Rozdzia³ 19. The Vinum Volume Manager</th><td width="20%" align="right"> <a accesskey="n" href="l10n.html">Nastêpny</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vinum-root"></a>19.9. Using Vinum for the Root Filesystem</h2></div></div></div><p>For a machine that has fully-mirrored filesystems using
      Vinum, it is desirable to also mirror the root filesystem.
      Setting up such a configuration is less trivial than mirroring
      an arbitrary filesystem because:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The root filesystem must be available very early during
	  the boot process, so the Vinum infrastructure must already be
	  available at this time.</p></li><li class="listitem"><p>The volume containing the root filesystem also contains
	  the system bootstrap and the kernel, which must be read
	  using the host system's native utilities (e. g. the BIOS on
	  PC-class machines) which often cannot be taught about the
	  details of Vinum.</p></li></ul></div><p>In the following sections, the term <span class="quote">"<span class="quote">root
      volume</span>"</span> is generally used to describe the Vinum volume
      that contains the root filesystem.  It is probably a good idea
      to use the name <code class="literal">"root"</code> for this volume, but
      this is not technically required in any way.  All command
      examples in the following sections assume this name though.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89915728"></a>19.9.1. Starting up Vinum Early Enough for the Root
	Filesystem</h3></div></div></div><p>There are several measures to take for this to
	happen:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Vinum must be available in the kernel at boot-time.
	    Thus, the method to start Vinum automatically described in
	    <a class="xref" href="vinum-config.html#vinum-rc-startup" title="19.8.1.1. Automatic Startup">Sekcja 19.8.1.1, "Automatic Startup"</a> is not applicable to
	    accomplish this task, and the
	    <code class="literal">start_vinum</code> parameter must actually
	    <span class="emphasis"><em>not</em></span> be set when the following setup
	    is being arranged.	The first option would be to compile
	    Vinum statically into the kernel, so it is available all
	    the time, but this is usually not desirable.  There is
	    another option as well, to have
	    <code class="filename">/boot/loader</code> (<a class="xref" href="boot-blocks.html#boot-loader" title="12.3.3. Stage Three, /boot/loader">Sekcja 12.3.3, "Stage Three, <code class="filename">/boot/loader</code>"</a>) load the vinum kernel module
	    early, before starting the kernel.	This can be
	    accomplished by putting the line:</p><pre class="programlisting">geom_vinum_load="YES"</pre><p>into the file
	    <code class="filename">/boot/loader.conf</code>.</p></li><li class="listitem"><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">For <span class="emphasis"><em>Gvinum</em></span>, all startup
	  is done automatically once the kernel module has been
	  loaded, so the procedure described above is all that is
	  needed.  The following text documents the behaviour of
	  the historic Vinum system, for the sake of older
	  setups.</p></div><p>Vinum must be initialized early since it needs to
	    supply the volume for the root filesystem.	By default,
	    the Vinum kernel part is not looking for drives that might
	    contain Vinum volume information until the administrator
	    (or one of the startup scripts) issues a <code class="command">vinum
	    start</code> command.</p><div xmlns="" class="note"><h3 class="admontitle">Uwaga: </h3><p xmlns="http://www.w3.org/1999/xhtml">The following paragraphs are outlining the steps
	    needed for FreeBSD 5.X and above.  The setup required for
	    FreeBSD 4.X differs, and is described below in <a class="xref" href="vinum-root.html#vinum-root-4x" title="19.9.5. Differences for FreeBSD 4.X">Sekcja 19.9.5, "Differences for FreeBSD 4.X"</a>.</p></div><p>By placing the line:</p><pre class="programlisting">vinum.autostart="YES"</pre><p>into <code class="filename">/boot/loader.conf</code>, Vinum is
	    instructed to automatically scan all drives for Vinum
	    information as part of the kernel startup.</p><p>Note that it is not necessary to instruct the kernel
	    where to look for the root filesystem.
	    <code class="filename">/boot/loader</code> looks up the name of the
	    root device in <code class="filename">/etc/fstab</code>, and passes
	    this information on to the kernel.	When it comes to mount
	    the root filesystem, the kernel figures out from the
	    device name provided which driver to ask to translate this
	    into the internal device ID (major/minor number).</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89947856"></a>19.9.2. Making a Vinum-based Root Volume Accessible to the
	Bootstrap</h3></div></div></div><p>Since the current FreeBSD bootstrap is only 7.5 KB of
	code, and already has the burden of reading files (like
	<code class="filename">/boot/loader</code>) from the UFS filesystem, it
	is sheer impossible to also teach it about internal Vinum
	structures so it could parse the Vinum configuration data, and
	figure out about the elements of a boot volume itself.	Thus,
	some tricks are necessary to provide the bootstrap code with
	the illusion of a standard <code class="literal">"a"</code> partition
	that contains the root filesystem.</p><p>For this to be possible at all, the following requirements
	must be met for the root volume:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The root volume must not be striped or RAID-5.</p></li><li class="listitem"><p>The root volume must not contain more than one
	    concatenated subdisk per plex.</p></li></ul></div><p>Note that it is desirable and possible that there are
	multiple plexes, each containing one replica of the root
	filesystem.  The bootstrap process will, however, only use one
	of these replica for finding the bootstrap and all the files,
	until the kernel will eventually mount the root filesystem
	itself.	 Each single subdisk within these plexes will then
	need its own <code class="literal">"a"</code> partition illusion, for
	the respective device to become bootable.  It is not strictly
	needed that each of these faked <code class="literal">"a"</code>
	partitions is located at the same offset within its device,
	compared with other devices containing plexes of the root
	volume.	 However, it is probably a good idea to create the
	Vinum volumes that way so the resulting mirrored devices are
	symmetric, to avoid confusion.</p><p>In order to set up these <code class="literal">"a"</code> partitions,
	for each device containing part of the root volume, the
	following needs to be done:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>The location (offset from the beginning of the device)
	    and size of this device's subdisk that is part of the root
	    volume need to be examined, using the command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>gvinum l -rv root</code></strong></pre><p>Note that Vinum offsets and sizes are measured in
	    bytes.  They must be divided by 512 in order to obtain the
	    block numbers that are to be used in the
	    <code class="command">bsdlabel</code> command.</p></li><li class="step"><p>Run the command:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>bsdlabel -e devname</code></strong></pre><p>for each device that participates in the root volume.
	    <em class="replaceable"><code>devname</code></em> must be either the name
	    of the disk (like <code class="filename">da0</code>) for disks
	    without a slice (aka. fdisk) table, or the name of the
	    slice (like <code class="filename">ad0s1</code>).</p><p>If there is already an <code class="literal">"a"</code>
	    partition on the device (presumably, containing a
	    pre-Vinum root filesystem), it should be renamed to
	    something else, so it remains accessible (just in case),
	    but will no longer be used by default to bootstrap the
	    system.  Note that active partitions (like a root
	    filesystem currently mounted) cannot be renamed, so this
	    must be executed either when being booted from a
	    <span class="quote">"<span class="quote">Fixit</span>"</span> medium, or in a two-step process,
	    where (in a mirrored situation) the disk that has not been
	    currently booted is being manipulated first.</p><p>Then, the offset the Vinum partition on this
	    device (if any) must be added to the offset of the
	    respective root volume subdisk on this device.  The
	    resulting value will become the
	    <code class="literal">"offset"</code> value for the new
	    <code class="literal">"a"</code> partition.  The
	    <code class="literal">"size"</code> value for this partition can be
	    taken verbatim from the calculation above.	The
	    <code class="literal">"fstype"</code> should be
	    <code class="literal">4.2BSD</code>.	The
	    <code class="literal">"fsize"</code>, <code class="literal">"bsize"</code>,
	    and <code class="literal">"cpg"</code> values should best be chosen
	    to match the actual filesystem, though they are fairly
	    unimportant within this context.</p><p>That way, a new <code class="literal">"a"</code> partition will
	    be established that overlaps the Vinum partition on this
	    device.  Note that the <code class="command">bsdlabel</code> will
	    only allow for this overlap if the Vinum partition has
	    properly been marked using the <code class="literal">"vinum"</code>
	    fstype.</p></li><li class="step"><p>That's all!  A faked <code class="literal">"a"</code> partition
	    does exist now on each device that has one replica of the
	    root volume.  It is highly recommendable to verify the
	    result again, using a command like:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>fsck -n /dev/devnamea</code></strong></pre></li></ol></div><p>It should be remembered that all files containing control
	information must be relative to the root filesystem in the
	Vinum volume which, when setting up a new Vinum root volume,
	might not match the root filesystem that is currently active.
	So in particular, the files <code class="filename">/etc/fstab</code>
	and <code class="filename">/boot/loader.conf</code> need to be taken
	care of.</p><p>At next reboot, the bootstrap should figure out the
	appropriate control information from the new Vinum-based root
	filesystem, and act accordingly.  At the end of the kernel
	initialization process, after all devices have been announced,
	the prominent notice that shows the success of this setup is a
	message like:</p><pre class="screen">Mounting root from ufs:/dev/gvinum/root</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89970896"></a>19.9.3. Example of a Vinum-based Root Setup</h3></div></div></div><p>After the Vinum root volume has been set up, the output of
	<code class="command">gvinum l -rv root</code> could look like:</p><pre class="screen">
...
Subdisk root.p0.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p0 at offset 0 (0  B)
		Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p1 at offset 0 (0  B)
		Drive disk1 (/dev/da1h) at offset 135680 (132 kB)
	</pre><p>The values to note are <code class="literal">135680</code> for the
	offset (relative to partition
	<code class="filename">/dev/da0h</code>).  This translates to 265
	512-byte disk blocks in <code class="command">bsdlabel</code>'s terms.
	Likewise, the size of this root volume is 245760 512-byte
	blocks.	 <code class="filename">/dev/da1h</code>, containing the
	second replica of this root volume, has a symmetric
	setup.</p><p>The bsdlabel for these devices might look like:</p><pre class="screen">
...
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  a:   245760      281    4.2BSD     2048 16384     0   # (Cyl.    0*- 15*)
  c: 71771688        0    unused        0     0         # (Cyl.    0 - 4467*)
  h: 71771672       16     vinum                        # (Cyl.    0*- 4467*)
	</pre><p>It can be observed that the <code class="literal">"size"</code>
	parameter for the faked <code class="literal">"a"</code> partition
	matches the value outlined above, while the
	<code class="literal">"offset"</code> parameter is the sum of the offset
	within the Vinum partition <code class="literal">"h"</code>, and the
	offset of this partition within the device (or slice).	This
	is a typical setup that is necessary to avoid the problem
	described in <a class="xref" href="vinum-root.html#vinum-root-panic" title="19.9.4.3. Nothing Boots, the Bootstrap Panics">Sekcja 19.9.4.3, "Nothing Boots, the Bootstrap
	  Panics"</a>.	 It can also
	be seen that the entire <code class="literal">"a"</code> partition is
	completely within the <code class="literal">"h"</code> partition
	containing all the Vinum data for this device.</p><p>Note that in the above example, the entire device is
	dedicated to Vinum, and there is no leftover pre-Vinum root
	partition, since this has been a newly set-up disk that was
	only meant to be part of a Vinum configuration, ever.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89987280"></a>19.9.4. Troubleshooting</h3></div></div></div><p>If something goes wrong, a way is needed to recover from
	the situation.	The following list contains few known pitfalls
	and solutions.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89988304"></a>19.9.4.1. System Bootstrap Loads, but System Does Not Boot</h4></div></div></div><p>If for any reason the system does not continue to boot,
	  the bootstrap can be interrupted with by pressing the
	  <span class="keycap"><strong>space</strong></span> key at the 10-seconds warning.	 The
	  loader variables (like <code class="literal">vinum.autostart</code>)
	  can be examined using the <code class="command">show</code>, and
	  manipulated using <code class="command">set</code> or
	  <code class="command">unset</code> commands.</p><p>If the only problem was that the Vinum kernel module was
	  not yet in the list of modules to load automatically, a
	  simple <code class="command">load geom_vinum</code> will help.</p><p>When ready, the boot process can be continued with a
	  <code class="command">boot -as</code>.	The options
	  <code class="option">-as</code> will request the kernel to ask for the
	  root filesystem to mount (<code class="option">-a</code>), and make the
	  boot process stop in single-user mode (<code class="option">-s</code>),
	  where the root filesystem is mounted read-only.  That way,
	  even if only one plex of a multi-plex volume has been
	  mounted, no data inconsistency between plexes is being
	  risked.</p><p>At the prompt asking for a root filesystem to mount, any
	  device that contains a valid root filesystem can be entered.
	  If <code class="filename">/etc/fstab</code> had been set up
	  correctly, the default should be something like
	  <code class="literal">ufs:/dev/gvinum/root</code>.  A typical alternate
	  choice would be something like
	  <code class="literal">ufs:da0d</code> which could be a
	  hypothetical partition that contains the pre-Vinum root
	  filesystem.  Care should be taken if one of the alias
	  <code class="literal">"a"</code> partitions are entered here that are
	  actually reference to the subdisks of the Vinum root device,
	  because in a mirrored setup, this would only mount one piece
	  of a mirrored root device.  If this filesystem is to be
	  mounted read-write later on, it is necessary to remove the
	  other plex(es) of the Vinum root volume since these plexes
	  would otherwise carry inconsistent data.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp90000592"></a>19.9.4.2. Only Primary Bootstrap Loads</h4></div></div></div><p>If <code class="filename">/boot/loader</code> fails to load, but
	  the primary bootstrap still loads (visible by a single dash
	  in the left column of the screen right after the boot
	  process starts), an attempt can be made to interrupt the
	  primary bootstrap at this point, using the
	  <span class="keycap"><strong>space</strong></span> key.  This will make the bootstrap
	  stop in stage two, see <a class="xref" href="boot-blocks.html#boot-boot1" title="12.3.2. Stage One, /boot/boot1, and Stage Two, /boot/boot2">Sekcja 12.3.2, "Stage One, <code class="filename">/boot/boot1</code>, and Stage Two,
	<code class="filename">/boot/boot2</code>"</a>.  An
	  attempt can be made here to boot off an alternate partition,
	  like the partition containing the previous root filesystem
	  that has been moved away from <code class="literal">"a"</code>
	  above.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="vinum-root-panic"></a>19.9.4.3. Nothing Boots, the Bootstrap
	  Panics</h4></div></div></div><p>This situation will happen if the bootstrap had been
	  destroyed by the Vinum installation.	Unfortunately, Vinum
	  accidentally currently leaves only 4 KB at the beginning of
	  its partition free before starting to write its Vinum header
	  information.	However, the stage one and two bootstraps plus
	  the bsdlabel embedded between them currently require 8 KB.
	  So if a Vinum partition was started at offset 0 within a
	  slice or disk that was meant to be bootable, the Vinum setup
	  will trash the bootstrap.</p><p>Similarly, if the above situation has been recovered,
	  for example by booting from a <span class="quote">"<span class="quote">Fixit</span>"</span> medium,
	  and the bootstrap has been re-installed using
	  <code class="command">bsdlabel -B</code> as described in <a class="xref" href="boot-blocks.html#boot-boot1" title="12.3.2. Stage One, /boot/boot1, and Stage Two, /boot/boot2">Sekcja 12.3.2, "Stage One, <code class="filename">/boot/boot1</code>, and Stage Two,
	<code class="filename">/boot/boot2</code>"</a>, the bootstrap will trash the Vinum
	  header, and Vinum will no longer find its disk(s).  Though
	  no actual Vinum configuration data or data in Vinum volumes
	  will be trashed by this, and it would be possible to recover
	  all the data by entering exact the same Vinum configuration
	  data again, the situation is hard to fix at all.  It would
	  be necessary to move the entire Vinum partition by at least
	  4 KB off, in order to have the Vinum header and the system
	  bootstrap no longer collide.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="vinum-root-4x"></a>19.9.5. Differences for FreeBSD 4.X</h3></div></div></div><p>Under FreeBSD 4.X, some internal functions required to
	make Vinum automatically scan all disks are missing, and the
	code that figures out the internal ID of the root device is
	not smart enough to handle a name like
	<code class="filename">/dev/vinum/root</code> automatically.
	Therefore, things are a little different here.</p><p>Vinum must explicitly be told which disks to scan, using a
	line like the following one in
	<code class="filename">/boot/loader.conf</code>:</p><pre class="programlisting">vinum.drives="/dev/<em class="replaceable"><code>da0</code></em> /dev/<em class="replaceable"><code>da1</code></em>"</pre><p>It is important that all drives are mentioned that could
	possibly contain Vinum data.  It does not harm if
	<span class="emphasis"><em>more</em></span> drives are listed, nor is it
	necessary to add each slice and/or partition explicitly, since
	Vinum will scan all slices and partitions of the named drives
	for valid Vinum headers.</p><p>Since the routines used to parse the name of the root
	filesystem, and derive the device ID (major/minor number) are
	only prepared to handle <span class="quote">"<span class="quote">classical</span>"</span> device names
	like <code class="filename">/dev/ad0s1a</code>, they cannot make
	any sense out of a root volume name like
	<code class="filename">/dev/vinum/root</code>.  For that reason,
	Vinum itself needs to pre-setup the internal kernel parameter
	that holds the ID of the root device during its own
	initialization.	 This is requested by passing the name of the
	root volume in the loader variable
	<code class="literal">vinum.root</code>.	The entry in
	<code class="filename">/boot/loader.conf</code> to accomplish this
	looks like:</p><pre class="programlisting">vinum.root="root"</pre><p>Now, when the kernel initialization tries to find out the
	root device to mount, it sees whether some kernel module has
	already pre-initialized the kernel parameter for it.  If that
	is the case, <span class="emphasis"><em>and</em></span> the device claiming the
	root device matches the major number of the driver as figured
	out from the name of the root device string being passed (that
	is, <code class="literal">"vinum"</code> in our case), it will use the
	pre-allocated device ID, instead of trying to figure out one
	itself.	 That way, during the usual automatic startup, it can
	continue to mount the Vinum root volume for the root
	filesystem.</p><p>However, when <code class="command">boot -a</code> has been
	requesting to ask for entering the name of the root device
	manually, it must be noted that this routine still cannot
	actually parse a name entered there that refers to a Vinum
	volume.  If any device name is entered that does not refer to
	a Vinum device, the mismatch between the major numbers of the
	pre-allocated root parameter and the driver as figured out
	from the given name will make this routine enter its normal
	parser, so entering a string like
	<code class="literal">ufs:da0d</code> will work as expected. Note
	that if this fails, it is however no longer possible to
	re-enter a string like <code class="literal">ufs:vinum/root</code>
	again, since it cannot be parsed.  The only way out is to
	reboot again, and start over then.  (At the
	<span class="quote">"<span class="quote">askroot</span>"</span> prompt, the initial
	<code class="filename">/dev/</code> can always be omitted.)</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="vinum-config.html">Poprzedni</a> </td><td width="20%" align="center"><a accesskey="u" href="vinum-vinum.html">Pocz±tek rozdzia³u</a></td><td width="40%" align="right"> <a accesskey="n" href="l10n.html">Nastêpny</a></td></tr><tr><td width="40%" align="left" valign="top">19.8. Configuring Vinum </td><td width="20%" align="center"><a accesskey="h" href="index.html">Spis tre¶ci</a></td><td width="40%" align="right" valign="top"> Rozdzia³ 20. Localization - I18N/L10N Usage and Setup</td></tr></table></div><p xmlns="" align="center"><small>All FreeBSD documents are available for download
    at <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="" align="center"><small>Questions that are not answered by the
    <a href="http://www.FreeBSD.org/docs.html">documentation</a> may be
    sent to &lt;<a href="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</a>&gt;.<br />
    Send questions about this document to &lt;<a href="mailto:freebsd-doc@FreeBSD.org">freebsd-doc@FreeBSD.org</a>&gt;.</small></p></body></html>