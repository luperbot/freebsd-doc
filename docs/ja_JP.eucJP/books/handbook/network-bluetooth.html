<?xml version="1.0" encoding="euc-jp" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>22.4. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD ハンドブック" /><link rel="up" href="advanced-networking.html" title="第22章 高度なネットワーク" /><link rel="prev" href="network-wireless.html" title="22.3. 無線ネットワーク" /><link rel="next" href="network-bridging.html" title="22.5. ブリッジ" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">22.4. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-wireless.html">戻る</a>〓</td><th width="60%" align="center">第22章 高度なネットワーク</th><td width="20%" align="right">〓<a accesskey="n" href="network-bridging.html">次へ</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>22.4. Bluetooth</h2></div><div><span class="authorgroup">原作: <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="surname">Lucistnik</span> <span class="firstname">Pav</span> [FAMILY Given]</span>. </span></div></div></div><a id="idp95677136" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95677648"></a>22.4.1. はじめに</h3></div></div></div><p>Bluetooth は免許のいらない 2.4 GHz の帯域を利用して、
	10 m 程度のパーソナルネットワークを作る無線技術です。
	ネットワークはたいていの場合、その場その場で、携帯電話や
	PDA やノートパソコンなどの携帯デバイスから形成されます。
	Wi-Fi などの他の有名な無線技術とは違い、
	Bluetooth はより高いレベルのサービスを提供します。
	たとえば、FTP のようなファイルサーバ、ファイルのプッシュ、
	音声伝送、シリアル線のエミュレーションなどのサービスです。</p><p>FreeBSD 内での Bluetooth スタックは Netgraph フレームワーク
	(<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a> 参照) を使って実現されています。
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a> ドライバは、
	多種多様な Bluetooth USB ドングルに対応しています。
	Broadcom BCM2033 チップを搭載した Bluetooth デバイスは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ubtbcmfw</span>(4)</span></a>
	および <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a> ドライバによって対応されています。
	3Com Bluetooth PC カード 3CRWB60-A は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a>
	ドライバによって対応されています。
	シリアルおよび UART を搭載した Bluetooth デバイスは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>,
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a> および <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>
	ドライバによって対応されています。
	この節では USB Bluetooth ドングルの使用法について説明します。
	Bluetooth に対応しているのは FreeBSD 5.0 以降のシステムです。</p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">5.0, 5.1 Release ではカーネルモジュールは利用可能ですが、
	  種々のユーティリティとマニュアルは標準でコンパイルされていません。
	</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95690704"></a>22.4.2. デバイスの挿入</h3></div></div></div><p>デフォルトでは Bluetooth
	デバイスドライバはカーネルモジュールとして利用できます。
	デバイスを接続する前に、
	カーネルにドライバを読み込む必要があります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>Bluetooth デバイスがシステム起動時に存在している場合、
	<code class="filename">/boot/loader.conf</code>
	からモジュールを読み込んでください。</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>USB ドングルを挿してください。コンソールに (または syslog に)
	下記のような表示が現れるでしょう。</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><p><code class="filename">/usr/share/examples/netgraph/bluetooth/rc.bluetooth</code>
	を <code class="filename">/etc/rc.bluetooth</code>
	のようなどこか便利な場所にコピーしてください。
	このスクリプトは Bluetooth
	スタックを開始および終了させるのに使われます。
	デバイスを抜く前にスタックを終了するのはよい考えですが、
	(たいていの場合) しなくても致命的ではありません。
	スタックを開始するときに、下記のような出力がされます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95701072"></a>22.4.3. ホストコントローラインタフェース (HCI)</h3></div></div></div><a id="idp95701712" class="indexterm"></a><p>ホストコントローラインタフェース (HCI) は、
	ベースバンドコントローラおよびリンクマネージャへのコマンドインタフェースを提供し、
	ハードウェアステータスおよびコントロールレジスタへアクセスします。
	このインタフェースは
	Bluetooth ベースバンド機能へアクセスする画一的な方法を提供します。
	ホストの HCI 層は Bluetooth ハードウェア上の HCI ファームウェアと、
	データとコマンドをやり取りします。
	ホストコントローラトランスポート層 (つまり物理的なバス) のドライバは、
	両方の HCI 層に相互に情報を交換する能力を与えます。</p><p>一つの Bluetooth デバイスにつき、<span class="emphasis"><em>hci</em></span>
	タイプの Netgraph ノードが一つ作成されます。
	HCI ノードは通常 Bluetooth デバイスドライバノード (下流) と
	L2CAP ノード (上流) に接続されます。
	すべての HCI 動作はデバイスドライバノード上ではなく、
	HCI ノード上で行われなくてはいけません。
	HCI ノードのデフォルト名は <span class="quote">「<span class="quote">devicehci</span>」</span> です。
	詳細については <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a> マニュアルを参照してください。</p><p>最も一般的なタスクの一つに、無線通信的に近傍にある Bluetooth
	デバイスの発見があります。
	この動作は <span class="emphasis"><em>inquiry (問い合わせ)</em></span> と呼ばれています。
	Inquiry や他の HCI に関連した動作は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a>
	ユーティリティによってなされます。
	下記の例は、どの
	Bluetooth デバイスが通信圏内にあるかを知る方法を示しています。
	デバイスのリストが表示されるには数秒かかります。
	リモートデバイスは <span class="emphasis"><em>discoverable (発見可能な)</em></span>
	モードにある場合にのみ
	inquiry に返答するということに注意してください。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> は
	Bluetooth デバイスに固有のアドレスです。
	これはネットワークカードの MAC アドレスに似ています。
	このアドレスはデバイスとの通信を続けるのに必要となります。
	BD_ADDR に人間が判読しやすい名前を割り当てることもできます。
	<code class="filename">/etc/bluetooth/hosts</code> ファイルには、
	既知の Bluetooth ホストに関する情報が含まれています。
	次の例はリモートデバイスに割り当てられている、
	人間が判読しやすい名前を得る方法を示しています。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>リモートの Bluetooth デバイス上で inquiry を実行すると、
	あなたのコンピュータは <span class="quote">「<span class="quote">your.host.name (ubt0)</span>」</span>
	と認識されます。
	ローカルデバイスに割り当てられた名前はいつでも変更できます。</p><p>Bluetooth システムは一対一接続 (二つの
	Bluetooth ユニットだけが関係します) または一対多接続を提供します。
	一対多接続では、接続はいくつかの Bluetooth デバイス間で共有されます。
	次の例は、ローカルデバイスに対するアクティブなベースバンド接続のリストを得る方法を示しています。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p><span class="emphasis"><em>connection handle</em></span>
	はベースバンド接続の終了が必要とされるときに便利です。
	もっとも、通常はこれを手動で行う必要はありません。
	Bluetooth スタックはアクティブでないベースバンド接続を自動的に終了します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>利用可能な HCI コマンドの完全な一覧を得るには、
	<code class="command">hccontrol help</code> を参照してください。
	HCI コマンドのほとんどはスーパユーザ権限を必要としません。</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95714384"></a>22.4.4. ロジカルリンクコントロールおよびアダプテーションプロトコル (L2CAP)</h3></div></div></div><a id="idp95715024" class="indexterm"></a><p>ロジカルリンクコントロールおよびアダプテーションプロトコル
	(L2CAP) は、プロトコル多重化ケーパビリティおよび分割・再編成動作を備えた、
	上位層プロトコルへのコネクション指向およびコネクションレスデータサービスを提供します。
	L2CAP は上位層プロトコルおよびアプリケーションが
	64 KB までの長さの
	L2CAP データパケットを送受信することを可能にします。</p><p>L2CAP は <span class="emphasis"><em>チャネル</em></span> の概念に基づいています。
	チャネルはベースバンド接続の上位に位置する論理的な接続です。
	それぞれのチャネルは多対一の方法で一つのプロトコルに結びつけられます。
	複数のチャネルを同じプロトコルに結びつけることは可能ですが、
	一つのチャネルを複数のプロトコルに結びつけることはできません。
	チャネル上で受け取られたそれぞれの L2CAP パケットは、
	適切なより上位のプロトコルに渡されます。
	複数のチャネルは同じベースバンド接続を共有できます。</p><p>一つの Bluetooth デバイスに対して、<span class="emphasis"><em>l2cap</em></span>
	タイプの Netgraph ノードが一つ作成されます。
	L2CAP ノードは通常 Bluetooth HCI ノード (下流) と
	Bluetooth ソケットノード (上流) に接続されます。
	L2CAP ノードのデフォルト名は <span class="quote">「<span class="quote">devicel2cap</span>」</span> です。
	詳細については <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a> マニュアルを参照してください。</p><p>便利なコマンドに、他のデバイスに ping を送ることができる
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a> があります。Bluetooth 実装によっては、
	送られたデータすべては返さないことがあります。
	したがって次の例で <span class="emphasis"><em>0 バイト</em></span> は正常です。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> ユーティリティは
	L2CAP ノード上でさまざまな操作を行うのに使われます。
	この例は、ローカルデバイスに対する論理的な接続 (チャネル)
	およびベースバンド接続の一覧を得る方法を示しています。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p>別の診断ツールが <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a> です。
	これは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> と同様の作業を、Bluetooth
	ネットワークに関するデータ構造についての行います。
	下記の例は上の <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> と同じ論理的な接続を示します。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95777360"></a>22.4.5. RFCOMM プロトコル</h3></div></div></div><a id="idp95778000" class="indexterm"></a><p>RFCOMM プロトコルは L2CAP
	プロトコルを介してシリアルポートのエミュレーションを提供します。
	このプロトコルは ETSI (訳注: 欧州電気通信標準化機構)
	標準 TS 07.10 に基づいています。
	RFCOMM プロトコルは、単純な伝送プロトコルに RS-232 (EIATIA-232-E)
	シリアルポートの 9 本の結線をエミュレートする項目を加えたものです。
	RFCOMM プロトコルは、二つの Bluetooth デバイス間で、最大 60
	までの同時接続 (RFCOMM チャネル) に対応しています。</p><p>RFCOMM の目的から、完全な通信経路は、異なるデバイス上
	(通信の端点) で動作している二つのアプリケーションと、
	その間の通信セグメントを含んでいます。RFCOMM
	は、それが動いているデバイスのシリアルポートを利用するアプリケーションをカバーするためのものです。
	通信セグメントはあるデバイスから他のデバイスへの Bluetooth リンクです
	(直接接続)。</p><p>RFCOMM は直接接続している場合のデバイス間の接続、
	またはネットワークの場合のデバイスとモデムの間の接続にだけ関係があります。
	RFCOMM は、一方が Bluetooth 無線技術で通信し、
	もう一方で有線インタフェースを提供するモジュールのような、
	他の構成にも対応できます。</p><p>FreeBSD では RFCOMM プロトコルは
	Bluetooth ソケット層に実装されています。</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95780176"></a>22.4.6. デバイスのペアリング</h3></div></div></div><a id="idp95780816" class="indexterm"></a><p>デフォルトでは Bluetooth 通信は認証されておらず、
	すべてのデバイスが他のすべてのデバイスと通信できます。
	Bluetooth デバイス (たとえば携帯電話) は特定のサービス
	(たとえばダイアルアップサービス) を提供するために、
	認証を要求することも選択できます。
	Bluetooth 認証は通常 <span class="emphasis"><em>PIN コード</em></span> で行われます。
	PIN コードは最長 16 文字のアスキー文字列です。
	ユーザは両デバイスで同じ PIN コードを入力することを要求されます。
	一度 PIN コードを入力すると、
	両デバイスは <span class="emphasis"><em>リンクキー</em></span> を作成します。
	その後、リンクキーはそのデバイス自身または、
	不揮発性記憶デバイス内に格納できます。
	次の機会には、両デバイスは前に作成されたリンクキーを使用するでしょう。
	このような手続きを<span class="emphasis"><em>ペアリング (pairing)</em></span>
	と呼びます。いずれかのデバイス上でリンクキーが失われたときには、
	ペアリングをやり直さなければならないことに注意してください。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> デーモンが
	Bluetooth 認証要求のすべてを扱う責任を負っています。
	デフォルトの設定ファイルは
	<code class="filename">/etc/bluetooth/hcsecd.conf</code> です。
	PIN コードが <span class="quote">「<span class="quote">1234</span>」</span>
	に設定された携帯電話に関する例は以下の通りです。</p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>PIN コードには (長さを除いて) 制限はありません。
	いくつかのデバイス (たとえば Bluetooth ヘッドフォン)
	には固定的な PIN コードが組み込まれているかもしれません。
	<code class="option">-d</code> オプションは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a>
	デーモンがフォアグラウンドで動作するように強制するため、
	何が起きているのか確認しやすくなります。
	リモートデバイスがペアリングを受け取るように設定して、
	リモートデバイスへの Bluetooth 接続を開始してください。
	リモートデバイスはペアリングが受け入れらた、と応答して
	PIN コードを要求するでしょう。
	<code class="filename">hcsecd.conf</code> 内にあるのと同じ
	PIN コードを入力してください。
	これであなたの PC とリモートデバイスがペアとなりました。
	また、リモートデバイスからペアリングを開始することもできます。
	以下は <code class="command">hcsecd</code> の出力例です。</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95788112"></a>22.4.7. サービスディスカバリプロトコル (SDP)</h3></div></div></div><a id="idp95788752" class="indexterm"></a><p>サービスディスカバリプロトコル (SDP) は、
	クライアントアプリケーションが、
	サーバアプリケーションが提供するサービスの存在とその属性を発見する手段を提供します。
	サービスの属性には提示されているサービスのタイプまたはクラス、
	および、サービスを利用するのに必要な仕組みまたはプロトコルの情報が含まれます。</p><p>SDP には SDP サーバと SDP クライアント間の通信が含まれます。
	SDP サーバは、サーバに関連づけられたサービスの特性について記述しているサービスレコードの一覧を維持しています。
	各サービスレコードにはそれぞれ 1 つのサービスの情報が書かれています。
	クライアントは SDP リクエストを出すことによって、
	SDP サーバが維持しているサービスレコードから情報を検索できます。
	クライアントまたはクライアントに関連づけられたアプリケーションがサービスを利用することにしたら、
	サービスを利用するためには、
	サービスプロバイダへの接続を別途開かなければなりません。
	SDP はサービスとそれらの属性を発見するための仕組みを提供しますが、
	そのサービスを利用するための仕組みは提供しません。</p><p>通常 SDP
	クライアントは希望するサービスの特性に基づいてサービスを検索します。
	しかしながら、サービスに関する事前の情報なしに、
	どのタイプのサービスが SDP
	サーバのサービスレコードに記述されているか知ることが望ましいことがあります。
	この、提供されている任意のサービスを閲覧する手順を、
	<span class="emphasis"><em>ブラウジング (browsing)</em></span> と呼びます。</p><p>現在のところ Bluetooth SDP サーバおよびクライアントは、
	<a class="link" href="http://www.geocities.com/m_evmenkin/" target="_top">ここ</a>
	からダウンロードできる第三者パッケージ
	<span class="application">sdp-1.5</span> で実装されています。
	<span class="application">sdptool</span>
	はコマンドラインの SDP クライアントです。
	次の例は SDP ブラウズの問い合わせ方法を示しています。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdptool browse 00:80:37:29:19:a4</code></strong>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 "Headset Audio Gateway" (0x1112)
 "Generic Audio" (0x1203)
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 3
</pre><p>... 等々。
	それぞれのサービスは属性の一覧 (たとえば RFCOMM チャネル)
	を持っていることに注意してください。サービスによっては、
	属性のリストの一部についてメモをとっておく必要があるかもしれません。
	Bluetooth 実装のいくつかは、サービスブラウジングに対応しておらず、
	空の一覧を返してくるかもしれません。この場合、
	特定のサービスを検索をすることは可能です。下記の例は
	OBEX オブジェクトプッシュ (OPUSH)
	サービスを検索する方法です。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</code></strong></pre><p>FreeBSD 上における Bluetooth クライアントへのサービス提供は
	<span class="application">sdpd</span> サーバが行います。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpd</code></strong></pre><p><span class="application">sdptool</span> は、ローカル
	SDP サーバにサービスを登録するのにも用いられます。
	下記の例は PPP (LAN)
	サービスを備えたネットワークアクセスを登録する方法を示しています。
	一部のサービスでは属性 (たとえば RFCOMM チャネル)
	を要求することに注意してください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdptool add --channel=7 LAN</code></strong></pre><p>ローカル SDP サーバに登録されたサービスの一覧は SDP
	ブラウザの問い合わせを <span class="quote">「<span class="quote">特別な</span>」</span> BD_ADDR
	に送ることで得られます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdptool browse ff:ff:ff:00:00:00</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95804240"></a>22.4.8. ダイアルアップネットワーク (DUN) および PPP (LAN)
	を用いたネットワークアクセスプロファイル</h3></div></div></div><p>ダイアルアップネットワーク (DUN) プロファイルはほとんどの場合、
	モデムや携帯電話とともに使用されます。
	このプロファイルが対象とする場面は以下のものです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>コンピュータから携帯電話またはモデムを、
	  ダイアルアップインターネットアクセスサーバへの接続、
	  または他のダイアルアップサービスを利用するための無線モデムとして使うこと</p></li><li class="listitem"><p>データ呼び出しを受けるための、
	  コンピュータによる携帯電話またはモデムの使用</p></li></ul></div><p>PPP (LAN) によるネットワークアクセスプロファイルは、
	次の状況で利用できます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>単一の Bluetooth デバイスへの LAN アクセス
	  </p></li><li class="listitem"><p>マルチ Bluetooth デバイスへの LAN アクセス
	  </p></li><li class="listitem"><p>(シリアルケーブルエミュレーション上の PPP
	    ネットワーク接続を使用した) PC から PC への接続</p></li></ul></div><p>FreeBSD ではどちらのプロファイルも <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> と
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> (RFCOMM Bluetooth 接続を
	PPP が制御可能なように変換するラッパ) で実装されています。
	いずれかのプロファイルが使用可能となる前に、
	<code class="filename">/etc/ppp/ppp.conf</code> 内に新しい
	PPP ラベルが作成されていなければなりません。
	例については、 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>
	のマニュアルページを参照してください。</p><p>次の例では、DUN RFCOMM チャネル上で
	BD_ADDR が 00:80:37:29:19:a4 のリモートデバイスへの RFCOMM
	接続を開くのに <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> が使われます。実際の RFCOMM
	チャネル番号は SDP を介してリモートデバイスから得ます。
	手動で RFCOMM チャネルを指定することもでき、その場合
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> は SDP 問い合わせを実行しません。
	リモートデバイス上の RFCOMM チャネルを見つけるには、
	<span class="application">sdptool</span> を使ってください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>PPP (LAN) サービスでネットワークアクセスを提供するためには、
	<span class="application">sdpd</span> サーバが動いていなければなりません。
	これはローカル SDP サーバに LAN サービスを登録するのにも必要です。
	LAN サービスは RFCOMM チャネル属性を必要とすることに注意してください。
	<code class="filename">/etc/ppp/ppp.conf</code> ファイル内に
	LAN クライアントの新しいエントリを作成しなければなりません。
	例については <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> のマニュアルページを参照してください。
	最後に、RFCOMM PPP サーバが実行され、
	ローカル SDP サーバに登録されているのと同じ
	RFCOMM チャネルで待ち受けていなければなりません。
	次の例は RFCOMM PPP サーバを起動する方法を示しています。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95822928"></a>22.4.9. OBEX プッシュ (OPUSH) プロファイル</h3></div></div></div><a id="idp95823568" class="indexterm"></a><p>OBEX はモバイルデバイス間で広く使われている単純なファイル転送プロトコルです。
	これは主に赤外線通信で利用されており、ノートパソコンや
	PDA 間の汎用的なファイル転送、および
	PIM アプリケーションを搭載した携帯電話その他のデバイス間で名刺やカレンダーエントリを転送するのに用いられます。</p><p>OBEX サーバおよびクライアントは、
	<a class="link" href="http://www.geocities.com/m_evmenkin/" target="_top">ここ</a>
	からダウンロードできる <span class="application">obexapp-1.0</span>
	という第三者のパッケージとして実装されています。
	このパッケージは <span class="application">openobex</span> ライブラリ
	(上記の <span class="application">obexapp</span> に含まれます) および
	<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/devel/glib12/pkg-descr">devel/glib12</a> port を必要とします。
	なお、<span class="application">obexapp</span>
	はルート権限を必要としません。</p><p>OBEX クライアントは OBEX
	サーバとの間でオブジェクトを渡したり (プッシュ)
	および受け取ったり (プル) するのに使用されます。
	オブジェクトは、たとえば名刺や予定などになります。
	OBEX クライアントは RFCOMM チャネル番号を
	SDP によってリモートデバイスから得ることができます。
	これは RFCOMM チャネル番号の代わりにサービス名を指定することによって行うことができます。
	対応しているサービス名は IrMC, FTRN および OPUSH です。
	RFCOMM チャネルを番号で指定することもできます。
	下記は、デバイス情報オブジェクトを携帯電話から受け取り、
	新しいオブジェクト (名刺) が携帯電話に渡される場合の
	OBEX セッションの例です。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>OBEX プッシュサービスを提供するためには、
	<span class="application">sdpd</span>
	サーバが実行されていなければなりません。
	また OPUSH サービスをローカル SDP サーバに登録することも必要です。
	なお、OPUSH サービスには RFCOMM チャネル属性が必要です。
	渡されるオブジェクトをすべて格納するルートフォルダを作成しなければいけません。
	ルートフォルダのデフォルトパスは
	<code class="filename">/var/spool/obex</code> です。
	最後に OBEX サーバが実行され、
	ローカル SDP サーバに登録されているのと同じ
	RFCOMM チャネルで待ち受けていなければなりません。
	下記の例は OBEX サーバの起動方法を示します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95835216"></a>22.4.10. シリアルポート (SP) プロファイル</h3></div></div></div><p>シリアルポート (SP) プロファイルは Bluetooth デバイスが RS232
	(または同様の) シリアルケーブルエミュレーションを行えるようにします。
	このプロファイルが対象とする場面は、
	レガシーアプリケーションが、仮想シリアルポート抽象を介して
	Bluetooth をケーブルの代替品として使うところです。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a>
	ユーティリティはシリアルポートプロファイルを実装します。
	Pseudo tty が仮想シリアルポート抽象概念として用いられます。
	下記の例はリモートデバイスのシリアルポートサービスへ接続する方法を示します。
	なお、RFCOMM チャネルを指定する必要はありません。―
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> は
	SDP を介してリモートデバイスからその情報を得ることができます。
	これを上書きしたい場合にはコマンドラインで
	RFCOMM チャネルを指定してください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>接続された pseudo tty はシリアルポートとして利用することができます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95840464"></a>22.4.11. トラブルシューティング</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95841104"></a>22.4.11.1. リモートデバイスが接続できません</h4></div></div></div><p>古い Bluetooth
	  デバイスのなかにはロールスイッチング (role switching)
	  に対応していないものがあります。
	  デフォルトでは FreeBSD が新しい接続を受け付けるときに、
	  ロールスイッチを実行してマスタになろうとします。
	  これに対応していないデバイスは接続できないでしょう。
	  なお、ロールスイッチングは新しい接続が確立されるときに実行されるので、
	  ロールスイッチングに対応しているかどうかリモートデバイスに問い合わせることはできません。
	  ローカル側でロールスイッチングを無効にする
	  HCI オプションがあります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp95847376"></a>22.4.11.2. 何かがうまくいっていないみたいです。
	  何が実際に起こっているか確認できますか?</h4></div></div></div><p>できます。
	  <a class="link" href="http://www.geocities.com/m_evmenkin/" target="_top">ここ</a>
	  からダウンロードできる第三者パッケージ
	  <span class="application">hcidump-1.5</span> を使ってください。
	  <span class="application">hcidump</span> ユーティリティは
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a> と似ています。
	  これはターミナル上の Bluetooth パケットの内容の表示および
	  Bluetooth パケットをファイルにダンプするのに使えます。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-wireless.html">戻る</a>〓</td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">上に戻る</a></td><td width="40%" align="right">〓<a accesskey="n" href="network-bridging.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">22.3. 無線ネットワーク〓</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">〓22.5. ブリッジ</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文書、および他の文書は
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>
    からダウンロードできます。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>FreeBSD に関する質問がある場合には、
    <a href="http://www.FreeBSD.org/ja/docs.html">ドキュメント</a> を読んだ上で
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt; まで (英語で) 連絡してください。<br></br>
    本文書に関する質問については、
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt; まで電子メールを (英語で) 送ってください。</small></p></body></html>