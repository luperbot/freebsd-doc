<?xml version="1.0" encoding="euc-jp" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>第10章 PPP</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="up" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="prev" href="networking.html" title="第9章 ネットワーキング" /><link rel="next" href="serial.html" title="第11章 シリアル接続" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第10章 PPP</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="networking.html">戻る</a>〓</td><th width="60%" align="center">〓</th><td width="20%" align="right">〓<a accesskey="n" href="serial.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ppp"></a>第10章 PPP</h1></div></div></div><div class="qandaset"><a id="idp82356816"></a><dl><dt>10.1. <a href="ppp.html#idp82357072">ppp が動きません。どこを間違えているのでしょう?</a></dt><dt>10.2. <a href="ppp.html#idp82376272">ppp を実行するとハングします</a></dt><dt>10.3. <a href="ppp.html#idp82381392">ppp が
            -auto モードでダイアルしてくれない</a></dt><dt>10.4. <a href="ppp.html#idp82393552">「No route to host」
            とはどういう意味ですか?</a></dt><dt>10.5. <a href="ppp.html#idp82403920">3 分ほど経つと接続が切れてしまう</a></dt><dt>10.6. <a href="ppp.html#idp82413264">負荷が高いと接続が切れてしまう</a></dt><dt>10.7. <a href="ppp.html#idp82421456">接続がランダムに切れてしまう</a></dt><dt>10.8. <a href="ppp.html#idp82424656">接続が不規則にハングアップしてしまう</a></dt><dt>10.9. <a href="ppp.html#idp82437072">回線の向こう側での反応がない</a></dt><dt>10.10. <a href="ppp.html#idp82443728">ppp がハングアップする</a></dt><dt>10.11. <a href="ppp.html#idp82451664">Login OK!
            のメッセージが出た後、何も起こらない</a></dt><dt>10.12. <a href="ppp.html#idp82458064">でもまだ 「magic is the same」
            というエラーが出る</a></dt><dt>10.13. <a href="ppp.html#idp82503376">接続が切れるまで LCP
            のネゴシエーションが続くのですが。</a></dt><dt>10.14. <a href="ppp.html#idp82545360">ppp が接続直後に固まってしまう</a></dt><dt>10.15. <a href="ppp.html#idp82553168">ppp の内部でシェルを起動しようとすると固まってしまう</a></dt><dt>10.16. <a href="ppp.html#idp82559056">ヌルモデムケーブルを使用しているとき、
            ppp が終了しない</a></dt><dt>10.17. <a href="ppp.html#idp82563664">ppp を
            -auto モードで動かすと、
            勝手にダイアルすることがある</a></dt><dt>10.18. <a href="ppp.html#idp82590160">CCP
            エラーとはどういう意味ですか</a></dt><dt>10.19. <a href="ppp.html#idp82594000">ファイル転送の途中で、ppp が
            IO エラーを出して固まってしまう</a></dt><dt>10.20. <a href="ppp.html#idp82610000">どうして ppp
            は接続速度をログに残さないんでしょう?</a></dt><dt>10.21. <a href="ppp.html#idp82628176">私の chat スクリプトでは
            「\」
            という文字を PPP が解釈してくれません。</a></dt><dt>10.22. <a href="ppp.html#idp82647760">ppp が
            segmentation fault になるのですが、
            ppp.core ファイルがありません</a></dt><dt>10.23. <a href="ppp.html#idp82672976">auto モードでダイアルをするようなプロセスが接続されない。
          </a></dt><dt>10.24. <a href="ppp.html#idp82713808">何故ほとんどのゲームが
            -nat スイッチ付きだと動かないんですか?</a></dt><dt>10.25. <a href="ppp.html#idp82764112">有用なポート番号のリストはありませんか?</a></dt><dt>10.26. <a href="ppp.html#idp82790224">FCS エラーって何?</a></dt><dt>10.27. <a href="ppp.html#PPPoEwithNAT">ゲートウェイで PPPoE を実行すると MacOS や
            Windows 98 との接続がフリーズしてしまうのですが、
            これはなぜなのでしょうか?</a></dt><dt>10.28. <a href="ppp.html#idp82824400">どれにも当てはまらない! どうしたらいいの?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp82357072"></a><a id="userppp"></a><p><strong>10.1.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が動きません。どこを間違えているのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            のマニュアルと、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP" target="_top">FreeBSD
              ハンドブックの「PPP」</a>を読んでみましょう。
            次に、
          </p><pre class="programlisting">set log Phase Chat Connect Carrier lcp ipcp ccp command</pre><p>
            という命令を <span class="application">ppp</span>
            のコマンドプロンプトに対して打ち込むか、
            設定ファイル
            <code class="filename">/etc/ppp/ppp.conf</code>
            に加えて (<code class="literal">default</code>
            セクションの先頭に加えるのが一番良いでしょう)
            ログを有効にしてみてください。
            その際、
            <code class="filename">/etc/syslog.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">syslog.conf</span>(5)</span></a> 参照)
            に
          </p><pre class="programlisting">!ppp
*.*              /var/log/ppp.log</pre><p>
            と書かれた行が含まれているか、また、
            <code class="filename">/var/log/ppp.log</code>
            が存在しているかどうか確かめておいてください。
            さて、これで何が起きているのか突き止めるために、
            ログファイルからたくさんの情報を得られるようになりました。
            ログに訳の分らない部分があっても心配ご無用。
            あなたが助けを求めた誰かにとっては、
            その部分が意味をなす場合があるのです。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                ログの取得に syslog を使用するようになったのは
                2.2.5 以降からです。
              </p></div><p>
            使用中の <code class="command">ppp</code> のバージョンで
            <span class="quote">「<span class="quote"><code class="literal">set log</code></span>」</span>
            命令を解釈しない場合は、<a class="link" href="http://people.FreeBSD.org/~brian/" target="_top">最新版</a>をダウンロードすべきです。
            FreeBSD の 2.1.5 以降でビルドできます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82376272"></a><a id="ppp-hangs"></a><p><strong>10.2.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> を実行するとハングします</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ホスト名の解決がうまくいっていないのでしょう。まず、
            リゾルバ (resolver) が
            <code class="filename">/etc/hosts</code>を参照するように、
            <code class="filename">/etc/host.conf</code>
            の最初の行に
            <code class="literal">host</code>
            と書き込んでください。
            つぎに、<code class="filename">/etc/hosts</code>
            に使用しているマシンのエントリを書き加えます。
            ローカルでネットワークを使用していない場合は、
            <code class="literal">localhost</code>
            の行を以下のように変更してください。
          </p><pre class="programlisting">127.0.0.1      foo.bar.com foo localhost</pre><p>
            使用しているホストのエントリを追加してもかまいません。
            詳細は関連するマンページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82381392"></a><a id="ppp-nodial-auto"></a><p><strong>10.3.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が
            <code class="option">-auto</code> モードでダイアルしてくれない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まず最初に、デフォルトルートが確立しているかどうかチェックしてください。
            <code class="command">netstat -rn</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> 参照)
            を実行すると、以下のような情報が表示されるはずです。
          </p><pre class="screen">Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</pre><p>
            これはあなたがハンドブックやマニュアル、
            <code class="filename">ppp.conf.sample</code>
            の中で出てくるアドレスを使用していると仮定した場合の例です。
            デフォルトルートが確立していない場合、
            <code class="filename">ppp.conf</code>
            の中の
            <code class="literal">HISADDR</code>
            が理解できない、
            古いバージョンの
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            が走っている可能性があります。
            FreeBSD 2.2.5 より前のバージョンに付属していた
            <span class="application">ppp</span>
            を使用している場合、
          </p><pre class="programlisting">add 0 0 HISADDR</pre><p>
            と書かれた行を以下のように修正してください。
          </p><pre class="programlisting">add 0 0 10.0.0.2</pre><p>
            <code class="command">netstat -rn</code>
            でデフォルトルートの情報が表示されない場合、もう一つ、
            <code class="filename">/etc/rc.conf</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> 参照) (2.2.2
            より前のリリースでは
            <code class="filename">/etc/sysconfig</code>
            と呼ばれていました) の中でデフォルトのルータを誤って設定し、
            <code class="filename">ppp.conf</code> から
          </p><pre class="programlisting">delete ALL</pre><p>
            の行をうっかり消してしまった可能性があります。
            この場合は、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP-FINAL" target="_top">FreeBSD
              ハンドブックの「システムの最終設定」</a>の項を読み直してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82393552"></a><a id="no-route-to-host"></a><p><strong>10.4.</strong></p></td><td align="left" valign="top"><p><span class="quote">「<span class="quote"><code class="computeroutput">No route to host</code></span>」</span>
            とはどういう意味ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            このエラーは通常、
            <code class="filename">/etc/ppp/ppp.linkup</code>
            に以下のようなセクションが無い場合に起こります。
          </p><pre class="programlisting">MYADDR:
  delete ALL
  add 0 0 HISADDR</pre><p>
            これは動的 <acronym class="acronym">IP</acronym>
            アドレスを使用している場合、
            またはゲートウェイのアドレスを知らない場合にのみ必要な設定です。
            インタラクティブモードを使用している場合、
            <span class="emphasis"><em>パケットモード</em></span>に入った後で (プロンプトが
            <acronym class="acronym">PPP</acronym>
            と大文字に変わったらパケットモードに入ったしるしです)、
            以下の命令を入力してください。
          </p><pre class="screen">delete ALL
add 0 0 HISADDR</pre><p>
            詳しい情報については、
            <a class="link" href="../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP" target="_top">FreeBSD
              ハンドブックの「PPP と動的 IP 設定」</a>の項を参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82403920"></a><a id="connection-threeminutedrop"></a><p><strong>10.5.</strong></p></td><td align="left" valign="top"><p>3 分ほど経つと接続が切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">ppp</code>
            のタイムアウトは デフォルトでは 3 分です。
            これは
          </p><pre class="programlisting">set timeout <em class="replaceable"><code>NNN</code></em></pre><p>
            という命令によって調整することができます。
            <em class="replaceable"><code>NNN</code></em> には、
            接続が切れるまでのアイドル時間が秒数で入ります。
            <em class="replaceable"><code>NNN</code></em> が 0 の場合、
            タイムアウトによる切断は起こりません。
            このコマンドは <code class="filename">ppp.conf</code>
            に入れることも、
            インタラクティブモードでプロンプトから入力することも
            できます。
            ソケットを用いる
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> か <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppctl</span>(8)</span></a> を使用し、
            <span class="application">ppp</span>
            サーバに接続することによって、
            回線がアクティブな間に限定してタイムアウトの時間を調整することも可能です。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                <code class="command">pppctl</code> は 2.2.5R からです。
              </p></div><p>
            詳しい情報は
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            のマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82413264"></a><a id="ppp-drop-heavy-load"></a><p><strong>10.6.</strong></p></td><td align="left" valign="top"><p>負荷が高いと接続が切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Link Quality Reporting (LQR) の設定を行っている場合、
            マシンと接続先の間で非常にたくさんの <acronym class="acronym">LQR</acronym>
            パケットが失われている可能性があります。結果として
            <code class="command">ppp</code> は回線の具合いが悪いと考え、
            回線を切断するのです。2.2.5 より前のバージョンの FreeBSD では
            <acronym class="acronym">LQR</acronym>
            はデフォルトで有効になっています。
            現在ではデフォルトの状態で無効です。
            <acronym class="acronym">LQR</acronym>
            は以下の命令で無効にすることができます。
          </p><pre class="programlisting">disable lqr</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82421456"></a><a id="ppp-drop-random"></a><p><strong>10.7.</strong></p></td><td align="left" valign="top"><p>接続がランダムに切れてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ノイズの多い回線、あるいは待ち機能付きの回線では、
            時々モデムが (誤って) キャリアを失ったと思い込み、
            回線が切断されてしまうことがあります。
          </p><p>
            大多数のモデムでは、
            一時的なキャリアの喪失をどれくらいの時間で検出するかを、
            設定で決めることができます。
            たとえば USR Sportster では、S10 レジスタ
            の値を 10 倍した秒数がその値になります。
            この場合、モデムをもっとのんびり屋さんにするには、
            dial 行に次のような文字列を加えると良いでしょう。
          </p><pre class="programlisting">set dial "...... ATS10=10 OK ......"</pre><p>
            詳しくはお使いのモデムのマニュアルをご覧ください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82424656"></a><a id="ppp-hangs-random"></a><p><strong>10.8.</strong></p></td><td align="left" valign="top"><p>接続が不規則にハングアップしてしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            たくさんの人が、原因不明のハングアップを経験しています。
            検証のために必要なのは、まずどちら側のリンクでそれが起こっているか、
            ということです。
          </p><p>
            外部接続型モデムを利用しているなら、
            単に <code class="command">ping</code> を使うことで、
            データを送信するときに <acronym class="acronym">TD</acronym>
            ランプが点灯するかどうかを確認することができます。
            もし、<acronym class="acronym">TD</acronym> ランプが点灯して、
            <acronym class="acronym">RD</acronym> ランプが点灯しなければ、
            問題は回線の向こう側にあります。<acronym class="acronym">TD</acronym> が点灯しなければ、
            問題は回線のこちら側です。内蔵型モデムの場合、
            <code class="filename">ppp.conf</code> ファイルに
            <code class="command">set server</code> コマンドを入れる必要があるでしょう。
            回線が切断されたとき、<code class="command">pppctl</code>
            を使って <code class="command">ppp</code>
            に接続してください。
            そのとき、
            ネットワーク接続が急に復旧 (診断ソケットへのアクセスで、
            <code class="command">ppp</code> が復活します) するか、
            もしくは接続自体が全くできない (ただし、
            <code class="command">ppp</code>
            起動時に <code class="command">set socket</code>
            コマンドがちゃんと実行されているとします) としたら、
            問題は回線のこちら側です。
            もし、接続可能で、かつ状況が変化しなければ、
            <code class="command">set log local async</code>
            を使ってローカル非同期ログ (async logging) を有効にし、
            <code class="command">ping</code>
            を他のウィンドウかターミナルから使ってください。
            非同期ログには、こちら側のリンクの送受信データが記録されます。
            もし、データが送信されたにもかかわらず返って来ていなければ、
            問題は回線の向こう側にあることになります。
          </p><p>
            問題が回線のどちら側かにあることが分かったら、
            つぎの二つの可能性が考えられるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82437072"></a><a id="ppp-remote-not-responding"></a><p><strong>10.9.</strong></p></td><td align="left" valign="top"><p>回線の向こう側での反応がない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これに対処できることはほとんどありません。大部分の ISP
            は、Microsoft 社製 OS 以外の利用者に対してのサポートを拒否するでしょう。
            <code class="filename">ppp.conf</code> ファイルの中に
            <code class="literal">enable lqr</code>
            を記述することで
            <code class="command">ppp</code>
            が回線の向こう側で発生する切断を検出することができますが、
            この検出は比較的遅いため、あまり役に立ちません。また、あなたは
            user-ppp を利用していることを
            ISP に知られたくないと思うかも知れませんね。
          </p><p>
            まず最初に、こちら側の圧縮機能をすべて無効にしてみてください。
            それには、設定ファイルをつぎのようにします。
          </p><pre class="programlisting">disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</pre><p>
            そして再接続し、変更前と同じように通信できることを確認します。
            もしこれによって状況が改善されるか、完全に解決したら、
            (上の設定のうち) どの設定で状況が変化したのかを、
            色々な組合せで試してみてください。これは、ISP
            に問い合わせを行なうときの有効な情報となります (ただし、
            あなたが Microsoft
            社製品以外のものを利用していることも明らかにしてしまいますが)。
          </p><p>
            ISP に問い合わせを行なう前に、こちら側の非同期ログを有効にして、
            接続がハングアップするまで待ってください。この作業は、
            非常に多くのディスク空間を消費するかも知れません。
            興味の対象となっているのは、通信ポートから最後に読み込まれたデータです。
            それは通常 <acronym class="acronym">ASCII</acronym> データで、
            問題点の詳細 (<span class="quote">「<span class="quote"><code class="computeroutput">Memory fault, core dump</code></span>」</span> など) が
            記載されている可能性があります。
          </p><p>
            回線の向こう側で通信ログを監視することは可能なはずですので、
            切断が発生した時、ISP の対応が好意的ならば
            どうして ISP 側で問題が発生したのかこちらに伝えてくれるかも知れません。
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:brian@Awfulhak.org">brian@Awfulhak.org</a>&gt;</code>
            まで詳細を送って頂くか、ISP
            に直接私に連絡するように伝えて下さっても構いません。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82443728"></a><a id="ppp-hung"></a><p><strong>10.10.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> がハングアップする</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ベストな方法は、
            <code class="literal">CFLAGS+=-g</code> と
            <code class="literal">STRIP=</code> を
            <code class="command">ppp</code> の
            <code class="filename">Makefile</code>
            に追加して、
            <code class="command">ppp</code> を再構築し、
            そして
            <code class="literal">make clean &amp;&amp; make &amp;&amp; make install</code>
            を行なうことです。
            <code class="command">ppp</code> がハングアップした時、
            <code class="literal">ps ajxww | fgrep ppp</code> を使って
            <code class="command">ppp</code>
            のプロセス ID を調べ、
            <code class="literal">gdb ppp PID</code> を実行してください。
            <code class="command">gdb</code>
            のプロンプトから、
            <code class="command">bt</code>
            を使ってスタックをトレースすることができます。
          </p><p>
            スタックトレースの結果は、<code class="email">&lt;<a xmlns="" class="email" href="mailto:brian@Awfulhak.org">brian@Awfulhak.org</a>&gt;</code>
            まで送ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82451664"></a><a id="ppp-loginok-thennothing"></a><p><strong>10.11.</strong></p></td><td align="left" valign="top"><p><code class="computeroutput">Login OK!</code>
            のメッセージが出た後、何も起こらない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            2.2.5 より前のリリースの FreeBSD では、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            はリンクが確立した後、接続先が <acronym class="acronym">Line Control Protocol (LCP)</acronym>
            を発信するのを待ちます。しかし、多くの <acronym class="acronym">ISP</acronym>
            ではネゴシエーションを自分からは起こさず、
            クライアントが起こすのを待っています。
            <span class="application">ppp</span> に強制的に
            <acronym class="acronym">LCP</acronym> を発信させるには、
            次の命令を使います。
          </p><pre class="programlisting">set openmode active</pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                両方の側がネゴジェーションを起こしても、
                大抵の場合は何の問題もありません。
                ですから、現在では openmode
                はデフォルトで有効になっています。
                次のセクションでこれが<span class="emphasis"><em>問題になる場合</em></span>を説明します。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82458064"></a><a id="ppp-same-magic"></a><p><strong>10.12.</strong></p></td><td align="left" valign="top"><p>でもまだ <span class="quote">「<span class="quote"><code class="computeroutput">magic is the same</code></span>」</span>
            というエラーが出る</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            時折、接続直後のログに
            <span class="quote">「<span class="quote"><code class="computeroutput">magic is the same</code></span>」</span>
            というメッセージがあらわれることがあります。
            このメッセージがあらわれても何も起きない場合もありますし、
            どちらかの側が接続を切ってしまう場合もあります。
            <code class="command">ppp</code> の実装の多くはこの問題に対応できておらず、
            その場合にはちゃんと link が上がっている状態であっても、
            <code class="command">ppp</code> が最終的にあきらめてしまい、
            接続を切るまで設定のリクエストが繰り返し送られ、
            設定が行われたという通知がログファイルに残ると思います。
          </p><p>
            これは通常、
            ディスクアクセスの遅いサーバマシンのシリアルポートで
            <code class="command">getty</code> が生きていて、
            <code class="command">ppp</code> がログインスクリプトか、
            ログイン直後に起動されたプログラムから実行されている場合に起こります。
            <code class="command">slirp</code>
            を使用している場合に同様の症状が見られたという報告もあります。
            原因は
            <code class="command">getty</code> の終了されるまでと、
            <code class="command">ppp</code> が実行され、
            クライアント側の
            <code class="command">ppp</code> が
            <acronym class="acronym">Line Control Protocol (LCP)</acronym>
            を送り始めるまでのタイミングにあります。
            サーバ側のシリアルポートで
            <code class="literal">ECHO</code>
            が有効なままになっているので、
            クライアント側の
            <code class="command">ppp</code>
            にパケットが「反射」してしまうのです。
          </p><p>
            <acronym class="acronym">LCP</acronym>
            ネゴシエーションの一部として、
            リンクの両サイドで
            magic number を定めて、
            「反射」が起きていないかどうか確かめる作業があります。
            規約では、接続相手がこちらと同じ magic number を提示してきたら、
            <acronym class="acronym">NAK</acronym> を送って新しい
            magic number を選択しなければならないと定めています。
            この作業の間、サーバのシリアルポートの
            <code class="literal">ECHO</code> がずっと有効になったままなので、
            クライアント側の <code class="command">ppp</code>
            は <acronym class="acronym">LCP</acronym> パケットを送り、
            パケットが反射して全く同じ magic number
            が送られてくるのを見つけ、
            それに対して <acronym class="acronym">NAK</acronym>
            を送るのです。一方 <acronym class="acronym">NAK</acronym>
            自体も (これは <code class="command">ppp</code>
            が magic number
            を変更しなければいけないことを意味しています) 反射してくるので、
            結果として magic number が数えきれないほど変更され、
            そのすべてがサーバの <acronym class="acronym">tty</acronym>
            バッファの中に積み重なることになるのです。
            サーバでスタートした <code class="command">ppp</code>
            は、すぐに magic number であふれかえってしまい、
            <acronym class="acronym">LCP</acronym>
            のネゴシエーションを十分に行ったものと判断して、
            さっさと接続を切ってしまいます。
            一方、
            クライアント側は反射が帰ってこなくなったので満足しますが、
            それもサーバが接続を切ったことを知るまでです。
          </p><p>
            この事態は、以下の行を
            <code class="filename">ppp.conf</code>
            の中に書いて、
            相手がネゴシエーションを開始できるようにする事によって回避できます。
          </p><pre class="programlisting">set openmode passive</pre><p>
            これで <code class="command">ppp</code> はサーバが
            <acronym class="acronym">LCP</acronym>
            ネゴシエーションを起こすのを待つようになります。
            しかし、
            自分からは決してネゴジェーションを起こさないサーバもあるかもしれません。
            もしこの状況に遭遇した場合には、次のようにしてください。
          </p><pre class="programlisting">set openmode active 3</pre><p>
            これによって <code class="command">ppp</code> は 3 秒間
            passive モードを続けた後で、
            <acronym class="acronym">LCP</acronym> リクエストを送り始めます。
            この間に相手がリクエストを送り始めた場合には
            3 秒間待たずにこのリクエストに即座に応答します。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82503376"></a><a id="ppp-lcp-constant"></a><p><strong>10.13.</strong></p></td><td align="left" valign="top"><p>接続が切れるまで <acronym class="acronym">LCP</acronym>
            のネゴシエーションが続くのですが。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            現在の <span class="application">ppp</span> は、まだ
            <acronym class="acronym">LCP</acronym> や
            <acronym class="acronym">CCP</acronym>、
            <acronym class="acronym">IPCP</acronym>
            の返事が、
            元のリクエストと連携してくれる機能がきちんと実装されていません。
            その結果、ある
            <span class="application">ppp</span>
            の実装が相手よりも 6 秒以上遅い場合には、
            <acronym class="acronym">LCP</acronym> 設定のリクエストをさらに 2 回送ります。
            これは致命的な物です。
          </p><p>
            <code class="systemitem">A</code> と <code class="systemitem">B</code>という
            2 つの実装を考えてみましょう。
            <code class="systemitem">A</code> が接続の直後に
            <acronym class="acronym">LCP</acronym> リクエストを送り、
            一方 <code class="systemitem">B</code> の方はスタートするのに
            7 秒かかったとします。<code class="systemitem">B</code> がスタートする時には
            <code class="systemitem">A</code> は <acronym class="acronym">LCP</acronym>
            リクエストを 3 回送ってしまっています。
            前の節で述べた magic number の問題が起きないよう、
            <code class="literal">ECHO</code> は <code class="literal">off</code> になっていると考えています。
            <code class="systemitem">B</code> は <acronym class="acronym">REQ</acronym> を送ります。
            するとこれは <code class="systemitem">A</code> の <acronym class="acronym">REQ</acronym> のうち、
            最初の物に対する <acronym class="acronym">ACK</acronym> となります。
            結果として、<code class="systemitem">A</code>
            は <acronym class="acronym">OPENED</acronym>
            の状態に入り、
            <code class="systemitem">B</code>
            に対して (最初の) <acronym class="acronym">ACK</acronym> を送ります。
            そのうちに
            <code class="systemitem">B</code> は、<code class="systemitem">B</code>
            がスタートする前に
            <code class="systemitem">A</code>
            から送られたもう 2 つの
            <acronym class="acronym">REQ</acronym> に対する
            <acronym class="acronym">ACK</acronym> を送り返します。
            <code class="systemitem">B</code> は <code class="systemitem">A</code>
            からの最初の
            <acronym class="acronym">ACK</acronym> を受け取り
            <acronym class="acronym">OPENED</acronym> の状態に入ります。
            <code class="systemitem">A</code> は <code class="systemitem">B</code> からの
            2 つ目の <acronym class="acronym">ACK</acronym>
            を受け取りますので、
            <acronym class="acronym">REQ-SENT</acronym>の状態に戻り、
            さらに、RFC のとおりに (4 つ目の) <acronym class="acronym">REQ</acronym>
            を送ります。そして 3 つ目の
            <acronym class="acronym">ACK</acronym>
            を受け取って
            <acronym class="acronym">OPENED</acronym> 状態に入ります。
            一方、<code class="systemitem">B</code> は <code class="systemitem">A</code>
            からの 4 つ目の
            <acronym class="acronym">REQ</acronym>
            を受け取りますので、
            <acronym class="acronym">ACK-SENT</acronym>
            の状態に入り、2 つ目の
            <acronym class="acronym">REQ</acronym>
            と 4 つ目の
            <acronym class="acronym">ACK</acronym> を
            RFC のとおりに送ります。
            <code class="systemitem">A</code>は、
            <acronym class="acronym">REQ</acronym>
            を受けとると
            <acronym class="acronym">REQ-SENT</acronym>
            の状態になり、さらに
            <acronym class="acronym">REQ</acronym>
            を送ります。
            そしてすぐに
            <acronym class="acronym">ACK</acronym> を受け取って
            <acronym class="acronym">OPENED</acronym>
            の状態に入ります。
          </p><p>
            これが、片方の
            <code class="command">ppp</code>
            があきらめてしまうまで続きます。
          </p><p>
            これを回避する最も良い方法は、
            片方を
            <code class="literal">passive</code>
            モードに設定する、
            すなわち反対側がネゴシエーションを開始するまで待つようにする事です。
            これは、
          </p><pre class="programlisting">set openmode passive</pre><p>
            というコマンドでできます。
            このオプションは気を付けて使わないといけません。さらに
          </p><pre class="programlisting">set stopped <em class="replaceable"><code>N</code></em></pre><p>
            というコマンドを追加して、
            <span class="application">ppp</span> がネゴシエーションが開始するまで待つ
            最大の時間を設定してください。もしくは、
          </p><pre class="programlisting">set openmode active <em class="replaceable"><code>N</code></em></pre><p>
            というコマンド (ここで、
            <em class="replaceable"><code>N</code></em>
            はネゴシエーションが始まるまで待つ時間) を使うこともできます。
            詳しくはマニュアルページを参照してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82545360"></a><a id="ppp-lockups"></a><p><strong>10.14.</strong></p></td><td align="left" valign="top"><p>ppp が接続直後に固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            2.2.5 より前のバージョンの FreeBSD では、<span class="application">ppp</span>
            が Predictor1 圧縮のネゴシエーションを誤って解釈して、
            接続直後にリンクを無効にしている可能性があります。
            これは両サイドが異なる
            <acronym class="acronym">Compression Control Protocols (CCP)</acronym>
            を使ってネゴジェーションを行った場合にのみ発生します。
            この問題は現在は解決していますが、あなたの走らせている
            <span class="application">ppp</span>
            のバージョンが古い場合でも、次の命令で解決することができます。</p><pre class="programlisting">disable pred1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82553168"></a><a id="ppp-shell-test-lockup"></a><p><strong>10.15.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> の内部でシェルを起動しようとすると固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">shell</code> あるいは
            <code class="command">!</code>
            コマンドを使用すると、
            <span class="application">ppp</span>
            はシェルを起動し (何か引数を渡した場合は、
            <span class="application">ppp</span>
            は引数も実行します)、
            コマンドが終了するまで処理を中断します。
            コマンドを実行中に <span class="application">ppp</span>
            のリンクを使おうとすると、
            リンクが固まっているように見えますが、
            これは <span class="application">ppp</span> がコマンドの終了を待っているからです。
          </p><p>
            このような場合は、代わりに
            <code class="command">!bg</code>
            コマンドを使用してください。
            与えられたコマンドがバックグラウンドで実行されるので、
            <code class="command">ppp</code>
            はリンクに関するサービスを継続することができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82559056"></a><a id="ppp-nullmodem"></a><p><strong>10.16.</strong></p></td><td align="left" valign="top"><p>ヌルモデムケーブルを使用しているとき、
            <code class="command">ppp</code> が終了しない</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ヌルモデムケーブルを使用して直接接続している場合、
            <span class="application">ppp</span>
            は自動的には接続の終了を知ることができません。
            これはヌルモデムシリアルケーブルの配線に起因しています。
            この種の接続形態を用いる場合は、
            以下の命令を用いて <acronym class="acronym">LQR</acronym>
            を常に有効にする必要があります。
          </p><pre class="programlisting">enable lqr</pre><p>
            こうすると、接続先がネゴシエーションを行う場合、デフォルトで
            <acronym class="acronym">LQR</acronym> の使用を受け入れるようになります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82563664"></a><a id="ppp-auto-noreasondial"></a><p><strong>10.17.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> を
            <code class="option">-auto</code> モードで動かすと、
            勝手にダイアルすることがある</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">ppp</span>
            が思いもしないときにダイアルを始める場合、その原因を突き止め、
            防止のためにダイヤルフィルタ (dfilters) をかけてやる
            必要があります。
          </p><p>
            原因を突き止めるためには、以下の命令を使用してください。
          </p><pre class="programlisting">set log +tcp/ip</pre><p>
            これで接続を通過するすべてのトラフィックをログに残すことができるようになりました。
            次に突然回線がつながったときのログのタイムスタンプをたどれば、
            原因を突き止めることができるはずです。
          </p><p>
            原因がわかったら、次に、このような状況ではダイヤルが起こらないようにしましょう。
            通常、この手の問題は、<acronym class="acronym">DNS</acronym>
            で名前の解決をしようとしたために起こります。
            <acronym class="acronym">DNS</acronym> による名前の解決によって、
            接続が行われるのを防止するには、
            次のような手段を用います (これは <span class="application">ppp</span>
            の既に確立した接続に関してパケットのフィルタリングをするものでは<span class="emphasis"><em>ありません</em></span>)。
          </p><pre class="programlisting">set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</pre><p>
            これはデマンドダイヤル機能に問題を生じさせるため、
            常に適切であるとはかぎりません。
            ほとんどのプログラムは他のネットワーク関連の処理を行なう前に
            <acronym class="acronym">DNS</acronym>
            への問い合わせが必要になります。
          </p><p>
            <acronym class="acronym">DNS</acronym> の場合は、
            何が実際にホスト名を検索しようとしているのかを突き止めるべきでしょう。
            大抵の場合は、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendmail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sendmail</span>(8)</span></a>
            が犯人です。
            設定ファイルで sendmail が
            <acronym class="acronym">DNS</acronym> に問い合わせないようになっているか確認すべきです。
            自分用の設定ファイルを作成するための詳しい方法は、
            <a class="link" href="admin.html#ispmail" title="7.22.">メールの設定</a> の項をご覧ください。
            または、
            <code class="filename">.mc</code>
            ファイルに次のような行を追加してもよいでしょう。
          </p><pre class="programlisting">define(`confDELIVERY_MODE', `d')dnl</pre><p>
            この行を追加すると、sendmail
            はメールキューを処理する (通常
            sendmail は 30 分ごとにキューを処理するよう、
            <span class="quote">「<span class="quote"><code class="option">-bd -q30m</code></span>」</span>
            というオプションを付けて起動されます) までか、
            または (多分 <code class="filename">ppp.linkup</code> というファイルの中で)
            <span class="quote">「<span class="quote"><code class="command">sendmail -q</code></span>」</span>
            というコマンドが実行されるまで、
            すべてのメールをキューに溜めるようになります。
          </p><div xmlns="" class="note"><h3 class="admontitle">訳注: </h3><p xmlns="http://www.w3.org/1999/xhtml">
                <span class="quote">「<span class="quote"><code class="command">sendmail -q</code></span>」</span>
                はその時点のメールキューの内容を処理して終了します。
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82590160"></a><a id="ccp-errors"></a><p><strong>10.18.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">CCP</acronym>
            エラーとはどういう意味ですか</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            ログファイル中の以下のエラーは、
          </p><pre class="programlisting">CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</pre><p>
            のネゴシエーションにおいて <code class="command">ppp</code> は
            Predictor1 圧縮を用いるべく主張したのに対して、
            接続先は圧縮を使用しないことを主張した場合に起こります。
            このメッセージには何の害もありませんが、
            出るのが嫌なら、以下の命令を用いてこちら側でも
            Predictor1 圧縮を無効にすることで対応できます。
          </p><pre class="programlisting">disable pred1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82594000"></a><a id="ppp-lockup-ioerrors"></a><p><strong>10.19.</strong></p></td><td align="left" valign="top"><p>ファイル転送の途中で、<code class="command">ppp</code> が
            IO エラーを出して固まってしまう</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.2.2 以前のバージョンの <code class="filename">tun</code>
            ドライバには、<code class="filename">tun</code>
            インタフェースの <acronym class="acronym">MTU</acronym>
            のサイズより大きなパケットを受け取ることができないというバグがありました。
            <acronym class="acronym">MTU</acronym>
            のサイズより大きなパケットを受け付けると IO エラーが起こり、
            <code class="command">syslogd</code> 経由で記録されるのです。
          </p><p>
            <code class="command">ppp</code> の仕様では、
            <acronym class="acronym">LCP</acronym>
            のネゴシエーションを行う場合を含む<span class="emphasis"><em>どのような場合でも</em></span>最低
            1500 オクテットの
            Maximum Receive Unit (<acronym class="acronym">MRU</acronym>)
            を受け入れる必要があります。
            ですから、<acronym class="acronym">MTU</acronym> を
            1500 以下に設定した場合でも、ISP はそれに関係なく
            1500 の大きさのパケットを送ってくるでしょう。
            そしてこのイケてない機能にぶちあたって、
            リンクが固まるのを目にすることになるのです。
          </p><p>
            FreeBSD 2.2.2 以前のバージョンでは、<acronym class="acronym">MTU</acronym>
            を決して 1500 より小さくしないことで、
            この問題を回避することができます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82610000"></a><a id="ppp-connectionspeed"></a><p><strong>10.20.</strong></p></td><td align="left" valign="top"><p>どうして <code class="command">ppp</code>
            は接続速度をログに残さないんでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            モデムとの「やり取り」すべての行をログに残すには、
            以下のようにして接続速度のログの有効化を行ってください。
          </p><pre class="programlisting">set log +connect</pre><p>これは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            に最後にくることが要求されている
            <span class="quote">「<span class="quote"><code class="literal">expect</code></span>」</span>
            という文字列がくるまでのすべてのものをログに記録させます。
          </p><p>
            接続速度はログにとりたいけれど、<acronym class="acronym">PAP</acronym>
            や <acronym class="acronym">CHAP</acronym>
            を使っている (その結果、ダイヤルスクリプト中の
            <code class="literal">CONNECT</code>
            以降に全く「やりとり」を行わない -
            <span class="quote">「<span class="quote"><code class="literal">set login</code></span>」</span>
            スクリプトには何も書かない) のであれば、
            <span class="application">ppp</span> に
            <span class="quote">「<span class="quote"><code class="literal">expect</code></span>」</span>
            を含んだ <code class="literal">CONNECT</code>
            行すべてがくるまで待たせるようにしないといけません、
            以下のようになります。
          </p><pre class="programlisting">set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</pre><p>
            ここで、<code class="literal">CONNECT</code> を受信してから、
            何も送らず、復帰改行 (linefeed) を待っています、
            <span class="application">ppp</span> に <code class="literal">CONNECT</code>
            の応答すべてを読み込ませているわけです。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82628176"></a><a id="ppp-ignores-backslash"></a><p><strong>10.21.</strong></p></td><td align="left" valign="top"><p>私の <code class="literal">chat</code> スクリプトでは
            <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>
            という文字を <code class="command">PPP</code> が解釈してくれません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">PPP</code> は設定ファイルを読み込むときに、
            <code class="literal">set phone "123 456 789"</code>
            のような文字列を正しく解釈し、
            番号が実際に<span class="emphasis"><em>1 つの</em></span>引数であると理解します。
            <span class="quote">「<span class="quote">"</span>」</span>
            という文字を指定するには、バックスラッシュ (backslash;
            <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) でエスケープしなければなりません。
          </p><p>
            <code class="literal">chat</code> の各引数が解釈されるときには、
            <span class="quote">「<span class="quote"><code class="literal">\P</code></span>」</span>
            や
            <span class="quote">「<span class="quote"><code class="literal">\T</code></span>」</span>
            のような特別なエスケープシーケンス (マニュアルページ参照のこと) を見付けるために、
            もう 1 回、字句解析を行います。
            このように字句解析は 2 回繰り返されますので、
            正しい回数だけエスケープ処理を行わないといけません。
          </p><p>
            モデムにたとえば <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>
            のような文字を送りたい場合には、
            次のようにする必要があります。</p><pre class="programlisting">set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</pre><p>
            実際にモデムに送られる文字列は次のようになります。
          </p><pre class="programlisting">ATZ
OK
AT\X
OK</pre><p>
            他の例ですと
          </p><pre class="programlisting">set phone 1234567
              set dial "\"\" ATZ OK ATDT\\T"</pre><p>
            は次のようになります。
          </p><pre class="programlisting">ATZ
OK
ATDT1234567</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82647760"></a><a id="ppp-segfault-nocore"></a><p><strong>10.22.</strong></p></td><td align="left" valign="top"><p><code class="command">ppp</code> が
            <code class="computeroutput">segmentation fault</code> になるのですが、
            <code class="filename">ppp.core</code> ファイルがありません</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <span class="application">ppp</span> (や他のプログラム) は決して
            core を吐いてはいけません。
            <span class="application">ppp</span>
            は実効 uid が 0 で動いていますので、
            オペレーティングシステムは <span class="application">ppp</span>
            を終了させる前にディスクに core イメージを書き込みません。
            しかし <span class="application">ppp</span>
            は実際にはセグメンテーション違反や、
            他の core を吐く原因となるようなシグナルによって終了しており、
            <span class="emphasis"><em>さらに</em></span>最新のバージョン
            (このセクションの始めを見てください)
            を使用しているならば、次のようにしてください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tar xfz ppp-*.src.tar.gz</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>cd ppp*/ppp</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>echo STRIP= &gt;&gt;Makefile</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>echo CFLAGS+=-g &gt;&gt;Makefile</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>make clean all</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make install</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 555 /usr/sbin/ppp</code></strong></pre><p>
            これでデバッグ可能なバージョンの
            <span class="application">ppp</span> がインストールされます。
            <code class="systemitem">root</code> で
            <span class="application">ppp</span> を実行し、
            すべての特権が無効になっているようにする必要があるでしょう。
            <span class="application">ppp</span> を実行する時には、
            カレントディレクトリが <code class="command">make</code>
            したディレクトリであるようにしてください。
          </p><p>
            これで、<span class="application">ppp</span>
            がセグメンテーション例外を受け取ったときには
            <code class="filename">ppp.core</code>
            という名前の
            core ファイルを吐くようになります。core が
            吐かれたら次のようにしてください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>gdb /usr/sbin/ppp ppp.core</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>bt</code></strong>
.....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>f 0</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>i args</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>l</code></strong>
.....</pre><p>
            質問する際には、これらすべての情報を提供して、
            問題点の分析ができるようにしてください。
          </p><p>
            <code class="command">gdb</code>
            の使い方に慣れている場合には、実際に dump
            の原因となった理由やそのアドレス、
            関連した変数の値なども調べる事ができるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82672976"></a><a id="ppp-autodialprocess-noconnect"></a><p><strong>10.23.</strong></p></td><td align="left" valign="top"><p>auto モードでダイアルをするようなプロセスが接続されない。
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これは <span class="application">ppp</span>
            がローカル側の <acronym class="acronym">IP</acronym> アドレスを、
            動的に通信相手と交渉するように設定されている時に発生する良く知られた障害でした。
            最新のバージョンでは、
            この問題は修正されています。
            <code class="literal">iface</code>
            をマニュアルページから検索してみてください。
          </p><p>
            これは、最初のプログラムが
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=connect&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a>
            を呼び出した時、<code class="filename">tun</code>
            インターフェイスの <acronym class="acronym">IP</acronym> アドレスが、
            ソケットの終端に割り当てられてしまうという問題です。
            カーネルは、
            外へ出ていく最初のパケットを作り、それを <code class="filename">tun</code>
            デバイスへ書き込みます。
            そして <span class="application">ppp</span> は、
            そのパケットを読み込んで接続を確立します。
            <span class="application">ppp</span>
            は動的に <acronym class="acronym">IP</acronym>
            アドレスを割り当てるため、
            もしインターフェイスのアドレスが変化してしまうと、
            最初に割り当てられたソケット終端の <acronym class="acronym">IP</acronym>
            アドレスは無効になってしまいます。
            そのため、それ以降相手に送られるすべてのパケットは通常、
            相手に届くことはないでしょう。もし仮に届いたとしても、
            既にこちらの <acronym class="acronym">IP</acronym> アドレスは変更されているので、
            どんな反応も最初のマシンには戻ってきません。
          </p><p>
            この問題に対処する理論的な方法がいくつかあります。もし可能なら、
            相手が再度、同じ <acronym class="acronym">IP</acronym>
            アドレスを割り当ててくれることが一番です <code class="literal">:-)</code>
            <span class="application">ppp</span>
            の現在のバージョンはこれを行ないますが、
            他のほとんどの実装はそういった動作をしません。
          </p><p>
            我々の側から対処できる最も簡単な方法は、<code class="filename">tun</code>
            インターフェイスの
            <acronym class="acronym">IP</acronym> アドレスを固定する事です。またそのかわりに、
            外に出ていくパケットを変更して、
            発信元 <acronym class="acronym">IP</acronym>
            アドレスをインターフェイスの <acronym class="acronym">IP</acronym>
            アドレスから、交渉によって得られた <acronym class="acronym">IP</acronym> アドレスに、
            適宜書きかえる事によっても対処できます。
            これは、基本的に
            <span class="application">ppp</span> の最新バージョンにある <code class="literal">iface-alias</code>
            オプションが行なっていることと同じです
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a>
            および、<span class="application">ppp</span> の <code class="option">-nat</code>
            スイッチにも関係します)。それは、以前の <acronym class="acronym">IP</acronym>
            アドレスをすべて管理し、
            それらを最後の交渉によって得られた <acronym class="acronym">IP</acronym>
            アドレスに対して NAT 機能を有効化します。</p><p>
            もう 1 つの (おそらく最も信頼できる) 方法は、bind された
            すべてのソケットの <acronym class="acronym">IP</acronym> アドレスを、
            異なるものに変更できるシステムコールを実装することです。
            <span class="application">ppp</span>は、
            新しい <acronym class="acronym">IP</acronym> アドレスが割り当てられた時、
            このシステムコールを用いて実行されているプログラムにある、
            すべてのソケットを書きかえてやるわけです。
            同じシステムコールが、<acronym class="acronym">DHCP</acronym> クライアントが利用するソケットを
            強制的に再 bind するのにも使うことができるでしょう。
          </p><p>
            3 つ目の方法は、<acronym class="acronym">IP</acronym>
            アドレスを指定しないでインターフェイスを利用できるようにすることです。
            外に出ていくパケットは、最初の <code class="literal">SIOCAIFADDR</code>
            ioctl の完了まで、
            255.255.255.255 という <acronym class="acronym">IP</acronym> アドレスが与えられます。
            これによって、ソケットは常に bind することができます。
            発信元 <acronym class="acronym">IP</acronym> アドレスを変更するのは
            <span class="application">ppp</span> の仕事です。ただし、
            それは発信元 <acronym class="acronym">IP</acronym> アドレスが
            255.255.255.255 になっていて、<acronym class="acronym">IP</acronym> アドレスと
            <acronym class="acronym">IP</acronym> チェックサムを変更する必要がある場合だけです。
            これは、カーネルが不適切に設定されたインターフェイスへは
            異常なパケットを送出しようとすることを利用して、なにか他の
            仕組みが遡及的に修正を行ってくれることを前提にしている、
            割り切った方法ではあります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82713808"></a><a id="ppp-nat-games"></a><p><strong>10.24.</strong></p></td><td align="left" valign="top"><p>何故ほとんどのゲームが
            <code class="option">-nat</code> スイッチ付きだと動かないんですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            

            libalias を使っている時にゲームなどの類のものが動作しない理由は、
            外側にあるマシンが接続しようとしているか、内側にあるマシンに
            (余計な) UDP パケットを送信しようとしているからです。
            内側のマシンにこれらのパケットを送るべきかについて、
            NAT ソフトウェアは関知しません。
          </p><p>
            うまく動かすためには、
            実行中のものが問題の発生しているソフトウェアだけであるかを確認し、
            ゲートウェイの <code class="filename">tun</code> インタフェースに対して
            <code class="command">tcpdump</code> を実行するか、
            ゲートウェイ上で <code class="command">ppp</code> の
            <acronym class="acronym">TCP</acronym>/<acronym class="acronym">IP</acronym>
            ログ記録を有効化 (<span class="quote">「<span class="quote"><code class="literal">set log
              +tcp/ip</code></span>」</span>) してください。</p><p>
            行儀の悪いソフトウェアを起動する際に、
            ゲートウェイマシンを通過するパケットを監視すべきです。
            外側から何かパケットが戻ってきた時に、
            そのパケットは破棄されるでしょう (それが問題なのです)。
            これらのパケットのポート番号に注意して、
            その行儀の悪いソフトウェアを停止してください。
            これを数回繰り返してポート番号が常に同じであるかを確認してみてください。
            同じであった場合は、
            <code class="filename">/etc/ppp/ppp.conf</code>
            の適切なセクションに次の行を入れると、
            そのソフトウェアは動作するようになるでしょう。
          </p><pre class="programlisting">nat <em class="replaceable"><code>port</code></em> <em class="replaceable"><code>proto</code></em> <em class="replaceable"><code>internalmachine</code></em>:<em class="replaceable"><code>port</code></em> <em class="replaceable"><code>port</code></em></pre><p>
            ここで <em class="replaceable"><code>proto</code></em> は
            <code class="literal">tcp</code> か <code class="literal">udp</code> であり、
            <em class="replaceable"><code>internalmachine</code></em>
            はパケットを送りたいマシン、そして
            <em class="replaceable"><code>port</code></em>
            はパケットの送信先のポート番号です。
          </p><p>
            上記のコマンドを変更せずに、
            他のマシン上でそのソフトウェアを使用できるようにはしたくないかもしれません。
            そして同時に二つの内部のマシン上でそのソフトウェアを実行することは、
            この質問の範囲を超えています。結局、外側の世界からは、
            内部ネットワーク全体がただ一つのマシンとして見えるのです。
          </p><p>
            ポート番号が常に同じとは限らない場合、さらに三つのオプションがあります。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                libalias でサポートするようにし、結果を送り付ける。
                特定の場合の例は <code class="filename">/usr/src/lib/libalias/alias_*.c</code>
                にあります (<code class="filename">alias_ftp.c</code>
                は良いプロトタイプです)。これには通常、外向きの特定のパケットを読み、
                内部の計算機のある特定のポートへの接続を開始するような命令が、
                外部の計算機対して送られていることを見分け、
                後続のパケットがどこに行けばいいのかが分かるように、
                エイリアステーブル中の
                <span class="quote">「<span class="quote"><em class="replaceable"><code>route</code></em></span>」</span>
                の部分を設定する、という作業が含まれます。
              </p><p>
                これは最も難しい方法ですが、最も良い方法でもありますし、ソフトウェアが
                複数の計算機で動くようにできます。
              </p></li><li class="listitem"><p>プロキシ (proxy) を使う。アプリケーションが、たとえば socks5
                をサポートしているか、(cvsup のように) <span class="quote">「<span class="quote">passive</span>」</span>
                オプションを持っているとこの方法が使えます。
                <span class="quote">「<span class="quote">passive</span>」</span>
                とは相手側のほうから接続を求めてくることを避けるためにあるオプションです。
              </p></li><li class="listitem"><p>
                <span class="quote">「<span class="quote"><code class="literal">nat addr</code></span>」</span>
                を使ってなんでもかんでも内部の計算機に向けて流してしまう。
                これはちょっと無理矢理な解決法です。
              </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82764112"></a><a id="useful-port-numbers"></a><p><strong>10.25.</strong></p></td><td align="left" valign="top"><p>有用なポート番号のリストはありませんか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            まだ出来ていません。しかし、
            これは (関心を持って頂けるならば) そういったリストにしていく予定です。
            それぞれの例にある
            <em class="replaceable"><code>internal</code></em> は、
            ゲームで遊ぶマシンの <acronym class="acronym">IP</acronym> アドレスに置き換えてください。
          </p><p>
            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Asheron's Call</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:65000 65000</pre><p>手動でゲームのポート番号を 65000 に変更してください。
                    マシンが複数ある場合は、それぞれのマシンに重複しないポート番号 (つまり
                    65001、65002 など) を設定し、その設定ごとに
                    <code class="literal">nat port</code> の行を追加します。</p></dd><dt><span class="term">Half Life</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:27005 27015</pre></dd><dt><span class="term">PCAnywhere 8.0</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:5632 5632
nat port tcp <em class="replaceable"><code>internal</code></em>:5631 5631</pre></dd><dt><span class="term">Quake</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:6112 6112</pre><p>このように設定する代わりに、
                    <a class="link" href="http://www.battle.net/support/proxy/" target="_top">www.battle.net</a>
                    で Quake のプロキシ (proxy) がサポートされているか調べてもいいでしょう。
                  </p></dd><dt><span class="term">Quake2</span></dt><dd><pre class="programlisting">alias port udp <em class="replaceable"><code>internal</code></em>:27901 27910</pre></dd><dt><span class="term">Red Alert</span></dt><dd><pre class="programlisting">nat port udp <em class="replaceable"><code>internal</code></em>:8675 8675
nat port udp <em class="replaceable"><code>internal</code></em>:5009 5009</pre></dd></dl></div><p>
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82790224"></a><a id="fcs-errors"></a><p><strong>10.26.</strong></p></td><td align="left" valign="top"><p><acronym class="acronym">FCS</acronym> エラーって何?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <acronym class="acronym">FCS</acronym> とは
            <code class="literal">F</code>rame <code class="literal">C</code>heck <code class="literal">S</code>equence
	    (フレームチェックシーケンス) の略です。
            個々の <span class="application">ppp</span> パケットには、
            送受信するデータが正しいかを調べるためのチェックサムが含まれています。
            受信したパケットの <acronym class="acronym">FCS</acronym> が正しくない場合は、そのパケットは廃棄され、
            <acronym class="acronym">HDLC</acronym> <acronym class="acronym">FCS</acronym> カウントが増やされます。
            <acronym class="acronym">HDLC</acronym> エラーの数は、
            <code class="command">show hdlc</code>
            コマンドを使って表示できます。
          </p><p>
            リンクの品質が悪かったり、
            シリアルドライバがパケットを取りこぼしていたりすると、
            <acronym class="acronym">FCS</acronym> エラーがたびたび発生します。
            <acronym class="acronym">FCS</acronym> エラーは、
            圧縮プロトコルの速度低下の原因にはなりますが、
            特に心配する必要はありません。
            外付けモデムを使っている場合は、
            ケーブルがちゃんとシールドされているかを確認してください。
            そうでない場合、
            <acronym class="acronym">FCS</acronym> エラーの原因となる場合があります。
          </p><p>
            接続直後からリンクがフリーズし、大量の
            <acronym class="acronym">FCS</acronym> エラーが発生する場合は、
            リンクが 8 ビットクリーンでない可能性があります。
            ソフトウェアフロー制御 (XON/XOFF)
            が使われていないことを確認してください。
            どうしてもソフトウェアフロー制御を使わなければならない場合は、
            <code class="literal">set accmap 0x000a0000</code> コマンドを使用して、
            <span class="application">ppp</span> に
            <code class="literal">^Q</code> と
            <code class="literal">^S</code> をエスケープさせてください。
          </p><p>
            リモートホストが <acronym class="acronym">PPP</acronym>
            プロトコルを使用してない場合も、大量の
            <acronym class="acronym">FCS</acronym> エラーが発生します。
            この場合はログをとりながら<span class="emphasis"><em>非同期</em></span>で接続し、
            ログインプロンプトやシェルプロンプトが送られて来ていないか確認してください。
          </p><p>
            ログファイルにリンクを終了した原因となるような記録がない場合は、
            リモートホスト (プロバイダ?) の管理者に、
            セッションを終了された理由を尋ねてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="PPPoEwithNAT"></a><a id="macos-win98-pppoe-freeze"></a><p><strong>10.27.</strong></p></td><td align="left" valign="top"><p>ゲートウェイで PPPoE を実行すると MacOS や
            Windows 98 との接続がフリーズしてしまうのですが、
            これはなぜなのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            Michael Wozniak <code class="email">&lt;<a xmlns="" class="email" href="mailto:mwozniak@netcom.ca">mwozniak@netcom.ca</a>&gt;</code>
            氏が、この現象に関して説明してくれました。
            また、Dan Flemming <code class="email">&lt;<a xmlns="" class="email" href="mailto:danflemming@mac.com">danflemming@mac.com</a>&gt;</code>
            氏は MacOS での解決策を提供してくれました。
            情報の提供に感謝します。
          </p><p>これは、いわゆる「ブラックホールルータ (Black Hole router)」に原因があります。
            Windows 98 と MacOS (および、おそらく他の Microsoft 社製 OS) の TCP パケット送出は、
            PPPoE のフレーム (Ethernet の MTU は標準で
            1500) に入らないような大きなセグメントサイズを要求します。
            <span class="emphasis"><em>そしてさらに</em></span>分割禁止 (<span class="quote">「<span class="quote">don't fragment</span>」</span>)
	    フラグビットを (TCP パケットにデフォルトで) セットするのですが、
            Telco のルータは、分割が必須 ("must fragment") であることを示す
            ICMP メッセージを、接続しようとするウェブサイトに対して送出しません
            (つまり、ルータは正しく ICMP パケットを送出しているのですが、
            ウェブサイトのファイアウォールがそれを落としているのです)。
            そのためウェブサーバが PPPoE 接続に対して大きすぎるフレームを送出すると
            Telco のルータはそのフレームを捨ててしまい、
            見ようとしたページが表示されないという症状が現われます
            (MSS より小さいページや画像は表示されます)。
            ほとんどの Telco PPPoE 設定は、標準でこのように設定されているようです。
            (ああ、彼らがルーティングプログラムの作り方を理解してさえいれば…)。
          </p><p>
            一つの解決法は、Windows 95/98 マシンで regedit を使い、
            次のレジストリエントリを追加することです。
          </p><pre class="programlisting">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</pre><p>
            レジストリエントリは、<span class="quote">「<span class="quote">1450</span>」</span> の値
            (もっと正確に言うと、TCP パケットを PPPoE フレームに完全に適合させるには
            <span class="quote">「<span class="quote">1464</span>」</span> であるべきでですが、
            <span class="quote">「<span class="quote">1450</span>」</span> とすると、現われる可能性がある他の IP
            プロトコルに対してエラーマージンを確保することができます)
            にする必要があります。
            このレジストリキーは、Windows2000 で
            <code class="literal">Tcpip\Parameters\Interfaces\ID for adapter\MTU</code>
            に移されたという報告がありました。
          </p><p>
            FreeBSD/NAT/PPPoE ルータと共存させるために Windoze の MTU
            を変更する方法に関する詳細は、
            <a class="link" href="http://search.support.microsoft.com/kb" target="_top">Microsoft Knowledge
            Base</a> にある、
            番号 <span class="quote">「<span class="quote">Q158474 - Windows TCPIP Registry Entries</span>」</span>、
            および番号
            <span class="quote">「<span class="quote">Q120642 - TCPIP &amp; NBT Configuration Parameters for Windows NT</span>」</span>
            を参照してください。
          </p><p>残念なことに、MacOS には
            TCP/IP 設定を変更する方法がありません。
            しかし、<a class="link" href="http://www.softworks.com/" target="_top">Sustainable Softworks 社</a>
            が販売している OTAdvancedTuner (OT は OpenTransport という
            MacOS の TCP/IP スタックの名前のこと) のような商用ソフトウェアが存在します。
            このソフトウェアは、ユーザから TCP/IP 設定の変更を行なうことを可能にします。
            MacOS NAT ユーザはドロップダウンメニューから
            <code class="literal">ip_interface_MTU</code> を選択し、
            ボックスにある <code class="literal">1500</code> の代わりに
            <code class="literal">1450</code> を入力し、
            <code class="literal">Save as Auto Configure</code> の隣のボックスをクリックして
            <code class="literal">Make Active</code> をクリックする必要があります。
          </p><p><span class="application">ppp</span> の最新版
            (2.3 かそれ以降) には、自動的に MSS を適切な値に調節する
            <code class="command">enable tcpmssfixup</code> コマンドがあります。
            この機能は標準で有効になっています。
            もし旧バージョンの <span class="application">ppp</span>
            を使わなければならない状況にあるなら、
            <span class="application">tcpmssd</span> の port
            をご覧になると良いでしょう。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp82824400"></a><a id="desperation"></a><p><strong>10.28.</strong></p></td><td align="left" valign="top"><p>どれにも当てはまらない! どうしたらいいの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            これまでのすべての質問に当てはまらない場合、設定ファイル、
            <span class="application">ppp</span>
            の実行方法、ログファイルの該当部分と
            <code class="command">netstat -rn</code>
            コマンドの出力 (接続前と接続後) を含む、
            あなたの持っているすべての情報を
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions" target="_top">FreeBSD general questions メーリングリスト</a>
            や
            <a class="link" href="news:comp.unix.bsd.freebsd.misc" target="_top">comp.unix.bsd.freebsd.misc</a>
            ニュースグループへ送ってください。誰かがあなたを正しい方向へ導いてくれるでしょう。
          </p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="networking.html">戻る</a>〓</td><td width="20%" align="center">〓</td><td width="40%" align="right">〓<a accesskey="n" href="serial.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第9章 ネットワーキング〓</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">〓第11章 シリアル接続</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文書、および他の文書は
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>
    からダウンロードできます。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>FreeBSD に関する質問がある場合には、
    <a href="http://www.FreeBSD.org/ja/docs.html">ドキュメント</a> を読んだ上で
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt; まで (英語で) 連絡してください。<br></br>
    本文書に関する質問については、
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt; まで電子メールを (英語で) 送ってください。</small></p></body></html>