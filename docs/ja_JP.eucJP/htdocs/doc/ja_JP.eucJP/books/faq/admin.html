<?xml version="1.0" encoding="euc-jp" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=euc-jp" /><title>第7章 システム管理</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="up" href="index.html" title="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)" /><link rel="prev" href="kernelconfig.html" title="第6章 カーネルコンフィグレーション" /><link rel="next" href="x.html" title="第8章 X Window System と仮想コンソール" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第7章 システム管理</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kernelconfig.html">戻る</a>〓</td><th width="60%" align="center">〓</th><td width="20%" align="right">〓<a accesskey="n" href="x.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="admin"></a>第7章 システム管理</h1></div></div></div><p>
      <span class="emphasis"><em>訳:
        にしか <code class="email">&lt;<a xmlns="" class="email" href="mailto:nishika@cheerful.com">nishika@cheerful.com</a>&gt;</code>、
        1997 年 11 月 12 日</em></span>
    </p><div class="qandaset"><a id="idp80858448"></a><dl><dt>7.1. <a href="admin.html#idp80858704">システムスタートアップファイルはどこにあるのですか?</a></dt><dt>7.2. <a href="admin.html#idp80880976">簡単にユーザを追加するにはどうすればいいのですか?</a></dt><dt>7.3. <a href="admin.html#idp80886608">新しいリムーバブルドライブを持っていますが、どうやって使うの?</a></dt><dt>7.4. <a href="admin.html#idp80908240">自分の crontab ファイルを編集した後
            root: not found
            のようなメッセージが延々と表示されるのですが、
            これはなぜですか?</a></dt><dt>7.5. <a href="admin.html#idp80931920">su(1) コマンドを実行して
            root になろうとすると、
            su が you are not in the correct group to
            su root と警告します。</a></dt><dt>7.6. <a href="admin.html#idp80944080">rc.conf やその他の
            スタートアップファイルを書き間違えてしまいました。
            しかもそのためファイルシステムがリードオンリーになってしまっていて
            編集ができません。どうすればいいですか?</a></dt><dt>7.7. <a href="admin.html#idp80952144">どのようにしたら DOS の拡張パーティションをマウントできますか?</a></dt><dt>7.8. <a href="admin.html#idp80962128">他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</a></dt><dt>7.9. <a href="admin.html#idp80968144">どのようにしたら FreeBSD を NT ローダーから起動させることができますか?</a></dt><dt>7.10. <a href="admin.html#idp80990800">FreeBSD と Linux を LILO から起動するには?</a></dt><dt>7.11. <a href="admin.html#idp81004624">FreeBSD と Linux を BootEasy から起動するには?</a></dt><dt>7.12. <a href="admin.html#idp81007184">「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?</a></dt><dt>7.13. <a href="admin.html#idp81124048">どのようにしたらスワップ領域を増やせますか?</a></dt><dt>7.14. <a href="admin.html#idp81176656">プリンタのセットアップで問題があります</a></dt><dt>7.15. <a href="admin.html#idp81182672">私のシステムのキーボードマッピングは間違っています。</a></dt><dt>7.16. <a href="admin.html#idp81220304">起動時に、unknown: &lt;PNP0303&gt; can't
              assign resources というメッセージが表示されるのですが?</a></dt><dt>7.17. <a href="admin.html#idp81224400">ユーザディスククォータが正常に動作していないようです。</a></dt><dt>7.18. <a href="admin.html#idp81239504">わたしの ccd は、
            何が適合していない (Inappropriate) のでしょう?</a></dt><dt>7.19. <a href="admin.html#idp81256144">どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</a></dt><dt>7.20. <a href="admin.html#idp81263184">FreeBSD は System V の IPC プリミティブをサポートしますか?</a></dt><dt>7.21. <a href="admin.html#idp81267152">UUCP でメールを配送するには sendmail をどう使えばよいのですか?</a></dt><dt>7.22. <a href="admin.html#idp81307728">ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?</a></dt><dt>7.23. <a href="admin.html#idp81338704">この UID が 0 の toor という
            アカウントとは何ですか? 危険にさらされているのでしょうか?</a></dt><dt>7.24. <a href="admin.html#idp81390288">しまった! root のパスワードを忘れてしまった!</a></dt><dt>7.25. <a href="admin.html#idp81395920">
            Control-Alt-Delete
            でシステムが再起動しないようにするにはどうすればいい?</a></dt><dt>7.26. <a href="admin.html#idp81402320">DOS のテキストファイルを UNIX
            のテキストファイルに整形するにはどうすればいい?</a></dt><dt>7.27. <a href="admin.html#idp81442256">名前で指定してプロセスにシグナルを送るにはどうすればいい?</a></dt><dt>7.28. <a href="admin.html#idp81445072">su が not in root's ACL
            と言って私を悩ませるのはなぜ?</a></dt><dt>7.29. <a href="admin.html#idp81448656">Kerberos をアンインストールするにはどうすればいいの?</a></dt><dt>7.30. <a href="admin.html#idp81452752">疑似ターミナルを追加するには?</a></dt><dt>7.31. <a href="admin.html#idp81466192">
            snd0
            デバイスを作成することができません!</a></dt><dt>7.32. <a href="admin.html#idp81472208">再起動せずにもう一度
            /etc/rc.conf
            を読み込んで
            /etc/rc
            を開始させるには?</a></dt><dt>7.33. <a href="admin.html#idp81483088">砂場 (sandbox) とは何ですか?</a></dt><dt>7.34. <a href="admin.html#idp81496656">セキュアレベル (securelevel) って何ですか?</a></dt><dt>7.35. <a href="admin.html#idp81517136">フロッピーや CDROM や他のリムーバブルメディアのマウントを一般ユーザーに許可するには?</a></dt><dt>7.36. <a href="admin.html#idp81545808">システムを新しい巨大ディスクへ移すにはどうするのですか?</a></dt><dt>7.37. <a href="admin.html#idp81584464">
            システムを最新の -STABLE にアップデートしようとしたのですが
            -RC や -BETA になってしまいました! 何が起こったのですか?
          </a></dt><dt>7.38. <a href="admin.html#idp81601104">新しいカーネルを入れようとしたのですが、
            chflags に失敗します。どうすれば良いのでしょう?</a></dt><dt>7.39. <a href="admin.html#idp81611344">システムの時刻を 1 秒以上変更することができないのです!
            どうすれば良いのでしょう?</a></dt><dt>7.40. <a href="admin.html#idp81617488">rpc.statd(8) にメモリリークを見つけました!
            メモリを 256 メガバイトも使っています。</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp80858704"></a><a id="startup-config-files"></a><p><strong>7.1.</strong></p></td><td align="left" valign="top"><p>システムスタートアップファイルはどこにあるのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.0.5R から 2.2.1R までは、
            プライマリコンフィグレーションファイルは
            <code class="filename">/etc/sysconfig</code> にあります。
            オプションはすべてこのファイルで設定され、他の
            <code class="filename">/etc/rc</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> 参照) および
            <code class="filename">/etc/netstart</code> といった
            ファイルはこれを読み込むだけです。
          </p><p>
            ファイル <code class="filename">/etc/sysconfig</code>
            を見て、システムに適合するように変更してください。
            このファイルには、
            それぞれの場所に何を書けばいいのかを表すコメントがたくさん書かれています。
          </p><p>
            FreeBSD 2.2.2 から 3.0 までのシステムでは、
            <code class="filename">/etc/sysconfig</code> は、
            より分りやすい名前の
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>
            に改名され、それに従って書式もいくぶん改められています。
            <code class="filename">/etc/netstart</code> も
            <code class="filename">/etc/rc.network</code> に改名され、
            全部のファイルを
            <code class="command">cp /usr/src/etc/rc* /etc</code>
            で一度にコピーすることが出来るようになります。
          </p><p>FreeBSD 3.1 とそれ以降では、
            <code class="filename">/etc/rc.conf</code> が
            <code class="filename">/etc/defaults/rc.conf</code> に移動しました。
            <span class="emphasis"><em>このファイルを編集してはいけません!</em></span>
            代わりに、
            <code class="filename">/etc/defaults/rc.conf</code>
            の中で変えたいエントリの行を
            <code class="filename">/etc/rc.conf</code> にコピーし、
            そこで変更するようにしてください。</p><p>たとえば named を起動したいとしましょう。
            FreeBSD 3.1 かそれ以降のシステムで FreeBSD 付属の DNS
            サーバを起動するには、次のようにするだけです。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>echo named_enable="YES" &gt;&gt;
              /etc/rc.conf</code></strong></pre><p>FreeBSD 3.1 かそれ以降でローカルサービスを起動するためには、
            <code class="filename">/usr/local/etc/rc.d</code> ディレクトリにシェルスクリプトを置きます。
            シェルスクリプトは起動可能に設定し、ファイル名が .sh で終わっていなければなりません。
            FreeBSD 3.0 とそれ以前のリリースでは、
            <code class="filename">/etc/rc.local</code> を編集する必要があります。</p><p>ファイル <code class="filename">/etc/rc.serial</code>
            はシリアルポートの初期化
            (たとえばポートの設定を固定したり等々)
            のためにあります。</p><p>ファイル <code class="filename">/etc/rc.i386</code> は iBCS2
            エミュレーションのような
            Intel アーキテクチャ固有の設定や、
            PC システムコンソール設定のためにあります。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80880976"></a><a id="adding-users"></a><p><strong>7.2.</strong></p></td><td align="left" valign="top"><p>簡単にユーザを追加するにはどうすればいいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=adduser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">adduser</span>(8)</span></a> コマンドを使用してください。
            また、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> コマンドを用いることで、さらに細かい操作が可能です。
          </p><p>
            ユーザを削除するには <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rmuser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rmuser</span>(8)</span></a> コマンドを使用してください。
            繰り返しになりますが、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a> でも構いません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80886608"></a><a id="removable-drives"></a><p><strong>7.3.</strong></p></td><td align="left" valign="top"><p>新しいリムーバブルドライブを持っていますが、どうやって使うの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            そのリムーバブルドライブが ZIP であれ EZ drive であれ
            (あるいはもしそういう風に使いたいのなら、フロッピーであれ)、
            またハードディスクであれ、一旦システムにインストールされて認識され、
            カートリッジ、フロッピー等々が挿入されていれば、
            ことはどのデバイスでも全く同じように進みます。
          </p><p><a id="disklabel"></a>
              (このセクションは<a class="link" href="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html" target="_top">Mark Mayo's ZIP FAQ</a> に基づいています)
          </p><p>
            ZIP ドライブやフロッピーで、すでに DOS のファイルシステムで
            フォーマットしてある場合、次のコマンドを使うことができます。
            これはフロッピーの場合です。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/fd0c /floppy</code></strong></pre><p>出荷時の設定の ZIP ディスクではこうです。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/da2s4 /zip</code></strong></pre><p>
            その他のディスクに関しては、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a> や
            <code class="filename">/stand/sysinstall</code> を使って、
            どのようにレイアウトされているか確かめてください。
          </p><p>
            以降は ZIP ドライブが 3 番目の SCSI ディスクで、
            da2 と認識されている場合の例です。
          </p><p>
            他人と共有しなければならないフロッピーやリムーバブルディスク
            でなければ、BSD ファイルシステムを載せてしまうのが良い考えでしょう。
            ロングファイル名もサポートされ、パフォーマンスは少なくとも
            2 倍は向上しますし、おまけにずっと安定しています。
            まず最初に、DOS レベルでのパーティション <code class="filename">/</code>
            ファイルシステムを無効にしておく必要があります。使用するのは
            <code class="command">fdisk</code> でも
            <code class="filename">/stand/sysinstall</code> でも結構です。
            複数のオペレーティングシステムを入れることを考慮する
            必要がないような容量の小さなドライブの場合は、
            次のように <acronym class="acronym">FAT</acronym> パーティションテーブル (スライス)
            全体を飛ばして、BSD
            のパーティション設定を行うだけで良いでしょう。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/dev/rda2 count=2</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -Brw da2 auto</code></strong></pre><p>
            複数の BSD パーティションをつくる場合、
            <code class="command">disklabel</code> か
            <code class="filename">/stand/sysinstall</code> を使います。
            固定ディスク上にスワップ領域を加える場合、
            そういうことをしたいと思うのはもっともですが、
            ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
            でしょう。
          </p><p>
            最後に、新しいファイルシステムをつくります。ディスク全体を使用する
            ZIP ドライブの場合は、以下のようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>newfs /dev/rda2c</code></strong></pre><p>次にマウントします。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount /dev/da2c /zip</code></strong></pre><p>また、次のような行を
            <code class="filename">/etc/fstab</code> (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fstab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fstab</span>(5)</span></a> 参照)
            に入れておくのも良い考えでしょう。
            <code class="command">mount /zip</code>
            と入力するだけでマウントできるようになります。
          </p><pre class="programlisting">/dev/da2c /zip ffs rw,noauto 0 0</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80908240"></a><a id="root-not-found-cron-errors"></a><p><strong>7.4.</strong></p></td><td align="left" valign="top"><p>自分の crontab ファイルを編集した後
            <span class="errorname">root: not found</span>
            のようなメッセージが延々と表示されるのですが、
            これはなぜですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは通常、システム crontab (<code class="filename">/etc/crontab</code>)
            を編集し、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a> を使ってインストールした場合に起こります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab /etc/crontab</code></strong></pre><p>この方法は正しくありません。
            システム crontab のフォーマットは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a>
            が更新する各ユーザの crontab とは異なります
            (フォーマットの相違点の詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">crontab</span>(5)</span></a>
            で説明されています)。</p><p>
            もしこのような操作をしてしまったなら、
            あらたな crontab は誤ったフォーマットの
            <code class="filename">/etc/crontab</code>
            のコピーになってしまっているからです。
            以下のコマンドで削除してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab -r</code></strong></pre><p>
            今度 <code class="filename">/etc/crontab</code> を編集する時は、
            その変更を <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> に伝えるような操作をしてはいけません。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> は、自動的にその変更を認識するからです。</p><p>
            もしあなたが何かを一日一回、あるいは一週間や一ヶ月に一回だけ
            実行させたいなら、シェルスクリプトを
            <code class="filename">/usr/local/etc/periodic</code> に追加し、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=periodic&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">periodic</span>(8)</span></a> コマンドにシステムの cron スケジュールから
            他の定期的なシステムのタスクとともに
            実行させたほうが良いかもしれません。
          </p><p>このエラーの実際の原因は、システム crontab には
            どのユーザ権限でコマンドを実行するかを指定する余分なフィールドがあることによるものです。
            FreeBSD に添付されている標準のシステム crontab には、
            すべてのエントリに <code class="systemitem">root</code> が書かれています。
            この crontab が <code class="systemitem">root</code> ユーザの crontab
            (システム crontab とは <span class="emphasis"><em>異なります</em></span>)
            として使われた場合、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> は <code class="literal">root</code>
            を実行するコマンドの最初の単語だと認識しますが、
            そのようなコマンドは存在しないのです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80931920"></a><a id="su-wheel-group"></a><p><strong>7.5.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> コマンドを実行して
            <code class="systemitem">root</code> になろうとすると、
            su が <span class="errorname">you are not in the correct group to
            su root</span> と警告します。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、セキュリティ上の機能です。su コマンドを実行して
            <code class="systemitem">root</code> (またはスーパーユーザ権限を持つ
            他のアカウント) になるには、<code class="systemitem">wheel</code>
            グループに所属していなければなりません。この機能がないと、
            システムにアカウントがあって <code class="systemitem">root</code> の
            パスワードを見つけさえすれば、誰でもスーパーユーザ権限で
            システムにアクセスできてしまいます。この機能がある場合は、
            必ずしもそうはなりません。<code class="systemitem">wheel</code> グループに
            所属していなければ、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> がパスワードの入力すら
            拒否するからです。</p><p>誰かが <code class="systemitem">root</code> に su できるように
            するには、その人を <code class="systemitem">wheel</code> グループに追加してください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80944080"></a><a id="rcconf-readonly"></a><p><strong>7.6.</strong></p></td><td align="left" valign="top"><p><code class="filename">rc.conf</code> やその他の
            スタートアップファイルを書き間違えてしまいました。
            しかもそのためファイルシステムがリードオンリーになってしまっていて
            編集ができません。どうすればいいですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            シェルのパス名を入力するプロンプトが表示されたときに、
            単に <code class="literal">ENTER</code> を押し、<code class="command">mount /</code> を
            実行してそルートファイルシステムを再マウントさせます。
            また、お気に入りのエディタがあるファイルシステムを
            マウントするために <code class="command">mount -a -t ufs</code> を
            する必要があるかも知れません。あなたのお気に入りのエディタが
            ネットワークファイルシステム上にある場合は、
            ネットワークファイルシステムをマウントする前にネットワークを
            手動で設定するか、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ed&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ed</span>(1)</span></a> のようなローカルファイルシステムにある
            エディタを使うかしなければなりません。</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vi&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">vi</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=emacs&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">emacs</span>(1)</span></a> の様なフルスクリーンエディタを
            使うつもりなら <code class="command">export TERM=cons25</code> と
            やってエディタが <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=termcap&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">termcap</span>(5)</span></a> データベースから正しい
            データを読み取れるようにしなければなりません。</p><p>これを行ったあとはいつもと同様、
            <code class="filename">/etc/rc.conf</code>
            を編集して間違いを訂正することができるようになります。
            カーネル起動メッセージの直後に表示されたエラーメッセージには、
            問題の起こったファイル内での行番号を表示されているはずです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80952144"></a><a id="mount-dos"></a><p><strong>7.7.</strong></p></td><td align="left" valign="top"><p>どのようにしたら DOS の拡張パーティションをマウントできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            DOS 拡張パーティションは、
            すべての基本パーティションの後に認識されます。
            たとえば、2台目の SCSIドライブの拡張パーティションに
            <span class="quote">「<span class="quote">E</span>」</span>
            パーティションがあるとしますと、
            これは <code class="filename">/dev</code>
            に「スライス 5 」のスペシャルファイルを作る必要があり、
            <code class="filename">/dev/da1s5</code>
            としてマウントされます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV da1s5</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount -t msdos /dev/da1s5 /dos/e</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80962128"></a><a id="mount-foreign-fs"></a><p><strong>7.8.</strong></p></td><td align="left" valign="top"><p>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="literal">Digital UNIX</code>:
            UFS CDROM は直接 FreeBSD でマウントすることができます。
            Digital UNIX やそれ以外のシステムのサポートする
            UFS のディスクパーティションをマウントすることはもっと複雑なことで、
            オペレーティングシステムのディスクパーティションの詳細に依存します。
          </p><p>
            <code class="literal">Linux</code>:
            2.2 以降は <code class="literal">ext2fs</code> パーティションをサポートします。
            詳しくは、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_ext2fs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_ext2fs</span>(8)</span></a> を見てください。
          </p><p>
            <code class="literal">NT</code>:
            FreeBSD 用の読みだしのみ可能な NTFS ドライバがあります。
            詳しくは、Mark Ovens 氏によって書かれたチュートリアル
            <a class="link" href="http://ukug.uk.freebsd.org/~mark/ntfs_install.html" target="_top">http://ukug.uk.freebsd.org/~mark/ntfs_install.html</a>
            をご覧ください。
          </p><p>
            この問題について他の情報があれば、他の人から感謝されるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80968144"></a><a id="nt-bootloader"></a><p><strong>7.9.</strong></p></td><td align="left" valign="top"><p>どのようにしたら FreeBSD を NT ローダーから起動させることができますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            この手順は 2.2.x と (起動が 3 つのステージに分かれている) 3.x
            のシステムとで多少異なります。
          </p><p>
            FreeBSD のネイティブルートパーティションの最初のセクタをファイルにして
            DOS/NT パーティション上に置くという画期的なアイディアがあります。
            ファイル名を
            <code class="filename">c:\bootsect.bsd</code> (<code class="filename">c:\bootsect.dos</code>
            からの発想です) としたとします。
            <code class="filename">c:\boot.ini</code>ファイルを次のように編集します。
          </p><pre class="programlisting">[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"</pre><p>
            この手順は、利用しているシステムが 2.2.x であり、DOS、NT、FreeBSD
            あるいはその他のオペレーティングシステムがすべて、
            <span class="emphasis"><em>同じ</em></span>ディスクのそれぞれの
            fdisk パーティションにインストールされていることを想定しています。
            この例は、DOS と NT を最初の fdisk パーティションにおき、
            FreeBSD は 2 番目においたシステムで確認しています。
            また、FreeBSD は MBR を使わずに、
            ネイティブパーティションから起動するように設定してあります
            (訳注: FreeBSD のインストールで、ブートマネジャを使わずに標準
            MBR を使う場合に相当します)。
          </p><p>
            (もし NTFS に変換してしまっているなら)DOS
            フォーマットのフロッピーディスクか FAT
            パーティションを <code class="filename">/mnt</code> に DOS
            マウントします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</code></strong></pre><p>
            再起動して DOS か NT に切替えます。NTFS ユーザは
            <code class="filename">bootsect.bsd</code> や
            <code class="filename">bootsect.lnx</code> をフロッピーディスクから
            <code class="filename">C:\</code>
            へコピーします。
            <code class="filename">boot.ini</code>
            のファイル属性 (パーミッション) の変更を以下のように行ないます。
          </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>attrib -s -r c:\boot.ini</code></strong></pre><p>
            上の例の
            <code class="filename">boot.ini</code> で示したような正しいエントリを加え、
            ファイル属性を元に戻します。
          </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>attrib +s +r c:\boot.ini</code></strong></pre><p>
            FreeBSD が MBR から起動するようになっている場合、
            それぞれのネイティブパーティションから起動するように設定した後で、
            DOS から <code class="command">fdisk</code>
            コマンドを実行して元に戻してください。
          </p><p>
            FreeBSD 3.X における手順は、これよりいくぶん簡単です。
          </p><p>
            FreeBSD が NT 起動パーティションとして同じディスクにインストールされている場合には、
            <code class="filename">/boot/boot1</code> を単純に
            <code class="filename">C:\BOOTSECT.BSD</code> へコピーします。
            もし FreeBSD が異なったディスクにインストールされている場合には、
            <code class="filename">/boot/boot1</code> では動作しませんので、
            <code class="filename">/boot/boot0</code> が必要です。

            </p><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">ここで <code class="filename">/boot/boot1</code> の代わりに
                <code class="filename">/boot/boot0</code> をコピーするようなことをしてはいけません!
                そうすると、パーティションテーブルを上書きしてしまい、
                コンピュータが起動できなくなってしまいます。</p></div><p>
          </p><p><code class="filename">/boot/boot0</code> をインストールするには、
            sysinstall のブートマネージャを利用するかどうか尋ねられる画面で
            FreeBSD ブートマネージャを選択する必要があります。
            <code class="filename">/boot/boot0</code>
            のパーティションテーブル部分は NULL 文字で埋められているのですが、
            sysinstall は <code class="filename">/boot/boot0</code> を MBR
            にコピーする前にパーティションテーブルをきちんとコピーしてくれるからです。</p><p>FreeBSD ブートマネージャは最後に起動した OS を記録するために
            パーティションテーブルの最後に起動した OS
            のエントリにあるアクティブフラグをセットし、512 バイト全体を MBR に書き戻します。
            これは <code class="filename">/boot/boot0</code> を
            <code class="filename">C:\BOOTSECT.BSD</code> にコピーし、
            エントリの一つにアクティブフラグをセットして空のパーティションテーブルを MBR
            に書き込むことと同じです。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp80990800"></a><a id="lilo-bootloader"></a><p><strong>7.10.</strong></p></td><td align="left" valign="top"><p>FreeBSD と Linux を LILO から起動するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD と Linux が同じディスクにインストールされている場合、
            単に Linux 以外の OS を起動するための LILO のインストール手順に
            従えばいいだけです。非常に簡単にではありますが、記してみましょう。
          </p><p>
            Linux を起動し、<code class="filename">/etc/lilo.conf</code>
            に以下の行を加えて
            ください。</p><pre class="programlisting">other=/dev/hda2
        table=/dev/hda
        label=FreeBSD</pre><p>
            (上記の手順は FreeBSD のスライスが Linux から
            <code class="filename">/dev/hda2</code>
            という名前で見えていると仮定しています。
            あなたの設定にあわせてください)
            その後、<code class="command">lilo</code> を
            <code class="systemitem">root</code>
            で実行すれば完了です。
          </p><p>
            FreeBSD が別のディスクにインストールされているのなら、
            LILO のエントリに
            <code class="literal">loader=/boot/chain.b</code>
            を追加してください。たとえば、このようになります。
          </p><pre class="programlisting">other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=FreeBSD</pre><p>
            場合によっては、二つ目のディスクを正しく起動するために FreeBSD
            ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません。
            たとえば、FreeBSD SCSI ディスクが BIOS によって
            BIOS ディスク 1 として認識されるのなら、
            FreeBSD のブートローダのプロンプトで、次のように指定する必要があります。

            </p><pre class="screen"><code class="prompt">Boot:</code> <strong class="userinput"><code>1:da(0,a)/kernel</code></strong></pre><p>
          </p><p>
            FreeBSD 2.2.5 やそれ以降の版では、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a> を設定すれば
            起動時に上記のことが自動的に行えます。
          </p><p>
            <a class="link" href="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html" target="_top">Linux+FreeBSD
              mini-HOWTO</a> が FreeBSD と Linux
            とを相互に使えるようにするためのよい参考資料になるでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81004624"></a><a id="booteasy-loader"></a><p><strong>7.11.</strong></p></td><td align="left" valign="top"><p>FreeBSD と Linux を BootEasy から起動するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            LILO をマスターブートレコード (MBR) ではなく
            Linux の起動パーティションにインストールしてください。
            これで BootEasy から
            LILO を起動できるようになります。
          </p><p>
            Windows95 と Linux を使用している場合は、
            いずれにせよ後者の方がおすすめです。
            Windows95 を再インストールする必要にかられたとき、
            Linux を起動可能に戻す手続きが簡単ですむからです
            (Windows95 は偏屈なオペレーティングシステムで、
            マスターブートレコード (MBR) から他のオペレーティングシステムを追い払ってしまうのです)。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81007184"></a><a id="dangerously-dedicated"></a><p><strong>7.12.</strong></p></td><td align="left" valign="top"><p>「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><a id="dedicate"></a>
              インストール作業中、
              ハードディスクのパーティションを切る際に
              2 つの方法を選ぶことができます。
              デフォルトの方法では、fdisk のテーブルエントリ (FreeBSD
              ではスライスと呼ばれる) を使って、
              自身のパーティションを使用する FreeBSD のスライスを、
              同じマシンの他のオペレーティングシステムと互換性のある形にします。
              それに付随して、ブートセレクタをインストールすれば、
              ディスク上の使用可能なオペレーティングシステムを切り替えることができます。
              もう一つの方法はディスクすべてを FreeBSD で使うというもので、
              この場合ほかのオペレーティングシステムとの互換性を考慮しないことになります。
          </p><p>
            では、なぜこれが 「危険覚悟の」と言われるのでしょう?
            このモードのディスクが、通常の PC のユーティリティが有効な fdisk
            テーブルと見なす情報を持っていないからです。
            ユーティリティの出来如何によりますが、
            そのようなディスクを発見したとき、
            警告を出すものもあります。また、もっと悪い場合、
            確認も通告もなしに
            BSD のブートストラップにダメージを与えるものもあるでしょう。
            さらには、「危険覚悟の」ディスクレイアウトは多数の BIOS、
            AWARD (たとえば HP Netserver や Micronics システム、
            他多数で使用されていた) や
            Symbios/NCR (人気のあるSCSI コントローラ 53C8xx
            用) などを混乱させることが分かっています。
            これは完全なリストではありません。
            他にもまだまだあります。この混乱の兆候は、
            起動時にシステムがロックするというだけでなく、
            FreeBSD のブートストラップが自分自身を見つけられないために表示する
            <span class="quote">「<span class="quote">read error</span>」</span>
            というメッセージなどにも現れることでしょう。
          </p><p>
            そもそもいったいなぜこのモードがあるのでしょうか?
            これはわずかに数キロバイトのディスク容量を節約するのみであり、
            新規インストールで実際に問題を生ずるのです。
            「危険覚悟の」モードの起源は新しい FreeBSD インストーラでの、
            BIOS から見えるディスクの
            「ジオメトリ」の値とディスク自身との整合性という、
            もっとも一般的な問題のひとつを回避したいという要求が背景にあります。
          </p><p>
            「ジオメトリ」は時代遅れの概念ですが、
            未だに PC BIOS とディスクへの相互作用の中核をなしています。
            FreeBSD のインストーラがスライスを作る時、
            ディスク上のスライスを BIOS が見つけられるように、
            スライス位置をディスク上に記録します。それが誤っていれば、
            起動できなくなってしまうでしょう。
          </p><p>
            「危険覚悟の」モードはこれを、
            問題を単純にすることで回避しようとします。
            状況によってはこれでうまくいきます。
            しかし次善の策として使われているに過ぎません。
            この問題を解決するもっと良い方法はいくらでもあるのです。
          </p><p>
            では、
            インストール時に「危険覚悟の専用」モードが必要になる
            状況を回避するにはどうすればよいのでしょうか?
            まず BIOS が報告するディスクのジオメトリの値を覚えておくことからはじめましょう。
            <span class="quote">「<span class="quote">boot:</span>」</span>
            プロンプトで <span class="quote">「<span class="quote"><code class="option">-v</code></span>」</span>
            を指定するか、ローダで
            <span class="quote">「<span class="quote">boot -v</span>」</span>
            と指定して、
            起動時にカーネルにこの値を表示させることができます。
            インストーラが起動する直前に、
            カーネルがジオメトリ値のリストを表示するでしょう。
            パニックを起こさないでください。
            インストーラが起動するのを待ち、
            逆スクロールでさかのぼって値を確認してください。
            普通は BIOS
            ディスクユニット番号は、
            FreeBSD がディスクを検出する順序と同様であり、
            最初に IDE、次に SCSI となります。
          </p><p>
            ディスクをスライシングする際に、
            FDISK の画面で表示されるディスクのジオメトリが正しいこと (BIOS
            の返す値と一致しているか) を確認してください。
            万一異なっていたら <span class="quote">「<span class="quote"><strong class="userinput"><code>g</code></strong></span>」</span>
            を押して修正してください。
            ディスクにまったくなにもない場合や、
            他のシステムから持ってきたディスクの場合は
            これを行なう必要があるかもしれません。
            これはそのディスクから起動させようとしている場合にのみ、
            問題になることに注意してください。
            FreeBSD はそのディスクをうまい具合いに他のディスクと区別してくれます。
          </p><p>
            ディスクのジオメトリについて BIOS と FreeBSD
            間で一致させることができたら、この問題はほぼ解決したと思ってよいでしょう。
            そしてもはや「危険覚悟の専用」モードは必要ありません。
            しかし、まだ起動時に恐怖の
            <span class="quote">「<span class="quote">read error</span>」</span>
            メッセージが出るようであれば、
            お祈りを捧げて新しいディスクを買いましょう。
            もう失うものは何もありません。
          </p><p>
            「危険覚悟の専用ディスク」を通常の PC
            での使用法に戻すには、
            原則として 2 つ方法があります。1 つは十分な NULL
            バイトを MBR に書き込んで、
            きたるべきインストーラにディスクはまっさらだと思い込ませる方法です。
            たとえば、こんな感じです。

            </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/dev/rda0 count=15</code></strong></pre><p>
          </p><p>
            また、マニュアルには書かれていない DOS の「機能」

            </p><pre class="screen"><code class="prompt">&gt;</code> <strong class="userinput"><code>fdisk /mbr</code></strong></pre><p>

              は、BSD ブートストラップを追い払ってくれる上に、
            新しいマスターブートレコードをインストールしてくれます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81124048"></a><a id="add-swap-space"></a><p><strong>7.13.</strong></p></td><td align="left" valign="top"><p>どのようにしたらスワップ領域を増やせますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            スワップパーティションのサイズを増やすのが最良の方法ですが、
            別のディスクを追加しなくて済むという利点のある方法があります。
            経験から得た一般的な方法はメインメモリの 2倍程度のスワップ領域を
            とるというものです。しかしごく小さなメインメモリしかない場合は、
            それ以上のスワップを構成したいと思うでしょう。また、将来のメモリの
            アップグレードに備え、後でスワップの構成を変更する必要がないように
            十分なスワップを構成しておくことは良い考えです。
          </p><p>
            スワップを別のディスク上に追加することは、単純に同じディスク上
            にスワップを追加する場合よりも高速に動作するようになります。
            例に挙げれば、あるディスク上のソースをコンパイルしているとして、
            スワップが別のディスク上に作られていれば、これらが同じディスク上
            にある場合よりも断然速いです。SCSI ディスクの場合は特にそうだと言えます。
          </p><p>
            ディスクが複数ある場合、スワップパーティションを各ディスクに
            作るように構成すると、使用中のディスク上にスワップを置いたとしても、
            通常の場合は有益です。一般的に、システムにある高速なディスクには
            スワップを作るようにすべきでしょう。
            FreeBSD はデフォルトでインターリーブなスワップデバイスを 4つまで
            サポートします。複数のスワップパーティションを構成する際に、
            普通はそれらを大体同じくらいの大きさにして作りたいところですが、
            カーネルのコアダンプを取るのに都合が良いようにメインの
            スワップパーティションを大きめにとる人もいます。
            メインのスワップパーティションはカーネルのコアがとれるように
            最低でも実メモリと同じ大きさにすべきでしょう。
          </p><p>
            IDE ドライブは同時に同じチャネル上の複数のドライブには
            アクセスできません (FreeBSD は mode 4 をサポートしていないので、
            すべての IDE ディスク I/O は <span class="quote">「<span class="quote">programmed</span>」</span> です)。
            IDE の場合であってもやはり、スワップを別のハードディスク上に
            作成することをおすすめします。
            ドライブは実に安いものです、心配するだけ無駄です。
          </p><p>
            NFS 越しにスワッピングさせる方法は、
            スワップ用のローカルディスクが無い場合にのみ推奨されます。
            NFS 越しのスワッピングは遅く、FreeBSD 4.x より前のリリースでは
            効率が悪いのですが、4.0 以降ではそれなりに高速になります。
            そうはいっても、利用できるネットワークの太さに制限されますし、
            NFS サーバに余計な負荷がかかります。
          </p><p>
            これは 64MBの vn-swap を作る例です (ここでは
            <code class="filename">/usr/swap0</code>
            としますが、もちろん好きな名前を使うことができます)。
          </p><p>
            カーネルが次の行を含むコンフィグファイルから構成されているかを
            確認します。GENERIC カーネルには、この行が含まれています。
          </p><pre class="programlisting">pseudo-device   vn 1   #Vnode driver (turns a file into a device)</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>vn デバイスを作ります</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh ./MAKEDEV vn0</code></strong></pre></li><li class="listitem"><p>スワップファイルを作ります
                (<code class="filename">/usr/swap0</code>)</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</code></strong></pre></li><li class="listitem"><p>スワップファイルに適切なパーミッションを設定します</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 0600 /usr/swap0</code></strong></pre></li><li class="listitem"><p><code class="filename">/etc/rc.conf</code>
                でスワップファイルを有効化させます</p><pre class="programlisting">swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</pre></li><li class="listitem"><p>マシンを再起動します</p></li></ol></div><p>
            スワップファイルをすぐに有効化させたいのなら以下のようにタイプします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>vnconfig -e /dev/vn0b /usr/swap0 swap</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81176656"></a><a id="printer-setup"></a><p><strong>7.14.</strong></p></td><td align="left" valign="top"><p>プリンタのセットアップで問題があります</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ハンドブックのプリンタの部分を参照してください。
            探している問題のほとんどが書かれているはずです。
            <a class="link" href="../handbook/printing.html" target="_top">FreeBSD
              ハンドブックの「プリンタの利用」</a>をご覧ください。
          </p><p>プリンタによっては、印刷するのにホスト側にドライバが
            必要です。これら <span class="quote">「<span class="quote">WinPrinters</span>」</span> と呼ばれるものは、
            素の FreeBSD では使えません。DOS や Windows NT 4.0 で動作しない
            なら、そのプリンタはおそらく WinPrinter でしょう。
            ただし、唯一の希望が残されています。
            <code class="filename">ports/print/pnm2ppa</code> の port が
            対応しているかどうか確認してみてください。<a class="link" href="http://www.freebsd.org/cgi/url.cgi?ports/print/pnm2ppa/pkg-descr" target="_top">
            パッケージの説明</a>にはこう書いてあります。</p><div class="blockquote"><blockquote class="blockquote"><p>このソフトウェアは PPA (printer performance
              architecture) プロトコルの出力を行います。このプロトコル
              は HP の "Windows 専用" プリンタの一部に使われています。
              そのなかには、HP Deskjet 820C シリーズ、HP DeskJet 720
              シリーズ、および HP DeskJet 1000 シリーズがあります。(略)</p><p>WWW: <a class="link" href="http://pnm2ppa.sourceforge.net/" target="_top">http://pnm2ppa.sourceforge.net/</a></p></blockquote></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81182672"></a><a id="keyboard-mappings"></a><p><strong>7.15.</strong></p></td><td align="left" valign="top"><p>私のシステムのキーボードマッピングは間違っています。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <code class="command">kbdcontrol</code> プログラムは、
            キーボードマップファイルを読み込むためのオプションを備えています。
            <code class="filename">/usr/share/syscons/keymaps</code>
            の下にたくさんのマップファイルがあります。
            システムに関連のあるものを一つ選んで、ロードしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kbdcontrol -l uk.iso</code></strong></pre><p>
            <code class="filename">/usr/share/syscons/keymaps</code>
            と拡張子
            <code class="filename">.kbd</code> は、どちらも
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kbdcontrol</span>(1)</span></a>
            によって使用されます。
          </p><p>
            これは <code class="filename">/etc/sysconfig</code> (または
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>)
            中で設定することができます。
            このファイル中にあるそれぞれのコメントを参照してください。
          </p><p>
            FreeBSD 2.0.5R
            やそれ以降の版では、
            テキストフォントやキーボードマッピングに関係のあるものはすべて、
            <code class="filename">/usr/share/examples/syscons</code>
            の中におさめられています。
          </p><p>現在以下のマッピングがサポートされています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Belgian ISO-8859-1</p></li><li class="listitem"><p>Brazilian 275 keyboard Codepage 850</p></li><li class="listitem"><p>Brazilian 275 keyboard ISO-8859-1</p></li><li class="listitem"><p>Danish Codepage 865</p></li><li class="listitem"><p>Danish ISO-8859-1</p></li><li class="listitem"><p>French ISO-8859-1</p></li><li class="listitem"><p>German Codepage 850 </p></li><li class="listitem"><p>German ISO-8859-1</p></li><li class="listitem"><p>Italian ISO-8859-1</p></li><li class="listitem"><p>Japanese 106</p></li><li class="listitem"><p>Japanese 106x</p></li><li class="listitem"><p>Latin American</p></li><li class="listitem"><p>Norwegian ISO-8859-1</p></li><li class="listitem"><p>Polish ISO-8859-2 (programmer's)</p></li><li class="listitem"><p>Russian Codepage 866 (alternative)</p></li><li class="listitem"><p>Russian koi8-r (shift)</p></li><li class="listitem"><p>Russian koi8-r</p></li><li class="listitem"><p>Spanish ISO-8859-1</p></li><li class="listitem"><p>Swedish Codepage 850</p></li><li class="listitem"><p>Swedish ISO-8859-1</p></li><li class="listitem"><p>Swiss-German ISO-8859-1</p></li><li class="listitem"><p>United Kingdom Codepage 850</p></li><li class="listitem"><p>United Kingdom ISO-8859-1</p></li><li class="listitem"><p>United States of America ISO-8859-1</p></li><li class="listitem"><p>United States of America dvorak</p></li><li class="listitem"><p>United States of America dvorakx</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81220304"></a><a id="pnp-resources"></a><p><strong>7.16.</strong></p></td><td align="left" valign="top"><p>起動時に、<span class="errorname">unknown: &lt;PNP0303&gt; can't
              assign resources</span> というメッセージが表示されるのですが?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>以下は、freebsd-current メーリングリストへの投稿からの
            抜粋です。</p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top">〓</td><td width="80%" valign="top"><p><span class="quote">「<span class="quote">can't assign resources</span>」</span> というメッセージは、
              そのデバイスがレガシー ISA デバイスで、PnP を意識していない
              ドライバがカーネルに組み込まれていることを示します。
              これには、キーボードコントローラ、プログラム可能な
              割り込み制御 IC やその他さまざまな標準的なデバイスが
              あります。リソースが割り当てられないのは、既にそのアドレスを
              使っているドライバがあるからです。</p></td><td width="10%" valign="top">〓</td></tr><tr><td width="10%" valign="top">〓</td><td colspan="2" align="right" valign="top">--<span class="attribution">Garrett Wollman, 2001 年 4 月 24 日</span></td></tr></table></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81224400"></a><a id="user-quotas"></a><p><strong>7.17.</strong></p></td><td align="left" valign="top"><p>ユーザディスククォータが正常に動作していないようです。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="quote">「<span class="quote"><code class="filename">/</code></span>」</span>
                  にはディスククォータを設定しないでください。</p></li><li class="listitem"><p>
                  クォータファイルが置かれるファイルシステム上に
                  クォータファイルを置くようにしてください。
                </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Filesystem</th><th>Quota file</th></tr></thead><tbody><tr><td><code class="filename">/usr</code></td><td><code class="filename">/usr/admin/quotas</code></td></tr><tr><td><code class="filename">/home</code></td><td><code class="filename">/home/admin/quotas</code></td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81239504"></a><a id="inappropriate-ccd"></a><p><strong>7.18.</strong></p></td><td align="left" valign="top"><p>わたしの ccd は、
            何が適合していない (Inappropriate) のでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>次のような症状が現れます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ccdconfig -C</code></strong>
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format</pre><p>
            通常この現象はタイプを「未使用 (unused)」のまま放っておかれた
            <code class="literal">c</code>
            パーティションをつなげようとした場合に現れます。ccd ドライバは
            FS_BSDFFS
            タイプをベースとするパーティションを要求します。
            つなげようとしているディスクのディスクラベルを編集して、
            パーティションのタイプを <code class="literal">4.2BSD</code>
            に変更してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81256144"></a><a id="ccd-disklabel"></a><p><strong>7.19.</strong></p></td><td align="left" valign="top"><p>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>次のような症状が現れます。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel ccd0</code></strong>
(it prints something sensible here, so let's try to edit it)
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -e ccd0</code></strong>
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label</pre><p>
            これは ccd から返されるディスクラベルが、
            実はディスク上にはないまったくの偽の情報だからです。
            これを明示的に書き直すことで問題を解消できます、
            それには、つぎのようにします。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>disklabel ccd0 &gt; /tmp/disklabel.tmp</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -Rr ccd0 /tmp/disklabel.tmp</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>disklabel -e ccd0</code></strong>
(this will work now)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81263184"></a><a id="sysv-ipc"></a><p><strong>7.20.</strong></p></td><td align="left" valign="top"><p>FreeBSD は System V の IPC プリミティブをサポートしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            はい。
            FreeBSD は System-V スタイルの IPC をサポートします。
            共有メモリ、メッセージ、セマフォが含まれます。
            以下の行をカーネルコンフィグファイルに加えると、
            サポートが有効になります。
          </p><pre class="programlisting">options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</pre><div xmlns="" class="note"><h3 class="admontitle">注記: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD 3.2 とそれ以降では、
                これらのオプションがあらかじめ <span class="emphasis"><em>GENERIC</em></span>
                カーネルに含まれていますので、
                あなたのシステムにはすでに組み込まれています。</p></div><p>カーネルを再構築してインストールしてください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81267152"></a><a id="uucpmail"></a><p><strong>7.21.</strong></p></td><td align="left" valign="top"><p>UUCP でメールを配送するには sendmail をどう使えばよいのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD に付属している sendmail は、
            インターネットに直接つながっているサイトにあわせて設定してあります。
            UUCP 経由で mail を交換したい場合には sendmail
            の設定ファイルを改めてインストールしなければなりません。
          </p><p>
            <code class="filename">/etc/sendmail.cf</code>
            を自分の手で改造するのは純粋主義者のやるような事です。
            sendmail の version 8 は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=m4&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">m4</span>(1)</span></a>
            のようなプリプロセッサを通して設定ファイルを生成する新しいアプローチを取っており、
            より抽象化されたレベルの設定ファイルを編集します。
            <code class="filename">/usr/src/usr.sbin/sendmail/cf</code>
            ディレクトリの中にある設定ファイルを使用してください。
          </p><p>
            もしすべてのソースをインストールしていない場合には sendmail
            の設定ツールは、別の tar ファイルにまとめてあります。CD-ROM が
            mount されている場合には、次のようにしてください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/src</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</code></strong></pre><p>
            これはたった数 100Kbyte ですから心配ないでしょう。
            <code class="filename">cf</code>
            ディレクトリにある <code class="filename">README</code>
            に、m4 での設定の基本的な説明があります。
          </p><p>
            UUCP での配送のためには、<code class="literal">mailertable</code> を使用すれば
            よいでしょう。これによって、sendmail
            が配送方式を決定するデータベースを
            作成することができます。
          </p><p>まずはじめに、
            <code class="filename">.mc</code> ファイルを作成しなければなりません。
            <code class="filename">/usr/src/usr.sbin/sendmail/cf/cf</code> というディレクトリが、
            これらのファイルを作成する場所です。既にいくつか例があると思います。
            これから作成するファイルの名前を <code class="filename">foo.mc</code> とすると、
            <code class="filename">sendmail.cf</code> を求めているような形式に変換するには、
            次のようにしてください。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/usr.sbin/sendmail/cf/cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make foo.cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cp foo.cf /etc/sendmail.cf</code></strong></pre><p>
            標準的な
            <code class="filename">.mc</code> ファイルは次のようになります。
          </p><pre class="programlisting">include(`../m4/cf.m4')
VERSIONID(`<em class="replaceable"><code>Your version number</code></em>')
OSTYPE(bsd4.4)

FEATURE(nodns)
FEATURE(nocanonify)
FEATURE(mailertable)

define(`UUCP_RELAY', <em class="replaceable"><code>your.uucp.relay</code></em>)
define(`UUCP_MAX_SIZE', 200000)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <em class="replaceable"><code>your.alias.host.name</code></em>
Cw    <em class="replaceable"><code>youruucpnodename.UUCP</code></em></pre><p>
            <code class="literal">nodns</code> と
            <code class="literal">nocanonify</code> という指定をすることで、
            mail の配送に DNS を使用しなくなります。
            <code class="literal">UUCP_RELAY</code> という
            行に関しては、
            ある理由から必要ですがそれは聞かないでください。
            .UUCP で終わる仮想ドメインを処理することのできるインターネット上での
            ホスト名をここに書いてください。通常は、ISP の mail リレーホストを
            書くことになると思います。
          </p><p>
            これが終了したら、次に
            <code class="filename">/etc/mailertable</code>
            というファイルが必要です。標準的な例は次のとおりです。
          </p><pre class="programlisting">#
# makemap hash /etc/mailertable.db &lt; /etc/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre><p>
            見れば分かるように、これは実在する設定のファイルです。はじめの
            3 行はドメイン名で指定されたメールが default の経路で配送されずに、
            「近道」するために UUCP で隣りのサイトに送るための特別な状況を
            処理するものです。
            次の行は Ethernet でつながっているローカルのドメインに対しては
            SMTP で送るための設定です。
            最後に、UUCP での隣りのサイトが .UUCP で終わる仮想ドメインの書式で
            指定されており、default の rule を
            <code class="literal">uucp-neighbour!
            recipient</code>
            で上書きするためのものです。一番最後の行はいつもドットを一つ書きます。
            これは、ここまでの行でマッチしなかったすべてのホストにマッチし、
            このサイトから世界に向けて出ていくための mail gateway に UUCP
            で配送するためのものです。
            <code class="literal">uucp-dom:</code> に続けて書かれているノード名は、
            <code class="literal">uuname</code> コマンドで指定することによって UUCP
            で直接配送される正しいノード名でなければなりません。
          </p><p>
            最後に、このファイルは使用する前に DBM データベースのファイルに
            変換する必要があります。これを行なうコマンドラインは mailertable
            の最初のコメントに書いてあります。mailertable を変更した時には、
            必ずこのコマンドを実行してください。
          </p><p>
            最後のヒントです: もし特定のメール配送がうまく作動するかどうか
            確かめたい場合には、sendmail の<code class="option">-bt</code> オプションを
            使用してください。このオプションによって sendmail は
            <span class="emphasis"><em>アドレステストモード</em></span>で起動します。
            <code class="literal">0</code>
            の後に配送したいアドレスを書いてください。最後の行に、実際に使用される
            mail agent、この mail agent で送られる送信先のホスト、そして
            (多分変換されている) アドレスが表示されます。このモードを抜けるには
            Control-D を押してください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sendmail -bt</code></strong>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>0 foo@interface-business.de</code></strong>
rewrite: ruleset  0   input: foo @ interface-business . de
...
rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
&lt; @ interface-business . de &gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>^D</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81307728"></a><a id="ispmail"></a><p><strong>7.22.</strong></p></td><td align="left" valign="top"><p>ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            静的に IP アドレスが割り当てられる場合は、
            デフォルトの状態を変更する必要はありません。
            割り当てられた名前をホストネームと
            するだけで、sendmail が後のことを引き受けてくれます。
          </p><p>
            ダイアルアップ <span class="application">ppp</span> を
            インターネット接続に使用し、動的に IP アドレスが割り当てられる場合は、
            インターネットサービスプロバイダ (ISP)
            のメールサーバにメールボックスがあるはずです。
            ISP のドメインが
            <code class="systemitem">myISP.com</code>
            で、あなたのユーザ名が
            <code class="systemitem">user</code> だと仮定します。
            また、あなたが自分のマシンを <code class="systemitem">bsd.home</code>
            と呼んでおり、ISP が
            <code class="systemitem">relay.myISP.com</code>
            をメールリレーとして使用できると言っているとしましょう。
          </p><p>
            メールボックスからメールを取ってくるためには、
            回収 (retrieval) エージェントをインストールする必要があります。
            <span class="application">Fetchmail</span>
            は多種多様なプロトコルをサポートしているのでお勧めです。
            ISP が使用しているのは、大抵 POP3 プロトコルです。
            ユーザ ppp を使用している場合、
            <code class="filename">/etc/ppp/ppp.linkup</code>
            に以下のように記述すると、
            インターネットと接続が完了した時点で自動的にメールを取得するようになります。
          </p><pre class="programlisting">MYADDR:
        !bg su user -c fetchmail</pre><p>
            ローカルでないアカウントにメールを配送するのに
            sendmail を使用している場合 (後述)、
            上に示したエントリの後に
          </p><pre class="programlisting">        !bg su user -c "sendmail -q"</pre><p>
            を記述します。これはネットワーク接続が確立したらすぐに
            <span class="application">sendmail</span> に溜っている
            mailqueue を強制的に処理させるようにします。
          </p><p>
            この例では、<code class="systemitem">user</code> が
            <code class="systemitem">bsd.home</code> にアカウントを持ち、
            <code class="systemitem">bsd.home</code> 上の
            <code class="systemitem">user</code>
            のホームディレクトリに、以下のような
            <code class="filename">.fetchmailrc</code>
            ファイルがつくられていることを想定しています。
          </p><pre class="programlisting">poll myISP.com protocol pop3 fetchall pass MySecret;</pre><p>
            言うまでもなく、このファイルは
            <code class="systemitem">user</code>
            以外のユーザが読むことが出来ないようにしなくてはなりません。
            内容にパスワード <code class="literal">MySecret</code>
            が含まれているからです。
          </p><p>
            正しい
            <code class="literal">from:</code>
            ヘッダをつけてメールを送るためには、
            <span class="application">sendmail</span> に
            <code class="literal">user@bsd.home</code> ではなく
            <code class="literal">user@myISP.com</code>
            を使用するよう教える必要があります。
            メールをより早く転送するために、すべてのメールを
            <code class="systemitem">relay.myISP.com</code>
            へ送るように <span class="application">sendmail</span> に
            指示しておくのも良いでしょう。
          </p><p>
            上の要件を満たすには、以下のような <code class="filename">.mc</code>
            ファイルが適しています。
          </p><pre class="programlisting">VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`myISP.com')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.myISP.com')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE', `deferred')dnl</pre><p>
            <code class="filename">.mc</code> ファイルから
            <code class="filename">sendmail.cf</code> への変換方法については、
            前のセクションを参照してください. sendmail.cf を更新した後に
            <span class="application">sendmail</span> をリスタートするのもお忘れなく。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81338704"></a><a id="toor-account"></a><p><strong>7.23.</strong></p></td><td align="left" valign="top"><p>この UID が 0 の <code class="systemitem">toor</code> という
            アカウントとは何ですか? 危険にさらされているのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>心配無用です。<code class="systemitem">toor</code> は
            <span class="quote">「<span class="quote">代替の</span>」</span> スーパーユーザーアカウントです
            (toor は root を逆に綴ったものです)。
            以前は、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bash&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">bash</span>(1)</span></a> シェルがインストールされた時に
            作成されていましたが、現在は標準で作成されています。
            このユーザーが作成されるのは、
            スーパーユーザが非標準のシェルを使う場合を想定しており、
            <code class="systemitem">root</code>
            の標準のシェルを変更しなくてもよくなっています。
            基本配布に含まれていないシェル
            (たとえば ports や packages からインストールされるシェル)
            は、デフォルトでは別のファイルシステムに存在する
            可能性のある <code class="filename">/usr/local/bin</code> に
            インストールされることが多いので、これは重要です。
            <code class="systemitem">root</code> のシェルが
            <code class="filename">/usr/local/bin</code> にあり、
            <code class="filename">/usr</code>
            (または、<code class="filename">/usr/local/bin</code>
            があるいずれかのファイルシステム)
            が何らかの理由でマウントされていないとすると、
            <code class="systemitem">root</code> は問題を解決するために
            ログインすることができません (シングルユーザーモードで再起動すれば、
            シェルのパスの入力を促されるのですが)。</p><p><code class="systemitem">toor</code> を日々の root の仕事を
            非標準のシェルで行うために使い、<code class="systemitem">root</code> は
            シングルユーザーモードや緊急時のために、標準のシェルのままに
            している人がいます。何もしなければ、パスワードを無効にしてあるので
            <code class="systemitem">toor</code> ではログインできません。
            使いたいなら、<code class="systemitem">root</code> でログインして <code class="systemitem">toor</code> の
            パスワードを設定しましょう。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81390288"></a><a id="forgot-root-pw"></a><p><strong>7.24.</strong></p></td><td align="left" valign="top"><p>しまった! root のパスワードを忘れてしまった!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            慌てないでください! 単にシステムを再起動し、
            シングルユーザモードに移るために <code class="prompt">Boot:</code>
            と表示されるプロンプトで <strong class="userinput"><code>boot -s</code></strong>
            と入力してください
            (FreeBSD の 3.2 より前のリリースでは
            <strong class="userinput"><code>-s</code></strong>となります)。
            どのシェルを使うのかという質問には、ENTER
            キーを押してください。<code class="prompt">#</code>
            に移ることができるでしょう。
            <code class="command">mount -u /</code> と入力して
            ルートファイルシステムの読み書きを再マウントし、
            <code class="command">mount -a</code> と入力して、
            すべてのファイルシステムをマウントし直した後、
            <code class="command">passwd root</code>
            と入力して <code class="systemitem">root</code>
            のパスワードを設定し直してください。
            その後、<code class="command">exit</code>
            と入力すれば、起動が続けられます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81395920"></a><a id="CAD-reboot"></a><p><strong>7.25.</strong></p></td><td align="left" valign="top"><p>
            <span class="keycap"><strong>Control</strong></span>-<span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>Delete</strong></span>
            でシステムが再起動しないようにするにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            FreeBSD 2.2.7-RELEASE 以降で syscons (デフォルトのコンソールドライバ)
            を使用している場合には、次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し、インストールしてください。
          </p><pre class="programlisting">options SC_DISABLE_REBOOT</pre><p>
            FreeBSD 2.2.5-RELEASE 以降で PCVT コンソールドライバを使用している
            場合には、同様に次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し、インストールしてください。
          </p><pre class="programlisting">options PCVT_CTRL_ALT_DEL</pre><p>
            上にあげたものよりも古い FreeBSD の場合、
            現在コンソールが使用しているキーマップを編集し、
            キーワード
            <code class="literal">boot</code> を
            <code class="literal">nop</code> に書き換えてください。
            <code class="filename">/usr/share/syscons/keymaps/us.iso.kbd</code>
            にあります。
            その変更を反映させようとして、
            このキーマップのロードを明示的に行なうために、
            <code class="filename">/etc/rc.conf</code> を実行すべきかもしれません。
            もちろん他の国のキーマップを使っているのであれば、
            代わりにそのキーマップファイルを編集してください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81402320"></a><a id="dos-to-unix-txt"></a><p><strong>7.26.</strong></p></td><td align="left" valign="top"><p>DOS のテキストファイルを UNIX
            のテキストファイルに整形するにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            単に次の perl コマンドを実行してください。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>perl -i.bak -npe 's/\r\n/\n/g' file ...</code></strong></pre><p>
            file
            の部分には処理するファイルを指定してください。
            整形後のファイルは元のファイル名で作成され、
            整形前のファイルはバックアップとして元の
            ファイル名の末尾に拡張子
            <code class="filename">.bak</code> のつけられた名前で作成されます。
          </p><p>
            あるいは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tr</span>(1)</span></a>
            コマンドを使うこともできます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tr -d '\r' &lt; dos-text-file &gt; unix-file</code></strong></pre><p>
            <em class="replaceable"><code>dos-text-file</code></em> は
            DOS 形式のテストファイル、
            <em class="replaceable"><code>unix-file</code></em>
            には変換された出力が格納されます。
            perl を使うよりほんのちょっぴり速くなります。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81442256"></a><a id="kill-by-name"></a><p><strong>7.27.</strong></p></td><td align="left" valign="top"><p>名前で指定してプロセスにシグナルを送るにはどうすればいい?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=killall&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">killall</span>(1)</span></a>
            を使ってください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81445072"></a><a id="root-acl"></a><p><strong>7.28.</strong></p></td><td align="left" valign="top"><p>su が not in <code class="systemitem">root</code>'s ACL
            と言って私を悩ませるのはなぜ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Kerberos の認証システムからくるエラーです。
            この問題は致命的なものではなく、
            うっとおしいといったものです。
            <code class="command">su</code> に <code class="option">-K</code>
            オプションをつけて起動するか、
            次の質問で説明されている方法で Kerberos
            をアンインストールしてください。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81448656"></a><a id="uninstall-kerberos"></a><p><strong>7.29.</strong></p></td><td align="left" valign="top"><p>Kerberos をアンインストールするにはどうすればいいの?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            システムから Kerberos を削除するには、
            あなたの動かしているリリースの
            bin ディストリビューションを再インストールしてください。
            もし CDROM を持っているのなら、
            その CDROM をマウント (マウントポイントは
            <code class="filename">/cdrom</code> と仮定) して、
            次のように入力してください。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/bin</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./install.sh</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81452752"></a><a id="add-pty"></a><p><strong>7.30.</strong></p></td><td align="left" valign="top"><p>疑似ターミナルを追加するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            telnet、ssh、X、screen をたくさん利用されている場合、
            疑似ターミナルが足りなくなっている可能性があります。
            これを増やすには次のようにします。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
                  次の行をカーネルコンフィグレーションファイルに追加して

                  </p><pre class="programlisting">pseudo-device pty 256</pre><p>

                  新たにカーネルを作りインストールします。
                </p></li><li class="step"><p>
                  次のコマンドを実行して

                  </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./MAKEDEV pty{1,2,3,4,5,6,7}</code></strong></pre><p>

                  新たなターミナル用の 256 個のデバイスノードを作ります。
                </p></li><li class="step"><p>
                  <code class="filename">/etc/ttys</code> を編集し
                  256 個のターミナルごとの定義を追加します。
                  既存のエントリーの形式にあわせる必要があるでしょう。
                  たとえばこんな感じです。
                </p><pre class="programlisting">ttyqc none network</pre><p>
                  正規表現を使った指定は
                  <code class="literal">tty[pqrsPQRS][0-9a-v]</code>
                  となります。
                </p></li><li class="step"><p>
                  新しいカーネルでシステムを再起動すると完了です。
                </p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81466192"></a><a id="create-snd0"></a><p><strong>7.31.</strong></p></td><td align="left" valign="top"><p>
            <code class="filename">snd0</code>
            デバイスを作成することができません!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="filename">snd</code> というデバイスは存在しません。
            この名前は、FreeBSD
            サウンドドライバによって作成されるさまざまなデバイス、
            <code class="filename">mixer</code> や
            <code class="filename">sequencer</code>、
            <code class="filename">dsp</code>
            などを総称したものです。
          </p><p>これらのデバイスを作成するには、次のようにする必要があります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV snd0</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81472208"></a><a id="reread-rc"></a><p><strong>7.32.</strong></p></td><td align="left" valign="top"><p>再起動せずにもう一度
            <code class="filename">/etc/rc.conf</code>
            を読み込んで
            <code class="filename">/etc/rc</code>
            を開始させるには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            シングルユーザモードに移行して、
            マルチユーザモードに戻ってください。
          </p><p>
            コンソールで次のように実行します。

            </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>shutdown now</code></strong><span class="emphasis"><em>(注: <code class="option">-r</code> や <code class="option">-h</code> は付けません)</em></span>
<code class="prompt">#</code> <strong class="userinput"><code>return</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>exit</code></strong></pre><p>
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81483088"></a><a id="sandbox"></a><p><strong>7.33.</strong></p></td><td align="left" valign="top"><p>砂場 (sandbox) とは何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote">「<span class="quote">砂場 (Sandbox)</span>」</span> とはセキュリティ用語の一つで、
            次の二つの意味があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  一つ目は、「仮想的な『防壁』で囲まれているプロセス」です。
                  その『防壁』は、そのプロセスに侵入した第三者が、
                  さらにシステムの広い範囲に影響を与えることを防ぐように設計されます。
                </p><p>
                  このプロセスの振舞いは、『防壁』の中だけに制限される、と表現できます。
                  つまり、このプロセスにおいて、『防壁』を越えるようなコードの実行は
                  できないという意味です。そのため、コードの実行におけるセキュリティは
                  確かなものであると保証でき、実行の詳細な追跡を行なう必要はなくなります。
                </p><p>
                  その『防壁』とは、たとえばユーザ ID がそれにあたるでしょう。
                  この定義は、security(7) や named(8) のマニュアルページで用いられています。
                </p><p>
                  <code class="literal">ntalk</code>
                  サービス (/etc/inetd.conf
                  参照のこと) を例にとってみます。
                  このサービスはかつて、実行時の ユーザ ID として
                  root
                  を用いていましたが、現在では
                  tty
                  というユーザ ID で動作します。
                  ユーザ
                  tty は、
                  ntalk を経由してシステムの侵入に成功した第三者が
                  そのユーザ ID 以上の権限を得ることを、
                  より一層困難にするために設計された砂場 (sandbox) なのです。
                </p></li><li class="listitem"><p>
                  二つ目は「シミュレートされたマシンの内側で実行されるプロセス」のことで、
                  こちらはより中核的です。
                  普通に考えれば、あるプロセスに侵入することができる第三者は、
                  マシンのより広い範囲にも侵入できると信じるものなのですが、
                  この種のプロセスの場合、それは実際にはシミュレートされたマシンに
                  侵入しただけなので、現実のデータを変更することは何一つできません。
                </p><p>
                  これを実現するための最も広く用いられている方法は、
                  シミュレートされた環境をサブディレクトリに構築し、
                  そのディレクトリに chroot して、そのディレクトリで
                  プロセスを実行すること (つまり、そのプロセスにとって
                  <code class="filename">/</code> は
                  システムの実際のルートディレクトリ
                  <code class="filename">/</code> ではなく、
                  chroot されたサブディレクトリを指す) です。
                </p><p>
                  広く用いられているもう一つの方法があります。
                  それは、既に存在しているファイルシステムを
                  読み込み専用 (read-only) でマウントし、その上に、あるプロセスに対して
                  そのファイルシステムが書き込み可能であるように見せるような、
                  もう一つのファイルシステムの層を用意するものです。すると、
                  そのプロセスはファイルを書き込むことができると認識し、
                  実際に書き込むことができるのもその特定のプロセスだけ
                  - システムにある他のプロセスは書き込めないのに対して -
                  であるという状況を実現することができます。
                </p><p>
                  この種の砂場 (sandbox) は、
                  その非常に透過的な性質を使って、ユーザ (もしくは侵入者) が
                  その事実に気付かないように実現されます。
                </p></li></ul></div><p>
            UNIX は、内部的に二つの砂場 (sandbox) を実装しています。
            一つはプロセスレベルのもの、もう一つはユーザ ID レベルのものです。
          </p><p>
            UNIX プロセスはすべて、他の UNIX プロセスから完全に隔離されています。
            どのプロセスも、他のプロセスのアドレス空間を変更することはできません。
            これは、あるプロセスが他のプロセスのアドレス空間を上書きできるような、
            クラッシュにつながる行為が容易に実現できる Windows とは全く異なるものです。
          </p><p>
            UNIX プロセスは、特定のユーザ ID が所有します。
            もし、実行者のユーザ ID が <code class="systemitem">root</code>
            ユーザのものでなければ、
            ユーザ ID は、他のユーザが所有するプロセスから
            そのプロセスを守る機能を果たすわけです。
            また、そのユーザ ID は、ディスク上にあるデータを
            保護するのにも使われています。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81496656"></a><a id="securelevel"></a><p><strong>7.34.</strong></p></td><td align="left" valign="top"><p>セキュアレベル (securelevel) って何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>セキュアレベルとはカーネルに実装されているセキュリティ機構の一つです。
            簡単に言うと、カーネルはセキュアレベルが正の値の時に、
            ある特定の操作を制限します。この制限は、たとえスーパユーザ
            (<code class="systemitem">root</code> のこと) であっても例外ではありません。
            この文を書いている時点では、
            セキュアレベル機構を使って以下のような操作を制限することができます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">schg</code> (system immutable flag)
                のようなファイルフラグの変更</p></li><li class="listitem"><p><code class="filename">/dev/mem</code> および
                <code class="filename">/dev/kmem</code>
                経由でのカーネルメモリへの書き込み</p></li><li class="listitem"><p>カーネルモジュールのロード</p></li><li class="listitem"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfirewall&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ipfirewall</span>(4)</span></a> ルールの変更</p></li></ul></div><p>稼働中のシステムでセキュアレベルの状態をチェックするには、
            次のコマンドを実行します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>出力には、<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> 変数 (今の場合は
            <code class="varname">kern.securelevel</code>) と数字が現れます。
            数字が現在のセキュアレベルの値です。
            これがもし正の値なら、
            何らかのセキュアレベルによる制限が有効になっています。</p><p>システム稼働中にセキュアレベルを下げることはできません。
            これは、それを可能にするとセキュアレベルの意味がなくなってしまうからです。
            セキュアレベルが正の値でないことを要求する操作
            (たとえば <code class="buildtarget">installworld</code> や日付の変更など)
            を行なう必要がある場合は、<code class="filename">/etc/rc.conf</code>
            にあるセキュアレベルの設定 (<code class="varname">kern_securelevel</code> と
            <code class="varname">kern_securelevel_enable</code> という変数)
            を変更して再起動する必要があります。</p><p>セキュアレベルに関する詳しい情報や、
            各レベルで実現される機能に関しては
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> のマニュアルページを参照してください。</p><div xmlns="" class="warning"><h3 class="admontitle">警告: </h3><p xmlns="http://www.w3.org/1999/xhtml">セキュアレベルは万能というわけではなく、
                弱点も数多く存在します。また、場合によっては、
                セキュリティを低下させてしまうこともあります。</p><p xmlns="http://www.w3.org/1999/xhtml">最も大きな問題の一つに、
                セキュアレベルの機能を有効にするには、
                起動処理でセキュアレベルが設定されるまでに使われるすべてのファイルを
                保護する必要があるということがあります。
                もし攻撃者が、システムがセキュアレベルを設定する前にコードを実行することができるとしたら、
                セキュアレベルによる保護は無意味になってしまいます
                (起動時には低いセキュアレベルでしか実行できない処理を行なう必要があるため、
                セキュアレベルの設定は、起動処理の最後の方で行なわれます)。
                起動処理で使われるすべてのファイルを保護することは技術的に不可能です。
                もしそうできたとしても、システムの保守はまさに悪夢となるでしょう。
                設定ファイル一つ書き換えるのにも、
                シングルユーザモードに切替えなければならなくなるのですから。
              </p><p xmlns="http://www.w3.org/1999/xhtml">以上で説明した内容やその他の点については、
                メーリングリストでも良く話題にのぼります。
                議論のようすを<a class="link" href="http://www.FreeBSD.org/search/" target="_top">このページ</a>から検索してみてください。
                セキュアレベルは、
                いずれより粒度の細かい機構にとって代わるだろうと考えている人々もいますが、
                その点についてはまだ不透明なままです。
              </p><p xmlns="http://www.w3.org/1999/xhtml">どうか注意するようにしてください。</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81517136"></a><a id="user-floppymount"></a><p><strong>7.35.</strong></p></td><td align="left" valign="top"><p>フロッピーや CDROM や他のリムーバブルメディアのマウントを一般ユーザーに許可するには?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            一般ユーザーでもデバイスをマウントできるようにすることができます。
            手順は次のとおりです。
          </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p><code class="systemitem">root</code>
                になって、
                sysctl 変数である
                <code class="varname">vfs.usermount</code> を
                <code class="literal">1</code> に設定します。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w vfs.usermount=1</code></strong></pre></li><li class="step"><p><code class="systemitem">root</code>
                になって、
                リムーバブルメディアに関連するブロックデバイスに適切なパーミッションを設定します。
              </p><p>
                例として、最初のフロッピーデバイスをユーザーがマウントできるようにするには、
                次のようにします。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 666 /dev/fd0</code></strong></pre><p>
                <code class="systemitem">operator</code> グループに所属するユーザが
                CDROM ドライブをマウントできるようにするには
                以下のようにします。
              </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chgrp operator /dev/cd0c</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>chmod 640 /dev/cd0c</code></strong></pre></li><li class="step"><p>
                最後に <code class="literal">vfs.usermount=1</code> という行を
                <code class="filename">/etc/sysctl.conf</code> ファイルに追加し、
                ブート時にセットされるようにしておきます。
              </p></li></ol></div><p>
            これで、すべてのユーザは
            フロッピー <code class="filename">/dev/fd0</code> を
            自身の所有するディレクトリへマウントすることができます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>mkdir ~/my-mount-point</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>mount -t msdos /dev/fd0 ~/my-mount-point</code></strong></pre><p>
            これで、<code class="systemitem">operator</code> グループに所属するユーザは
            CDROM <code class="filename">/dev/cd0c</code> を
            自身の所有するディレクトリへマウントすることができます。
          </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>mkdir ~/my-mount-point</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>mount -t msdos /dev/cd0c ~/my-mount-point</code></strong>
</pre><p>デバイスのアンマウントは簡単です。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>umount ~/my-mount-point</code></strong></pre><p>
            しかし、
            <code class="varname">vfs.usermount</code>
            を有効にすることは、セキュリティ上よいことではありません。
            MSDOS 形式のメディアにアクセスには、Ports コレクションにある
            パッケージ
            <a class="link" href="http://www.freebsd.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name" target="_top">mtools</a>
            を使用した方がよいでしょう。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81545808"></a><a id="new-huge-disk"></a><p><strong>7.36.</strong></p></td><td align="left" valign="top"><p>システムを新しい巨大ディスクへ移すにはどうするのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一番良いのは新しいディスクに OS を再インストールして、
            それからユーザデータを移すことです。特にあなたが -stable を
            複数のリリースを跨いで追い掛けている場合にはこの方法をおすすめします。
            あなたは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot0cfg</span>(8)</span></a> を使うことで booteasy を両方の
            ディスクにインストールでき、新しい配置で満足している間
            デュアルブートができます。これを行ったあとデータを移す
            方法を探すなら次の段落は読み飛ばしてください。</p><p>何もないディスクへインストールしないことに決めたならば
            <code class="filename">/stand/sysinstall</code>、なり <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a>
            と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=disklabel&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">disklabel</span>(8)</span></a> なりを使って新しいディスクに
            パーティションとディスクラベルを作らなければなりません。
            また <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot0cfg</span>(8)</span></a> で booteasy を両方のディスクに
            インストールして、コピーの作業が終わったあとに
            古いシステムからでも新しいディスクからでも起動できるように
            しておく必要があります。この作業の詳細は <a class="link" href="http://www.freebsd.org/tutorials/formatting-media/index.html" target="_top">formatting-media
            tutorial</a> を見てください。</p><p>新しいディスクの立ち上げが終わってデータの移動を
            待つばかりになりました。しかし悲しいかな、無闇やたらと
            コピーすればいいというものではありません。デバイスファイル
            (<code class="filename">/dev</code>) やシンボリックリンクなどは
            失敗の元になります。これらを理解するツール、すなわち
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> 等を使う必要があります。
            データの移転はシングルユーザで行うことをお勧めしますが、
            絶対と言うわけではありません。</p><p>あなたは <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=restore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">restore</span>(8)</span></a> 以外のもので
            root ファイルシステムを移行してはなりません。
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> コマンドでもたぶんうまく行くでしょうが、
            やらないほうがいいでしょう。パーティション一つを
            もう一つのからのパーティションに移すときは
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> と <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=restore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">restore</span>(8)</span></a> 使うべきです。
            パーティションのデータを新しいパーティションに移すのに
            dump を使うやり方は以下の通りです。</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>新しいパーティションに newfs をかける。</p></li><li class="step"><p>それを暫定的なマウントポイントにマウントする。</p></li><li class="step"><p>そのディレクトリに cd。</p></li><li class="step"><p>古いパーティションを dump し、
                その出力をパイプで新しい方へ。</p></li></ol></div><p>たとえば root を
            <code class="filename">/dev/ad1s1a</code> へ、暫定的なマウントポイントを
            <code class="filename">/mnt</code> として移そうとすると以下のようになります。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>newfs /dev/ad1s1a</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount /dev/ad1s1a</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cd /mnt</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>dump 0uaf - / | restore xf -</code></strong></pre><p>もしパーティションの構成を変えようと思っているなら -
            つまり一つだったものを二つにしたり二つだったものをくっつけたり
            しようとしているなら、自前であるディレクトリ以下のすべてを
            新しい場所へ移す必要が出てくるかも知れません。<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dump&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dump</span>(8)</span></a> は
            ファイルシステムに働くのでこの目的には使えません。この場合は
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> を使います。一般に <code class="filename">/old</code> から
            <code class="filename">/new</code> への移動は  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> で
            以下のようにします。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>(cd /old; tar cf - .) | (cd /new; tar xpf -)</code></strong></pre><p><code class="filename">/old</code> に他のファイルシステムが
            マウントされていて、そのデータの移動までは考えてないならば
            最初の <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> に 'l' フラグを追加します。</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>(cd /old; tar clf - .) | (cd /new; tar xpf -).</code></strong></pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tar&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span></a> のかわりに <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cpio&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">cpio</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pax&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pax</span>(1)</span></a>,
            cpdup (ports/sysutils/cpdup) 等を
            使っても構いません。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81584464"></a><a id="release-candidate"></a><p><strong>7.37.</strong></p></td><td align="left" valign="top"><p>
            システムを最新の -STABLE にアップデートしようとしたのですが
            -RC や -BETA になってしまいました! 何が起こったのですか?
          </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
            短い答え: ただの名前です。RC は
            <span class="quote">「<span class="quote">リリース候補 (Release Candidate)</span>」</span> に
            由来するもので、リリースが間近であることを意味します。
            また、FreeBSD における -BETA は通常、
            リリース前のコードフリーズ期間に入っているという意味になります。
          </p><p>
            長い答え: FreeBSD はそのリリースを 2 ヶ所あるうちの
            一方から派生させます。3.0-RELEASE や 4.0-RELEASE の様な
            (0 のマイナー番号を持つ) メジャーリリースは、一般に <a class="link" href="preface.html#current" title="5.">-CURRENT</a> と呼ばれる
            開発版の流れから分岐させられてできます。3.1-RELEASE や
            4.2-RELEASE などのマイナーリリースはアクティブな
            <a class="link" href="preface.html#stable" title="6.">-STABLE</a> ブランチ (枝) の
            スナップショットでした。
            4.3-RELEASE からは、リリース毎にブランチが作成されるように
            なりました。ものすごく保守的な開発速度 (主にセキュリティ
            勧告のみ) を求めている人は、このブランチを追跡すると
            よいでしょう。</p><p>
            リリースを作る時になるとそれを分岐させるブランチは
            特定のプロセスへ突入します。そのプロセスの一つは
            コードフリーズ (コードの凍結) です。コードフリーズが
            始まると、そのブランチの名前がリリースになろうとしていることを
            反映するものに変えられます。たとえば、4.0-STABLE と
            呼ばれていたブランチは名前が 4.1-BETA へと
            変えられ、コードフリーズとリリース前のテストが
            始まったことを示します。
            バグの修正はリリースの一部としてコミットされます。
            ソースコードがリリースの形を取ったなら名前が 4.1-RC へと
            変えられ、それからリリースが作られることを示します。
            ひとたび RC のステージになってしまうと、発見された
            もっとも致命的なバグの修正しかできなくなります。
            ひとたびリリースが (この例では 4.1-RELEASE) 作られれば、
            そのブランチは 4.1-STABLE と改名されます。
          </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81601104"></a><a id="kernel-chflag-failure"></a><p><strong>7.38.</strong></p></td><td align="left" valign="top"><p>新しいカーネルを入れようとしたのですが、
            chflags に失敗します。どうすれば良いのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>簡単な回答:
            多分、セキュアレベルが 0 より大きくなっているのでしょう。
            直接シングルユーザモードで再起動して、
            カーネルをインストールしてください。</p><p>詳しい回答:
            FreeBSD では、セキュアレベルが 0 より大きい場合、
            システムフラグの変更が禁止されます。
            現在のセキュアレベルは、次のコマンドを使って調べることができます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>セキュアレベルを下げる操作は、できないようになっています。
            そのため、カーネルをインストールするには、
            シングルユーザモードで起動するか、<code class="filename">/etc/rc.conf</code>
            のセキュリティ設定を変更して再起動する必要があります。
            セキュアレベルの詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> を、
            rc.conf の詳細は <code class="filename">/etc/defaults/rc.conf</code> および、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> のマニュアルページをご覧ください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81611344"></a><a id="kernel-securelevel-time"></a><p><strong>7.39.</strong></p></td><td align="left" valign="top"><p>システムの時刻を 1 秒以上変更することができないのです!
            どうすれば良いのでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>簡単な回答:
            多分、セキュアレベルが 1 より大きくなっているのでしょう。
            直接シングルユーザモードで再起動して、
            時刻の変更をしてください。</p><p>詳しい回答:
            FreeBSD では、セキュアレベルが 1 より大きい場合、
            1 秒以上の時刻変更が禁止されます。
            現在のセキュアレベルは、次のコマンドを使って調べることができます。
          </p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>セキュアレベルを下げる操作は、できないようになっています。
            そのため、システムの時刻を変更するには、
            シングルユーザモードで起動するか、<code class="filename">/etc/rc.conf</code>
            のセキュリティ設定を変更して再起動する必要ばあります。
            セキュアレベルの詳細は <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> を、
            rc.conf の詳細は <code class="filename">/etc/defaults/rc.conf</code> および、
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> のマニュアルページをご覧ください。</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp81617488"></a><a id="statd-mem-leak"></a><p><strong>7.40.</strong></p></td><td align="left" valign="top"><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rpc.statd</span>(8)</span></a> にメモリリークを見つけました!
            メモリを 256 メガバイトも使っています。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>いいえ。それはメモリリークではありませんし、
            256 メガバイトのメモリを使っている、ということでもありません。
            おそらく (ほとんどの場合)、
            処理に都合が良いように非常にたくさんの量のメモリを
            そのプロセスのアドレス空間にマッピングしているのでしょう。
            技術的な見地から考えても、これは大きな害があることではなく、
            単に <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> や <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> といったツールの表示に影響がある程度です。
          </p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rpc.statd</span>(8)</span></a> は、(<code class="filename">/var</code> にある)
            ステータスファイルを自分のアドレス空間にマッピングします。
            マッピングは、後で大きな空間が必要になった時に再マッピングしないで済むよう、
            非常に大きなサイズを指定して行なわれます。
            これは、ソースコードに含まれる <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mmap&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>
            関数のマッピング長を示す引数に
            <code class="literal">0x10000000</code> が指定されていることからも分かります。
            この数字が IA32 アーキテクチャの持つアドレススペース全体の
            16 分の 1、すなわち、ちょうど 256 メガバイトに相当するのです。</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kernelconfig.html">戻る</a>〓</td><td width="20%" align="center">〓</td><td width="40%" align="right">〓<a accesskey="n" href="x.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第6章 カーネルコンフィグレーション〓</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">〓第8章 X Window System と仮想コンソール</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文書、および他の文書は
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>
    からダウンロードできます。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>FreeBSD に関する質問がある場合には、
    <a href="http://www.FreeBSD.org/ja/docs.html">ドキュメント</a> を読んだ上で
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt; まで (英語で) 連絡してください。<br></br>
    本文書に関する質問については、
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt; まで電子メールを (英語で) 送ってください。</small></p></body></html>