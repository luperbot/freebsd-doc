<?xml version="1.0" encoding="iso-8859-7" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-7" /><title>29.3. Network File System (NFS)</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Εγχειρίδιο του FreeBSD" /><link rel="up" href="network-servers.html" title="Κεφάλαιο 29. Εξυπηρετητές Δικτύου" /><link rel="prev" href="network-inetd.html" title="29.2. The inetd «Super-Server»" /><link rel="next" href="network-nis.html" title="29.4. Network Information System (NIS/YP)" /><link rel="copyright" href="legalnotice.html" title="Νομική Σημείωση" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">29.3. Network File System (NFS)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-inetd.html">Προηγ</a> </td><th width="60%" align="center">Κεφάλαιο 29. Εξυπηρετητές Δικτύου</th><td width="20%" align="right"> <a accesskey="n" href="network-nis.html">Επόμενο</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-nfs"></a>29.3. Network File System (NFS)</h2></div><div><span class="authorgroup">Reorganized and enhanced by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Tom</span> <span class="surname">Rhodes</span></span>. </span></div><div><span class="authorgroup">Written by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Bill</span> <span class="surname">Swingle</span></span>. </span></div></div></div><a id="idp97398352" class="indexterm"></a><p>Among the many different file systems that FreeBSD supports
      is the Network File System, also known as <acronym class="acronym">NFS</acronym>.  <acronym class="acronym">NFS</acronym> allows a system to share directories and
      files with others over a network.  By using <acronym class="acronym">NFS</acronym>, users and programs can
      access files on remote systems almost as if they were local
      files.</p><p>Some of the most notable benefits that
      <acronym class="acronym">NFS</acronym> can provide are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Local workstations use less disk space because commonly
	  used data can be stored on a single machine and still remain
	  accessible to others over the network.</p></li><li class="listitem"><p>There is no need for users to have separate home
	  directories on every network machine.  Home directories
	  could be set up on the <acronym class="acronym">NFS</acronym> server and
	  made available throughout the network.</p></li><li class="listitem"><p>Storage devices such as floppy disks, CDROM drives, and
	  <span class="trademark">Zip</span>(R) drives can be used by other machines on the network.
	  This may reduce the number of removable media drives
	  throughout the network.</p></li></ul></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp97409360"></a>29.3.1. How <acronym class="acronym">NFS</acronym> Works</h3></div></div></div><p><acronym class="acronym">NFS</acronym> consists of at least two main
        parts: a server and one or more clients.  The client remotely
        accesses the data that is stored on the server machine.  In
        order for this to function properly a few processes have to be
        configured and running.</p><p>The server has to be running the following daemons:</p><a id="idp97411408" class="indexterm"></a><a id="idp97412560" class="indexterm"></a><a id="idp97413712" class="indexterm"></a><a id="idp97414608" class="indexterm"></a><a id="idp97415504" class="indexterm"></a><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Daemon</th><th>Description</th></tr></thead><tbody><tr><td><span class="application">nfsd</span></td><td>The <acronym class="acronym">NFS</acronym> daemon which services
	      requests from the <acronym class="acronym">NFS</acronym>
	      clients.</td></tr><tr><td><span class="application">mountd</span></td><td>The <acronym class="acronym">NFS</acronym> mount daemon which carries out
		the requests that <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=nfsd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">nfsd</span>(8)</span></a> passes on to it.</td></tr><tr><td><span class="application">rpcbind</span></td><td> This daemon allows
	      <acronym class="acronym">NFS</acronym> clients to discover which port
	      the <acronym class="acronym">NFS</acronym> server is using.</td></tr></tbody></table></div><p>The client can also run a daemon, known as
        <span class="application">nfsiod</span>.  The
        <span class="application">nfsiod</span> daemon services the requests
        from the <acronym class="acronym">NFS</acronym> server.  This is optional, and
        improves performance, but is not required for normal and
        correct operation.  See the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=nfsiod&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">nfsiod</span>(8)</span></a> manual page for
        more information.
      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-configuring-nfs"></a>29.3.2. Configuring <acronym class="acronym">NFS</acronym></h3></div></div></div><a id="idp97434576" class="indexterm"></a><p><acronym class="acronym">NFS</acronym> configuration is a relatively
        straightforward process.  The processes that need to be
        running can all start at boot time with a few modifications to
        your <code class="filename">/etc/rc.conf</code> file.</p><p>On the <acronym class="acronym">NFS</acronym> server, make sure that the
        following options are configured in the
        <code class="filename">/etc/rc.conf</code> file:</p><pre class="programlisting">rpcbind_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</pre><p><span class="application">mountd</span> runs automatically
        whenever the <acronym class="acronym">NFS</acronym> server is enabled.</p><p>On the client, make sure this option is present in
        <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">nfs_client_enable="YES"</pre><p>The <code class="filename">/etc/exports</code> file specifies which
        file systems <acronym class="acronym">NFS</acronym> should export (sometimes
        referred to as <span class="quote">«<span class="quote">share</span>»</span>).  Each line in
        <code class="filename">/etc/exports</code> specifies a file system to be
        exported and which machines have access to that file system.
        Along with what machines have access to that file system,
        access options may also be specified.  There are many such
        options that can be used in this file but only a few will be
        mentioned here.  You can easily discover other options by
        reading over the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exports&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">exports</span>(5)</span></a> manual page.</p><p>Here are a few example <code class="filename">/etc/exports</code>
	entries:</p><a id="idp97448144" class="indexterm"></a><p>The following examples give an idea of how to export
        file systems, although the settings may be different depending
        on your environment and network configuration.  For instance,
        to export the <code class="filename">/cdrom</code> directory to three
        example machines that have the same domain name as the server
        (hence the lack of a domain name for each) or have entries in
        your <code class="filename">/etc/hosts</code> file.  The
        <code class="option">-ro</code> flag makes the exported file system
        read-only.  With this flag, the remote system will not be able
        to write any changes to the exported file system.</p><pre class="programlisting">/cdrom -ro host1 host2 host3</pre><p>The following line exports <code class="filename">/home</code> to
	three hosts by IP address.  This is a useful setup if you have
	a private network without a <acronym class="acronym">DNS</acronym> server
	configured.  Optionally the <code class="filename">/etc/hosts</code>
	file could be configured for internal hostnames; please review
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a> for more information.  The
	<code class="option">-alldirs</code> flag allows the subdirectories to be
	mount points.  In other words, it will not mount the
	subdirectories but permit the client to mount only the
	directories that are required or needed.</p><pre class="programlisting">/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre><p>The following line exports <code class="filename">/a</code> so that
	two clients from different domains may access the file system.
	The <code class="option">-maproot=root</code> flag allows the
	<code class="systemitem">root</code> user on the remote system to write
	data on the exported file system as <code class="systemitem">root</code>.
	If the <code class="literal">-maproot=root</code> flag is not specified,
	then even if a user has <code class="systemitem">root</code> access on
	the remote system, he will not be able to modify files on
	the exported file system.</p><pre class="programlisting">/a  -maproot=root  host.example.com box.example.org</pre><p>In order for a client to access an exported file system,
	the client must have permission to do so.  Make sure the
	client is listed in your <code class="filename">/etc/exports</code>
	file.</p><p>In <code class="filename">/etc/exports</code>, each line represents
	the export information for one file system to one host.  A
	remote host can only be specified once per file system, and may
	only have one default entry.  For example, assume that
	<code class="filename">/usr</code> is a single file system.  The
	following <code class="filename">/etc/exports</code> would be
	invalid:</p><pre class="programlisting"># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</pre><p>One file system, <code class="filename">/usr</code>, has two lines
	specifying exports to the same host, <code class="systemitem">client</code>.
        The correct format for this situation is:</p><pre class="programlisting">/usr/src /usr/ports  client</pre><p>The properties of one file system exported to a given host
	must all occur on one line.  Lines without a client specified
	are treated as a single host.  This limits how you can export
	file systems, but for most people this is not an issue.</p><p>The following is an example of a valid export list, where
	<code class="filename">/usr</code> and <code class="filename">/exports</code>
	are local file systems:</p><pre class="programlisting"># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre><p>The <span class="application">mountd</span> daemon must be forced to
	recheck the <code class="filename">/etc/exports</code> file whenever it has
	been modified, so the changes can take effect.  This can be
	accomplished either by sending a HUP signal to the running daemon:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP `cat /var/run/mountd.pid`</code></strong></pre><p>or by invoking the <code class="command">mountd</code> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> script
        with the appropriate parameter:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/mountd onereload</code></strong></pre><p>Please refer to <a class="xref" href="configtuning-rcd.html" title="12.7. Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD">Τμήμα 12.7, «Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD»</a> for more
	information about using rc scripts.</p><p>Alternatively, a reboot will make FreeBSD set everything
        up properly.  A reboot is not necessary though.
        Executing the following commands as <code class="systemitem">root</code>
        should start everything up.</p><p>On the <acronym class="acronym">NFS</acronym> server:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rpcbind</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>nfsd -u -t -n 4</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mountd -r</code></strong></pre><p>On the <acronym class="acronym">NFS</acronym> client:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>nfsiod -n 4</code></strong></pre><p>Now everything should be ready to actually mount a remote file
	system.  In these examples the
	server's name will be <code class="systemitem">server</code> and the client's
	name will be <code class="systemitem">client</code>.  If you only want to
	temporarily mount a remote file system or would rather test the
	configuration, just execute a command like this as <code class="systemitem">root</code> on the
        client:</p><a id="idp97505872" class="indexterm"></a><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount server:/home /mnt</code></strong></pre><p>This will mount the <code class="filename">/home</code> directory
	on the server at <code class="filename">/mnt</code> on the client.  If
	everything is set up correctly you should be able to enter
	<code class="filename">/mnt</code> on the client and see all the files
        that are on the server.</p><p>If you want to automatically mount a remote file system
	each time the computer boots, add the file system to the
	<code class="filename">/etc/fstab</code> file.  Here is an example:</p><pre class="programlisting">server:/home	/mnt	nfs	rw	0	0</pre><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fstab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fstab</span>(5)</span></a> manual page lists all the available
        options.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp97512144"></a>29.3.3. Locking</h3></div></div></div><p>Some applications (e.g. <span class="application">mutt</span>)
	require file locking to operate correctly.  In the case of
	<acronym class="acronym">NFS</acronym>, <span class="application">rpc.lockd</span>
	can be used for file locking.  To enable it, add the following
	to the <code class="filename">/etc/rc.conf</code> file on both client
	and server (it is assumed that the <acronym class="acronym">NFS</acronym>
	client and server are configured already):</p><pre class="programlisting">rpc_lockd_enable="YES"
rpc_statd_enable="YES"</pre><p>Start the application by using:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/nfslocking start</code></strong></pre><p>If real locking between the <acronym class="acronym">NFS</acronym> clients
	and <acronym class="acronym">NFS</acronym> server is not required, it is
	possible to let the <acronym class="acronym">NFS</acronym> client do locking
	locally by passing <code class="option">-L</code> to <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_nfs</span>(8)</span></a>.
	Refer to the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_nfs</span>(8)</span></a> manual page for further details.
      </p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp97520464"></a>29.3.4. Practical Uses</h3></div></div></div><p><acronym class="acronym">NFS</acronym> has many practical uses.  Some of
        the more common ones are listed below:</p><a id="idp97521744" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Set several machines to share a CDROM or other media
	    among them.  This is cheaper and often a more convenient
	    method to install software on multiple machines.</p></li><li class="listitem"><p>On large networks, it might be more convenient to
	    configure a central <acronym class="acronym">NFS</acronym> server in which
	    to store all the user home directories.  These home
	    directories can then be exported to the network so that
	    users would always have the same home directory,
	    regardless of which workstation they log in to.</p></li><li class="listitem"><p>Several machines could have a common
            <code class="filename">/usr/ports/distfiles</code> directory.  That
            way, when you need to install a port on several machines,
            you can quickly access the source without downloading it
            on each machine.</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-amd"></a>29.3.5. Automatic Mounts with <span class="application">amd</span></h3></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Wylie</span> <span class="surname">Stilwell</span></span>. </span></div><div><span class="authorgroup">Rewritten by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Chern</span> <span class="surname">Lee</span></span>. </span></div></div></div><a id="idp97539152" class="indexterm"></a><a id="idp97539664" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">amd</span>(8)</span></a> (the automatic mounter daemon)
	automatically mounts a
	remote file system whenever a file or directory within that
	file system is accessed.  Filesystems that are inactive for a
	period of time will also be automatically unmounted by
	<span class="application">amd</span>.  Using
	<span class="application">amd</span> provides a simple alternative
	to permanent mounts, as permanent mounts are usually listed in
        <code class="filename">/etc/fstab</code>.</p><p><span class="application">amd</span> operates by attaching
	itself as an NFS server to the <code class="filename">/host</code> and
	<code class="filename">/net</code> directories.  When a file is accessed
	within one of these directories, <span class="application">amd</span>
	looks up the corresponding remote mount and automatically mounts
	it.  <code class="filename">/net</code> is used to mount an exported
	file system from an IP address, while <code class="filename">/host</code>
	is used to mount an export from a remote hostname.</p><p>An access to a file within
	<code class="filename">/host/foobar/usr</code> would tell
	<span class="application">amd</span> to attempt to mount the
	<code class="filename">/usr</code> export on the host
	<code class="systemitem">foobar</code>.</p><div class="example"><a id="idp97546960"></a><div class="example-title">Παράδειγμα 29.2. Mounting an Export with <span class="application">amd</span></div><div class="example-contents"><p>You can view the available mounts of a remote host with
	  the <code class="command">showmount</code> command.  For example, to
	  view the mounts of a host named <code class="systemitem">foobar</code>, you
	  can use:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>showmount -e foobar</code></strong>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
<code class="prompt">%</code> <strong class="userinput"><code>cd /host/foobar/usr</code></strong></pre></div></div><br class="example-break" /><p>As seen in the example, the <code class="command">showmount</code> shows
	<code class="filename">/usr</code> as an export.  When changing directories to
	<code class="filename">/host/foobar/usr</code>, <span class="application">amd</span>
	attempts to resolve the hostname <code class="systemitem">foobar</code> and
	automatically mount the desired export.</p><p><span class="application">amd</span> can be started by the
	startup scripts by placing the following lines in
	<code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">amd_enable="YES"</pre><p>Additionally, custom flags can be passed to
      <span class="application">amd</span> from the
      <code class="varname">amd_flags</code> option.  By default,
      <code class="varname">amd_flags</code> is set to:</p><pre class="programlisting">amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</pre><p>The <code class="filename">/etc/amd.map</code> file defines the
	default options that exports are mounted with.  The
	<code class="filename">/etc/amd.conf</code> file defines some of the more
	advanced features of <span class="application">amd</span>.</p><p>Consult the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">amd</span>(8)</span></a> and <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">amd.conf</span>(5)</span></a> manual pages for more
	information.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-nfs-integration"></a>29.3.6. Problems Integrating with Other Systems</h3></div><div><span class="authorgroup">Contributed by <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">John</span> <span class="surname">Lind</span></span>. </span></div></div></div><p>Certain Ethernet adapters for ISA PC systems have limitations
	which can lead to serious network problems, particularly with NFS.
	This difficulty is not specific to FreeBSD, but FreeBSD systems
	are affected by it.</p><p>The problem nearly always occurs when (FreeBSD) PC systems are
	networked with high-performance workstations, such as those made
	by Silicon Graphics, Inc., and Sun Microsystems, Inc.  The NFS
	mount will work fine, and some operations may succeed, but
	suddenly the server will seem to become unresponsive to the
	client, even though requests to and from other systems continue to
	be processed.  This happens to the client system, whether the
	client is the FreeBSD system or the workstation.  On many systems,
	there is no way to shut down the client gracefully once this
	problem has manifested itself.  The only solution is often to
	reset the client, because the NFS situation cannot be
	resolved.</p><p>Though the <span class="quote">«<span class="quote">correct</span>»</span> solution is to get a
	higher performance and capacity Ethernet adapter for the
	FreeBSD system, there is a simple workaround that will allow
	satisfactory operation.  If the FreeBSD system is the
	<span class="emphasis"><em>server</em></span>, include the option
	<code class="option">-w=1024</code> on the mount from the client.  If the
	FreeBSD system is the <span class="emphasis"><em>client</em></span>, then mount
	the NFS file system with the option <code class="option">-r=1024</code>.
	These options may be specified using the fourth field of the
	<code class="filename">fstab</code> entry on the client for automatic
	mounts, or by using the <code class="option">-o</code> parameter of the
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a> command for manual mounts.</p><p>It should be noted that there is a different problem,
	sometimes mistaken for this one, when the NFS servers and
	clients are on different networks.  If that is the case, make
	<span class="emphasis"><em>certain</em></span> that your routers are routing the
	necessary <acronym class="acronym">UDP</acronym> information, or you will not get anywhere, no
	matter what else you are doing.</p><p>In the following examples, <code class="systemitem">fastws</code> is the host
	(interface) name of a high-performance workstation, and
	<code class="systemitem">freebox</code> is the host (interface) name of a FreeBSD
	system with a lower-performance Ethernet adapter.  Also,
	<code class="filename">/sharedfs</code> will be the exported NFS
	file system (see <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exports&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">exports</span>(5)</span></a>), and
	<code class="filename">/project</code> will be the mount point on the
	client for the exported file system.  In all cases, note that
	additional options, such as <code class="option">hard</code> or
	<code class="option">soft</code> and <code class="option">bg</code> may be desirable in
	your application.</p><p>Examples for the FreeBSD system (<code class="systemitem">freebox</code>)
	as the client in <code class="filename">/etc/fstab</code> on
	<code class="systemitem">freebox</code>:</p><pre class="programlisting">fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre><p>As a manual mount command on <code class="systemitem">freebox</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t nfs -o -r=1024 fastws:/sharedfs /project</code></strong></pre><p>Examples for the FreeBSD system as the server in
	<code class="filename">/etc/fstab</code> on
	<code class="systemitem">fastws</code>:</p><pre class="programlisting">freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre><p>As a manual mount command on <code class="systemitem">fastws</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t nfs -o -w=1024 freebox:/sharedfs /project</code></strong></pre><p>Nearly any 16-bit Ethernet adapter will allow operation
	without the above restrictions on the read or write size.</p><p>For anyone who cares, here is what happens when the
	failure occurs, which also explains why it is unrecoverable.
	NFS typically works with a <span class="quote">«<span class="quote">block</span>»</span> size of
	8 K (though it may do fragments of smaller sizes).  Since
	the maximum Ethernet packet is around 1500 bytes, the NFS
	<span class="quote">«<span class="quote">block</span>»</span> gets split into multiple Ethernet
	packets, even though it is still a single unit to the
	upper-level code, and must be received, assembled, and
	<span class="emphasis"><em>acknowledged</em></span> as a unit.  The
	high-performance workstations can pump out the packets which
	comprise the NFS unit one right after the other, just as close
	together as the standard allows.  On the smaller, lower
	capacity cards, the later packets overrun the earlier packets
	of the same unit before they can be transferred to the host
	and the unit as a whole cannot be reconstructed or
	acknowledged.  As a result, the workstation will time out and
	try again, but it will try again with the entire 8 K
	unit, and the process will be repeated, ad infinitum.</p><p>By keeping the unit size below the Ethernet packet size
	limitation, we ensure that any complete Ethernet packet
	received can be acknowledged individually, avoiding the
	deadlock situation.</p><p>Overruns may still occur when a high-performance
	workstations is slamming data out to a PC system, but with the
	better cards, such overruns are not guaranteed on NFS
	<span class="quote">«<span class="quote">units</span>»</span>.  When an overrun occurs, the units
	affected will be retransmitted, and there will be a fair
	chance that they will be received, assembled, and
	acknowledged.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-inetd.html">Προηγ</a> </td><td width="20%" align="center"><a accesskey="u" href="network-servers.html">Πάνω</a></td><td width="40%" align="right"> <a accesskey="n" href="network-nis.html">Επόμενο</a></td></tr><tr><td width="40%" align="left" valign="top">29.2. The <span class="application">inetd</span> <span class="quote">«<span class="quote">Super-Server</span>»</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Αρχή</a></td><td width="40%" align="right" valign="top"> 29.4. Network Information System (NIS/YP)</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Αυτό το κείμενο, και άλλα κείμενα, μπορεί να βρεθεί στο
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Για ερωτήσεις σχετικά με το FreeBSD, διαβάστε την
    <a href="http://www.FreeBSD.org/docs.html">τεκμηρίωση</a> πριν να επικοινωνήσετε με την
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Για ερωτήσεις σχετικά με αυτή την τεκμηρίωση, στείλτε e-mail στην
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>