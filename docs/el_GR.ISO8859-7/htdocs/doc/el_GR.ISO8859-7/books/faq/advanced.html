<?xml version="1.0" encoding="iso-8859-7" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-7" /><title>Κεφάλαιο 18. Προχωρημένα Θέματα</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Συχνές Ερωτήσεις για το FreeBSD 6.X και 7.X" /><link rel="up" href="index.html" title="Συχνές Ερωτήσεις για το FreeBSD 6.X και 7.X" /><link rel="prev" href="funnies.html" title="Κεφάλαιο 17. Χιούμορ και FreeBSD" /><link rel="next" href="acknowledgments.html" title="Κεφάλαιο 19. Ευχαριστίες" /><link rel="copyright" href="legalnotice.html" title="Νομική Σημείωση" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Κεφάλαιο 18. Προχωρημένα Θέματα</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="funnies.html">Προηγ</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="acknowledgments.html">Επόμενο</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="advanced"></a>Κεφάλαιο 18. Προχωρημένα Θέματα</h1></div></div></div><div class="qandaset"><a id="idp79016656"></a><dl><dt>18.1. <a href="advanced.html#idp79016912">How can I learn more about FreeBSD's internals?</a></dt><dt>18.2. <a href="advanced.html#idp79021136">How can I contribute to FreeBSD?</a></dt><dt>18.3. <a href="advanced.html#idp79023696">What are SNAPs and RELEASEs?</a></dt><dt>18.4. <a href="advanced.html#idp79052112">How do I make my own custom release?</a></dt><dt>18.5. <a href="advanced.html#idp79054672">Why does make world clobber my existing
            installed binaries?</a></dt><dt>18.6. <a href="advanced.html#idp79059920">Why isn't cvsup.FreeBSD.org a round robin DNS entry to
	  share the load amongst the various CVSup servers?</a></dt><dt>18.7. <a href="advanced.html#idp79062480">Why does my system say «(bus speed
            defaulted)» when it boots?</a></dt><dt>18.8. <a href="advanced.html#idp79065296">Can I follow -CURRENT with limited Internet access?</a></dt><dt>18.9. <a href="advanced.html#idp79072464">How did you split the distribution into 240k files?</a></dt><dt>18.10. <a href="advanced.html#idp79076816">I have written a kernel extension, who do I send it
            to?</a></dt><dt>18.11. <a href="advanced.html#idp79079888">How are Plug N Play ISA cards detected and
            initialized?</a></dt><dt>18.12. <a href="advanced.html#idp79097424">Can you assign a major number for a device driver I have
            written?</a></dt><dt>18.13. <a href="advanced.html#idp79101904">What about alternative layout policies for
            directories?</a></dt><dt>18.14. <a href="advanced.html#idp79108560">How can I make the most of the data I see when my kernel
            panics?</a></dt><dt>18.15. <a href="advanced.html#idp79163600">Why has dlsym() stopped working for ELF executables?</a></dt><dt>18.16. <a href="advanced.html#idp79168592">How can I increase or reduce the kernel address space?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp79016912"></a><a id="learn-advanced"></a><p><strong>18.1.</strong></p></td><td align="left" valign="top"><p>How can I learn more about FreeBSD's internals?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>At this time, there is only one book on FreeBSD-specific OS
            internals, namely <span class="quote">«<span class="quote">The Design and Implementation of the
            FreeBSD Operating System</span>»</span> by Marshall Kirk McKusick and
            George V. Neville-Neil, ISBN 0-201-70245-2, which
            focuses on version 5.X of FreeBSD.</p><p>Additionally, much general <span class="trademark">UNIX</span>(R) knowledge is directly
            applicable to FreeBSD.</p><p>For a list of relevant books, please check the Handbook's <a class="link" href="../../../../doc/el_GR.ISO8859-7/books/handbook/bibliography-osinternals.html" target="_top">Operating
            System Internals Bibliography</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79021136"></a><a id="how-to-contribute"></a><p><strong>18.2.</strong></p></td><td align="left" valign="top"><p>How can I contribute to FreeBSD?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Please see the article on <a class="link" href="../../../../doc/el_GR.ISO8859-7/articles/contributing/article.html" target="_top">Contributing
	    to FreeBSD</a> for specific advice on how to do this.
	    Assistance is more than welcome!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79023696"></a><a id="define-snap-release"></a><p><strong>18.3.</strong></p></td><td align="left" valign="top"><p>What are SNAPs and RELEASEs?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>There are currently three active/semi-active branches
            in the FreeBSD <a class="link" href="http://www.FreeBSD.org/cgi/cvsweb.cgi" target="_top"> CVS
            Repository</a>. (Earlier branches are only changed
            very rarely, which is why there are only three active
            branches of development):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">RELENG_5</code>     AKA
                  <span class="emphasis"><em>5-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">RELENG_6</code>      AKA
                  <span class="emphasis"><em>6-STABLE</em></span></p></li><li class="listitem"><p><code class="literal">HEAD</code>         AKA
                  <span class="emphasis"><em>-CURRENT</em></span>  AKA
                  <span class="emphasis"><em>7.X-CURRENT</em></span></p></li></ul></div><p><code class="literal">HEAD</code> is not an actual branch tag,
            like the other two; it is simply a symbolic constant for
            <span class="quote">«<span class="quote"><span class="emphasis"><em>the current, non-branched development
            stream</em></span></span>»</span> which we simply refer to as
            <span class="quote">«<span class="quote">-CURRENT</span>»</span>.</p><p>Right now, <span class="quote">«<span class="quote">-CURRENT</span>»</span> is the 7.X development
            stream; the <code class="literal">5-STABLE</code> branch,
            <span class="symbol">RELENG_5</span>, forked off from
            <span class="quote">«<span class="quote">-CURRENT</span>»</span> in October 2004, and
            the <code class="literal">6-STABLE</code> branch,
            <span class="symbol">RELENG_6</span>, forked off from
            <span class="quote">«<span class="quote">-CURRENT</span>»</span> in November 2005.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79052112"></a><a id="custrel"></a><p><strong>18.4.</strong></p></td><td align="left" valign="top"><p>How do I make my own custom release?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Please see the <a class="link" href="../../../../doc/el_GR.ISO8859-7/articles/releng/article.html" target="_top">
            Release Engineering</a> article.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79054672"></a><a id="makeworld-clobbers"></a><p><strong>18.5.</strong></p></td><td align="left" valign="top"><p>Why does <code class="command">make world</code> clobber my existing
            installed binaries?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Yes, this is the general idea; as its name might suggest,
            <code class="command">make world</code> rebuilds every system binary from
            scratch, so you can be certain of having a clean and consistent
            environment at the end (which is why it takes so long).</p><p>If the environment variable <code class="literal">DESTDIR</code>
            is defined while running <code class="command">make world</code> or
            <code class="command">make install</code>, the newly-created binaries
            will be deposited in a directory tree identical to the
            installed one, rooted at <code class="literal">${DESTDIR}</code>.
            Some random combination of shared libraries modifications and
            program rebuilds can cause this to fail in <code class="command">make
            world</code> however.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79059920"></a><a id="cvsup-round-robin"></a><p><strong>18.6.</strong></p></td><td align="left" valign="top"><p>Why isn't cvsup.FreeBSD.org a round robin DNS entry to
	  share the load amongst the various CVSup servers?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>While CVSup mirrors update from the master CVSup
	    server hourly, this update might happen at any time during
	    the hour.  This means that some servers have newer code
	    than others, even though all servers have code that is
	    less than an hour old.  If <code class="systemitem">cvsup.FreeBSD.org</code> was a round
	    robin DNS entry that simply redirected users to a random
	    CVSup server, running CVSup twice in a row could download
	    code older than the code already on the system.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79062480"></a><a id="bus-speed-defaulted"></a><p><strong>18.7.</strong></p></td><td align="left" valign="top"><p>Why does my system say <span class="quote">«<span class="quote">(bus speed
            defaulted)</span>»</span> when it boots?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>The Adaptec 1542 SCSI host adapters allow the user to
            configure their bus access speed in software. Previous versions
            of the 1542 driver tried to determine the fastest usable speed
            and set the adapter to that. We found that this breaks some
            users' systems, so you now have to define the
            <span class="symbol">TUNE_1542</span> kernel configuration option in order
            to have this take place. Using it on those systems where it
            works may make your disks run faster, but on those systems
            where it does not, your data could be corrupted.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79065296"></a><a id="ctm"></a><p><strong>18.8.</strong></p></td><td align="left" valign="top"><p>Can I follow -CURRENT with limited Internet access?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Yes, you can do this <span class="emphasis"><em>without</em></span>
            downloading the whole source tree by using the <a class="link" href="../../../../doc/el_GR.ISO8859-7/books/handbook/synching.html#CTM" target="_top">CTM facility</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79072464"></a><a id="split-240k"></a><p><strong>18.9.</strong></p></td><td align="left" valign="top"><p>How did you split the distribution into 240k files?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Newer BSD based systems have a <code class="option">-b</code>
            option to <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=split&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">split</span>(1)</span></a> that allows them to split files on arbitrary
            byte boundaries.</p><p>Here is an example from
            <code class="filename">/usr/src/Makefile</code>.</p><pre class="programlisting">bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79076816"></a><a id="submitting-kernel-extensions"></a><p><strong>18.10.</strong></p></td><td align="left" valign="top"><p>I have written a kernel extension, who do I send it
            to?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Please take a look at the article on <a class="link" href="../../../../doc/el_GR.ISO8859-7/articles/contributing/article.html" target="_top">Contributing
            to FreeBSD</a> to learn how to submit code.</p><p>And thanks for the thought!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79079888"></a><a id="pnp-initialize"></a><p><strong>18.11.</strong></p></td><td align="left" valign="top"><p>How are Plug N Play ISA cards detected and
            initialized?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>By: Frank Durda IV
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:uhclem@nemesis.lonestar.org">uhclem@nemesis.lonestar.org</a>&gt;</code></p><p>In a nutshell, there a few I/O ports that all of the
            PnP boards respond to when the host asks if anyone is out
            there. So when the PnP probe routine starts, it asks if there
            are any PnP boards present, and all the PnP boards respond with
            their model # to a I/O read of the same port, so the probe
            routine gets a wired-OR <span class="quote">«<span class="quote">yes</span>»</span> to that question. At
            least one bit will be on in that reply. Then the probe code is
            able to cause boards with board model IDs (assigned by
            Microsoft/Intel) lower than X to go <span class="quote">«<span class="quote">off-line</span>»</span>. It
            then looks to see if any boards are still responding to the
            query. If the answer was <code class="literal">0</code>, then there are
            no boards with IDs above X. Now probe asks if there are any
            boards below <code class="literal">X</code>. If so, probe knows there are
            boards with a model numbers below X. Probe then asks for boards
            greater than X-(limit/4) to go off-line. If repeats the query.
            By repeating this semi-binary search of IDs-in-range enough
            times, the probing code will eventually identify all PnP boards
            present in a given machine with a number of iterations that is
            much lower than what 2^64 would take.</p><p>The IDs are two 32-bit fields (hence 2^64) + 8 bit
            checksum. The first 32 bits are a vendor identifier. They never
            come out and say it, but it appears to be assumed that
            different types of boards from the same vendor could have
            different 32-bit vendor ids. The idea of needing 32 bits just
            for unique manufacturers is a bit excessive.</p><p>The lower 32 bits are a serial #, Ethernet address,
            something that makes this one board unique. The vendor must
            never produce a second board that has the same lower 32 bits
            unless the upper 32 bits are also different. So you can have
            multiple boards of the same type in the machine and the full 64
            bits will still be unique.</p><p>The 32 bit groups can never be all zero.  This allows the
            wired-OR to show non-zero bits during the initial binary
            search.</p><p>Once the system has identified all the board IDs present,
            it will reactivate each board, one at a time (via the same I/O
            ports), and find out what resources the given board needs, what
            interrupt choices are available, etc. A scan is made over all
            the boards to collect this information.</p><p>This info is then combined with info from any ECU files
            on the hard disk or wired into the MLB BIOS. The ECU and BIOS
            PnP support for hardware on the MLB is usually synthetic, and
            the peripherals do not really do genuine PnP. However by
            examining the BIOS info plus the ECU info, the probe routines
            can cause the devices that are PnP to avoid those devices the
            probe code cannot relocate.</p><p>Then the PnP devices are visited once more and given
            their I/O, DMA, IRQ and Memory-map address assignments. The
            devices will then appear at those locations and remain there
            until the next reboot, although there is nothing that says you
            cannot move them around whenever you want.</p><p>There is a lot of oversimplification above, but you
            should get the general idea.</p><p>Microsoft took over some of the primary printer status
            ports to do PnP, on the logic that no boards decoded those
            addresses for the opposing I/O cycles. I found a genuine IBM
            printer board that did decode writes of the status port during
            the early PnP proposal review period, but MS said
            <span class="quote">«<span class="quote">tough</span>»</span>. So they do a write to the printer status
            port for setting addresses, plus that use that address +
            <code class="literal">0x800</code>, and a third I/O port for reading that
            can be located anywhere between <code class="literal">0x200</code> and
            <code class="literal">0x3ff</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79097424"></a><a id="major-numbers"></a><p><strong>18.12.</strong></p></td><td align="left" valign="top"><p>Can you assign a major number for a device driver I have
            written?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD-CURRENT after February 2003 has a facility for
	    dynamically and automatically allocating major numbers for
	    device drivers at runtime.  This mechanism is highly
	    preferred to the older procedure of statically allocating
	    device numbers.  Some comments on this subject can be
	    found in <code class="filename">src/sys/conf/majors</code>.</p><p>If you are forced for some reason to use a static
	    major number, the procedure for obtaining one depends on
	    whether or not you plan on making the driver publicly
	    available. If you do, then please send us a copy of the
	    driver source code, plus the appropriate modifications to
	    <code class="filename">files.i386</code>, a sample configuration
	    file entry, and the appropriate <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">MAKEDEV</span>(8)</span></a> code to
	    create any special files your device uses. If you do not,
	    or are unable to because of licensing restrictions, then
	    character major number 32 and block major number 8 have
	    been reserved specifically for this purpose; please use
	    them. In any case, we would appreciate hearing about your
	    driver on the <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers" target="_top">ηλεκτρονική λίστα τεχνικών συζητήσεων του FreeBSD</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79101904"></a><a id="alternate-directory-layout"></a><p><strong>18.13.</strong></p></td><td align="left" valign="top"><p>What about alternative layout policies for
            directories?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>In answer to the question of alternative layout policies
            for directories, the scheme that is currently in use is
            unchanged from what I wrote in 1983. I wrote that policy for
            the original fast filesystem, and never revisited it. It works
            well at keeping cylinder groups from filling up. As several of
            you have noted, it works poorly for find. Most filesystems are
            created from archives that were created by a depth first search
            (aka ftw). These directories end up being striped across the
            cylinder groups thus creating a worst possible scenario for
            future depth first searches. If one knew the total number of
            directories to be created, the solution would be to create
            (total / fs_ncg) per cylinder group before moving on.
            Obviously, one would have to create some heuristic to guess at
            this number. Even using a small fixed number like say 10 would
            make an order of magnitude improvement. To differentiate
            restores from normal operation (when the current algorithm is
            probably more sensible), you could use the clustering of up to
            10 if they were all done within a ten second window. Anyway, my
            conclusion is that this is an area ripe for
            experimentation.</p><p>Kirk McKusick, September 1998</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79108560"></a><a id="kernel-panic-troubleshooting"></a><p><strong>18.14.</strong></p></td><td align="left" valign="top"><p>How can I make the most of the data I see when my kernel
            panics?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="emphasis"><em>[This section was extracted from a mail
            written by Bill Paul on the freebsd-current
            <a class="link" href="support.html#mailing" title="2.3.">mailing list</a> by Dag-Erling C. Smorgrav, who
            fixed a few typos and added the bracketed comments]
            </em></span></p><pre class="programlisting">From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: Ben Rosengart
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org</pre><p><span class="emphasis"><em>Ben Rosengart posted the following
            panic message]</em></span></p><pre class="programlisting">&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</pre><p>[When] you see a message like this, it is not enough to just
            reproduce it and send it in. The instruction pointer value that
            I highlighted up there is important; unfortunately, it is also
            configuration dependent. In other words, the value varies
            depending on the exact kernel image that you are using. If
            you are using a GENERIC kernel image from one of the snapshots,
            then it is possible for somebody else to track down the
            offending function, but if you are running a custom kernel then
            only <span class="emphasis"><em>you</em></span> can tell us where the fault
            occurred.</p><p>What you should do is this:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Write down the instruction pointer value. Note that
                  the <code class="literal">0x8:</code> part at the beginning is not
                  significant in this case: it is the
                  <code class="literal">0xf0xxxxxx</code> part that we want.</p></li><li class="step"><p>When the system reboots, do the following:

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</code></strong></pre><p>

                  where <code class="literal">f0xxxxxx</code> is the instruction
                  pointer value. The odds are you will not get an exact
                  match since the symbols in the kernel symbol table are
                  for the entry points of functions and the instruction
                  pointer address will be somewhere inside a function, not
                  at the start. If you do not get an exact match, omit the
                  last digit from the instruction pointer value and try
                  again, i.e.:

                  </p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</code></strong></pre><p>

                   If that does not yield any results, chop off another
                   digit. Repeat until you get some sort of output. The
                   result will be a possible list of functions which caused
                   the panic. This is a less than exact mechanism for
                   tracking down the point of failure, but it is better than
                   nothing.</p></li></ol></div><p>I see people constantly show panic messages like this
            but rarely do I see someone take the time to match up the
            instruction pointer with a function in the kernel symbol
            table.</p><p>The best way to track down the cause of a panic is by
            capturing a crash dump, then using <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> to generate
            a stack trace on the crash dump.</p><p>In any case, the method I normally use is this:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Set up a kernel config file, optionally adding
                  <code class="literal">options DDB</code> if you think you need
                  the kernel debugger for something. (I use this mainly
                  for setting breakpoints if I suspect an infinite loop
                  condition of some kind.)</p></li><li class="step"><p>Use <code class="command">config -g
                  KERNELCONFIG</code> to set
                  up the build directory.</p></li><li class="step"><p><code class="command">cd /sys/compile/KERNELCONFIG; make</code></p></li><li class="step"><p>Wait for kernel to finish compiling.</p></li><li class="step"><p><code class="command">make install</code></p></li><li class="step"><p>reboot</p></li></ol></div><p>The <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> process will have built two kernels.
            <code class="filename">kernel</code> and
            <code class="filename">kernel.debug</code>.
            <code class="filename">kernel</code> was installed as
            <code class="filename">/kernel</code>, while
            <code class="filename">kernel.debug</code> can be used as the
            source of debugging symbols for <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>.</p><p>To make sure you capture a crash dump, you need edit
            <code class="filename">/etc/rc.conf</code> and set
            <code class="literal">dumpdev</code> to point to your swap
            partition. This will cause the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> scripts to use
            the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> command to enable crash dumps. You can
            also run <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> manually.  After a panic, the
            crash dump can be recovered using <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>; if
            <code class="literal">dumpdev</code> is set in
            <code class="filename">/etc/rc.conf</code>, the <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a> scripts
            will run <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> automatically and put the crash
            dump in <code class="filename">/var/crash</code>.</p><div xmlns="" class="note"><h3 class="admontitle">Σημείωση: </h3><p xmlns="http://www.w3.org/1999/xhtml">FreeBSD crash dumps are usually the same size as the
                physical RAM size of your machine. That is, if you have
                64MB of RAM, you will get a 64MB crash dump. Therefore you
                must make sure there is enough space in
                <code class="filename">/var/crash</code> to hold the dump.
                Alternatively, you run <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
                manually and have it recover the crash dump to another
                directory where you have more room. It is possible to limit
                the size of the crash dump by using <code class="literal">options
                MAXMEM=(foo)</code> to set the amount of memory the
                kernel will use to something a little more sensible. For
                example, if you have 128MB of RAM, you can limit the
                kernel's memory usage to 16MB so that your crash dump size
                will be 16MB instead of 128MB.</p></div><p>Once you have recovered the crash dump, you can get a
            stack trace with <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> as follows:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>where</code></strong></pre><p>Note that there may be several screens worth of
            information; ideally you should use
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> to capture all of them. Using the
            unstripped kernel image with all the debug symbols should show
            the exact line of kernel source code where the panic occurred.
            Usually you have to read the stack trace from the bottom up in
            order to trace the exact sequence of events that lead to the
            crash. You can also use <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> to print out
            the contents of various variables or structures in order to
            examine the system state at the time of the crash.</p><p>Now, if you are really insane and have a second computer,
            you can also configure <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> to do remote
            debugging such that you can use <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> on
            one system to debug the kernel on another system, including
            setting breakpoints, single-stepping through the kernel code,
            just like you can do with a normal user-mode program. I have not
            played with this yet as I do not often have the chance to set up
            two machines side by side for debugging purposes.</p><p><span class="emphasis"><em>[Bill adds: "I forgot to mention one thing: if
            you have DDB enabled and the kernel drops into the debugger,
            you can force a panic (and a crash dump) just by typing 'panic'
            at the ddb prompt. It may stop in the debugger again during the
            panic phase. If it does, type 'continue' and it will finish the
            crash dump." -ed]</em></span></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79163600"></a><a id="dlsym-failure"></a><p><strong>18.15.</strong></p></td><td align="left" valign="top"><p>Why has dlsym() stopped working for ELF executables?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>The ELF toolchain does not, by default, make the symbols
            defined in an executable visible to the dynamic linker.
            Consequently <code class="function">dlsym()</code> searches on handles
            obtained from calls to <code class="function">dlopen(NULL,
            flags)</code> will fail to find such symbols.</p><p>If you want to search, using
            <code class="function">dlsym()</code>, for symbols present in the
            main executable of a process, you need to link the
            executable using the <code class="option">-export-dynamic</code>
            option to the ELF linker (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp79168592"></a><a id="change-kernel-address-space"></a><p><strong>18.16.</strong></p></td><td align="left" valign="top"><p>How can I increase or reduce the kernel address space?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>By default, the kernel address space is 256 MB on
            FreeBSD 3.X and 1 GB on FreeBSD 4.X. If you run a
            network-intensive server (e.g. a large FTP or HTTP server),
            you might find that 256 MB is not enough.</p><p>So how do you increase the address space? There are two
            aspects to this. First, you need to tell the kernel to reserve
            a larger portion of the address space for itself. Second, since
            the kernel is loaded at the top of the address space, you need
            to lower the load address so it does not bump its head against
            the ceiling.</p><p>The first goal is achieved by increasing the value of
            <code class="literal">NKPDE</code> in
            <code class="filename">src/sys/i386/include/pmap.h</code>. Here is what
            it looks like for a 1 GB address space:</p><pre class="programlisting">#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</pre><p>To find the correct value of <code class="literal">NKPDE</code>,
            divide the desired address space size (in megabytes) by four,
            then subtract one for UP and two for SMP.</p><p>To achieve the second goal, you need to compute the
            correct load address: simply subtract the address space size
            (in bytes) from 0x100100000; the result is 0xc0100000 for a 1
            GB address space. Set <span class="symbol">LOAD_ADDRESS</span> in
            <code class="filename">src/sys/i386/conf/Makefile.i386</code> to that
            value; then set the location counter in the beginning of the
            section listing in
            <code class="filename">src/sys/i386/conf/kernel.script</code> to the
            same value, as follows:</p><pre class="programlisting">OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</pre><p>Then reconfig and rebuild your kernel. You will
            probably have problems with <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> and the
            like; <code class="command">make world</code> should take care of it
            (or a manual rebuild of <code class="filename">libkvm</code>,
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> and <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> after copying the patched
            <code class="filename">pmap.h</code> to
            <code class="filename">/usr/include/vm/</code>.</p><p>NOTE: the size of the kernel address space must be a
            multiple of four megabytes.</p><p>[David Greenman adds: <span class="emphasis"><em>I think the kernel address space
            needs to be a power of two, but I am not certain about that. The
          old(er) boot code used to monkey with the high order address bits
          and I think expected at least 256MB
          granularity.]</em></span></p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="funnies.html">Προηγ</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="acknowledgments.html">Επόμενο</a></td></tr><tr><td width="40%" align="left" valign="top">Κεφάλαιο 17. Χιούμορ και FreeBSD </td><td width="20%" align="center"><a accesskey="h" href="index.html">Αρχή</a></td><td width="40%" align="right" valign="top"> Κεφάλαιο 19. Ευχαριστίες</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Αυτό το κείμενο, και άλλα κείμενα, μπορεί να βρεθεί στο
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Για ερωτήσεις σχετικά με το FreeBSD, διαβάστε την
    <a href="http://www.FreeBSD.org/docs.html">τεκμηρίωση</a> πριν να επικοινωνήσετε με την
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Για ερωτήσεις σχετικά με αυτή την τεκμηρίωση, στείλτε e-mail στην
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>