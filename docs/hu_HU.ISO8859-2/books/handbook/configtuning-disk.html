<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>11.12. A lemezek finomhangolása</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD kézikönyv" /><link rel="up" href="config-tuning.html" title="11. fejezet - Beállítás és finomhangolás" /><link rel="prev" href="configtuning-sysctl.html" title="11.11. Finomhangolás a sysctl használatával" /><link rel="next" href="configtuning-kernel-limits.html" title="11.13. A rendszermag korlátainak finomhangolása" /><link rel="copyright" href="legalnotice.html" title="Jogi közlemény" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.12. A lemezek finomhangolása</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Vissza</a> </td><th width="60%" align="center">11. fejezet - Beállítás és
    finomhangolás</th><td width="20%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">Elõre</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="configtuning-disk"></a>11.12. A lemezek finomhangolása</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85203280"></a>11.12.1. Sysctl változók</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85203920"></a>11.12.1.1. <code class="varname">vfs.vmiodirenable</code></h4></div></div></div><a id="idp85204688" class="indexterm"></a><p>A <code class="varname">vfs.vmiodirenable</code> sysctl
	  változó értéke lehet 0 (ki) vagy 1
	  (be, és ez az alapértelmezés is).  Ez a
	  változó vezérli a könyvtárak
	  gyorsítótárazását a
	  rendszerben.  A könyvtárak többsége
	  kis méretû, így az
	  állományrendszerbõl csak egyetlen
	  (általában 1 KB méretû)
	  darabkát használnak és még
	  ennél is kevesebbet (általában
	  512 byte-ot) a pufferben.  A változó
	  kikapcsolt (avagy 0) értéke mellett a puffer
	  csak rögzített számú
	  könyvtárat táraz be még abban az
	  esetben is, amikor temérdek mennyiségû
	  memória áll a rendelkezésére.  Ha
	  viszont (az 1 értékkel)
	  engedélyezzük, akkor a rendszer a
	  könyvtárak tárazására
	  felhasználja a virtuális
	  memóriában pufferelt lapokat is, amivel
	  lényegében az összes elérhetõ
	  memóriát a könyvtárak
	  tárazására fordítja.  Ilyenkor
	  azonban az egyes könyvtárak
	  tárazására használt legkisebb
	  memóriaterület a fizikai lapmérettel
	  egyezik meg (ami általában 4 KB) és
	  nem 512 byte.  Abban az esetben javasoljuk ennek a
	  beállításnak a használatát,
	  ha olyan szolgáltatásokkal dolgozunk, amelyek
	  nagy számú állománnyal dolgoznak
	  egyszerre.  Ilyen szolgáltatások többek
	  közt a webes gyorsítótárak, nagyobb
	  levelezõrendszerek és hírrendszerek.  Az
	  opció engedélyezése alapvetõen nem
	  veti vissza a rendszer teljesítményét
	  még akkor sem, ha ezzel memóriát
	  pazarlunk el, de ezt igazából érdemes
	  kikísérletezni.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85206352"></a>11.12.1.2. <code class="varname">vfs.write_behind</code></h4></div></div></div><a id="idp85207120" class="indexterm"></a><p>A <code class="varname">vfs.write_behind</code> sysctl
	  változó alapértelmezett
	  értéke <code class="literal">1</code> (bekapcsolt).  Ez
	  arra utasítja az állományrendszert, hogy
	  csak akkor küldje ki az adatokat az eszközre, ha
	  belõlük teljes fürtök gyûltek
	  össze.  Ez jellemzõ módon nagyobb
	  szekvenciális állományok
	  írása esetén kedvezõ.  Arra
	  szolgál, hogy segítségével el
	  lehessen kerülni az I/O túlságosan gyakori
	  módosítások okozta
	  terhelését.  Bizonyos
	  körülmények közt ez azonban
	  lassíthatja a futó programok
	  mûködését, ezért ilyenkor
	  érdemes megfontolni a
	  kikapcsolását.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85209040"></a>11.12.1.3. <code class="varname">vfs.hirunningspace</code></h4></div></div></div><a id="idp85209808" class="indexterm"></a><p>A <code class="varname">vfs.hirunningspace</code> sysctl
	  változó értéke azt adja meg, hogy
	  tetszõleges számú
	  példánynál rendszerszinten mekkora
	  mértékû írási mûvelet
	  irányítható át a
	  lemezvezérlõk soraiba.  Az
	  alapértelmezés többnyire elegendõ, de
	  olyan gépeken, ahol sok lemez dolgozik egyszerre, ez az
	  érték négy vagy öt
	  <span class="emphasis"><em>megabyte-ra</em></span> is felszökhet!
	  Hozzátennénk, hogy ha ezt az
	  értéket túlságosan nagyra
	  állítjuk (és így
	  túllépjük a puffer írási
	  küszöbértékét), akkor ezzel
	  hihetetlenül gyenge fürtözési
	  teljesítményt nyerünk.  Semmiképp se
	  állítsuk túlzottan nagy
	  értékre!  A nagyobb írási
	  értékek a velük párhuzamos
	  olvasások számára
	  késleltetést is jelentenek.</p><p>Találhatunk még más egyéb
	  pufferelési és
	  gyorsítótárazási sysctl
	  változókat, azonban ezek
	  megváltoztatását egyáltalán
	  nem javasoljuk, mivel a virtuális memória
	  alrendszer kiválóan tudja
	  önállóan állítani ezeket a
	  paramétereit.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85212112"></a>11.12.1.4. <code class="varname">vm.swap_idle_enabled</code></h4></div></div></div><a id="idp85212880" class="indexterm"></a><p>A <code class="varname">vm.swap_idle_enabled</code> sysctl
	  változó módosítása olyan
	  nagyobb többfelhasználós rendszerekben
	  bizonyulhat hasznosnak, ahol sok felhasználó
	  lép be és lép ki a rendszerbe és
	  sok az üresjáratban futó program.  Az ilyen
	  jellegû rendszerek hajlamosak nagy mennyiségû
	  folyamatos terhelést mérni a tartalékolt
	  szabad memóriára.  A
	  beállítás
	  engedélyezésével, valamint a
	  <code class="varname">vm.swap_idle_threshold1</code> és a
	  <code class="varname">vm.swap_idle_threshold2</code>
	  változókon keresztül a kilapozás
	  <span class="quote">"<span class="quote">reakcióidejének</span>"</span> alkalmas
	  behangolásával a megszokottnál gyorsabban
	  lenyomhatjuk az üresjáratban dolgozó
	  programokhoz tartozó memórialapok
	  prioritását, amivel a kilapozásokat
	  vezérlõ démon kezére
	  játszunk.  Azonban tényleg csak akkor
	  engedélyezzük ezt a lehetõséget, ha
	  valóban szükségünk van rá,
	  mivel így a memóriát jóval
	  elõbb lapozzuk ki és ezzel több
	  lapozóállományt és
	  lemezteljesítményt emésztünk fel.
	  Kisebb rendszerekben jól behatárolható a
	  hatása, azonban a nagyobb rendszerekben, ahol
	  már eleve visszafogott mértékû
	  lapozás történik, ez a
	  beállítás lehetõvé teszi a
	  virtuális memóriát kezelõ alrendszer
	  számára, hogy könnyedén ki-
	  és be rakosgasson komplett futó programokat a
	  memóriába.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85223888"></a>11.12.1.5. <code class="varname">hw.ata.wc</code></h4></div></div></div><a id="idp85224656" class="indexterm"></a><p>A FreeBSD 4.3 egyszer már kacérkodott az
	  IDE-lemezek írási pufferének
	  kikapcsolásával.  Ez ugyan csökkentette az
	  IDE-lemezek írási
	  sávszélességét, azonban bizonyos
	  merevlemezgyártók
	  gondatlanságából eredõ súlyos
	  adatvesztések miatt szükséges volt a
	  használata.  A gond ezzel kapcsolatban ott van, hogy
	  egyes IDE-meghajtók hazudnak az írások
	  teljesítésérõl.  A lemezek
	  írási
	  gyorsítótárazásának
	  bekapcsolásával az IDE-meghajtók nem csak
	  az írások sorrendjét rendezik át,
	  hanem nagyobb terhelés esetén egyes blokkokat
	  jóval késõbb is rögzítenek.
	  Ezért a rendszer esetleges összeomlása vagy
	  egy áramkimaradás súlyos károkat
	  okozhat az állományrendszerben.  A FreeBSD
	  úgy döntött, hogy a
	  megbízhatóságot választja.  Sajnos
	  ez olyan nagyságú
	  teljesítményvesztést okozott, hogy a
	  következõ kiadásban már
	  kénytelenek voltunk alapértelmezés
	  szerint is visszakapcsolni ezt a lehetõséget.  A
	  <code class="varname">hw.ata.wc</code> nevû sysctl
	  változó vizsgálatával
	  ellenõrizhetjük a rendszerünkön
	  érvényes alapértelmezett
	  beállítást.  Amennyiben az IDE
	  írások
	  gyorsítótárazása nem
	  engedélyezett, akkor ezt a változó
	  értékének 1-re
	  állításával
	  állíthatjuk vissza.  Ezt a rendszer
	  indításakor a rendszerbetöltõben
	  tehetjük meg.  A rendszermag indítása
	  után ennek már nincs hatása.</p><p>A részleteket a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ata&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ata</span>(4)</span></a> man oldalon tudhatjuk
	  meg.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85227344"></a>11.12.1.6. <code class="literal">SCSI_DELAY</code>
	  (<code class="varname">kern.cam.scsi_delay</code>)</h4></div></div></div><a id="idp85228624" class="indexterm"></a><a id="idp85229264" class="indexterm"></a><p>A rendszermag <code class="literal">SCSI_DELAY</code> nevû
	  beállítása a rendszer
	  indulásának idejét hivatott
	  mérsékelni.  Az alapértelmezett
	  értéke viszonylag magas, innen származik
	  a rendszer indítása során keletkezõ
	  <code class="literal">15</code> másodperces
	  csúszás.  Általában az is
	  megfelelõ, ha ezt visszavesszük az
	  <code class="literal">5</code> értékre (fõleg a
	  modernebb meghajtók számára).  A FreeBSD
	  újabb (5.0 vagy késõbbi)
	  változataiban ez az érték már a
	  <code class="varname">kern.cam.scsi_delay</code> sysctl
	  változó értékével is
	  megadható a rendszer indításakor.
	  Azonban ügyeljünk rá, hogy mind a
	  finomhangoláshoz használt változó,
	  mind pedig rendszermag beállítása
	  <span class="emphasis"><em>ezredmásodpercben</em></span> és
	  <span class="emphasis"><em>nem</em></span>
	  <span class="emphasis"><em>másodpercben</em></span> értelmezi ezt
	  az értéket.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="soft-updates"></a>11.12.2. Soft Updates</h3></div></div></div><a id="idp85234768" class="indexterm"></a><a id="idp85235280" class="indexterm"></a><p>A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a> nevû program használható
	az állományrendszerek
	finomhangolására.  Nagyon sok opciót
	találhatunk benne, de itt most csak a <span class="quote">"<span class="quote">Soft
	Updates</span>"</span> ki- és bekapcsolásával
	foglalkozunk, amit a következõ módon
	tehetünk meg:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>tunefs -n enable /allomanyrendszer</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>tunefs -n disable /allomanyrendszer</code></strong></pre><p>Amíg egy állományrendszer
	csatlakoztatott állapotban van, addig nem
	módosítható a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a> paranccsal.  A
	Soft Updates bekapcsolására ezért az a
	legalkalmasabb idõpont, amikor
	egyfelhasználós módban vagyunk és
	még egyetlen partíciót sem
	csatlakoztattunk.</p><p>A Soft Updates beállítás
	engedélyezése a memóriában pufferelt
	gyorsítótáron keresztül jelentõs
	mértékben fokozza a metaadatok
	teljesítményét, elsõsorban az
	állományok létrehozását
	és törlését.  A Soft Updates
	használatát ezért minden
	állományrendszer esetén ajánljuk.  A
	Soft Updates alkalmazásának két rossz
	oldalára kell tekintettel lennünk.
	Elõször is a Soft Updates a rendszer
	összeomlása esetén ugyan garantálja az
	állományrendszer konzisztenciáját,
	de könnyen elképzelhetõ, hogy több
	másodperccel (vagy akár egy egész perccel!)
	hátrébb jár a fizikai lemez
	frissítésében.  Másodszor a Soft
	Updates késlelteti az állományrendszer
	blokkjainak felszabadítását.  Ha van egy
	olyan állományrendszerünk (mint
	például a rendszer
	indításához használt
	gyökér partíció), ami már
	majdnem betelt, akkor egy nagyobb frissítés,
	például a <code class="command">make installworld</code>
	parancs kiadása, során az
	állományrendszer egyszerûen kifogy a
	helybõl és így a frissítés
	meghiúsul.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp85241040"></a>11.12.2.1. Bõvebben a Soft Updates
	  mûködésérõl</h4></div></div></div><a id="idp85241680" class="indexterm"></a><p>Két hagyományos
	  megközelítés létezik az
	  állományrendszerek metaadatainak
	  visszaírására.  (A metaadatok
	  módosításakor olyan nem adatot
	  tartalmazó blokkok változnak meg, mint
	  például az állományokra
	  vonatkozó információk vagy a
	  könyvtárak.)</p><p>Eredetileg alapértelmezés szerint a
	  metaadatok változásait szinkron módon
	  írták ki.  Amikor egy könyvtár
	  megváltozott, a rendszer egészen addig
	  várt, amíg ez a változás a lemezre
	  nem íródott.  Ugyanekkor az
	  állományok adatait tartalmazó pufferek
	  (az állományok tartalma) átkerültek
	  a pufferelt gyorsítótárba, hogy majd
	  késõbb, aszinkron módon kerüljenek
	  kiírásra.  Ennek az
	  implementációnak a biztonságos
	  mûködés volt az elõnye, mivel így
	  a metaadatok még akkor is konzisztens állapotban
	  maradtak, amikor valamilyen hiba következett be.
	  Tehát egy állomány vagy teljesen
	  létrejött vagy egyáltalán nem.  Ha
	  az állományhoz tartozó blokkok már
	  nem tudtak kijutni a
	  gyorsítótárból az
	  összeomlás ideje elõtt, akkor az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a>
	  felismerte ezt a helyzetet és az
	  állományrendszer ilyen jellegû
	  hibáját úgy orvosolta, hogy az adott
	  állomány méretét nullára
	  állította.  Ezenkívül még az
	  implementációs részletek is
	  tiszták és egyszerûek maradtak.  Ennek
	  viszont hátránya, hogy a metaadatok
	  kezelése lassú.  Ha például
	  kiadunk egy <code class="command">rm -r</code> parancsot, akkor az a
	  könyvtárban levõ állományokat
	  szekvenciálisan dolgozza fel, de minden egyes
	  változtatást (az állományok
	  törlését) csak szinkron módon
	  rögzíti a lemezre.  Ezek a
	  frissítések érintik magát a
	  könyvtárat, az állományokkal
	  kapcsolatos információkat tároló
	  táblázatot (az ún.  inode
	  táblát) és minden
	  valószínûség szerint az
	  állományok által lefoglalt blokkokat is
	  közvetve.  Hasonló megfontolások
	  élnek a nagyobb könyvtárszerkezetek
	  kibontása esetén is (<code class="command">tar
	  -x</code>).</p><p>A második lehetõség a metaadatok
	  aszinkron frissítése.  Ez az
	  alapértelmezés a Linux ext2fs és BSD-k
	  <code class="command">mount -o async</code> opcióval
	  csatlakoztatott UFS állományrendszerei
	  esetén.  Ilyenkor minden metaadattal kapcsolatos
	  aktualizálás egyszerûen bekerült a
	  pufferelt gyorsítótárba, tehát az
	  állományok adatai és ezek a
	  típusú frissítések keverednek.
	  Ennek a megvalósításnak az az
	  elõnye, hogy nem kell megvárni, amíg a
	  metaadatok is kiíródnak a lemezre, ezért
	  a metaadatok óriási mennyiségû
	  változásával járó
	  mûveletek sokkal gyorsabban hajtódnak
	  végre, mint a szinkron esetben.  Sõt, maga az
	  implementáció is tiszta és egyszerû
	  marad, ezért a kódban megjelenõ
	  hibák beszivárgásának
	  kockázata alacsony.  A módszer
	  hátránya, hogy egyáltalán
	  semmilyen garanciát nem kapunk az
	  állományrendszer
	  konzisztenciájára.  Ha tehát egy rengeteg
	  metaadat megváltozásával
	  együttjáró mûvelet közben
	  történik valamilyen probléma
	  (áramkimaradás, vagy valaki egyszerûen
	  megnyomja a reset gombot), akkor az
	  állományrendszer elõre
	  kiszámíthatatlan állapotba kerül.  A
	  rendszer újbóli indításakor
	  ezért nincs lehetõségünk
	  megvizsgálni az állományrendszer
	  állapotát.  Elképzelhetõ, hogy az
	  állományokhoz tartozó adatok már
	  kikerültek a lemezre, miközben a rá
	  vonatkozó inode- vagy könyvtári
	  bejegyzések még nem.  Így
	  lényegében lehetetlen olyan
	  <code class="command">fsck</code> implementációt
	  készíteni, ami képes lenne
	  eltüntetni ezt a káoszt (hiszen az ehhez
	  szükséges adatok nem állnak
	  rendelkezésre).  Ha az állományrendszer
	  helyrehozhatatlanul károsodott, akkor csak a
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">newfs</span>(8)</span></a> és a biztonsági mentés
	  visszaállítása segíthet
	  rajta.</p><p>Ezt általában úgy
	  küszöbölik ki, hogy az egészhez
	  hozzáteszik még a
	  <span class="emphasis"><em>módosított területek
	  feljegyzését</em></span>, amit gyakran csak
	  <span class="emphasis"><em>naplózásnak</em></span> (journaling)
	  neveznek, habár ezt az elnevezést nem mindenhol
	  ilyen értelemben használják, ezért
	  a tranzakciók naplózásának
	  más formáira is utalhat.  A metaadatok
	  frissítése ebben az esetben is csak szinkron
	  módon történik, de csak a lemez egy kisebb
	  területére.  Késõbb ez a
	  megfelelõ helyére kerül.  Mivel a lemez
	  naplózásra fordított része egy
	  viszonylag kis méretû, folytonos terület, a
	  lemez fejének még a megterhelõbb
	  mûveletek esetén sem kell sokat mozognia,
	  ezért valójában ez a megoldás
	  gyorsabb, mint a mezei szinkron frissítések.  Az
	  implementáció bonyolultsága
	  továbbra is jól behatárolható, a
	  velejáró hibalehetõségek
	  kockázata alacsony.  Hátránya, hogy
	  minden metaadat kétszer íródik ki
	  (egyszer a naplózási területre,
	  aztán a megfelelõ helyre), ezért a
	  hétköznapi használat során
	  <span class="quote">"<span class="quote">visszaesés</span>"</span> tapasztalható a
	  teljesítményben.  Másrészrõl
	  azonban egy összeomlás esetén a
	  naplózási terület
	  segítségével minden függõben
	  levõ metaadattal kapcsolatos mûvelet könnyen
	  visszafordítható vagy lezárható a
	  rendszer következõ indításakor,
	  így ezzel egy gyors
	  helyreállítást nyerünk.</p><p>Kirk McKusick, a Berkeley FFS fejlesztõje ezt a
	  problémát a Soft Updates
	  segítségével hidalta át: a
	  metaadatokkal kapcsolatos minden függõben levõ
	  frissítést a memóriában tart, majd
	  ezeket rendezett sorrendben írja ki a lemezre (<span class="quote">"<span class="quote">a
	  metaadatok rendezett frissítése</span>"</span>).  Ennek
	  következményeképpen a metaadatok komolyabb
	  frissítése során a késõbb
	  érkezõ módosításoknak
	  lehetõségük van <span class="quote">"<span class="quote">elkapni</span>"</span> a
	  memóriában levõ korábbi
	  változataikat, ha azok még nem kerültek ki
	  a lemezre.  Így az összes, például
	  könyvtárakon végzett, mûvelet a
	  lemezre írás elõtt általában
	  elõször a memóriában
	  játszódik le (az adatblokkok a
	  pozíciójuknak megfelelõen kerülnek
	  rendezésre, ezért a rájuk
	  vonatkozó metaadatok elõtt nem jutnak ki a
	  lemezre).  Ha eközben a rendszer összeomlik, akkor
	  így implicit módon a <span class="quote">"<span class="quote">napló
	  visszalapozását</span>"</span> eredményezi:
	  minden olyan mûvelet, ami már nem tudott kijutni a
	  lemezre, meg nem történtnek számít.
	  Ezen a módon az állományrendszernek egy
	  30 és 60 másodperc közti korábbi
	  állapota marad fenn.  Az algoritmus garantálja,
	  hogy az összes használt erõforrás a
	  nekik megfelelõ bittérképekben helyesen
	  jelölõdik, a blokkokban és az inode-okban.
	  Az összeomlás után az
	  erõforrások kiosztásával
	  kapcsolatban csak egyetlen hiba léphet fel: amikor
	  olyan erõforrások jelölõdnek
	  <span class="quote">"<span class="quote">használtnak</span>"</span>, amelyek
	  igazából <span class="quote">"<span class="quote">szabadok</span>"</span>.  Az
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> azonban képes felismerni ezeket a
	  helyzeteket és felszabadítani a nem
	  használt erõforrásokat.  A <code class="command">mount
	  -f</code> parancs kiadásával minden
	  további következmény nélkül
	  figyelmen kívül hagyhatjuk az
	  állományrendszer félkész
	  állapotát és csatlakoztathatjuk az
	  állományrendszereket.  A használatban
	  már nem levõ erõforrások
	  felszabadításához az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a>
	  parancsot késõbb kell futtatni.  Ez az
	  alapötlet húzódik meg a
	  <span class="emphasis"><em>háttérben végzett
	  lemezellenõrzés</em></span> mögött.  A
	  rendszer indításakor az
	  állományrendszernek csupán egy
	  <span class="emphasis"><em>pillanatképét</em></span>
	  rögzítjük, és az
	  <code class="command">fsck</code> tényleges
	  lefuttatását késõbbre toljuk.  Mivel
	  mindegyik állományrendszer
	  csatlakoztatható <span class="quote">"<span class="quote">félkész</span>"</span>
	  állapotban, ezért a rendszer képes
	  elindulni többfelhasználós módban.
	  Eközben a háttérben az
	  <code class="command">fsck</code> beütemezhetõ minden olyan
	  állományrendszer számára, ahol
	  arra szükség van, hogy szabadítsa fel az
	  esetlegesen már nem használt
	  erõforrásokat.  (Így a Soft Updates
	  opciót nem alkalmazó
	  állományrendszerek esetén továbbra
	  is szükség van az elõtérben
	  elvégzett <code class="command">fsck</code> parancsra.)</p><p>A módszer elõnye, hogy így a
	  metaadatokkal kapcsolatos mûveletek közel olyan
	  gyorsak, mint az aszinkron módon végzett
	  frissítések (tehát gyorsabb, mintha
	  <span class="emphasis"><em>naplóznánk</em></span>, ami ugye minden
	  metaadatot kétszer ír ki).  A
	  hátránya a bonyolultabb kód (ami miatt
	  növekszik az olyan hibák lehetõsége,
	  amelyek érzékenyen
	  befolyásolhatják a felhasználói
	  adatok elvesztését) és a nagyobb
	  memóriaigény.  Ezenkívül még
	  van néhány olyan egyéni jellemzõje,
	  amelyet meg kell szokni.  A rendszer összeomlása
	  után az állományrendszer valamivel
	  <span class="quote">"<span class="quote">régebbi</span>"</span> lesz.  Amikor pedig megszokott
	  szinkron megközelítés szerint az
	  <code class="command">fsck</code> lefutása után nulla
	  méretû állományok
	  jönnének létre, ezek az
	  állományok a Soft Updates esetén
	  egyáltalán meg sem jelennek, mivel sem a
	  rájuk vonatkozó metaadatok, sem pedig a
	  tartalmuk nem került ki a lemezre.  Egy
	  <code class="command">rm</code> lefuttatása után a
	  lemezterület addig nem kerül
	  felszabadításra, amíg a
	  frissítések teljesen rá nem kerülnek
	  a lemezre.  Ez nagyobb mennyiségû adat
	  telepítésekor gondokat okozhat egy olyan
	  állományrendszeren, ahol nincs elegendõ
	  hely az állományok kétszeri
	  tárolására.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Vissza</a> </td><td width="20%" align="center"><a accesskey="u" href="config-tuning.html">Fel</a></td><td width="40%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">Elõre</a></td></tr><tr><td width="40%" align="left" valign="top">11.11. Finomhangolás a sysctl
      használatával </td><td width="20%" align="center"><a accesskey="h" href="index.html">Fõoldal</a></td><td width="40%" align="right" valign="top"> 11.13. A rendszermag korlátainak
      finomhangolása</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ha kérdése van a FreeBSD-vel kapcsolatban, a
    következõ címre írhat (angolul):
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Ha ezzel a dokumentummal kapcsolatban van kérdése, kérjük erre a címre írjon:
    &lt;<a href="mailto:gabor@FreeBSD.org">gabor@FreeBSD.org</a>&gt;.</small></p></body></html>