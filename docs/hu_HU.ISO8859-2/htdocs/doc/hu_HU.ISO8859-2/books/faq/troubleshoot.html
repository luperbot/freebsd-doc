<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>5. fejezet - Hibaelhárítás</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="up" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="prev" href="compatibility-other.html" title="4.8. Egyéb eszközök" /><link rel="next" href="commercial.html" title="6. fejezet - Kereskedelmi alkalmazások" /><link rel="copyright" href="legalnotice.html" title="Jogi közlemény" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. fejezet - Hibaelhárítás</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="compatibility-other.html">Vissza</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="commercial.html">Elõre</a></td></tr></table><hr /></div><div xml:lang="hu" class="chapter" lang="hu"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="troubleshoot"></a>5. fejezet - Hibaelhárítás</h1></div></div></div><div class="qandaset"><a id="idp76296528"></a><dl><dt>5.1. <a href="troubleshoot.html#idp76296784">Miért állapítja meg rosszul a FreeBSD
	    a memória mennyiségét i386TM
	    hardveren?</a></dt><dt>5.2. <a href="troubleshoot.html#idp76339152">Mit tegyünk, ha meghibásodott szektorokat
	    találunk a merevlemezünkön?</a></dt><dt>5.3. <a href="troubleshoot.html#idp76344528">A FreeBSD miért nem találja meg a
	    HP Netserver SCSI-vezérlõjét?</a></dt><dt>5.4. <a href="troubleshoot.html#idp76356816">Állandóan ed1:
	    timeout és ahhoz hasonló
	    üzenetek jelennek meg.  Mi lehet velük
	    kezdeni?</a></dt><dt>5.5. <a href="troubleshoot.html#idp76361296">Miért állnak le a 3Com(R) 3C509
	    kártyák minden különösebb ok
	    nélkül?</a></dt><dt>5.6. <a href="troubleshoot.html#idp76364368">A párhuzamos nyomtató nevetségesen
	    lassú.  Mi lehet ezzel kezdeni?</a></dt><dt>5.7. <a href="troubleshoot.html#idp76371664">A programok miért állnak le
	    idõnként Signal 11
	    hibákkal?</a></dt><dt>5.8. <a href="troubleshoot.html#idp76393424">A rendszer összeomlik vagy egy Fatal
	    trap 12: page fault in kernel mode vagy pedig
	    valamilyen panic: hibaüzenettel
	    és egy halom számot ír ki.  Mit
	    tegyünk?</a></dt><dt>5.9. <a href="troubleshoot.html#idp76396752">A rendszer indulása közben miért
	    sötétül a képernyõ és megy
	    el rajta a kép?</a></dt><dt>5.10. <a href="troubleshoot.html#idp76416592">A FreeBSD miért csak 64 MB
	    memóriát használ, amikor 128 MB van
	    a gépben?</a></dt><dt>5.11. <a href="troubleshoot.html#idp76420816">A számítógépben több
	    mint 1 GB memória van, de mégis
	    kmem_map too small üzenetek
	    jelennek meg.  Mi a gond?</a></dt><dt>5.12. <a href="troubleshoot.html#idp76429136">A számítógépben nincs
	    1 GB memória, a FreeBSD mégis
	    kmem_map too small hibával
	    leáll!</a></dt><dt>5.13. <a href="troubleshoot.html#idp76432080">Miért jelenik meg a kernel: proc:
	    table is full hibaüzenet?</a></dt><dt>5.14. <a href="troubleshoot.html#idp76456144">Az új rendszermag indításakor
	    miért keletkezik CMAP busy
	    hibaüzenet?</a></dt><dt>5.15. <a href="troubleshoot.html#idp76464592">Mit jelent az ahc0: brkadrint, Illegal Host
	    Access at seqaddr 0x0 üzenet?</a></dt><dt>5.16. <a href="troubleshoot.html#idp76467920">Amikor elindul a rendszer, egy ahc0: illegal
	    cable configuration hibaüzenet jelenik meg.
	    A kábelek bekötésével semmilyen
	    gond nincs.  Mégis akkor mi a baj?</a></dt><dt>5.17. <a href="troubleshoot.html#idp76476112">Miért küld a
	    sendmail mail loops back
	    to myself hibaüzenetet?</a></dt><dt>5.18. <a href="troubleshoot.html#idp76479440">A távoli gépeken miért viselkednek
	    olyan furcsán a teljes képernyõs
	    alkalmazások?</a></dt><dt>5.19. <a href="troubleshoot.html#idp76495696">A Plug and Play kártyákat miért nem
	    találja meg (vagy unknown
	    típusúként látja) a
	    FreeBSD?</a></dt><dt>5.20. <a href="troubleshoot.html#idp76525648">Miért keletkezik nlist
	    failed hiba például a
	    top vagy systat
	    parancsok futtatásakor?</a></dt><dt>5.21. <a href="troubleshoot.html#idp76537680">Miért tart olyan sokáig
	    ssh vagy telnet
	    használatával csatlakozni a
	    számítógéphez?</a></dt><dt>5.22. <a href="troubleshoot.html#idp76554448">Mire utal a stray IRQ
	    (kóbor megszakítási kérés)
	    üzenet?</a></dt><dt>5.23. <a href="troubleshoot.html#idp76562000">Miért jelenik meg folyamatosan a file:
	    table is full üzenet a
	    rendszernaplóban?</a></dt><dt>5.24. <a href="troubleshoot.html#idp76565456">Miért árasztják el
	    calcru: negative runtime vagy
	    calcru: runtime went backwards
	    üzenetek a konzolt?</a></dt><dt>5.25. <a href="troubleshoot.html#idp76575824">Miért jár rosszul az óra a
	    számítógépen?</a></dt><dt>5.26. <a href="troubleshoot.html#idp76593744">A rendszer laptopon miért nem tudja rendesen
	    megtalálni a PC-kártyákat?</a></dt><dt>5.27. <a href="troubleshoot.html#idp76597712">Miért ad a FreeBSD rendszertöltõje
	    Read error hibát és
	    áll meg a BIOS képernyõn?</a></dt><dt>5.28. <a href="troubleshoot.html#idp76613200">Egy másik operációs rendszer
	    letörölte a boot managert.  Hogyan lehet
	    visszaállítani?</a></dt><dt>5.29. <a href="troubleshoot.html#idp76626000">Mit jelent a swap_pager: indefinite wait
	    buffer: hibaüzenet?</a></dt><dt>5.30. <a href="troubleshoot.html#idp76629200">Mik azok a UDMA ICRC hibák
	    és hogyan lehet ellenük tenni valamit?</a></dt><dt>5.31. <a href="troubleshoot.html#idp76635216">Mi az a lock order
	    reversal?</a></dt><dt>5.32. <a href="troubleshoot.html#idp76638160">Mit jelent a Called ...  with the following
	    non-sleepable locks held üzenet?</a></dt><dt>5.33. <a href="troubleshoot.html#idp76642640">A
	    buildworld/installworld
	    miért áll le touch: not
	    found hibával?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp76296784"></a><a id="pae"></a><p><strong>5.1.</strong></p></td><td align="left" valign="top"><p>Miért állapítja meg rosszul a FreeBSD
	    a memória mennyiségét <span class="trademark">i386</span>TM
	    hardveren?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A válasz nagy
	    valószínûséggel a fizikai
	    és virtuális memóriacímek
	    közti különbségben rejlik.</p><p>A legtöbb PC-s hardvereszköz megegyezés
	    szerint a 3,5 GB és 4 GB közti
	    memóriaterületet speciális célokra
	    tartja fenn (általában a PCI
	    számára).  Ezen a címterületen
	    keresztül éri a PCI eszközöket.  Ennek
	    egyik következménye, hogy a fizikai
	    memória ezen a részen nem érhetõ
	    el.</p><p>Hogy pontosan mi történik az itt
	    elhelyezkedõ memóriával, teljesen a
	    hardvertõl függ.  Sajnálatos módon
	    bizonyos eszközök semmilyen megoldást nem
	    nyújtanak a problémára, és
	    így lényegében az utolsó
	    500 MB-nyi memória elveszik.</p><p>Szerencsére a legtöbb eszköz azonban
	    képes ezt a területet egy felsõbb
	    címre leképezni, így ki tudjuk
	    használni.  Ilyenkor azonban tapasztalhatunk
	    némi félreértést, amikor
	    megnézzük a rendszerindítás
	    közben megjelenõ üzeneteket.</p><p>A FreeBSD 32 bites változata esetén ez a
	    memóriaterület elveszik, mivel a címe a
	    4 GB-os határ felé kerül, amelyet a
	    32 bites módban futó rendszermag
	    már nem képes elérni.  Ezen egy PAE
	    támogatással rendelkezõ rendszermag
	    használatával segíthetünk.  A
	    GYIK-on belül <a class="link" href="install.html#memory-limits" title="3.23.">ebben a bejegyzésben</a>
	    olvashatunk bõvebben a
	    memóriakorlátokról, valamint <a class="link" href="compatibility-memory.html#memory-upper-limitation" title="4.2.1.">ebben a részben</a>
	    láthatjuk a különbözõ
	    platformokra vonatkozó
	    memóriakorlátozásokat.</p><p>A FreeBSD 64 bites változata vagy a PAE
	    használata esetén azonban a FreeBSD rendesen
	    felismeri és leképezi a fennmaradó
	    memóriaterületeket, így azok
	    használhatóvá válnak.  A
	    rendszerindítás során azonban az
	    elõbb említett leképezés miatt
	    látszólag úgy fog tûnni, mintha a
	    FreeBSD több memóriát észlelne, mint
	    amennyivel valójában rendelkezünk.  Ez
	    teljesen normálisnak tekinthetõ és a
	    ténylegesen elérhetõ memória
	    mennyisége a folyamat végén be fog
	    állítódni.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76339152"></a><a id="awre"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>Mit tegyünk, ha meghibásodott szektorokat
	    találunk a merevlemezünkön?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A SCSI-meghajtók esetében a
	    meghajtó általában képes
	    önmagától átképezni az
	    ilyen szektorokat.  A legtöbb meghajtóban ez a
	    lehetõség viszont alapból nem
	    engedélyezett.</p><p>A hibás szektorok
	    átképezéséhez az eszköz
	    elsõ lapmódját kell átírnunk,
	    amelyet (<code class="systemitem">root</code>
	    felhasználóként) így
	    tehetünk meg:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>camcontrol modepage sd0 -m 1 -e -P 3</code></strong></pre><p>Változtassuk meg az AWRE (az írás
	    automatikus átképzése) és ARRE (az
	    olvasás automatikus átképzése)
	    beállítások értékeit
	    0-ról 1-re:</p><pre class="programlisting">AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</pre><p>A modernebb IDE-meghajtók is képesek a
	    vezérlõjükkel nyilvántartani az
	    idõközben meghibásodott szektorokat,
	    és ezt általában alapból
	    engdélyezik.</p><p>Ha rossz szektorokra figyelmeztetõ
	    hibaüzeneteket látunk (akármilyen
	    típusú meghajtónk is legyen), az
	    kétségtelenül arra utal, hogy ideje
	    lecserélnünk a hardvert.  A hibás
	    szektorok használatát esetleg a
	    gyártó saját diagnosztikai
	    programjával le tudjuk tiltani, de hosszabb
	    távon mindenképpen az lesz a legjobb, ha
	    veszünk egy újat.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76344528"></a><a id="hpnetserver-scsi-failure"></a><p><strong>5.3.</strong></p></td><td align="left" valign="top"><p>A FreeBSD miért nem találja meg a
	    HP Netserver SCSI-vezérlõjét?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez tulajdonképpen egy ismert probléma.  A
	    HP Netserver gépekben egy integrált EISA
	    buszos SCSI-vezérlõ található,
	    amely a 11-es EISA bõvítõhelyen
	    található, ezért az összes
	    <span class="quote">"<span class="quote">valódi</span>"</span> EISA
	    bõvítõhely ez elõtt helyezkedik el.
	    Sajnos a 10 feletti EISA bõvítõhelyek
	    címei ütköznek a PCI eszközök
	    számára kiosztott címekkel,
	    ezért a FreeBSD önmagától nem tudja
	    valami jól kezelni az ilyen helyzeteket.</p><p>Ezért a legjobban akkor járunk, ha
	    egyszerûen letagadjuk a címterek
	    ütközését :) Ezt úgy tudjuk
	    megtenni, ha a rendszermag <code class="literal">EISA_SLOTS</code>
	    nevû beállítását a 12
	    értékre állítjuk.  Ezután
	    már csak be kell konfigurálunk és
	    újra kell fordítanunk a rendszermagot, ahogy
	    azt a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/kernelconfig.html" target="_top">kézikönyv
	    megfelelõ része is
	    tárgyalja</a>.</p><p>Természetesen, amikor egy ilyen gépre
	    akarunk telepíteni, a helyzet tovább
	    bonyolódik.  A telepítést úgy
	    tudjuk megoldani, ha a <span class="emphasis"><em>UserConfig</em></span>
	    programon belül alkalmazunk egy apró
	    trükköt.  Most ne a <span class="quote">"<span class="quote">vizuális</span>"</span>
	    felületét használjuk, hanem a
	    parancssoros részt.  Gépeljük be, majd a
	    megszokottak szerint telepítsük a
	    rendszert:</p><pre class="programlisting">eisa 12
quit</pre><p>Ettõl függetlenül természetesen
	    továbbra is javasolt egy, az elõbbiek szerint
	    módosított rendszermagot fordítanunk
	    és telepítenünk.</p><p>A következõ verziókban
	    remélhetõleg már lesz valamilyen
	    megoldás erre a problémára.</p><div xmlns="" class="note"><h3 class="admontitle">Megjegyzés: </h3><p xmlns="http://www.w3.org/1999/xhtml">A HP Netserver esetén nem tudunk a
		lemezeken <code class="literal">Veszélyesen
		dedikált</code> (<code class="literal">Dangerously
		Dedicated</code>) módot használni.
		Errõl <a class="link" href="disks.html#dedicate">itt</a>
		olvashatunk bõvebben.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76356816"></a><a id="ed1-timeout"></a><p><strong>5.4.</strong></p></td><td align="left" valign="top"><p>Állandóan <span class="errorname">ed1:
	    timeout</span> és ahhoz hasonló
	    üzenetek jelennek meg.  Mi lehet velük
	    kezdeni?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ezt a hibát általában a
	    megszakítások ütközése okozza
	    (például két kártya ugyanazt a
	    megszakítást akarja használni).
	    Indítsuk a rendszerünket a <code class="option">-c</code>
	    beállítás használatával
	    és az
	    <code class="filename">ed0</code>/<code class="filename">de0</code>/...
	    bejegyzéseket változtassuk meg a
	    kártyáknak megfelelõen.</p><p>Ha a hálózati kártyánkon BNC
	    típusú csatlakozó
	    található, akkor még elõfordulhat,
	    hogy azért látunk ilyen hibaüzeneteket,
	    mert nem jól zártuk le a csatlakozást.
	    Ezt úgy tudjuk könnyen ellenõrizni, ha a
	    lezárót közvetlenül a
	    kártyára dugjuk rá (kábel
	    nélkül) és figyeljük, hogy
	    továbbra is jönnek-e a hibaüzenetek.</p><p>Egyes NE2000-kompatibilis kártyák akkor
	    adják ezt a hibát, ha az UTP portjukon nincs
	    aktív összeköttetés vagy nem dugtuk
	    be a kábelt.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76361296"></a><a id="bad-3c509"></a><p><strong>5.5.</strong></p></td><td align="left" valign="top"><p>Miért állnak le a <span class="trademark">3Com</span>(R) 3C509
	    kártyák minden különösebb ok
	    nélkül?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az ilyen típusú kártyák
	    néha hajlamosak elfelejteni a
	    beállításaikat.  Frissítsük
	    a kártya beállításait a
	    <code class="command">3c5x9.exe</code> program
	    segítségével.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76364368"></a><a id="printer-slow"></a><p><strong>5.6.</strong></p></td><td align="left" valign="top"><p>A párhuzamos nyomtató nevetségesen
	    lassú.  Mi lehet ezzel kezdeni?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ha csupán annyi a problémánk, hogy
	    a nyomtató irdatlanul lassan mûködik, akkor
	    próbáljuk meg a kézikönyv <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/printing-intro-setup.html" target="_top">nyomtatásról
	    szóló részében</a>
	    leírtakhoz hasonlóan
	    átállítani a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE" target="_top">nyomtató
	    portkezelését</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76371664"></a><a id="signal11"></a><p><strong>5.7.</strong></p></td><td align="left" valign="top"><p>A programok miért állnak le
	    idõnként <span class="errorname">Signal 11</span>
	    hibákkal?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ezek a hibák akkor keletkeznek, amikor a
	    futó programok olyan memóriaterülethez
	    próbálnak meg hozzáférni, amihez
	    eredetileg nem lenne szabad.  Ha valami ehhez hasonló
	    történik a rendszerünkben
	    látszólag teljesen
	    véletlenszerûen, akkor nagyon óvatosan
	    kezdjünk el vizsgálódni.</p><p>A lehetséges okok az alábbiak
	    lehetnek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ha csak olyan alkalmazások esetében
		jelentkezik ez a hiba, amelyeket mi magunk
		fejlesztünk, akkor az
		valószínûleg arra utal, hogy
		valamelyik része hibásan
		mûködik.</p></li><li class="listitem"><p>Ha a FreeBSD alaprendszerének valamelyik
		részében tapasztalunk ilyen hibákat,
		akkor azt szintén okozhatja hibás
		kód, de az ilyen hibákat
		általában hamarabb meg szokták
		találni és ki szokták
		javítani, mint ahogy a GYIK-ot olvasók
		többsége találkozna velük (a
		<code class="literal">-CURRENT</code> ág pontosan ezt a
		célt szolgálja).</p></li></ol></div><p>Elõfordulhat, hogy ez egy olyan furcsaság
	    eredménye, amely <span class="emphasis"><em>nem</em></span> a FreeBSD
	    hibája: például ugyanazon program
	    fordításakor mindig mást csinál
	    a fordítóprogram.</p><p>Például tegyük fel, hogy a
	    <code class="command">make buildworld</code>
	    parancsot futtatjuk, és a fordítás
	    félbeszakad, amikor az <code class="filename">ls.c</code>
	    állományból el akarja
	    készíteni az <code class="filename">ls.o</code>
	    állományt.  Ha ezután megint
	    megpróbáljuk kiadni a <code class="command">make
	    buildworld</code> parancsot,
	    akkor a fordítás ugyanazon a helyen
	    újból meghiúsul -
	    valószínûleg hibás a
	    forráskód, frissítsük a
	    forrásainkat és próbáljuk meg
	    ismét.  Ha viszont a fordítás ilyenkor
	    már egy másik helyen akad el, akkor szinte
	    biztos, hogy hardverhibával akadtunk
	    össze.</p><p>Amit ilyenkor tenni tudunk:</p><p>Az elsõ esetben egy nyomkövetõ,
	    például a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>
	    segítségével keressük meg a program
	    azon pontját, ahol rossz
	    memóriaterülethez próbál meg
	    hozzáférni és javítsuk
	    ki.</p><p>A második esetben ellenõrizzük, hogy
	    nem a hardver a hibás.</p><p>Ennek okai többek közt a következõk
	    lehetnek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Túlmelegednek a merevlemezeink:
		ellenõrizzük, hogy a gépben
		található ventillátorok rendesen
		mûködnek-e (persze elõfordulhat, hogy
		más eszközök melegednek
		túl).</p></li><li class="listitem"><p>A processzor túlmelegedett: lehet, hogy mert
		túlságosan nagy órajelen
		járatjuk, vagy mert egyszerûen leállt
		a hûtése.  Akármelyik eset is
		következett be, legalább a hiba
		felderítéséig
		állítsuk vissza a hivatalos
		sebességére.</p><p>Ha feltétlenül ragaszkodunk a
		rendszerünk tuningolásához, akkor
		érdemes elgondolkoznunk azon, hogy egy lassabb
		rendszerrel jobban járunk, mint egy
		állandóan cserélendõ,
		ropogósra sült rendszerrel.  Az emberek
		általában nem is nagyon szeretik az ilyen
		rendszereket, független attól, hogy
		szerintünk érdemes-e ilyet csinálni
		vagy sem.</p></li><li class="listitem"><p>Hibás memóriamodulok: ha több
		SIMM és DIMM modul is található a
		gépünkben, akkor vegyük ki az
		összeset és próbáljuk ki
		mindegyiket egyesével, ezzel is
		leszûkíthetjük a probléma
		felderítését a hibás
		DIMM/SIMM modulokra vagy azok
		kombinációjára.</p></li><li class="listitem"><p>Az alaplap túlbecslõ
		értékei: a BIOS
		beállításai között vagy
		az alaplapon található jumperekkel
		szabályozni tudjuk a
		különbözõ
		idõzítéseket, ahol
		általában az alapértelmezett
		értékek megfelelnek, de néha
		elõfordulhat, hogy a memóriamodulok
		késleltetését lassúra, vagy
		éppen turbó sebességre
		állítják (<span class="quote">"<span class="quote">RAM Speed:
		Turbo</span>"</span> vagy ehhez hasonló néven
		keressük a BIOS-ban), ami szintén okozhat
		furcsa viselkedést.  Próbáljuk meg
		visszaállítani az BIOS
		alapértelmezett értékeit, de
		elõtte érdemes lejegyezni az aktuális
		beállításainkat.</p></li><li class="listitem"><p>Az alaplap zajos vagy kevés áramot
		kap: ha vannak használaton kívüli I/O
		kártyáink, merevlemezeink,
		CD-meghajtóink a rendszerünkben, akkor
		próbáljuk meg ideiglenesen
		eltávolítani ezeket vagy egyszerûen
		csak lehúzni róluk a
		tápkábelt.  Ezzel tudjuk vizsgálni,
		hogy a számítógépünk
		tápegysége képes-e
		megbirkózni a kisebb terheléssel.  Esetleg
		kipróbálhatunk egy másik
		tápegységet is, lehetõleg egy
		kicsivel erõsebbet (például ha a
		jelenlegi tápegységünk
		teljesítménye 250 watt, akkor
		használjunk helyette egy
		300 wattosat).</p></li></ol></div><p>Továbbá érdemes lehet még
	    elolvasnunk a SIG11 GYIK-ot (lásd lentebb), ahol
	    mindezeket a problémákat részletesen
	    kifejtik, noha a <span class="trademark">Linux</span>(R)
	    nézõpontjából.  Arról is
	    olvashatunk benne, hogy egy hibás
	    memóriát miért nem képesek
	    észlelni a szoftveres vagy hardveres
	    tesztelõeszközök.</p><p>Végezetül, ha az egyik javaslat sem
	    segített a probléma megoldásában,
	    akkor valószínûleg sikerült
	    hibát találnunk a FreeBSD kódjában,
	    amirõl nyugodtan írhatunk a fejlesztõknek
	    egy hibajelentést.</p><p>A problémáról minden
	    részletre kiterjedõ módon <a class="link" href="http://www.bitwizard.nl/sig11/" target="_top">A SIG11-es probléma GYIK-ja</a>
	    írásban olvashatunk (angolul).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76393424"></a><a id="trap-12-panic"></a><p><strong>5.8.</strong></p></td><td align="left" valign="top"><p>A rendszer összeomlik vagy egy <span class="errorname">Fatal
	    trap 12: page fault in kernel mode</span> vagy pedig
	    valamilyen <span class="errorname">panic:</span> hibaüzenettel
	    és egy halom számot ír ki.  Mit
	    tegyünk?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A FreeBSD fejlesztõi nagyon kíváncsiak
	    az ilyen hibákra, de a
	    felderítéséhez sajnos jóval
	    több információra van
	    szükségük, mint amennyit láthattunk.
	    Másoljuk le az összeomláshoz
	    tartozó teljes üzenetet.  Ezután
	    nézzük meg a GYIK-nak azt a
	    részét, amely a <a class="link" href="advanced.html#kernel-panic-troubleshooting" title="18.13.">rendszermag
	    összeomlásáról</a> szól,
	    készítsünk egy nyomkövetési
	    információkkal ellátott rendszermagot
	    és kérjük le a hívási
	    láncot.  Ez elsõre talán bonyolultnak
	    hangzik, de ehhez igazából nem igényel
	    semmilyen programozási tudást, egyszerûen
	    csak a megadott utasításokat kell
	    követnünk.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76396752"></a><a id="screen-loses-sync"></a><p><strong>5.9.</strong></p></td><td align="left" valign="top"><p>A rendszer indulása közben miért
	    sötétül a képernyõ és megy
	    el rajta a kép?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez az ATI Mach 64 videokártyák
	    esetében jelentkezõ probléma.  Ilyenkor az
	    a gond, hogy a kártya a <code class="literal">0x2e8</code>
	    címet használja, akárcsak a negyedik
	    soros port.  A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a> meghajtóban levõ hiba
	    (vagy netalán beállítás?) miatt
	    azonban a negyedik soros portot
	    <span class="emphasis"><em>még</em></span> akkor is használni
	    fogja, ha kikapcsoljuk a <code class="filename">sio3</code> (a
	    negyedik soros port) eszközt.</p><p>A hibát kijavításáig
	    így kerülhetjük meg:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A betöltõ parancssorában adjuk meg
		a <code class="option">-c</code> paramétert.  (Így
		elõ tudjuk hozni a rendszermag
		konfigurációs
		módját.)</p></li><li class="listitem"><p>Kapcsoljuk ki a <code class="filename">sio0</code>,
		<code class="filename">sio1</code>,
		<code class="filename">sio2</code> és
		<code class="filename">sio3</code> eszközöket
		(tehát mindegyiket).  Emiatt a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>
		meghajtó nem indul el, és így nem
		okoz problémát.</p></li><li class="listitem"><p>Lépjünk ki és folytassuk a
		rendszer indítását.</p></li></ol></div><p>Ha a soros portokat is használni akarjuk, akkor
	    következõ módosításokkal
	    készítsünk egy új rendszermagot: a
	    <code class="filename">/usr/src/sys/dev/sio/sio.c</code> (vagy pc98
	    esetén a
	    <code class="filename">/usr/src/sys/pc98/cbus/sio.c</code>)
	    állományban keressük meg a
	    <code class="literal">0x2e8</code> karakterláncot és az
	    azt megelõzõ vesszõt távolítsuk
	    el (de az utána következõt tartsuk meg).
	    Miután végrehajtottuk ezt a
	    módosítást, a megszokott módon
	    fordítsuk újra a rendszermagot.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76416592"></a><a id="reallybigram"></a><p><strong>5.10.</strong></p></td><td align="left" valign="top"><p>A FreeBSD miért csak 64 MB
	    memóriát használ, amikor 128 MB van
	    a gépben?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Mivel FreeBSD a BIOS-tól próbálja
	    megtudni a rendelkezésre álló
	    memória méretét, ezért csak
	    16 biten képes lekérdezni a KB-okban
	    (vagyis 65 535 KByte = 64 MB, vagy még
	    ennél is kevesebb, mivel egyes BIOS-ok legfeljebb
	    16 MB memóriát engednek látni).
	    Tehát ha 64 MB-nál több
	    memóriával rendelkezünk, akkor a FreeBSD
	    ugyan megpróbálja azt felderíteni, de
	    nem feltétlenül fog sikerülni.</p><p>Ezt úgy tudjuk megoldani, ha a rendszermag
	    alábbi beállítását
	    használjuk.  Alapvetõen ugyanis létezik
	    egy módszer, amivel le lehet kérdezni a
	    memória teljes méretét a
	    BIOS-tól, de a hozzá tartozó rutin nem
	    fért el a rendszerindító blokkban.  Ha
	    egyszer majd sikerül neki helyet csinálni, akkor
	    a rendszer képes lesz kizárólag ezzel a
	    módszerrel dolgozni.  Amíg viszont ez nem
	    így van, addig kénytelenek leszünk a most
	    következõ megoldást
	    választani:</p><pre class="programlisting">options MAXMEM=<em class="replaceable"><code>N</code></em></pre><p>ahol <em class="replaceable"><code>N</code></em> a memória
	    Kilobyte-okban megadott mérete.  Tehát egy
	    128 MB memóriával rendelkezõ
	    számítógép esetén ez
	    <code class="literal">131072</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76420816"></a><a id="kmem-map-too-small"></a><p><strong>5.11.</strong></p></td><td align="left" valign="top"><p>A számítógépben több
	    mint 1 GB memória van, de mégis
	    <span class="errorname">kmem_map too small</span> üzenetek
	    jelennek meg.  Mi a gond?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A FreeBSD általában a rendszermag
	    néhány fontos paraméterét, mint
	    például az egyszerre megnyitható
	    állományok maximális
	    számát a
	    számítógépben
	    található memória
	    méretébõl származtatja.  Az
	    1 GB memóriánál több
	    esetén azonban elképzelhetõ, hogy ez az
	    <span class="quote">"<span class="quote">automatikus méretezés</span>"</span>
	    túlságosan is nagy értékeket
	    választ.  Így a rendszer
	    indításakor a rendszermag olyan nagy
	    méretû táblázatokat és
	    egyéb struktúrákat foglal le, amelyek
	    betöltik a rendelkezésére
	    bocsátott terület nagy részét.
	    Késõbb, a rendszer futása közben
	    pedig a rendszermag szépen lassan kifogy a dinamikus
	    memóriaterületekbõl és
	    összeomlik.</p><p>Készítsünk egy olyan saját
	    rendszermagot, ahol a <code class="option">VM_KMEM_SIZE_MAX</code>
	    beállítást megnöveljük
	    egészen a maximális 400 MB-os
	    értékig (<code class="option">options
	    VM_KMEM_SIZE_MAX=419430400</code>).  400 MB
	    használata valószínûleg
	    elég lesz egészen 6 GB
	    memóriáig.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76429136"></a><a id="panic-kmemmap-too-small"></a><p><strong>5.12.</strong></p></td><td align="left" valign="top"><p>A számítógépben nincs
	    1 GB memória, a FreeBSD mégis
	    <span class="errorname">kmem_map too small</span> hibával
	    leáll!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez a hibaüzenet arra utal, hogy a rendszer
	    kifogyott a hálózati pufferek
	    (különösen az mbuf klaszterek)
	    számára kiosztott virtuális
	    memóriából.  Az mbuf klaszterek
	    részére fenntartott virtuális
	    memória méretének
	    beállításáról a
	    kézikönyv <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/configtuning-kernel-limits.html#NMBCLUSTERS" target="_top">Hálózati
	    korlátozások</a> címû
	    szakaszában olvashatunk.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76432080"></a><a id="proc-table-full"></a><p><strong>5.13.</strong></p></td><td align="left" valign="top"><p>Miért jelenik meg a <span class="errorname">kernel: proc:
	    table is full</span> hibaüzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A FreeBSD rendszermagja egyszerre csak bizonyos
	    számú programot enged futni.  Ezek
	    konkrét száma a
	    <code class="varname">kern.maxusers</code>
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>-változótól függ.  A
	    <code class="varname">kern.maxusers</code> ezenkívül
	    még hatással van más belsõ
	    korlátokra is, például a
	    hálózati pufferekre (lásd <a class="link" href="troubleshoot.html#panic-kmemmap-too-small" title="5.12.">ezt</a> a
	    korábbi kérdést).  Ha a
	    számítógépünk
	    túlságosan leterhelt, akkor érdemes
	    megpróbálkoznunk a
	    <code class="varname">kern.maxusers</code>
	    értékének
	    növelésével.  Ennek
	    átállítása a rendszerben
	    egyszerre futtatható maximális programok
	    számával együtt sok más
	    rendszerszintû korlátozást is
	    finomít.</p><p>A <code class="varname">kern.maxusers</code>
	    értékének
	    beállításához nézzük
	    meg a kézikönyv <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/configtuning-kernel-limits.html#KERN-MAXFILES" target="_top">Az állományok és futó programok korlátozásairól</a>
	    szóló szakaszát.  (Miközben ez a
	    rész a megnyitható állományok
	    maximális számáról szól,
	    addig ugyanez érvényes a futó
	    programokra is.)</p><p>Ha viszont a
	    számítógépünk nem éri
	    akkora terhelés, de mégis szeretnénk
	    egyszerre nagyobb számú programot is futtatni
	    rajta, akkor ehhez elegendõ csak
	    <code class="varname">kern.maxproc</code> változót
	    átállítanunk.  Ezt úgy tudjuk
	    megtenni, ha felvesszük a
	    <code class="filename">/boot/loader.conf</code>
	    állományba.  Ez az érték
	    természetesen addig nem
	    beállítódni, amíg a
	    rendszerünket újra nem indítjuk.
	    Ezekrõl a változókról a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">loader.conf</span>(5)</span></a> és <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">sysctl.conf</span>(5)</span></a> man
	    oldalakon tájékozódhatunk
	    részletesebben.  Ha az összes programot egyetlen
	    felhasználóval akarjuk futtatni, akkor a
	    <code class="varname">kern.maxprocperuid</code> változót
	    értékét is át kell
	    állítanunk, méghozzá a
	    <code class="varname">kern.maxproc</code> új
	    értékénél eggyel kisebbre.
	    (Ezért kell így csinálni, mert egy
	    rendszerprogram, az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> mindig fut.)</p><p>A sysctl változók
	    beállításait úgy is tudjuk
	    véglegesíteni, ha felvesszük ezeket az
	    <code class="filename">/etc/sysctl.conf</code>
	    állományba.  A kézikönyv <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/configtuning-sysctl.html" target="_top">A
	    rendszermag korlátainak finomhangolása</a>
	    címû szakaszában részletesebb is
	    olvashatunk róla, hogy miként
	    állítsuk be a rendszerünket.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76456144"></a><a id="cmap-busy-panic"></a><p><strong>5.14.</strong></p></td><td align="left" valign="top"><p>Az új rendszermag indításakor
	    miért keletkezik <span class="errorname">CMAP busy</span>
	    hibaüzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az elavult <code class="filename">/var/db/kvm_*.db</code>
	    állományokat összegyûjtõ rutin
	    idõnként nem mûködik megfelelõen,
	    és a nem egyezõ állományok
	    esetén össze is omolhat.</p><p>Amikor ilyen történik, indítsuk
	    újra a rendszert egyfelhasználós
	    módban és gépeljük be:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm /var/db/kvm_*.db</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76464592"></a><a id="brkadrint-illegal-host-access"></a><p><strong>5.15.</strong></p></td><td align="left" valign="top"><p>Mit jelent az <span class="errorname">ahc0: brkadrint, Illegal Host
	    Access at seqaddr 0x0</span> üzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez az Ultrastor SCSI vezérlõkártya
	    ütközésére utal.</p><p>A rendszerindítás közben
	    lépjünk be a rendszermag
	    konfigurációs menüjébe és
	    tiltsuk le a gondot okozó
	    <code class="filename">uha0</code> eszközt.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76467920"></a><a id="aci0-illegal-cable"></a><p><strong>5.16.</strong></p></td><td align="left" valign="top"><p>Amikor elindul a rendszer, egy <span class="errorname">ahc0: illegal
	    cable configuration</span> hibaüzenet jelenik meg.
	    A kábelek bekötésével semmilyen
	    gond nincs.  Mégis akkor mi a baj?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Az alaplapon nem található olyan
	    áramkör, amely támogatja az automatikus
	    lezárást (<span class="quote">"<span class="quote">automatic
	    termination</span>"</span>).  A SCSI BIOS-ban az automatikus
	    lezárás helyett adjuk meg a megfelelõ
	    lezárást.  Az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ahc&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ahc</span>(4)</span></a> meghajtója
	    nem képes rendesen érzékelni a
	    kábeleket, ha az alaplapon van ilyen
	    érzékelés (és így
	    automatikus lezárás).  A meghajtó
	    egyszerûen annyit feltételez, hogy ennek
	    támogatása csak akkor érhetõ el,
	    ha az EEPROM-ban megadtuk az <span class="quote">"<span class="quote">automatic
	    termination</span>"</span> beállítást.  A
	    megfelelõ kábeldetektáló
	    eszköz nélkül a meghajtó gyakran
	    rosszul állapítja meg a
	    lezárást, ami pedig így
	    veszélyezteti a SCSI busz
	    megbízhatóságát.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76476112"></a><a id="mail-loopback"></a><p><strong>5.17.</strong></p></td><td align="left" valign="top"><p>Miért küld a
	    <span class="application">sendmail</span> <span class="errorname">mail loops back
	    to myself</span> hibaüzenetet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Errõl részletesebben a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/mail-trouble.html#Q26.5.2." target="_top">kézikönyvben</a>
	    olvashatunk.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76479440"></a><a id="remote-fullscreen"></a><p><strong>5.18.</strong></p></td><td align="left" valign="top"><p>A távoli gépeken miért viselkednek
	    olyan furcsán a teljes képernyõs
	    alkalmazások?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Elõfordulhat, hogy az adott távoli
	    gépen a terminál típusa nem
	    <code class="literal">cons25</code>, amire viszont a FreeBSD konzolnak a
	    megfelelõ mûködéshez
	    szüksége lenne.</p><p>Ezt a problémát többféle
	    módon is meg tudjuk kerülni:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Mikor bejelentkezünk a távoli
		gépre, állítsuk a <code class="envar">TERM</code>
		környezeti változót az
		<code class="literal">ansi</code> vagy <code class="literal">sco</code>
		értékre, amibõl kiderül, hogy
		egyáltalán ismeri ezeket a
		termináltípusokat.</p></li><li class="listitem"><p>A FreeBSD konzolban használjunk VT100
		emulátort, például a
		<span class="application">screen</span> alkalmazást.  A
		<span class="application">screen</span>
		segítségével egyetlen
		terminálról egyszerre több
		munkamenetet is tudunk indítani, de
		egyébként is egy nagyon jó program.
		Minden <span class="application">screen</span> által
		létrehozott ablak VT100-as
		terminálként mûködik,
		ezért a távoli gépen a
		<code class="envar">TERM</code> környezeti
		változó nyugodtan
		beállítható a
		<code class="literal">vt100</code> értékre.</p></li><li class="listitem"><p>Tegyük hozzá a <code class="literal">cons25</code>
		bejegyzést a távoli gép
		terminálokat tároló
		adatbázisához.  Ez pontos módszere
		jelentõs mértékben függ az adott
		gépen található
		operációs rendszertõl.  Ebben
		leginkább az adott gépen
		található man oldalak tudnak
		segíteni.</p></li><li class="listitem"><p>Indítsunk el a FreeBSD rendszert futtató
		gépen egy X szervert és a távoli
		géprõl egy X rendszerre
		íródott terminálemulátorral,
		például az <code class="command">xterm</code> vagy
		az <code class="command">rxvt</code> programmal jelentkezzük
		be.  A távoli gépen ekkor a
		<code class="envar">TERM</code> változó
		értéke vagy <code class="literal">xterm</code>, vagy
		pedig <code class="literal">vt100</code> lesz.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76495696"></a><a id="pnp-not-found"></a><p><strong>5.19.</strong></p></td><td align="left" valign="top"><p>A Plug and Play kártyákat miért nem
	    találja meg (vagy <code class="literal">unknown</code>
	    típusúként látja) a
	    FreeBSD?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ennek az okait a következõ levélben
	    fejtette ki Peter Wemm a <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions" target="_top">FreeBSD general questions levelezési lista</a> tagjainak, amelyben
	    arra válaszolt, hogy egy belsõ modemet
	    miért nem észlel a rendszer miután
	    frissítették
	    FreeBSD 4.<em class="replaceable"><code>X</code></em>-re (az
	    érthetõség kedvéért
	    szögletes zárójelek között
	    hozzáadtunk néhány
	    kiegészítést is).</p><div xmlns="" class="note"><h3 class="admontitle">Megjegyzés: </h3><p xmlns="http://www.w3.org/1999/xhtml">Az eredeti szövegbõl készült
	      idézetet frissítettük.</p></div><div class="blockquote"><blockquote class="blockquote"><p>A PNP BIOS beállította [a modemet]
	      és magára hagyta valahol a portok
	      számára fenntartott címtérben,
	      így az ISA eszközök régi
	      típusú [3.<em class="replaceable"><code>X</code></em>-ben
	      levõ] eszközpróbálgatásai
	      ott <span class="quote">"<span class="quote">találták</span>"</span> meg.</p><p>A 4.0 esetében azonban az ISA
	      eszközöket kezelõ kód már
	      sokkal inkább a PnP
	      támogatására koncentrál.
	      Korábban [a 3.X verziókban]
	      elõfordulhatott az is, hogy az ISA eszközök
	      keresése során a rendszer egy
	      <span class="quote">"<span class="quote">kóbor</span>"</span> eszközt talált,
	      majd ugyanazt megtalálta PnP eszközként
	      és ütköztek az így duplán
	      lefoglalni kívánt erõforrások.
	      Ennek kivédésére elõször
	      tehát letiltjuk a programozható
	      kártyák felderítését,
	      így ez a típusú kettõs
	      detektálás nem történhet meg.
	      Ez továbbá azt is jelenti, hogy a
	      támogatott PnP hardverek azonosítóit
	      elõre ismerni kell.  Ennek
	      hangolhatóságát már
	      tervbevettük.</p></blockquote></div><p>Tehát egy ilyen eszköz
	    mûködtetéséhez
	    szükségünk lesz a PnP
	    azonosítójára, valamint arra, hogy
	    felvegyük a felderítendõ PnP
	    eszközök ISA eszközök közé.
	    Ezt a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> segítségével
	    kérhetjük le, amely például egy
	    belsõ modem esetén a következõ
	    kimenetet fogja adni:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pnpinfo</code></strong>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</pre><p>[a többi részt kihagytuk]</p><pre class="screen">TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</pre><p>Innen a <code class="literal">Vendor ID</code> kezdetû sorra
	    lesz szükségünk.  A zárójelek
	    között szereplõ hexadecimális
	    szám (ami a példában a
	    <code class="literal">0x3024a341</code>) lesz az eszköz PnP
	    azonosítója, valamint a közvetlenül
	    ez elõtt szereplõ karakterlánc az egyedi
	    ASCII azonosítója
	    (<code class="literal">PMC2430</code>).</p><p>Ha a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> lefuttatásának
	    eredményeképpen megjelenõ lista nem
	    tartalmazza a kérdéses eszközt, akkor
	    helyette a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pciconf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pciconf</span>(8)</span></a> használatával is
	    próbálkozhatunk.  Íme a
	    <code class="command">pciconf -vl</code> parancs kimenete egy
	    integrált hangkártya esetében:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pciconf -vl</code></strong>
chip1@pci0:31:5:        class=0x040100 card=0x00931028 chip=0x24158086 rev=0x02 hdr=0x00
    vendor   = 'Intel Corporation'
    device   = '82801AA 8xx Chipset AC'97 Audio Controller'
    class    = multimedia
    subclass = audio</pre><p>Ebbõl a <code class="varname">chip</code>
	    változót, vagyis a
	    <code class="literal">0x24158086</code> értéket kell
	    felhasználnunk.</p><p>Ezt az információt (a <code class="literal">Vendor
	    ID</code> vagy a <code class="varname">chip</code>
	    értékét) ezután a
	    <code class="filename">/usr/src/sys/dev/sio/sio_isa.c</code>
	    állományba kell felvennünk.</p><p>Ehhez elõször is készítsünk
	    egy biztonsági másolatát a
	    <code class="filename">sio_isa.c</code>
	    állományról arra az esetre, ha
	    véletlenül valami rossz történne.
	    Ez azért is hasznunkra fog válni, mert
	    így tudunk egy javítást
	    mellékelni a hibajelentésünk mellé
	    (mert ugye írni fogunk róla
	    hibajelentést, ugye?).  Szóval, keressük
	    meg a <code class="filename">sio_isa.c</code>
	    állományban a következõ sort:</p><pre class="programlisting">static struct isa_pnp_id sio_ids[] = {</pre><p>Menjük lentebb egészen addig, amíg
	    nem találunk egy helyet, ahova be tudunk szúrni
	    egy bejegyzést az eszközünkhöz.  A
	    bejegyzések megadásának módja
	    lentebb látható, és a jobb oldalt
	    megjegyzésbe tett ASCII Vendor ID szerint
	    rendezettek, amelyek mellett még
	    megtalálható (amennyiben kifér) a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> <span class="emphasis"><em>Device Description</em></span>
	    kimenetében kapott érték is:</p><pre class="programlisting">{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</pre><p>A megfelelõ helyre ezután vegyük fel az
	    eszközünkhöz tartozó
	    hexadecimális Vendor ID értéket,
	    mentsük el az állományt, fordítsuk
	    újra a rendszermagot és indítsuk
	    újra vele a rendszerünket.  Ha mindent
	    jól csináltunk, akkor az eszköz
	    <code class="filename">sio</code> eszközként fog
	    megjelenni.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76525648"></a><a id="nlist-failed"></a><p><strong>5.20.</strong></p></td><td align="left" valign="top"><p>Miért keletkezik <span class="errorname">nlist
	    failed</span> hiba például a
	    <code class="command">top</code> vagy <code class="command">systat</code>
	    parancsok futtatásakor?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A gondot alapvetõen az okozza, hogy a
	    kérdéses alkalmazás valamiért egy
	    olyan rendszermagbeli szimbólumot keres, amit nem
	    talál.  Ez a típusú hiba a
	    következõkbõl eredhet:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A rendszermag és a hozzá tartozó
		programok nincsenek szinkronban (vagyis
		fordítottunk egy új rendszermagot, de nem
		volt <code class="buildtarget">installworld</code> vagy
		fordítva) és emiatt a szimbólumokat
		tároló táblázat nem teljesen
		úgy épül fel, ahogy azt az
		alkalmazás gondolja.  Ha errõl lenne
		szó, akkor egyszerûen nincs más
		teendõnk, mint befejezni a frissítést
		(ennek pontos részleteit lásd a
		<code class="filename">/usr/src/UPDATING</code>
		állományban).</p></li><li class="listitem"><p>Nem a <code class="command">/boot/loader</code>, hanem
		közvetlenül a <code class="filename">boot2</code>
		(lásd <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a>)
		segítségével töltjük be a
		rendszermagot.  Noha alapvetõen semmilyen
		problémát nem nem okoz a
		<code class="command">/boot/loader</code> kihagyása,
		általánosságban véve
		azért mégis jobban
		elérhetõvé tudja tenni a
		rendszermagban található
		szimbólumokat a felhasználói
		programok felé.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76537680"></a><a id="connection-delay"></a><p><strong>5.21.</strong></p></td><td align="left" valign="top"><p>Miért tart olyan sokáig
	    <code class="command">ssh</code> vagy <code class="command">telnet</code>
	    használatával csatlakozni a
	    számítógéphez?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A tünet: nagyon sok idõ telik
	    aközött, amíg a TCP kapcsolat
	    felépül és a kliens bekéri a
	    jelszót (vagy a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a> esetében
	    amíg a bejelentkezõ képernyõ
	    megjelenik).</p><p>A betegség: nagyon valószínû,
	    hogy a késlekedést az okozza, amikor a szerver
	    megpróbálja a kliens IP-címét
	    feloldani hálózati névvé.  Sok
	    szerver, köztük a FreeBSD-ben is
	    megtalálható <span class="application">Telnet</span>
	    és <span class="application">SSH</span> szerver is ezt
	    csinálja, többek közt azért, hogy
	    a rendszergazda számára el tudja
	    tárolni egy naplóban ezt a
	    hálózati nevet.</p><p>Az orvosság: ha az említett
	    jelenség minden olyan esetben jelentkezik, amikor a
	    számítógéprõl (mint
	    kliensrõl) valamilyen szerverhez csatlakozni akarunk,
	    akkor a kliens oldalán lesz a gond.  Ehhez
	    hasonlóan, ha csak egy adott szervernél
	    tapasztaljuk, akkor azzal a
	    számítógéppel
	    történhetett valami.</p><p>Amennyiben a problémákat a kliens okozza,
	    nem tehetünk mást, a névoldáson kell
	    úgy javítanunk, hogy a szerver
	    normálisan fel tudja oldani.  Ha helyi
	    hálózaton tapasztaljuk mindezt, akkor ez
	    már a szerver problémája és
	    olvassunk tovább.  Ellenkezõ esetben az internet
	    a felelõs, ezért nagyon
	    valószínû, hogy fel kell vennünk a
	    kapcsolatot az internet-szolgáltatónkkal
	    és segítséget kérni
	    tõlük a hiba
	    elhárításában.</p><p>Ha a problémát viszont a helyi
	    hálózaton található szerver
	    okozza, akkor úgy kell azt
	    beállítanunk, hogy a helyi neveket
	    képes legyen rendesen feloldani.  Ezzel kapcsolatban
	    a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a> és <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a> man oldalakat
	    érdemes elolvasnunk.  Ha a probléma viszont az
	    interneten jelenik meg, akkor valószínû,
	    hogy a szerver névfeloldása nem üzemel
	    rendesen.  Nézzünk meg egy másik
	    gépet - például a
	    <code class="systemitem">www.yahoo.com</code> címet.  Ha ez sem
	    mûködik, akkor nálunk van a gond.</p><p>A FreeBSD friss telepítését
	    követõen az is elképzelhetõ, hogy
	    egyszerûen csak hiányoznak a
	    tartományokkal és névszerverekkel
	    kapcsolatos megfelelõ adatok az
	    <code class="filename">/etc/resolv.conf</code>
	    állományból.  Ez gyakran okoz
	    késlekedést az <span class="application">SSH</span>
	    mûködésében, mivel az <code class="filename">/etc/ssh</code>
	    könyvtárban található
	    <code class="filename">sshd_config</code> állományban
	    alapértelmezés szerint a
	    <code class="literal">UseDNS</code> beállítás
	    értéke <code class="literal">yes</code> (tehát a
	    névfeloldás használata
	    engedélyezett).  Ha valóban ez okozza a
	    problémát, akkor a pótoljuk az
	    <code class="filename">/etc/resolv.conf</code>
	    állományból hiányzó
	    adatokat vagy az <code class="filename">sshd_config</code>
	    állományban a <code class="literal">UseDNS</code>
	    értéke ideiglenesen legyen
	    <code class="literal">no</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76554448"></a><a id="stray-irq"></a><p><strong>5.22.</strong></p></td><td align="left" valign="top"><p>Mire utal a <span class="errorname">stray IRQ</span>
	    (kóbor megszakítási kérés)
	    üzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A kóbor megszakítási
	    kéréseket jelzõ üzenetek
	    általában a hardveres megszakítási
	    kérések egyenletlenségeire utalnak,
	    ezen belül is leginkább olyan esetekre, amikor
	    az eszköz egy megszakítási
	    kérés nyugtázása
	    közepén eltávolítja az adott
	    kérést.</p><p>Három dolgot tehetünk ezzel
	    kapcsolatban:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Elviseljük ezeket a figyelmeztetéseket.
		Megszakítási
		kérésenként az elsõ öt
		üzenet után amúgy sem jelez
		többet a rendszer.</p></li><li class="listitem"><p>Ha platformunkhoz (mint például
		<span class="trademark">i386</span>TM) tartozó <code class="filename">intr_machdep.c</code>
		állományban található
		<code class="varname">MAX_STRAY_LOG</code>
		értékét átírjuk
		<code class="literal">5</code>-rõl <code class="literal">0</code>-ra
		és így újrafordítjuk a
		rendszermagot, akkor ezzel teljesen letilthatjuk a
		figyelmeztetéseket.</p></li><li class="listitem"><p>Megszüntetjük az üzeneteket
		úgy, hogy csatlakoztatunk a rendszerhez egy olyan
		párhuzamos vonali eszközt, amely a 7-es
		IRQ-t használja, és rakunk fel
		hozzá egy PPP meghajtót (a legtöbb
		helyen egyébként ezzel lesz a gond),
		valamint a 15-ös IRQ-ra pedig rakunk egy
		IDE-meghajtót vagy más hasonló
		eszközt és telepítjük
		hozzá a megfelelõ meghajtót.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76562000"></a><a id="file-table-full"></a><p><strong>5.23.</strong></p></td><td align="left" valign="top"><p>Miért jelenik meg folyamatosan a <span class="errorname">file:
	    table is full</span> üzenet a
	    rendszernaplóban?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ha ilyen hibaüzenetet látunk, akkor az arra
	    utal, hogy kifogytunk a rendszerünkben egyszerre
	    használható
	    állományleírókból.  A
	    probléma leírásával és
	    megoldásával kapcsolatban olvassuk el a
	    kézikönyvben a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/configtuning-kernel-limits.html#KERN-MAXFILES" target="_top">kern.maxfiles
	    </a> változóról szóló
	    részt <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/configtuning-kernel-limits.html" target="_top">A
	    rendszermag korlátainak finomhangolása</a>
	    címû szakaszban.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76565456"></a><a id="calcru-negative-runtime"></a><p><strong>5.24.</strong></p></td><td align="left" valign="top"><p>Miért árasztják el
	    <span class="errorname">calcru: negative runtime</span> vagy
	    <span class="errorname">calcru: runtime went backwards</span>
	    üzenetek a konzolt?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ismert egy olyan probléma, hogy a BIOS-ban
	    engedélyezzük az <span class="trademark">Intel</span>(R) Enhanced SpeedStep
	    technológiáját, akkor a rendszermag
	    ehhez hasonló <span class="errorname">calcru</span>
	    üzeneteket kezd el küldözgetni:</p><pre class="screen">calcru: runtime went backwards from 6 usec to 3 usec for pid 37 (pagezero)
calcru: runtime went backwards from 6 usec to 3 usec for pid 36 (vmdaemon)
calcru: runtime went backwards from 170 usec to 138 usec for pid 35 (pagedaemon)
calcru: runtime went backwards from 553 usec to 291 usec for pid 15 (swi6: task queue)
calcru: runtime went backwards from 15521 usec to 10366 usec for pid 2 (g_event)
calcru: runtime went backwards from 25 usec to 12 usec for pid 11 (swi1: net)
calcru: runtime went backwards from 4417 usec to 3960 usec for pid 1 (init)
calcru: runtime went backwards from 2084385 usec to 1793542 usec for pid 1 (init)
calcru: runtime went backwards from 408 usec to 204 usec for pid 0 (swapper)</pre><p>Ennek oka, hogy az <span class="trademark">Intel</span>(R) SpeedStep (EIST) egyes
	    alaplapokkal nem kompatibilis.</p><p>Megoldás: Tiltsuk le a BIOS-ban az EIST
	    használatát.  Ekkor még az
	    ACPI-alapú
	    processzorfrekvencia-szabályozás
	    továbbra is elérhetõ a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=powerd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">powerd</span>(8)</span></a>
	    használatán keresztül.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76575824"></a><a id="computer-clock-skew"></a><p><strong>5.25.</strong></p></td><td align="left" valign="top"><p>Miért jár rosszul az óra a
	    számítógépen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A számítógépnek kettõ
	    vagy több idõmérõ eszköze van,
	    és a FreeBSD pont a rosszabbikat
	    választotta.</p><p>Adjuk ki a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dmesg</span>(8)</span></a> parancsot és
	    vizsgáljuk meg a <code class="literal">Timecounter</code>
	    kezdetû sorokat.  Ezek közül a FreeBSD a
	    legnagyobb <span class="quote">"<span class="quote">quality</span>"</span> értékkel
	    rendelkezõt választotta.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dmesg | grep Timecounter</code></strong>
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec</pre><p>Errõl a
	    <code class="varname">kern.timecounter.hardware</code> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(3)</span></a>
	    változó lekérdezésével
	    tudunk ténylegesen megbizonyosodni:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.timecounter.hardware</code></strong>
kern.timecounter.hardware: ACPI-fast</pre><p>Elõfordulhat, hogy az ACPI-idõzítõ
	    hibás.  Ilyenkor az a legegyszerûbb, ha az
	    <code class="filename">/etc/loader.conf</code>
	    állományban letiltjuk az
	    ACPI-idõzítõ
	    használatát:</p><pre class="programlisting">debug.acpi.disabled="timer"</pre><p>Vagy a BIOS is tudja módosítani a TSC
	    idõzítõt - például
	    azért, hogy csökkentse a processzor
	    sebességét, amikor merül az
	    akkumulátor vagy energiatakarékos módra
	    vált.  A FreeBSD sajnos nem figyel ezekre a
	    változtatásokra és elcsúszik az
	    idõméréssel.</p><p>Ahogy viszont az iménti példában is
	    látható, itt még az
	    <code class="literal">i8254</code> idõzítõ is
	    használható, méghozzá
	    úgy, hogy a
	    <code class="varname">kern.timecounter.hardware</code> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>
	    változó értékét
	    átállítjuk erre az
	    értékre:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.hardware=i8254</code></strong>
kern.timecounter.hardware: TSC -&gt; i8254</pre><p>Innentõl kezdve a
	    számítógépünk már
	    sokkal pontosabban mutatja az idõt.</p><p>Ezt a változtatást úgy tudjuk
	    minden rendszerindítás során
	    automatikusan megtenni, ha felvesszük a
	    következõ sort az
	    <code class="filename">/etc/sysctl.conf</code>
	    állományba:</p><pre class="programlisting">kern.timecounter.hardware=i8254</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76593744"></a><a id="null-null"></a><p><strong>5.26.</strong></p></td><td align="left" valign="top"><p>A rendszer laptopon miért nem tudja rendesen
	    megtalálni a PC-kártyákat?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez a probléma gyakran megjelenik olyan
	    laptopokon, amelyek egynél több
	    operációs rendszert is futtatnak, egyes
	    nem-BSD típusú rendszerek ugyanis hajlamosak a
	    hardvert inkonzisztens állapotban hagyni.  Emiatt a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pccardd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pccardd</span>(8)</span></a> parancs az adott kártyát
	    <span class="errorname">"(null)""(null)"</span> néven
	    észleli a valós típusa helyett.</p><p>A hardvert innen teljesen csak úgy tudjuk
	    alapállapotába hozni, ha a PC-kártya
	    foglalatát áramtalanítjuk.  Ehhez ki
	    kell kapcsolnunk a laptopot.  (Tehát ne tegyük
	    se készenléti, se pedig hibernált
	    állapotba - teljesen ki kell kapcsolni.) A
	    PC-kártya ezután várhatóan
	    már mûködni fog.</p><p>Némely laptopok hazudnak arról, hogy
	    rendesen ki vannak-e kapcsolva.  Amennyiben az elõbbi
	    módszer nem válna be, próbáljuk
	    meg úgy, hogy kikapcsoljuk a gépet,
	    kivesszük az akkumulátort, várunk egy
	    keveset, visszarakjuk és újra
	    bekapcsoljuk.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76597712"></a><a id="boot-read-error"></a><p><strong>5.27.</strong></p></td><td align="left" valign="top"><p>Miért ad a FreeBSD rendszertöltõje
	    <span class="errorname">Read error</span> hibát és
	    áll meg a BIOS képernyõn?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A FreeBSD rendszertöltõje rosszul ismerte fel a
	    merevlemez geometriáját.  Ezt a FreeBSD slice-ok
	    létrehozásakor és
	    módosításakor külön meg kell
	    adni az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a> használatakor.</p><p>A meghajtóhoz tartozó megfelelõ
	    geometriai beállítások a
	    számítógép BIOS-ában
	    találhatóak.  Keressük meg az adott
	    meghajtó cilinder-fej-szektor (Cylinder/Head/Sector)
	    értékét.</p><p>A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a>
	    partíciószerkesztõjében a
	    <span class="keycap"><strong>G</strong></span> billentyû lenyomásával
	    tudjuk beállítani ezt.</p><p>Ekkor egy párbeszédablak jelenik meg, ahol
	    meg tudjuk adni a cilinderek, fejek és a
	    sávonkénti szektorok számát.
	    Ide perjelekkel elválasztva gépeljük e a
	    BIOS-ban talált értékeket.
	    Például ha a merevlemez geometriája
	    5000 cilinder, 250 fej és sávonként 60
	    szektor, akkor a <strong class="userinput"><code>5000/250/60</code></strong>
	    értéket kell megadnunk.</p><p>Az <span class="keycap"><strong>Enter</strong></span> billentyû
	    lenyomására ezek az értékek
	    beállítódnak, és a
	    <span class="keycap"><strong>W</strong></span> lenyomására pedig az
	    új partíciós tábla
	    kiíródik a lemezre.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76613200"></a><a id="bootmanager-restore"></a><p><strong>5.28.</strong></p></td><td align="left" valign="top"><p>Egy másik operációs rendszer
	    letörölte a boot managert.  Hogyan lehet
	    visszaállítani?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Indítsuk el a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> programot, majd
	    válasszuk a <span class="guimenuitem">Configure</span>
	    és <span class="guimenuitem">Fdisk</span>
	    menüpontokat.  A
	    partíciószerkesztõben a
	    <span class="keycap"><strong>Space</strong></span> billentyûvel tudjuk
	    kiválasztani azt a partíciót, amelyen
	    korábban a boot manager volt.  Ezután az
	    <span class="keycap"><strong>W</strong></span> billentyû lenyomásával
	    tudjuk a változtatásainkat lemezre menteni.
	    Ekkor egy menü jelenik meg, ahol a telepíteni
	    kívánt rendszertöltõt
	    választhatjuk ki.  Adjuk meg és ekkor
	    visszakerül a helyére.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76626000"></a><a id="indefinite-wait-buffer"></a><p><strong>5.29.</strong></p></td><td align="left" valign="top"><p>Mit jelent a <span class="errorname">swap_pager: indefinite wait
	    buffer:</span> hibaüzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez arra utal, hogy egy futó program
	    megpróbált kiírni egy lapot a
	    memóriából a lemezre, azonban 20
	    másodperce már nem tudott
	    hozzáférni a lemezhez.  Ezt okozhatják
	    hibás szektorok a lemezen, a lemez hibás
	    kábelezése vagy esetleg valamilyen
	    lemezmûveletekkel kapcsolatos hardver
	    meghibásodása.  Amennyiben maga a
	    meghajtó a rossz, akkor az ilyen hibaüzenetek
	    mellett még más, a lemez hibás
	    mûködésére utaló
	    üzenetet is látnunk kell a
	    <code class="filename">/var/log/messages</code>
	    állományban vagy a <code class="command">dmesg</code>
	    kimenetében.  Minden más esetben
	    érdemes a meghajtó csatlakozásait
	    és kábelezését
	    ellenõrizni.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76629200"></a><a id="udma-icrc"></a><p><strong>5.30.</strong></p></td><td align="left" valign="top"><p>Mik azok a <span class="errorname">UDMA ICRC</span> hibák
	    és hogyan lehet ellenük tenni valamit?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ata&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ata</span>(4)</span></a> meghajtó jelenti ezeket a
	    <span class="errorname">UDMA ICRC</span> hibákat olyan esetekben,
	    amikor a merevlemezre vagy a merevlemezrõl
	    érkezõ DMA átvitel hibás.  A
	    meghajtó ilyenkor még párszor
	    megpróbálja megismételni a
	    mûveletet.  Amennyiben ezek a mûveletek is
	    meghiúsulnak, a DMA átvitel helyett a lassabb
	    PIO átviteli módra állítja
	    át a merevlemez felé irányuló
	    kommunikációt.</p><p>Ezt a problémát több
	    tényezõ is okozhatja, habár ennek a
	    leggyakoribb oka a hibás vagy rossz
	    kábelezés.  Ilyenkor mindig
	    ellenõrizzük, hogy a merevlemezhez
	    csatlakozó ATA-kábelek sértetlenek
	    és a használni kívánt
	    Ultra DMA átviteli módra alkalmasak.  Ha
	    cserélhetõ lemezes meghajtót
	    használunk, akkor kompatibilisnek is kell
	    lenniük.  Ez a gond akkor jelentkezhet, amikor
	    ugyanarra az ATA-csatornára egy
	    Ultra DMA 66-os (vagy annál is gyorsabb)
	    és egy régebbi meghajtót
	    csatlakoztatunk.  Végezetül ezek a
	    hibaüzenetek arra is utalhatnak, hogy a meghajtó
	    meghibásodott.  A legtöbb gyártó
	    külön szoftver ajánl fel ennek
	    vizsgálatára, ezért ilyenkor
	    érdemes letesztelnünk az érintett
	    meghajtót, illetve amennyiben szükséges,
	    biztonsági másolatot készíteni
	    az adatainkról és kicserélni az
	    eszközt.</p><p>Az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=atacontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">atacontrol</span>(8)</span></a> segédprogram
	    használatával ellenõrizni tudjuk, hogy
	    jelenleg az egyes ATA-eszközök milyen DMA vagy PIO
	    módban mûködnek.  Erre a célra
	    különösen az <code class="command">atacontrol mode
	    csatorna</code> parancsot
	    javasoljuk, amivel képesek vagyünk
	    megnézni az adott ATA-csatornára
	    csatlakozó eszközök átviteli
	    módjait.  Itt a <em class="replaceable"><code>csatorna</code></em>
	    értéke nullától indul.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76635216"></a><a id="lock-order-reversal"></a><p><strong>5.31.</strong></p></td><td align="left" valign="top"><p>Mi az a <span class="errorname">lock order
	    reversal</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Erre a kérdésre a választ a FreeBSD-s
	    szakkifejezések gyûjteményében
	    találjuk meg a <a class="link" href="../../../../doc/hu_HU.ISO8859-2/books/handbook/freebsd-glossary.html#LOR-GLOSSARY" target="_top">LOR</a>
	    címszó alatt.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76638160"></a><a id="called-with-non-sleepable-locks-held"></a><p><strong>5.32.</strong></p></td><td align="left" valign="top"><p>Mit jelent a <span class="errorname">Called ...  with the following
	    non-sleepable locks held</span> üzenet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez az üzenet arra utalhat, hogy egy
	    függvény lepihent miközben nála volt
	    egy mutex (vagy más, nem pihentethetõ)
	    típusú zárolás.</p><p>Azért keletkezik ilyen hiba, mert a mutexeket nem
	    úgy tervezték, hogy hosszabb ideig is meg
	    lehessen tartani, kizárólag csak rövid
	    idõtartamra vonatkozó
	    szinkronizációt lehet velük
	    végezni.  Ez a programozói megegyezés
	    lehetõvé teszi az eszközmeghajtók
	    számára, hogy a megszakítások
	    közben mutexek segítségével
	    képesek legyenek szinkronizálni a rendszermag
	    többi részével.  A
	    megszakítások (FreeBSD alatt) pedig nem
	    pihenhetnek.  Ezért a rendszermagon belül
	    semmilyen olyan alrendszer nem blokkolódhat
	    huzamosabb ideig, amelyik mutexet tart
	    magánál.</p><p>Ezeket a hibákat úgy tudjuk
	    elcsípni, ha olyan ellenõrzéseket
	    teszünk a rendszermagba, amelyek jeleznek a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=witness&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">witness</span>(4)</span></a> alrendszernek, hogy küldjön
	    figyelmeztetést vagy akár végzetes
	    hibát (a rendszer
	    konfigurációjától
	    függõen) azokban a helyzetekben, amikor egy
	    sejthetõen hosszabb ideig blokkolt hívás
	    tart magánál egy mutexet.</p><p>Röviden úgy foglalhatnánk össze,
	    hogy ezek a hibák alapvetõen nem
	    végzetesek, de egy kis balszerencsével az
	    egyszerû kis megakadásoktól kezdve a
	    teljes lefagyásig szinte bármilyen
	    hibáért felelõsek lehetnek.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp76642640"></a><a id="touch-not-found"></a><p><strong>5.33.</strong></p></td><td align="left" valign="top"><p>A
	    <code class="buildtarget">buildworld</code>/<code class="buildtarget">installworld</code>
	    miért áll le <span class="errorname">touch: not
	    found</span> hibával?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ez a hibaüzenet nem azt jelenti, hogy a
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=touch&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">touch</span>(1)</span></a> segédprogram nem található,
	    hanem inkább azt, hogy az érintett
	    állományok dátuma a jövõre
	    állítódott be.  Ha a CMOS
	    óránkat a helyi idõ szerint
	    állítottuk be, akkor
	    egyfelhasználós módban indítsuk
	    újra a rendszert és a
	    <code class="command">adjkerntz -i</code> parancs
	    kiadásával állítsuk be a
	    rendszermag óráját.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="compatibility-other.html">Vissza</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="commercial.html">Elõre</a></td></tr><tr><td width="40%" align="left" valign="top">4.8. Egyéb eszközök </td><td width="20%" align="center"><a accesskey="h" href="index.html">Fõoldal</a></td><td width="40%" align="right" valign="top"> 6. fejezet - Kereskedelmi alkalmazások</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ha kérdése van a FreeBSD-vel kapcsolatban, a
    következõ címre írhat (angolul):
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Ha ezzel a dokumentummal kapcsolatban van kérdése, kérjük erre a címre írjon:
    &lt;<a href="mailto:gabor@FreeBSD.org">gabor@FreeBSD.org</a>&gt;.</small></p></body></html>