<?xml version="1.0" encoding="iso-8859-2" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2" /><title>13. fejezet - Biztonság</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="up" href="index.html" title="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól" /><link rel="prev" href="networking.html" title="12. fejezet - Hálózatok" /><link rel="next" href="ppp.html" title="14. fejezet - PPP" /><link rel="copyright" href="legalnotice.html" title="Jogi közlemény" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">13. fejezet - Biztonság</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="networking.html">Vissza</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ppp.html">Elõre</a></td></tr></table><hr /></div><div xml:lang="hu" class="chapter" lang="hu"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security"></a>13. fejezet - Biztonság</h1></div></div></div><div class="qandaset"><a id="idp78279888"></a><dl><dt>13.1. <a href="security.html#idp78280144">Mi az a "járóka"
	    (sandbox)?</a></dt><dt>13.2. <a href="security.html#idp78329936">Mi az a biztonsági szint (securelevel)?</a></dt><dt>13.3. <a href="security.html#idp78358608">A BIND (named)
	    különféle nagyobb sorszámú
	    portokat használ.  Miért?</a></dt><dt>13.4. <a href="security.html#idp78365136">A sendmail a
	    szabványos 25-ös port mellett az 587-es portot
	    használja!  Miért?</a></dt><dt>13.5. <a href="security.html#idp78367952">Kié az a nullás felhasználói
	    azonosítójú toor
	    fiók?  Betörtek a gépre?</a></dt><dt>13.6. <a href="security.html#idp78382544">A suidperl parancs miért nem
	    mûködik rendesen?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp78280144"></a><a id="sandbox"></a><p><strong>13.1.</strong></p></td><td align="left" valign="top"><p>Mi az a <span class="quote">"<span class="quote">járóka</span>"</span>
	    (sandbox)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A járóka alapvetõen egy
	    biztonsági szakkifejezés.  Két dolgot
	    jelenthet:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Egy virtuális falak között
		  futó programot, melyeket azért emeltek a
		  program köré, hogy a
		  feltörését követõen
		  megakadályozzák a rendszer többi
		  részének
		  elérését.</p><p>A program csak a falon belül
		  <span class="quote">"<span class="quote">játszhat</span>"</span>.  Ilyenkor semmilyen
		  olyan kódot nem képes futtatni, amellyel
		  át tudna lépni a falakon, így a
		  használatához nem kell elõzetesen
		  átvizsgálni a forrásait ahhoz,
		  hogy meg tudjuk gyõzõdni a
		  biztonságosságáról.</p><p>Ez a fal lehet például egy
		  felhasználói azonosító.  A
		  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=security&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">security</span>(7)</span></a> és <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a> man oldalakon
		  is ezt a definíciót találjuk
		  meg.</p><p>Vegyük például az
		  <code class="literal">ntalk</code> szolgáltatást
		  (lásd <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>).  Ezt a
		  szolgáltatást korábban a
		  <code class="systemitem">root</code> felhasználó
		  azonosítójával futtatták,
		  de manapság viszont már a
		  <code class="systemitem">tty</code> felhasználóval
		  fut.  A <code class="systemitem">tty</code>
		  felhasználó lényegében egy
		  olyan járóka, amely az
		  <code class="literal">ntalk</code> szolgáltatás
		  feltörésekor nem engedi, hogy a rendszer
		  többi részéhez is hozzá
		  lehessen férni.</p></li><li class="listitem"><p>A valódi gépet utánzó
		  rendszerben futó programot.  Ez már egy
		  sokkal kifinomultabb megoldás.  Ha ilyenkor
		  valakinek sikerül betörnie a programba,
		  akkor könnyen azt hiheti, hogy sikerült a
		  rendszer többi részét is
		  elérnie, de valójában csak egy
		  szimulált gépen van, és semmilyen
		  valós adatot nem képes
		  módosítani.</p><p>Leggyakrabban ezt úgy szokták
		  elérni, hogy egy könyvtárban
		  létrehoznak egy szimulált
		  környezetet, majd itt futtatják az adott
		  programot a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chroot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">chroot</span>(8)</span></a>
		  segítségével.  (Ekkor az
		  iménti könyvtár lesz a
		  gyökérkönyvtár az adott
		  folyamat számára, nem pedig a rendszer
		  igazi gyökere.)</p><p>Másik szintén gyakori
		  megoldás a használt
		  állományrendszerek
		  írásvédett
		  csatlakoztatása, amely felett aztán
		  kialakítanak a program számára
		  egy látszólag írható
		  réteget.  Ilyenkor a program teljesen
		  úgy érzékeli, hogy képes a
		  rendszerben elérhetõ
		  állományokat módosítani,
		  azonban egyedül csak saját maga
		  látja ezeket, a rendszerben futó
		  többi program viszont nem
		  feltétlenül.</p><p>Ezeket a járókákat
		  általában úgy szokták
		  felépíteni, hogy a
		  felhasználók (vagy a
		  támadók) számára teljesen
		  észrevétlenek legyenek.</p></li></ul></div><p>A <span class="trademark">UNIX</span>(R) két alapvetõ
	    járókát valósít meg.  Az
	    egyik a futó programok, a másik pedig a
	    felhasználói azonosítók
	    szintjén mûködik.</p><p>Futása közben minden <span class="trademark">UNIX</span>(R) program teljesen
	    elszigetelt minden más <span class="trademark">UNIX</span>(R) programtól,
	    így az egyik nem képes
	    módosítani a másik
	    memóriában tárolt adatait.  A
	    <span class="trademark">Windows</span>(R)-tól eltérõen, ahol
	    ugyebár az egyik program könnyedén el
	    tudja érni egy másik
	    memóriaterületét, ezért a program
	    nem képesek egymásban kárt
	    tenni.</p><p>A <span class="trademark">UNIX</span>(R) alatt futó programok mindig egy adott
	    felhasználóhoz tartoznak.  Ha ez nem a
	    <code class="systemitem">root</code> felhasználó, akkor
	    azzal lényegében egy tûzfalat hozunk
	    létre a különbözõ
	    felhasználók által birtokolt folyamatok
	    között.  A felhasználók
	    azonosítói emellett segítenek a lemezen
	    tárolt adatokat is elszigetelni
	    egymástól.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78329936"></a><a id="securelevel"></a><p><strong>13.2.</strong></p></td><td align="left" valign="top"><p>Mi az a biztonsági szint (securelevel)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A biztonsági szintek egy rendszermagon belül
	    megvalósított védelmi módszert
	    képviselnek.  A pozitív
	    értékû biztonsági szintek
	    esetén a rendszermag korlátoz bizonyos
	    feladatokat, amelyeket ilyenkor még a
	    rendszeradminisztrátor (vagyis a
	    <code class="systemitem">root</code> felhasználó) sem
	    képes elvégezni.  Az írás
	    pillanatában a biztonsági szintek, több
	    más dolog mellett, a következõk
	    szabályozására alkalmasak:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>a különbözõ
		állományjelzõk, például
		az <code class="literal">schg</code> (a <span class="quote">"<span class="quote">system
		immutable</span>"</span> jelzés)
		törlése;</p></li><li class="listitem"><p>a rendszermag memóriájának
		elérése a <code class="filename">/dev/mem</code>
		és <code class="filename">/dev/kmem</code>
		eszközökön keresztül;</p></li><li class="listitem"><p>a rendszermag moduljainak
		betöltése;</p></li><li class="listitem"><p>a tûzfal szabályainak
		módosítása.</p></li></ul></div><p>A jelenleg futó rendszer biztonsági
	    szintjét a következõ parancs
	    segítségével lehet
	    lekérdezni:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>A parancs eredménye az adott <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>
	    változó (vagyis esetünkben a
	    <code class="varname">kern.securelevel</code>) és annak
	    értéke lesz, amely egy szám.  Ez
	    utóbbi adja meg a biztonsági szint
	    aktuális értékét.  Amennyiben ez
	    pozitív (vagyis nullánál nagyobb),
	    akkor érvényben vannak a biztonsági
	    szintekhez kapcsolódó bizonyos
	    korlátozások.</p><p>Egy mûködõ rendszer biztonsági
	    szintjét nem lehet csökkenteni, hiszen ezzel
	    tulajdonképpen hatástalanná
	    tennénk.  Ha olyan feladatot akarunk
	    végrehajtani, amely nem pozitív
	    biztonsági szintet igényel
	    (például az alaprendszer
	    frissítése vagy a dátum
	    átállítása), akkor ahhoz
	    elõször módosítanunk kell az
	    <code class="filename">/etc/rc.conf</code> állományt
	    (lásd <code class="varname">kern_securelevel</code> és
	    <code class="varname">kern_securelevel_enable</code>
	    változók), majd újraindítani a
	    rendszert.</p><p>A biztonsági szintekkel és rájuk
	    vonatkozó információkkal kapcsolatban
	    olvassuk el az <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> man oldalt.</p><div xmlns="" class="warning"><h3 class="admontitle">Figyelem: </h3><p xmlns="http://www.w3.org/1999/xhtml">A biztonsági szintek nem
		feltétlenül jelentenek minden
		problémára tökéletes
		megoldást.  Rentegeg ismert
		hátulütõvel rendelkeznek, és
		gyakran a biztonság hamis érzetét
		keltik.</p><p xmlns="http://www.w3.org/1999/xhtml">Ezzel kapcsolatban az egyik legnagyobb gond, hogy
		csak abban az esetben mûködik rendesen a
		rendszer, ha a rendszerindítás
		során a biztonsági szintek
		beállításáig minden
		állományt levédünk.  Ha a
		támadó képes lefuttatni a
		saját programját még a
		biztonsági szint beállítása
		elõtt (amely viszont elég késõn
		történik meg, hiszen a
		rendszerindítás során számos
		olyan dolog feladat van, amely nem végezhetõ
		el magasabb biztonsági szinteken), akkor azzal az
		egész védelmi módszer
		hatástalanítható.  Habár a
		rendszerindítás folyamán
		felhasznált állományok
		biztonságba helyezése technikailag
		egyáltalán nem lehetetlen,
		nehezebbé válik tõle a rendszer
		karbantartása, mivel ilyenkor az egész
		rendszert át kell állítanunk
		legalább egyfelhasználós
		módba és úgy
		módosítani a konfigurációs
		állományokat.</p><p xmlns="http://www.w3.org/1999/xhtml">Ezt és az ehhez hasonló
		problémák gyakran felmerülnek a
		levelezési listákon,
		különösen a <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-security" target="_top">FreeBSD security levelezési lista</a>
		archívumaiban.  <a class="link" href="../../../../search/index.html" target="_top">Ezen</a> a
		funkción keresztül nézhetünk
		után a téma részletesebb
		tárgyalásának.
		Néhányan reménykednek, hogy a
		biztonsági szinteket hamarosan leváltja
		valami sokkal finomabb beállítási
		lehetõségekkel rendelkezõ
		megoldás, azonban a dolgok még
		eléggé homályosak ebbõl a
		szempontból.</p><p xmlns="http://www.w3.org/1999/xhtml">Figyelmeztettünk mindenkit!</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78358608"></a><a id="extra-named-port"></a><p><strong>13.3.</strong></p></td><td align="left" valign="top"><p>A BIND (<code class="command">named</code>)
	    különféle nagyobb sorszámú
	    portokat használ.  Miért?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A BIND a kimenõ kérésekhez
	    véletlenszerûen kiválaszt egy nagyobb
	    sorszámú portot.  A legújabb
	    változataiban már minden egyes
	    kéréshez külön
	    véletlenszerûen keres új UDP portot.  Ez
	    bizonyos hálózati konfigurációk
	    esetén problémákhoz vezethet,
	    különösen olyankor, amikor a
	    beérkezõ UDP csomagokat egy tûzfal
	    megállítja.  A tûzfalak által
	    blokkolt porttartományok használatát az
	    <code class="literal">avoid-v4-udp-ports</code> vagy az
	    <code class="literal">avoid-v6-udp-ports</code>
	    beállítással tilthatjuk le a program
	    számára.</p><div xmlns="" class="warning"><h3 class="admontitle">Figyelem: </h3><p xmlns="http://www.w3.org/1999/xhtml">Ha ezt a portot (mint például az 53) az
	      <code class="filename">/etc/namedb/named.conf</code>
	      állományban a
	      <code class="literal">query-source</code> vagy a
	      <code class="literal">query-source-v6</code>
	      beállításokkal adjuk meg explicit
	      módon, akkor a program nem fogja
	      véletlenszerûen váltogatni a portokat.
	      Határozottan javasoljuk, hogy ezekkel az
	      opciókkal ne adjunk meg elõre
	      rögzített portokat.</p></div><p>Mindenesetre örülünk, hogy ezt is valaki
	    megkérdezte!  Hiába, nem árt néha
	    nézegetni a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">sockstat</span>(1)</span></a> kimenetét
	    és észrevenni benne néhány
	    furcsaságot.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78365136"></a><a id="sendmail-port-587"></a><p><strong>13.4.</strong></p></td><td align="left" valign="top"><p>A <span class="application">sendmail</span> a
	    szabványos 25-ös port mellett az 587-es portot
	    használja!  Miért?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A <span class="application">sendmail</span> újabb
	    verzióiban felfedezhetõ
	    levélküldési lehetõségek az
	    587-es portot használják.  Jelenleg ezt
	    még nem sokan használják ki, de
	    növekszik a népszerûsége.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78367952"></a><a id="toor-account"></a><p><strong>13.5.</strong></p></td><td align="left" valign="top"><p>Kié az a nullás felhasználói
	    azonosítójú <code class="systemitem">toor</code>
	    fiók?  Betörtek a gépre?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ne aggódjunk!  A <code class="systemitem">toor</code> egy
	    <span class="quote">"<span class="quote">alternatív</span>"</span> rendszergazdai
	    hozzáférés (a <span class="quote">"<span class="quote">toor</span>"</span> a
	    <span class="quote">"<span class="quote">root</span>"</span> visszafelé).  Korábban
	    csak a <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=bash&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">bash</span>(1)</span></a> parancsértelmezõ
	    telepítésekor jött létre, azonban
	    manapság már alapértelmezés
	    szerint létrejön.  A nem szabványos
	    parancsértelmezõk számára
	    találták ki, így nem a
	    <code class="systemitem">root</code> alapértelmezett
	    parancsértelmezõjét kell
	    megváltoztatnunk.  Ez különösen olyan
	    parancsértelmezõk esetén fontos, amelyek
	    nem részei az alaprendszernek (például
	    a portként vagy csomagként telepített
	    parancsértelmezõk esetén) és
	    ezért a <code class="filename">/usr/local/bin</code>
	    könyvtárba fognak kerülni.  Ez a
	    könyvtár alapértelmezés szerint
	    azonban egy külön állományrendszeren
	    található.  Ha a <code class="systemitem">root</code>
	    parancsértelmezõje viszont a <code class="filename">/usr/local/bin</code>
	    könyvtárban lenne, miközben a <code class="filename">/usr</code> (vagy bármelyik
	    más állományrendszer, amely az
	    imént említett könyvtárat
	    tartalmazza) nem csatlakoztatható valamilyen
	    oknál fogva, akkor a <code class="systemitem">root</code> nem
	    lenne képes bejelentkezni és kijavítani
	    a problémát.  (Noha amikor
	    újraindítjuk a rendszerünket
	    egyfelhasználós módban, akkor a
	    rendszer rá fog kérdezni, hogy melyik
	    parancsértelmezõt akarjuk
	    használni.)</p><p>Egyesek nem szabványos
	    parancsértelmezõn keresztül a
	    <code class="systemitem">toor</code> felhasználóval
	    végzik el a <code class="systemitem">root</code> mindennapi
	    teendõit, így a szabványos
	    parancsértelmezõt csak a vészhelyzetekre
	    tartogatják.  Alapértelmezés szerint a
	    <code class="systemitem">toor</code> felhasználóval nem
	    tudunk bejelentkezni, mivel nincs jelszava, ezért ha
	    használni akarjuk, akkor elõször
	    jelentkezzünk be a <code class="systemitem">root</code>
	    felhasználóval, majd állítsunk
	    be neki egy jelszót.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp78382544"></a><a id="suidperl"></a><p><strong>13.6.</strong></p></td><td align="left" valign="top"><p>A <code class="command">suidperl</code> parancs miért nem
	    mûködik rendesen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Biztonsági okokból a
	    <code class="command">suidperl</code> parancs
	    alapértelmezés szerint nem kerül
	    telepítésre.  Ha forrásból
	    frissítjük rendszerünket és azt
	    szeretnénk, hogy ennek során a
	    <code class="command">suidperl</code> is leforduljon, akkor a
	    <code class="command">perl</code> fordításának
	    megkezdése elõtt vegyük fel a
	    <code class="literal">ENABLE_SUIDPERL=true</code>
	    sort az <code class="filename">/etc/make.conf</code>
	    állományba.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="networking.html">Vissza</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ppp.html">Elõre</a></td></tr><tr><td width="40%" align="left" valign="top">12. fejezet - Hálózatok </td><td width="20%" align="center"><a accesskey="h" href="index.html">Fõoldal</a></td><td width="40%" align="right" valign="top"> 14. fejezet - PPP</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Ha kérdése van a FreeBSD-vel kapcsolatban, a
    következõ címre írhat (angolul):
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Ha ezzel a dokumentummal kapcsolatban van kérdése, kérjük erre a címre írjon:
    &lt;<a href="mailto:gabor@FreeBSD.org">gabor@FreeBSD.org</a>&gt;.</small></p></body></html>