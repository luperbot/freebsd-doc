<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Uafhængig Verifikation af IPsec Funktionalitet i FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="Dansk version af Laust S. Jespersen Laust@doc.freebsd.dk. Du installerede IPsec og det ser ud til at virke. Men hvordan ved du det? Jeg beskriver en metode til eksperimentalt at verificere at IPsec virker." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="da" class="article" lang="da"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp60420944"></a>Uafhængig Verifikation af IPsec Funktionalitet i
      FreeBSD</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Honig</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:honig@sprynet.com">honig@sprynet.com</a>&gt;</code></p></div></div></div></div><div>Revision: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD is a registered trademark of
  the FreeBSD Foundation.</p><p>Motif, OSF/1, and UNIX are
  registered trademarks and IT DialTone and The Open Group are
  trademarks of The Open Group in the United States and other
  countries.</p><p>Many of the designations used by
  manufacturers and sellers to distinguish their products are claimed
  as trademarks.  Where those designations appear in this document,
  and the FreeBSD Project was aware of the trademark claim, the
  designations have been followed by the <span class="quote">&#8220;<span class="quote">&#8482;</span>&#8221;</span> or the
  <span class="quote">&#8220;<span class="quote">®</span>&#8221;</span> symbol.</p></div></div><div>  3 Maj 1999 af .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Resumé</div><p><span class="emphasis"><em>Dansk version af Laust S. Jespersen
  <code class="email">&lt;<a xmlns="" class="email" href="mailto:Laust@doc.freebsd.dk">Laust@doc.freebsd.dk</a>&gt;</code>.</em></span></p><p>Du installerede IPsec og det ser ud til at virke.  Men
	hvordan ved du det?  Jeg beskriver en metode til
	eksperimentalt at verificere at IPsec virker.</p></div></div></div><hr /></div><div class="toc"><div class="toc-title">Indholdsfortegnelse</div><dl class="toc"><dt><span class="sect1"><a href="#problem">1. Problemet</a></span></dt><dt><span class="sect1"><a href="#solution">2. Løsningen</a></span></dt><dt><span class="sect1"><a href="#experiment">3. Eksperimentet</a></span></dt><dt><span class="sect1"><a href="#caveat">4. Undtagelse</a></span></dt><dt><span class="sect1"><a href="#IPsec">5. IPsec---Definition</a></span></dt><dt><span class="sect1"><a href="#ipsec-install">6. Installering af IPsec</a></span></dt><dt><span class="sect1"><a href="#kernel">7. src/sys/i386/conf/KERNELNAME</a></span></dt><dt><span class="sect1"><a href="#code">8. Maurers universelle statistiske test (for blok
      størrelse=8 bits)</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="problem"></a>1. Problemet</h2></div></div></div><p>Lad os antage, at du har <a class="link" href="#ipsec-install" title="6. Installering af IPsec">
      installeret <span class="emphasis"><em>IPsec</em></span></a>.  Hvordan ved du
      at det <a class="link" href="#caveat" title="4. Undtagelse">virker</a>?
      Selvfølgelig virker din forbindelse ikke hvis den er
      miskonfigureret, og den vil virke når du endelig laver det
      rigtigt.  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> lister den.  Men kan du verificere det
      uafhængigt?</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="solution"></a>2. Løsningen</h2></div></div></div><p>Først, noget krypto-relevant teoretisk
      information:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>krypterede data er uniformt distribueret, som f.eks. har
	  maksimal entropi pr. symbol;</p></li><li class="listitem"><p>rå, ukomprimerede data er typisk redundant,
	  f.eks., har sub-maksimal entropi.</p></li></ol></div><p>Hvis du kunne måle entropien af dataene til og fra dit
      netværks interface.  Så kunne du se forskellen
      mellem ukrypterede og krypterede data.  Det ville være
      tilfældet selvom nogle af dataene i <span class="quote">&#8220;<span class="quote">krypteret
      mode</span>&#8221;</span> ikke var krypterede, som f.eks. den yderste IP
      header skal være, hvis pakken skal kunne routes.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="MUST"></a>2.1. MUST</h3></div></div></div><p>Ueli Maurers <span class="quote">&#8220;<span class="quote">Universal Statistical Test for Random
	Bit Generators</span>&#8221;</span> (<a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/universal.pdf" target="_top">
	<acronym class="acronym">MUST</acronym></a>) måler hurtigt entropien
	af en stikprøve.  Den bruger en kompressionsagtig
	algoritme.  <a class="link" href="#code" title="8. Maurers universelle statistiske test (for blok størrelse=8 bits)">Forneden angives
	kildekoden</a> til en variant der måler successive
	(~kvart megabyte) store bidder af en fil.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="tcpdump"></a>2.2. Tcpdump</h3></div></div></div><p>Vi har også brug for en måde at opsamle de
	rå netværksdata.  Et program kaldet
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a> lader dig gøre dette, hvis du har slået
	<span class="emphasis"><em>Berkeley Packet Filter</em></span> interfacet til i
	din <a class="link" href="#kernel" title="7. src/sys/i386/conf/KERNELNAME">kerne konfig fil</a>.</p><p>Kommandoen</p><pre class="screen"><strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w dumpfile.bin</code></strong></pre><p>vil opfange 4000 rå pakker til
	<em class="replaceable"><code>dumpfile.bin</code></em>.  Op til 10.000 bytes
	per pakke bliver opfanget i dette eksempel.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="experiment"></a>3. Eksperimentet</h2></div></div></div><p>Her er eksperimentet:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Åbn et vindue til en IPsec vært og et andet
	  vindue til en usikker vært.</p></li><li class="step"><p>Start nu med at <a class="link" href="#tcpdump" title="2.2. Tcpdump">opfange
	  pakker</a>.</p></li><li class="step"><p>I det <span class="quote">&#8220;<span class="quote">sikre</span>&#8221;</span> vindue, køres <span class="trademark">UNIX</span>®
	  kommandoen <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=yes&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">yes</span>(1)</span></a>, hvilket vil streame
	  <code class="literal">y</code> karakteren.  Stop dette efter et stykke
	  tid.  Skift til det usikre vindue, og gentag.  Stop igen efter
	  et stykke tid.</p></li><li class="step"><p>Kør nu <a class="link" href="#code" title="8. Maurers universelle statistiske test (for blok størrelse=8 bits)">MUST</a> på de
	  opfangede pakker.  Du skulle se noget lignende det
	  følgende.  Det vigtige at notere sig er, at den sikre
	  forbindelse har 93% (6,7) af den ventede værdi (7.18),
	  og den <span class="quote">&#8220;<span class="quote">normale</span>&#8221;</span> forbindelse har 29% (2.1) af den
	  ventede værdi.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w ipsecdemo.bin</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>uliscan ipsecdemo.bin</code></strong>

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre></li></ol></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="caveat"></a>4. Undtagelse</h2></div></div></div><p>Dette eksperiment viser at, IPsec <span class="emphasis"><em>kan</em></span>
      se ud til at distribuere payload data
      <span class="emphasis"><em>uniformt</em></span>, som kryptering skal.  Men det
      eksperiment der er beskrevet her <span class="emphasis"><em>kan ikke</em></span>
      detektere mange mulige fejl i et system (ingen af hvilke jeg har
      nogle beviser for).  Disse inkluderer dårlig nøgle
      generering eller udveksling, data eller nøgler der kan
      ses af andre, brug af svage algoritmer, kernel undergravning,
      osv.  Studér kildekoden; kend kildekoden.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="IPsec"></a>5. IPsec---Definition</h2></div></div></div><p>Internet Protokol sikkerheds udvidelser til IPv4;
      krævet for IPv6.  En protokol til at forhandle kryptering
      og autentifikation på IP (vært-til-vært)
      niveau.  SSL sikrer kun en applikationssocket;
      <span class="application">SSH</span> sikrer kun et login;
      <span class="application">PGP</span> sikrer kun en specifik fil eller
      besked.  IPsec krypterer alting mellem to værter.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ipsec-install"></a>6. Installering af IPsec</h2></div></div></div><p>De fleste af de moderne versioner af FreeBSD har IPsec
      support i deres base kildekode.  Så du er sikkert
      nødt til at inkludere <code class="option">IPSEC</code> optionen i
      din kernel konfig og, efter genbygning og reinstallation af
      kernel, konfigurere IPsec forbindelser ved hjælp af
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=setkey&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">setkey</span>(8)</span></a> kommandoen.</p><p>En udførlig guide om at køre IPsec på
      FreeBSD er tilrådighed i <a class="link" href="../../books/handbook/ipsec.html" target="_top">FreeBSD
      Håndbogen</a>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel"></a>7. src/sys/i386/conf/KERNELNAME</h2></div></div></div><p>Dette skal være til stede i kernel konfig filen for at
      være i stand til at opfange netværksdata med
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Vær sikker på at køre
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=config&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">config</span>(8)</span></a> efter at tilføje dette, og genbygge og
      reinstallere.</p><pre class="programlisting">device	bpf</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="code"></a>8. Maurers universelle statistiske test (for blok
      størrelse=8 bits)</h2></div></div></div><p>Du kan finde samme kode på <a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/uliscanc.txt" target="_top">
      dette link</a>.</p><pre class="programlisting">/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1&lt;&lt;L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc &lt; 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i &lt; V; i++) {
    table[i] = 0;
  }

  for (i = 0; i &lt; Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run &amp;&amp; i &lt; Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b &lt; 0)
          run = 0;

        if (run) {
          if (table[b] &gt; j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i &lt; (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i &lt; Q; i++) {
        b = fgetc(fptr);
        if (b &lt; 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}</pre></div></div></body></html>