<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>9. Дополнительный сеанс вопросов и ответов от Аллена Бриггса (Allen Briggs) &lt;briggs@ninthwonder.com&gt;</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Элементы архитектуры системы виртуальной памяти во FreeBSD" /><link rel="up" href="index.html" title="Элементы архитектуры системы виртуальной памяти во FreeBSD" /><link rel="prev" href="conclusion.html" title="8. Заключение" /><link rel="copyright" href="trademarks.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9. Дополнительный сеанс вопросов и ответов от Аллена Бриггса (Allen
      Briggs) <code class="email">&lt;<a xmlns="" class="email" href="mailto:briggs@ninthwonder.com">briggs@ninthwonder.com</a>&gt;</code></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="conclusion.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="allen-briggs-qa"></a>9. Дополнительный сеанс вопросов и ответов от Аллена Бриггса (Allen
      Briggs) <code class="email">&lt;<a xmlns="" class="email" href="mailto:briggs@ninthwonder.com">briggs@ninthwonder.com</a>&gt;</code></h2></div></div></div><div class="qandaset"><a id="idp72178256"></a><dl><dt>9.1. <a href="allen-briggs-qa.html#idp72179280">Что это за "алгоритм чередования", который вы
            упоминали в списке недостатков подсистемы управления разделом
            подкачки во FreeBSD 3.X?</a></dt><dt>9.2. <a href="allen-briggs-qa.html#idp72207568">Как разделение чистых и грязных (неактивных) страниц связано с
            ситуацией, когда вы видите маленький счетчик очереди кэша и
            большой счетчик активной очереди в выдаче команды
	    systat -vm?  Разве системная статистика не
            считает активные и грязные страницы вместе за счетчик активной
            очереди?</a></dt><dt>9.3. <a href="allen-briggs-qa.html#idp72218064">В примере с ls(1) / vmstat 1 могут ли
            некоторые ошибки доступа к странице быть ошибками страниц данных
            (COW из выполнимого файла в приватные страницы)?  То есть я
            полагаю, что ошибки доступа к страницам являются частично ошибками
            при заполнении нулями, а частично данных программы.  Или вы
            гарантируете, что FreeBSD выполняет предварительно COW для данных
            программы?</a></dt><dt>9.4. <a href="allen-briggs-qa.html#idp72234064">В вашем разделе об оптимизации таблицы страниц, не могли бы вы
            более подробно рассказать о pv_entry и
	    vm_page (или vm_page должна быть
	    vm_pmap-как в 4.4, cf. pp. 180-181 of
	    McKusick, Bostic, Karel, Quarterman)?  А именно какое
            действие/реакцию должно потребоваться для сканирования
            отображений?</a></dt><dt>9.5. <a href="allen-briggs-qa.html#idp72280144">Наконец, в разделе о подгонке страниц хорошо бы было
            иметь краткое описание того, что это значит.  Я не совсем это
            понял.</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp72179280"></a><a id="idp72180304"></a><p><strong>9.1.</strong></p></td><td align="left" valign="top"><p>Что это за "алгоритм чередования", который вы
            упоминали в списке недостатков подсистемы управления разделом
            подкачки во FreeBSD 3.X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD использует в области подкачки механизм чередования,
            с индексом по умолчанию, равным четырем.  Это означает, что FreeBSD
            резервирует пространство для четырех областей подкачки, даже если
            у вас имеется всего лишь одна, две или три области.  Так как в
            области подкачки имеется чередование, то линейное адресное
            пространство, представляющее <span class="quote"><<<span class="quote">четыре области подкачки</span>>></span>,
            будет фрагментироваться, если у вас нет на самом деле четырех
            областей подкачки.  Например, если у вас две области A и B, то
            представление адресного пространства для этой области подкачки во
            FreeBSD будет организовано с чередованием блоков из 16
            страниц:</p><div class="literallayout"><p>A B C D A B C D A B C D A B C D</p></div><p>FreeBSD 3.X использует <span class="quote"><<<span class="quote">последовательный список свободных
            областей</span>>></span> для управления свободными областями в разделе
            подкачки.  Идея состоит в том, что большие последовательные блоки
            свободного пространства могут быть представлены при помощи узла
            односвязного списка (<code class="filename">kern/subr_rlist.c</code>).  Но
            из-за фрагментации последовательный список сам становится
            фрагментированным.  В примере выше полностью неиспользуемое
            пространство в A и B будет показано как <span class="quote"><<<span class="quote">свободное</span>>></span>,
            а C и D как <span class="quote"><<<span class="quote">полностью занятое</span>>></span>.  Каждой
            последовательности A-B требуется для учета узел списка, потому что
            C и D являются дырами, так что узел списка не может быть связан
            со следующей последовательностью A-B.</p><p>Почему мы организуем чередование в области подкачки вместо
            того, чтобы просто объединить области подкачки в одно целое и
            придумать что-то более умное?  Потому что гораздо легче выделять
            последовательные полосы адресного пространства и получать в
            результате автоматическое чередование между несколькими дисками,
            чем пытаться выдумывать сложности в другом месте.</p><p>Фрагментация вызывает другие проблемы.  Являясь
            последовательным списком в 3.X и имея такое огромную фрагментацию,
            выделение и освобождение в области подкачки становится алгоритмом
            сложности O(N), а не O(1).  Вместе с другими факторами (частое
            обращение к области подкачки) вы получаете сложность уровней O(N^2)
            и O(N^3), что плохо.  В системе 3.X также может потребоваться
            выделение KVM во время работы с областью подкачки для создания
            нового узла списка, что в условии нехватки памяти может привести к
            блокировке, если система попытается сбросить страницы в область
            подкачки.</p><p>В 4.X мы не используем последовательный список.  Вместо этого
            мы используем базисное дерево и битовые карты блоков области
            подкачки, а не ограниченный список узлов.  Мы принимаем
            предварительное выделение всех битовых карт, требуемых для всей
            области подкачки, но при этом тратится меньше памяти, потому что
            мы используем битовые карты (один бит на блок), а не связанный
            список узлов.  Использование базисного дерева вместо
            последовательного списка дает нам производительность O(1) вне
            зависимости от фрагментации дерева.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp72207568"></a><a id="idp72208080"></a><p><strong>9.2.</strong></p></td><td align="left" valign="top"><p>Как разделение чистых и грязных (неактивных) страниц связано с
            ситуацией, когда вы видите маленький счетчик очереди кэша и
            большой счетчик активной очереди в выдаче команды
	    <code class="command">systat -vm</code>?  Разве системная статистика не
            считает активные и грязные страницы вместе за счетчик активной
            очереди?</p><p>Я не понял следующее:</p><div class="blockquote"><blockquote class="blockquote"><p>Стоит отметить, что во FreeBSD VM-система пытается разделить
              чистые и грязные страницы во избежание срочной необходимости в
              ненужных сбросах грязных страниц (что отражается на пропускной
              способности ввода/вывода) и не перемещает беспричинно страницы
              между разными очередями, когда подсистема управления памятью не
              испытывает нехватку ресурсов.  Вот почему вы можете видеть, что
              при выполнении команды <code class="command">systat -vm</code> в некоторых
              системах значение счетчика очереди кэша мало, а счетчик активной
              очереди большой.</p></blockquote></div></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Да, это запутывает.  Связь заключается в "желаемом"
	    и "действительном".  Мы желаем разделить страницы, но
            реальность такова, что пока у нас нет проблем с памятью, нам это на
            самом деле не нужно.</p><p>Это означает, что FreeBSD не будет очень сильно стараться над
            отделением грязных страниц (неактивная очередь) от чистых страниц
            (очередь кэша), когда система не находится под нагрузкой, и не
            будет деактивировать страницы (активная очередь -&gt; неактивная
            очередь), когда система не нагружена, даже если они не
            используются.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp72218064"></a><a id="idp72218320"></a><p><strong>9.3.</strong></p></td><td align="left" valign="top"><p>В примере с <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> / <code class="command">vmstat 1</code> могут ли
            некоторые ошибки доступа к странице быть ошибками страниц данных
            (COW из выполнимого файла в приватные страницы)?  То есть я
            полагаю, что ошибки доступа к страницам являются частично ошибками
            при заполнении нулями, а частично данных программы.  Или вы
            гарантируете, что FreeBSD выполняет предварительно COW для данных
            программы?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ошибка COW может быть ошибкой при заполнении нулями или данных
            программы.  Механизм в любом случае один и тот же, потому что
            хранилище данных программы уже в кэше.  Я на самом деле не рад
            ни тому, ни другому.  FreeBSD не выполняет предварительное COW
            данных программы и заполнение нулями, но она
            <span class="emphasis"><em>выполняет</em></span> предварительно отображение страниц,
            которые имеются в ее кэше.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp72234064"></a><a id="idp72234704"></a><p><strong>9.4.</strong></p></td><td align="left" valign="top"><p>В вашем разделе об оптимизации таблицы страниц, не могли бы вы
            более подробно рассказать о <code class="literal">pv_entry</code> и
	    <code class="literal">vm_page</code> (или vm_page должна быть
	    <code class="literal">vm_pmap</code>-как в 4.4, cf. pp. 180-181 of
	    McKusick, Bostic, Karel, Quarterman)?  А именно какое
            действие/реакцию должно потребоваться для сканирования
            отображений?</p><p>Что делает Linux в тех случаях, когда FreeBSD работает плохо
	    (совместное использование отображения файла между многими
            процессами)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="literal">vm_page</code> представляет собой пару
            (object,index#).  <code class="literal">pv_entry</code> является записью из
            аппаратной таблицы страниц (pte).  Если у вас имеется пять
            процессов, совместно использующих одну и ту же физическую страницу,
            и в трех таблицах страниц этих процессов на самом деле отображается
            страница, то страница будет представляться одной структурой
	    <code class="literal">vm_page</code> и тремя структурами
            <code class="literal">pv_entry</code>.</p><p>Структуры <code class="literal">pv_entry</code> представляют страницы,
            отображаемые MMU (одна структура <code class="literal">pv_entry</code>
            соответствует одной pte).  Это означает, что, когда нам нужно
            убрать все аппаратные ссылки на <code class="literal">vm_page</code> (для
            того, чтобы повторно использовать страницу для чего-то еще,
            выгрузить ее, очистить, пометить как грязную и так далее), мы
            можем просто просмотреть связный список структур
	    <code class="literal">pv_entry</code>, связанных с этой
            <code class="literal">vm_page</code>, для того, чтобы удалить или изменить
            pte из их таблиц страниц.</p><p>В Linux нет такого связного списка.  Для того, чтобы удалить
            все отображения аппаратной таблицы страниц для
            <code class="literal">vm_page</code>, linux должен пройти по индексу каждого
            объекта VM, который <span class="emphasis"><em>может</em></span> отображать страницу.
            К примеру, если у вас имеется 50 процессов, которые все отображают
            ту же самую динамическую библиотеку и хотите избавиться от страницы
            X в этой библиотеке, то вам нужно пройтись по индексу всей таблицы
            страниц для каждого из этих 50 процессов, даже если только 10 из
            них на самом деле отображают страницу.  Так что Linux использует
            простоту подхода за счет производительности.  Многие алгоритмы VM,
            которые имеют сложность O(1) или (N малое) во FreeBSD, в Linux
            приобретают сложность O(N), O(N^2) или хуже.  Так как pte,
            представляющий конкретную страницу в объекте, скорее всего, будет
            с тем же смещением во всех таблицах страниц, в которых они
            отображаются, то уменьшение количества обращений в таблицы страниц
            по тому же самому смещению часто позволяет избежать разрастания
            кэша L1 для этого смещения, что приводит к улучшению
            производительности.</p><p>Во FreeBSD введены дополнительные сложности (схема с
            <code class="literal">pv_entry</code>) для увеличения производительности
            (уменьшая количество обращений <span class="emphasis"><em>только</em></span> к тем
            pte, которые нужно модифицировать).</p><p>Но во FreeBSD имеется проблема масштабирования, которой нет в
            Linux, потому что имеется ограниченное число структур
            <code class="literal">pv_entry</code>, и это приводит к возникновению проблем
            при большом объеме совместно используемых данных.  В этом случае
            у вас может возникнуть нехватка структур
            <code class="literal">pv_entry</code>, даже если свободной памяти хватает.
            Это может быть достаточно легко исправлено увеличением количества
            структур <code class="literal">pv_entry</code> при настройке, но на самом
            деле нам нужно найти лучший способ делать это.</p><p>Что касается использования памяти под таблицу страниц против
            схемы с <code class="literal">pv_entry</code>: Linux использует
	    <span class="quote"><<<span class="quote">постоянные</span>>></span> таблицы страниц, которые не сбрасываются,
            но ему не нужны <code class="literal">pv_entry</code> для каждого
            потенциально отображаемого pte.  FreeBSD использует
            <span class="quote"><<<span class="quote">сбрасываемые</span>>></span> таблицы страниц, но для каждого
            реально отображаемого pte добавляется структура
            <code class="literal">pv_entry</code>.  Я думаю, что использование памяти
            будет примерно одинакова, тем более что у FreeBSD есть
            алгоритмическое преимущество, заключающееся в способности
            сбрасывать таблицы страниц с очень малыми накладными
            расходами.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp72280144"></a><a id="idp72281168"></a><p><strong>9.5.</strong></p></td><td align="left" valign="top"><p>Наконец, в разделе о подгонке страниц хорошо бы было
            иметь краткое описание того, что это значит.  Я не совсем это
            понял.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Знаете ли вы, как работает аппаратный кэш памяти L1?  Объясняю:
            Представьте машину с 16МБ основной памяти и только со 128К памяти
            кэша L1.  В общем, этот кэш работает так, что каждый блок по 128К
            основной памяти использует <span class="emphasis"><em>те же самые</em></span> 128К
            кэша.  Если вы обращаетесь к основной памяти по смещению 0, а затем
            к основной памяти по смещению 128К, вы перезаписываете данные кэша,
            прочтенные по смещению 0!</p><p>Я очень сильно все упрощаю.  То, что я только что описал,
            называется <span class="quote"><<<span class="quote">напрямую отображаемым</span>>></span> аппаратным кэшем
            памяти.  Большинство современных кэшей являются так называемыми
            2-сторонними множественными ассоциативными или 4-сторонними
            множественными ассоциативными кэшами.  Множественная
            ассоциативность позволяет вам обращаться к вплоть до N различным
            областям памяти, которые используют одну и ту же память кэша без
            уничтожения ранее помещенных в кэш данных.  Но только N.</p><p>Так что если у меня имеется 4-сторонний ассоциативный кэш, я
            могу обратиться к памяти по смещению 0, смещению 128К, 256К и
            смещению 384K, затем снова обратиться к памяти по смещению 0 и
            получу ее из кэша L1.  Однако, если после этого я обращусь к памяти
            по смещению 512К, один из ранее помещенных в кэш объектов данных
            будет из кэша удален.</p><p>Это чрезвычайно важно... для большинства обращений к
            памяти процессора <span class="emphasis"><em>чрезвычайно</em></span> важно, чтобы
            данные находились в кэше L1, так как кэш L1 работает на тактовой
            частоте работы процессора.  В случае, если данных в кэше L1 не
            обнаруживается, и они ищутся в кэше L2 или в основной памяти,
            процессор будет простаивать, или, скорее, сидеть, сложив ручки,
            в ожидании окончания чтения из основной памяти, хотя за это время
            можно было выполнить <span class="emphasis"><em>сотни</em></span> операций.  Основная
            память (динамическое ОЗУ, которое установлено в компьютере)
            работает по сравнению со скоростью работы ядра современных
            процессоров <span class="emphasis"><em>медленно</em></span>.</p><p>Хорошо, а теперь рассмотрим подгонку страниц: Все современные
            кэши памяти являются так называемыми
            <span class="emphasis"><em>физическими</em></span> кэшами.  Они кэшируют адреса
            физической памяти, а не виртуальной.  Это позволяет кэшу не
            принимать во внимание переключение контекстов процессов, что очень
            важно.</p><p>Но в мире <span class="trademark">UNIX</span>(R) вы работаете с виртуальными адресными
            пространствами, а не с физическими.  Любая программа, вами
            написанная, имеет дело с виртуальным адресным пространством, ей
            предоставленным.  Реальные <span class="emphasis"><em>физические</em></span>
            страницы, соответствующие виртуальному адресному пространству, не
            обязательно расположены физически последовательно!  На самом деле
            у вас могут оказаться две страницы, которые в адресном пространстве
            процессов являются граничащими, но располагающимися по смещению 0 и
            по смещению 128К в <span class="emphasis"><em>физической</em></span> памяти.</p><p>Обычно программа полагает, что две граничащие страницы будут
            кэшироваться оптимально.  То есть вы можете обращаться к объектам
            данных в обеих страницах без замещений в кэше данных друг друга.
            Но это имеет место, если только физические страницы,
            соответствующие виртуальному адресному пространству, располагаются
            рядом (в такой мере, что попадают в кэш).</p><p>Это именно то, что выполняет подгонка.  Вместо того,
            чтобы назначать <span class="emphasis"><em>случайные</em></span> физические страницы
            виртуальным адресам, что может привести к неоптимальной работе
            кэша, при подгонке страниц виртуальным адресам назначаются
            <span class="emphasis"><em>примерно подходящие по порядку</em></span> физические
            страницы.  Таким образом, программы могут писаться в предположении,
            что характеристики низлежащего аппаратного кэша для виртуального
            адресного пространства будут такими же, как если бы программа
            работала непосредственно в физическом адресном пространстве.</p><p>Заметьте, что я сказал <span class="quote"><<<span class="quote">примерно</span>>></span> подходящие, а не
            просто <span class="quote"><<<span class="quote">последовательные</span>>></span>.  С точки зрения напрямую
            отображаемого кэша в 128К, физический адрес 0 одинаков с физическим
            адресом 128К.  Так что две граничащие страницы в вашем виртуальном
            адресном пространстве могут располагаться по смещению 128К и 132К
            физической памяти, но могут легко находиться по смещению 128К и по
            смещению 4К физической памяти, и иметь те же самые характеристики
            работы кэша.  Так что при подгонке <span class="emphasis"><em>не
            нужно</em></span> назначать в действительности последовательные
            страницы физической памяти последовательным страницам виртуальной
            памяти, достаточно просто добиться расположения страниц по
            соседству друг с другом с точки зрения работы кэша.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="conclusion.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">8. Заключение </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>