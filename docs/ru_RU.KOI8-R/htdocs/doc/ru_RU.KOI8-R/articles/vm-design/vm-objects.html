<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>2. Объекты VM</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Элементы архитектуры системы виртуальной памяти во FreeBSD" /><link rel="up" href="index.html" title="Элементы архитектуры системы виртуальной памяти во FreeBSD" /><link rel="prev" href="index.html" title="Элементы архитектуры системы виртуальной памяти во FreeBSD" /><link rel="next" href="swap-layers.html" title="3. Уровни области подкачки" /><link rel="copyright" href="trademarks.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Объекты VM</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="swap-layers.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="vm-objects"></a>2. Объекты VM</h2></div></div></div><p>Лучше всего начать описание VM-системы FreeBSD с попытки взглянуть на
      нее с точки зрения пользовательского процесса.  Каждый пользовательский
      процесс имеет единое, принадлежащее только ему и неразрывное адресное
      пространство VM, содержащее несколько типов объектов памяти.  Эти объекты
      имеют различные характеристики.  Код программы и ее данные являются
      единым файлом, отображаемым в память (это выполняющийся двоичный файл),
      однако код программы доступен только для чтения, когда как данные
      программы размещаются в режиме копирования-при-записи.  BSS программы
      представляет собой всего лишь выделенную область памяти, заполненную,
      если это требовалось, нулями, что называется обнулением страниц памяти
      по требованию.  Отдельные файлы могут также отображаться в адресное
      пространство, именно так работают динамические библиотеки.  Такие
      отображения требуют изменений, чтобы оставаться принадлежащими процессу,
      который их выполнил.  Системный вызов fork добавляет переводит проблему
      управления VM полностью в новую плоскость, вдобавок к уже имеющимся
      сложностям.</p><p>Иллюстрирует сложность страница данных двоичной программы (которая
      является страницей копируемой-при-записи).  Двоичная программа содержит
      секцию предварительно инициализированных данных, которая первоначально
      отображается непосредственно из файла программы.  Когда программа
      загружается в Vm-пространство процесса, эта область сначала отображается
      в память и поддерживается бинарным файлом программы, позволяя VM-системе
      освобождать/повторно использовать страницу, а потом загружать ее снова
      из бинарного файла.  Однако в момент, когда процесс изменяет эти данные,
      VM-система должна сделать копию страницы, принадлежащую только этому
      процессу.  Так как эта копия была изменена, то VM-система не может больше
      освобождать эту страницу, так как впоследствии ее невозможно будет
      восстановить.</p><p>Вы тут же заметите, что то, что сначала было простым отображением
      файла в память, становится гораздо более сложным предметом.  Данные могут
      модифицироваться постранично, когда как отображение файла выполняется для
      многих страниц за раз.  Сложность еще более увеличивается, когда процесс
      выполняет вызов fork.  При этом порождаются два процесса-каждый со
      с собственным адресным пространством, включающим все изменения,
      выполненные исходным процессом до вызова функции
      <code class="function">fork()</code>.  Было бы глупо для VM-системы делать полную
      копию данных во время вызова <code class="function">fork()</code>, так как весьма
      вероятно, что один из двух процессов будет нужен только для чтения из
      той страницы, что позволяет использование исходной страницы.  То, что
      было страницей, принадлежащей только процессу, сделается снова страницей,
      копируемой при записи, так как каждый из процессов (и родитель, и
      потомок) полагают, что их собственные изменения после разветвления будут
      принадлежать только им, и не затронут родственный процесс.</p><p>FreeBSD управляет всем этим при помощи многоуровневой модели
      VM-объектов.  Исходный файл с двоичной программой переносится на самый
      нижний уровень объектов VM.  Уровень страниц, копируемых при записи,
      находится выше него, и хранит те страницы, которые были скопированы из
      исходного файла.  Если программа модифицирует страницы данных,
      относящиеся к исходному файлу, то система VM обнаруживает это и переносит
      копию этой страницы на более высокий уровень.  Когда процесс
      разветвляется, добавляются новые уровни VM-объектов.  Это можно показать
      на простом примере.  Функция <code class="function">fork()</code> является общей
      операцией для всех систем *BSD, так что в этом примере будет
      рассматриваться программа, которая запускается, а затем разветвляется.
      Когда процесс запускается, VM-система создает некоторый уровень объектов,
      обозначим его A:</p><div class="mediaobject"><img src="fig1.png" alt="Рисунок" /></div><p>A соответствует файлу-по необходимости страницы памяти могут
      высвобождаться и подгружаться с носителя файла.  Подгрузка с диска
      может потребоваться программе, однако на самом деле мы не хотим, чтобы
      она записывалась обратно в файл.  Поэтому VM-система создает второй
      уровень, B, который физически поддерживается дисковым пространством
      подкачки:</p><div class="mediaobject"><img src="fig2.png" /></div><p>При первой записи в страницу после выполнения этой операции, в B
      создается новая страница, содержимое которой берется из A.  Все страницы
      в B могут сбрасываться и считываться из устройства подкачки.  Когда
      программа ветвится, VM-система создает два новых уровня объектов-C1
      для порождающего процесса и C2 для порожденного-они располагаются
      поверх B:</p><div class="mediaobject"><img src="fig3.png" /></div><p>В этом случае, допустим, что страница в B была изменена начальным
      родительским процессом.  В процессе возникнет ситуация копирования при
      записи и страница скопируется в C1, при этом исходная страница останется
      в B нетронутой.  Теперь допустим, что та же самая страница в B изменяется
      порожденным процессом.  В процессе возникнет ситуация копирования при
      записи и страница скопируется в C2.  Исходная страница в B теперь
      полностью скрыта, так как и C1, и C2 имеют копии, а B теоретически может
      быть уничтожена, если она не представляет собой <span class="quote"><<<span class="quote">реального</span>>></span>
      файла).
      Однако такую оптимизацию не так уж просто осуществить, потому что она
      делается на уровне мелких единиц.  Во FreeBSD такая оптимизация не
      выполняется.  Теперь положим (а это часто случается), что порожденный
      процесс выполняет вызов <code class="function">exec()</code>.  Его текущее
      адресное пространство обычно заменяется новым адресным пространством,
      представляющим новый файл.  В этом случае уровень C2 уничтожается:</p><div class="mediaobject"><img src="fig4.png" /></div><p>В этом случае количество потомков B становится равным одному и все
      обращения к B теперь выполняются через C1.  Это означает, что B и C1
      могут быть объединены.  Все страницы в B, которые также существуют и в
      C1, во время объединения из B удаляются.  Таким образом, хотя оптимизация
      на предыдущем шаге может не делаться, мы можем восстановить мертвые
      страницы при окончании работы процессов или при вызове
      <code class="function">exec()</code>.</p><p>Такая модель создает некоторое количество потенциальных проблем.
      Первая, с которой вы можете столкнуться, заключается в сравнительно
      большой последовательности уровней объектов VM, на сканирование которых
      тратится время и память.  Большое количество уровней может возникнуть,
      когда процессы разветвляются, а затем разветвляются еще раз (как
      порожденные, так и порождающие).  Вторая проблема заключается в том, что
      вы можете столкнуться с мертвыми, недоступными страницами глубоко в
      иерархии объектов VM.  В нашем последнем примере если как родитель, так
      и потомок изменяют одну и ту же страницу, они оба получают собственные
      копии страницы, а исходная страница в B становится никому не доступной.
      такая страница в B может быть высвобождена.</p><p>FreeBSD решает проблему с глубиной вложенности с помощью приема
      оптимизации, который называется "All Shadowed Case".  Этот
      случай возникает, если в C1 либо C2 возникает столько случаев копирования
      страниц при записи, что они полностью закрывают все страницы в B.
      Допустим, что такое произошло в C1.  C1 может теперь полностью заменить
      B, так что вместо цепочек C1-&gt;B-&gt;A и C2-&gt;B-&gt;A мы теперь имеем цепочки
      C1-&gt;A и C2-&gt;B-&gt;A.  Но посмотрите, что получается-теперь B имеет
      только одну ссылку (C2), так что мы можем объединить B и C2.  В конечном
      итоге B будет полностью удален и мы имеем цепочки C1-&gt;A и C2-&gt;A.  Часто B
      будет содержать большое количество страниц, и ни C1, ни C2 не смогут
      полностью их заменить.  Если мы снова породим процесс и создадим набор
      уровней D, при этом, однако, более вероятно, что один из уровней D
      постепенно сможет полностью заместить гораздо меньший набор данных,
      представленный C1 и C2.  Та же самая оптимизация будет работать в любой
      точке графа и главным результатом этого является то, что даже на сильно
      загруженной машине с множеством порождаемых процессов стеки объектов VM
      не часто бывают глубже четырех уровней.  Это так как для порождающего,
      так и для порожденного процессов, и остается в силе как в случае, когда
      ветвление делает родитель, так и в случае, когда ветвление выполняет
      потомок.</p><p>Проблема с мертвой страницей все еще имеет место, когда C1 или C2
      не полностью перекрывают B.  Из-за других применяемых нами методов
      оптимизации этот случай не представляет большой проблемы и мы просто
      позволяем таким страницам существовать.  Если система испытывает нехватку
      оперативной памяти, она выполняет их выгрузку в область подкачки, что
      занимает некоторое пространство в области подкачки, но это все.</p><p>Преимущество модели VM-объектов заключается в очень быстром
      выполнении функции <code class="function">fork()</code>, так как при этом не
      выполняется реального копирования данных.  Минусом этого подхода является
      то, что вы можете построить сравнительно сложную иерархию объектов VM,
      которая несколько замедляет обработку ситуаций отсутствия страниц памяти,
      и к тому же тратится память на управление структурами объектов VM.
      Приемы оптимизации, применяемые во FreeBSD, позволяют снизить значимость
      этих проблем до степени, когда их можно без особых потерь
      игнорировать.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="swap-layers.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Элементы архитектуры системы виртуальной памяти во FreeBSD </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> 3. Уровни области подкачки</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>