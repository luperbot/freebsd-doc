<?xml version="1.0" encoding="koi8-r"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>Независимое исследование работы IPsec во FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><meta name="description" content="Вы только что установили и настроили IPsec, и оно, кажется, заработало. Как это можно проверить? Я опишу метод экспериментальной проверки правильного функционирования IPsec." /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="ru" class="article" lang="ru"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp69635408"></a>Независимое исследование работы IPsec во FreeBSD</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Honig</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a xmlns="" class="email" href="mailto:honig@sprynet.com">honig@sprynet.com</a>&gt;</code></p></div></div></div></div><div>Издание: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="trademarks"></a><p>FreeBSD это зарегистрированная торговая
  марка FreeBSD Foundation.</p><p>Motif, OSF/1 и UNIX это
  зарегистрированные торговые марки, а IT DialTone и The Open Group это
  торговые марки Open Group в Соединенных Штатах и других
  странах.</p><p>Многие из обозначений, используемые
  производителями и продавцами для обозначения своих продуктов, заявляются
  в качестве торговых марок.  Когда такие обозначения появляются в этом
  документе, и Проекту FreeBSD известно о торговой марке, к обозначению
  добавляется знак <span class="quote"><<<span class="quote">TM</span>>></span> или
  <span class="quote"><<<span class="quote">(R)</span>>></span>.</p></div></div><div>  1999-05-03  .</div><div><div xmlns="http://www.w3.org/1999/xhtml" class="abstract"><div class="abstract-title">Аннотация</div><p>Вы только что установили и настроили IPsec, и оно,
	кажется, заработало.  Как это можно проверить?  Я опишу метод
	экспериментальной проверки правильного функционирования
	IPsec.</p></div></div></div><hr /></div><div class="toc"><div class="toc-title">Содержание</div><dl class="toc"><dt><span class="sect1"><a href="#problem">1. Постановка задачи</a></span></dt><dt><span class="sect1"><a href="#solution">2. Решение</a></span></dt><dt><span class="sect1"><a href="#experiment">3. Эксперимент</a></span></dt><dt><span class="sect1"><a href="#caveat">4. Замечание</a></span></dt><dt><span class="sect1"><a href="#IPsec">5. Определение IPsec</a></span></dt><dt><span class="sect1"><a href="#ipsec-install">6. Установка IPsec</a></span></dt><dt><span class="sect1"><a href="#kernel">7. src/sys/i386/conf/KERNELNAME</a></span></dt><dt><span class="sect1"><a href="#code">8. Универсальный Статистический Тест Маурера (размер блока
      - 8 бит)</a></span></dt></dl></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="problem"></a>1. Постановка задачи</h2></div></div></div><p>Для начала предположим, что Вы <a class="link" href="#ipsec-install" title="6. Установка IPsec">
      настроили <span class="emphasis"><em>IPsec</em></span></a>.  Как Вы
      узнаете, что IPsec <a class="link" href="#caveat" title="4. Замечание">работает</a>?
      Несомненно, соединения не будет, если Вы неверно его
      сконфигурировали.  И оно, конечно, появится в выводе команды
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>, когда Вы всё сделаете верно.  Но можно ли
      как-то подтвердить сам факт функционирования IPsec?</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="solution"></a>2. Решение</h2></div></div></div><p>Для начала немножко криптографической теории:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Шифрованные данные равномерно распределены по области
	  определения, то есть каждый символ имеет максимальную
	  энтропию;</p></li><li class="listitem"><p><span class="quote"><<<span class="quote">Сырые</span>>></span> и несжатые данные как правило
	  избыточны, то есть их энтропия меньше максимально
	  возможной.</p></li></ol></div><p>Предположим, что у Вас имеется возможность измерить энтропию
      входящего и исходящего трафика на сетевом интерфейсе.  В этом
      случае Вы сможете легко отличить зашифрованные данные от
      открытых, причём даже в том случае, когда часть данных в
      <span class="quote"><<<span class="quote">режиме шифрования</span>>></span> передаётся в открытом виде, к
      примеру внешние заголовки IP, которые используются для
      маршрутизации.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="MUST"></a>2.1. MUST</h3></div></div></div><p><span class="quote"><<<span class="quote">Универсальный Статистический Тест для Генераторов
	Случайных Чисел</span>>></span> Уэли Маурера (Ueli Maurer's Universal
	Statistical Test for Random Bit Generators), сокращённо <a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/universal.pdf" target="_top">
	<acronym class="acronym">MUST</acronym></a> позволяет быстро измерить
	энтропию последовательного набора данных.  Используемый
	алгоритм похож на алгоритм сжатия.  <a class="link" href="#code" title="8. Универсальный Статистический Тест Маурера (размер блока - 8 бит)">В
	приложении</a> приведён исходный код, позволяющий измерять
	энтропию последовательных кусков данных размером около
	четверти мегабайта.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="tcpdump"></a>2.2. Tcpdump</h3></div></div></div><p>Ещё нам нужен способ сохранения информации,
	проходящей через интерфейс.  Программа <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>
	позволяет сделать это в случае, если Вы <a class="link" href="#kernel" title="7. src/sys/i386/conf/KERNELNAME">сконфигурировали своё ядро</a> с
	поддержкой <span class="emphasis"><em>Пакетного Фильтра Беркли (Berkeley Packet
	Filter)</em></span>.</p><p>Команда</p><pre class="screen"><strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w <em class="replaceable"><code>dumpfile.bin</code></em></code></strong></pre><p>сохранит 4000 пакетов в файл
	<em class="replaceable"><code>dumpfile.bin</code></em>.  В данном примере объём
	записываемой информации в каждом пакете не может превышать
	10,000 байтов.</p></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="experiment"></a>3. Эксперимент</h2></div></div></div><p>Повторите следующие шаги эксперимента:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Откройте два окна терминала и свяжитесь в одном из них с
	  каким-нибудь компьютером через канал IPsec, а в другом - с
	  обычным, <span class="quote"><<<span class="quote">незащищённым</span>>></span> компьютером.</p></li><li class="step"><p>Теперь начните <a class="link" href="#tcpdump" title="2.2. Tcpdump">сохранять
	  пакеты</a>.</p></li><li class="step"><p>В <span class="quote"><<<span class="quote">шифрованном</span>>></span> окне запустите команду <span class="trademark">UNIX</span>(R)
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=yes&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">yes</span>(1)</span></a>, которая будет выдавать бесконечный
	  поток символов <code class="literal">y</code>.  Немножко подождите и
	  завершите её.  Затем переключитесь в обычное окно (не
	  использующее канал IPsec) и сделайте то же самое.</p></li><li class="step"><p>Заключительный этап: запустите <a class="link" href="#code" title="8. Универсальный Статистический Тест Маурера (размер блока - 8 бит)">
	    MUST</a>, передав ему для обработки только что
	  сохранённые пакеты через командную строку.  Вы должны
	  увидеть что-то вроде изображённого чуть ниже.  Заметьте, что
	  безопасное соединение имеет 93% (6,7) от ожидаемого значения
	  (7,18), а обычное соединение - всего лишь 29%
	  (2,1).</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tcpdump -c 4000 -s 10000 -w <em class="replaceable"><code>ipsecdemo.bin</code></em></code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>uliscan <em class="replaceable"><code>ipsecdemo.bin</code></em></code></strong>

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre></li></ol></div></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="caveat"></a>4. Замечание</h2></div></div></div><p>Этот эксперимент показывает, что IPsec
      <span class="emphasis"><em>действительно</em></span> распределяет передаваемые
      байты по области определения <span class="emphasis"><em>равномерно</em></span>,
      как и любое другое шифрование.  Однако этот метод <span class="emphasis"><em>не
      может</em></span> обнаружить множество других изъянов в системе
      (хотя я таковых не знаю).  Для примера можно привести плохие
      алгоритмы генерации или обмена ключами, нарушение
      конфиденциальности данных или ключей, использование слабых в
      криптографическом смысле алгоритмов, взлом ядра и т. д.  Изучайте
      исходный код, узнавайте, что там происходит.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="IPsec"></a>5. Определение IPsec</h2></div></div></div><p>IPsec представляет собой протокол безопасного обмена
      информацией по Internet.  Существует в виде расширения к IPv4;
      является неотъемлемой частью IPv6.  Содержит в себе протокол
      шифрования и аутентификации на уровне IP (межмашинное
      <span class="quote"><<<span class="quote">host-to-host</span>>></span> взаимодействие).  SSL защищает
      только лишь конкретный прикладной сокет;
      <span class="application">SSH</span> защищает вход на машину;
      <span class="application">PGP</span> защищает определённый файл или
      письмо.  IPsec шифрует всю информацию, передаваемую между двумя
      машинами.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ipsec-install"></a>6. Установка IPsec</h2></div></div></div><p>Большинство современных версий FreeBSD уже имеют поддержку
      IPsec.  Вероятно, Вы должны будете лишь добавить опцию
      <code class="option">IPsec</code> в конфигурационный файл ядра, и после
      сборки и инсталляции нового ядра, сконфигурировать соединение
      IPsec с помощью команды <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=setkey&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">setkey</span>(8)</span></a>.</p><p>Более подробно о том, как запустить IPsec во FreeBSD можно
      прочесть в <a class="link" href="../../../../doc/ru_RU.KOI8-R/books/handbook/ipsec.html" target="_top">Руководстве
      пользователя</a>.</p></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="kernel"></a>7. src/sys/i386/conf/KERNELNAME</h2></div></div></div><p>Для того, чтобы захватывать сетевой трафик при помощи
      <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>, следующие строки должны присутствовать
      в конфигурационном файле ядра.  Не
      забудьте после модификации запустить <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=config&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">config</span>(8)</span></a>, и, как
      обычно, пересобрать и установить новое ядро.</p><pre class="programlisting">device	bpf</pre></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="code"></a>8. Универсальный Статистический Тест Маурера (размер блока
      - 8 бит)</h2></div></div></div><p>Оригинал нижеприведённого кода находится по <a class="link" href="http://www.geocities.com/SiliconValley/Code/4704/uliscanc.txt" target="_top">
        этому адресу</a>.</p><pre class="programlisting">/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1&lt;&lt;L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc &lt; 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i &lt; V; i++) {
    table[i] = 0;
  }

  for (i = 0; i &lt; Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run &amp;&amp; i &lt; Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b &lt; 0)
          run = 0;

        if (run) {
          if (table[b] &gt; j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i &lt; (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i &lt; Q; i++) {
        b = fgetc(fptr);
        if (b &lt; 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}</pre></div></div></body></html>