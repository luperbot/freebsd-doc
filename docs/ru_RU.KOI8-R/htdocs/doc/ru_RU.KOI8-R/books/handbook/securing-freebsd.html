<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>14.3. Защита FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Руководство FreeBSD" /><link rel="up" href="security.html" title="Глава 14. Безопасность" /><link rel="prev" href="security-intro.html" title="14.2. Введение" /><link rel="next" href="crypt.html" title="14.4. DES, MD5, и шифрование" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">14.3. Защита FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Пред.</a> </td><th width="60%" align="center">Глава 14. Безопасность</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>14.3. Защита FreeBSD</h2></div></div></div><a id="idp88083920" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Команда и протокол: </h3><p xmlns="http://www.w3.org/1999/xhtml">В этом документе мы будет использовать
	<span class="application">выделенный</span> текст, упоминая приложение,
	и <code class="command">моноширинный</code> шрифт, упоминая определенные
	команды.  Для протоколов используется обычный шрифт.  Это
	типографическое отличие полезно для таких случаев, как ssh, поскольку
	это и команда и протокол.</p></div><p>В последующем разделе будут рассмотрены методы защиты системы
      FreeBSD, упомянутые в <a class="link" href="security-intro.html" title="14.2. Введение">предыдущем разделе</a> этой главы.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>14.3.1. Защита учётной записи <code class="systemitem">root</code> и служебных
	учётных записей</h3></div></div></div><a id="idp88089424" class="indexterm"></a><p>Во-первых, не беспокойтесь о защите служебных учётных записей,
	если не защищена учётная запись <code class="systemitem">root</code>.  В
	большинстве систем у учётной записи <code class="systemitem">root</code> есть
	пароль.  Использование пароля <code class="systemitem">root</code>
	опасно <span class="emphasis"><em>всегда</em></span>.  Это не означает, что вы должны
	удалить пароль.  Пароль почти всегда необходим для доступа
	по консоли.  Но это означает, что вы должны сделать невозможным
	использование пароля не из консоли или может быть даже с помощью
	команды <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a>.  Например, убедитесь, что псевдо-терминалы
	в файле <code class="filename">/etc/ttys</code> перечислены с параметром
	<code class="literal">insecure</code>, что делает невозможным вход на них
	под <code class="systemitem">root</code> напрямую с помощью
	<code class="command">telnet</code> или <code class="command">rlogin</code>.  При
	использовании других средств входа, таких как
	<span class="application">sshd</span>, убедитесь что вход под
	<code class="systemitem">root</code> напрямую отключен и в них.  Сделайте
	это, открыв файл <code class="filename">/etc/ssh/sshd_config</code>, и
	убедившись, что параметр <code class="literal">PermitRootLogin</code>
	установлен в <code class="literal">NO</code>.  Проверьте каждый метод доступа
	- сервис FTP и ему подобные часто подвержены взлому.  Прямой
	вход под <code class="systemitem">root</code> должен быть разрешен только с
	системной консоли.</p><a id="idp88102224" class="indexterm"></a><p>Конечно, как системный администратор вы должны иметь доступ
	<code class="systemitem">root</code>, поэтому потребуется открыть несколько
	<span class="quote"><<<span class="quote">лазеек</span>>></span>.  Но убедитесь, что для доступа к ним необходим
	дополнительный пароль.  Одним из способов доступа к
	<code class="systemitem">root</code> является добавление соответствующих учётных
	записей к группе <code class="systemitem">wheel</code> (в файле
	<code class="filename">/etc/group</code>).  Это позволяет использовать
	<code class="command">su</code> для доступа к <code class="systemitem">root</code>.
	Вы никогда не должны давать таким учётным записям доступ
	к <code class="systemitem">wheel</code> непосредственно, помещая их в группу
	<code class="systemitem">wheel</code> в файле паролей.  Служебные учётные
	записи должны помещаться в группу <code class="systemitem">staff</code>,
	а затем добавляться к группе <code class="systemitem">wheel</code> в файле
	<code class="filename">/etc/group</code>.  Только те члены группы staff,
	которым действительно нужен доступ к <code class="systemitem">root</code>,
	должны быть помещены в группу <code class="systemitem">wheel</code>.
	При работе с такими методами аутентификации как Kerberos, возможно также
	использование файла <code class="filename">.k5login</code> в каталоге
	пользователя <code class="systemitem">root</code> для доступа к учётной записи
	<code class="systemitem">root</code> с помощью <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> без помещения
	кого-либо в группу <code class="systemitem">wheel</code>.  Это решение возможно
	лучше, поскольку механизм <code class="systemitem">wheel</code> все еще
	позволяет взлом <code class="systemitem">root</code>, если злоумышленник
	получил копию файла паролей и смог взломать служебную учётную запись.
	Хотя использование механизма <code class="systemitem">wheel</code> лучше,
	чем работа через <code class="systemitem">root</code> напрямую, это не
	обязательно самый безопасный способ.</p><p>Непрямой способ защиты служебных учётных записей и конечно
	<code class="systemitem">root</code> это использование альтернативных методов
	доступа и замена зашифрованных паролей на символ
	<span class="quote"><<<span class="quote"><code class="literal">*</code></span>>></span>.  Используя команду
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vipw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">vipw</span>(8)</span></a>, замените каждый зашифрованный пароль служебных учётных
	записей на этот символ для запрета входа с аутентификацией по паролю.
	Эта команда обновит файл <code class="filename">/etc/master.passwd</code> и
	базу данных пользователей/паролей.</p><p>Служебная учётная запись вроде этой:</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Должна быть заменена на такую:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Это изменение предотвратит обычный вход, поскольку зашифрованный
	пароль никогда не совпадет с <span class="quote"><<<span class="quote"><code class="literal">*</code></span>>></span>.
	После этого члены группы staff должны использовать другой механизм
	аутентификации, например <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kerberos&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kerberos</span>(1)</span></a> или <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> с парой
	ключей: публичным и приватным.  При использовании такой	системы как
	Kerberos, потребуется защитить сервер Kerberos и рабочую станцию.
	При использовании пары публичного/приватного ключей с ssh,
	потребуется защитить компьютер, <span class="emphasis"><em>с</em></span> которого
	происходит вход (обычно это рабочая станция).  Дополнительных слой
	защиты может быть добавлен путем защиты пары ключей при создании их
	с помощью <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh-keygen</span>(1)</span></a>.  Возможность заменить пароли служебных
	учётных записей на <span class="quote"><<<span class="quote"><code class="literal">*</code></span>>></span> гарантирует
	также, что вход может быть осуществлен только через защищенные методы
	доступа, которые вы настроили.  Это принуждает всех членов staff
	использовать защищенные, шифрованные соединения для всех входов,
	что закрывает большую брешь, используемую многими нарушителями:
	перехват паролей с другого, слабо защищенного компьютера.</p><p>Более непрямой механизм безопасности предполагает, что вы входите
	с более защищенного сервера на менее защищенный.  Например, если
	главный сервер работает со всеми сервисами, рабочая станция не должна
	работать ни с одним.  Для поднятия уровня безопасности до приемлемого
	уровня, число запущенных на ней сервисов необходимо сократить до
	минимума, вплоть до отключения их всех, кроме того необходимо
	использовать защищенный паролем хранитель экрана.  Конечно, при
	наличии физического доступа к рабочей станции атакующий может взломать
	любую систему безопасности.  Это определенно проблема, которую вы
	должны учитывать, но учтите также тот факт, что большинство взломов
	совершаются удаленно, через сеть, людьми, которые не имеют физического
	доступа к вашим рабочим станциям или серверам.</p><a id="idp88128976" class="indexterm"></a><p>Использование такой системы как Kerberos дает возможность
	заблокировать или изменить пароль в одном месте, что сразу
	отразиться на всех компьютерах, где существует служебная учётная
	запись.  Если эта учётная запись будет взломана, возможность
	немедленно изменить пароль на всех компьютерах нельзя недооценивать.
	Без этой возможности изменение паролей на N машинах может стать
	проблемой.  Вы можете также наложить ограничения на смену паролей
	с помощью Kerberos: не только установить значения timeout в
	Kerberos, но и добавить требование смены пароля пользователем
	после определенного периода времени (скажем, раз в месяц).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88130000"></a>14.3.2. Защита работающих под root сервисов и suid/sgid исполняемых
	файлов</h3></div></div></div><a id="idp88130768" class="indexterm"></a><a id="idp88131664" class="indexterm"></a><a id="idp88132560" class="indexterm"></a><a id="idp88133456" class="indexterm"></a><a id="idp88134352" class="indexterm"></a><a id="idp88135248" class="indexterm"></a><a id="idp88136144" class="indexterm"></a><a id="idp88137040" class="indexterm"></a><p>Предусмотрительный системный администратор запускает только те
	сервисы, в которых нуждается, ни больше ни меньше.  Учитывайте, что
	сервисы сторонних разработчиков наиболее подвержены ошибкам.  К примеру,
	работа со старыми версиями <span class="application">imapd</span> или
	<span class="application">popper</span> это все равно что раздача доступа
	<code class="systemitem">root</code> всему миру.  Никогда не запускайте
	сервисы, которые вы не проверили достаточно внимательно.  Многим
	сервисам не требуется работа под <code class="systemitem">root</code>.
	Например, даемоны <span class="application">ntalk</span>,
	<span class="application">comsat</span>, и
	<span class="application">finger</span> могут быть запущены в так
	называемых <em class="firstterm">песочницах</em>
	(<em class="firstterm">sandboxes</em>).  Песочница это не идеальное
	решение, поскольку вызывает много проблем, но она подходит под
	модель послойной безопасности: если кто-то сможет взломать сервис,
	работающий в песочнице, ему потребуется взломать еще и саму
	песочницу.  Чем больше уровней (<span class="quote"><<<span class="quote">слоев</span>>></span>) потребуется
	пройти атакующему, тем меньше вероятность его успеха.  Ошибки,
	позволяющие получать root доступ, находили фактически во всех
	сервисах, запускаемых под <code class="systemitem">root</code>, включая
	основные системные сервисы.  Если вы обслуживаете машину, на которую
	входят только через <span class="application">sshd</span> и никогда не
	входят через <span class="application">telnetd</span>,
	<span class="application">rshd</span> или
	<span class="application">rlogind</span>, отключите эти сервисы!</p><p>В FreeBSD сервисы
	<span class="application">ntalkd</span>,
	<span class="application">comsat</span> и
	<span class="application">finger</span> теперь по умолчанию работают в
	<span class="quote"><<<span class="quote">песочнице</span>>></span>.  Другая программа, которая может быть
	кандидатом на запуск в <span class="quote"><<<span class="quote">песочнице</span>>></span> это
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.  <code class="filename">/etc/defaults/rc.conf</code> включает
	необходимые для запуска <span class="application">named</span>
	в <span class="quote"><<<span class="quote">песочнице</span>>></span> аргументы в закомментированой форме.
	В зависимости от того, устанавливаете ли вы новую систему, или
	обновляете старую, учётные записи пользователей, используемые
	этими <span class="quote"><<<span class="quote">песочницами</span>>></span> могут не быть созданы.
	Предусмотрительный системный администратор должен узнать о
	<span class="quote"><<<span class="quote">песочницах</span>>></span> для сервисов и установить их если есть
	возможность.</p><a id="idp88157904" class="indexterm"></a><p>Есть множество других сервисов, которые обычно не работают в
	<span class="quote"><<<span class="quote">песочницах</span>>></span>: <span class="application">sendmail</span>,
	<span class="application">popper</span>,
	<span class="application">imapd</span>, <span class="application">ftpd</span>,
	и другие.  Некоторым из этих сервисов есть альтернативы,
	но их установка может потребовать больше работы, чем вы готовы
	выполнить (фактор удобства).  Вы можете запустить эти сервисы под
	<code class="systemitem">root</code> и положиться на другие механизмы обнаружения
	вторжений, которые могут пройти через них.</p><p>Другая большая потенциальная <code class="systemitem">root</code> брешь
	в системе это suid-root и sgid исполняемые файлы.  Большинство
	этих исполняемых файлов, таких как <span class="application">rlogin</span>,
	установлены в <code class="filename">/bin</code>, <code class="filename">/sbin</code>,
	<code class="filename">/usr/bin</code>, или <code class="filename">/usr/sbin</code>.
	Хотя ничто не может быть безопасно на 100%, находящиеся по умолчанию
	в системе suid и sgid исполняемые файлы могут быть признаны
	достаточно безопасными.  Но <code class="systemitem">root</code> бреши все еще
	обнаруживаются в этих исполняемых файлах.  <code class="systemitem">root</code>
	брешь, обнаруженная в <code class="literal">Xlib</code> в 1998 делала
	<span class="application">xterm</span> (который обычно suid) подверженным
	взлому.  Лучше сразу принять меры предосторожности, чем сожалеть
	потом. Предусмотрительный системный администратор ограничит права
	запуска suid исполняемых файлов, которые должны запускаться
	пользователями группы staff, только этой группой, а также запретит
	доступ (<code class="command">chmod 000</code>) к тем исполняемым файлам
	suid, которые никем не используются.  Серверу без монитора обычно
	не требуется исполняемый файл <span class="application">xterm</span>.
	Исполняемые sgid исполняемые файлы могут быть почти так же опасны.
	Если нарушитель сможет взломать sgid-kmem исполняемый файл, он
	возможно сможет прочесть <code class="filename">/dev/kmem</code> и
	таким образом получить файл зашифрованных паролей, что потенциально
	делает возможным взлом любой защищённой паролем учётной записи.
	Аналогично нарушитель, проникший в группу <code class="literal">kmem</code>,
	может отслеживать последовательности клавиш, отправляемые через
	псевдо-терминалы, включая те, что используют защищённые соединения.
	Нарушитель, вошедший в группу
	<code class="systemitem">tty</code> может сделать вывод почти на любой
	пользовательский терминал.  Если пользователь работает с
	терминальной программой или эмулятором с возможностью эмуляции
	клавиатуры, взломщик может потенциально сгенерировать поток данных,
	который заставит терминал пользователя ввести команду, и она будет
	запущена с правами этого пользователя.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>14.3.3. Защита учётных записей пользователей</h3></div></div></div><p>Учетные записи пользователей обычно сложнее всего защитить.
	Вы можете ввести драконовские ограничения доступа к служебным учётным
	записям, заменив их пароли на символ
	<span class="quote"><<<span class="quote"><code class="literal">*</code></span>>></span>, но возможно не сможете сделать
	то же с обычными учётными записями пользователей.  Если есть
	такая возможность, вы возможно сможете защитить учётные записи
	пользователей соответствующим образом.  Если нет, просто
	более бдительно отслеживайте эти учётные записи.  Использование
	ssh и Kerberos для учётных записей пользователей более
	проблематично, поскольку требует дополнительной административной
	работы и технической поддержки, но все же это решение лучше,
	чем файл с шифрованными паролями.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88207440"></a>14.3.4. Защита файла паролей</h3></div></div></div><p>Единственный абсолютно надежный способ это замена на
	<code class="literal">*</code> максимально возможного количества паролей и
	использование ssh или Kerberos для доступа к таким учётным записям.
	Хотя файл с шифрованными паролями (<code class="filename">/etc/spwd.db</code>)
	доступен для чтения только <code class="systemitem">root</code>, возможно, что
	нарушитель сможет получить доступ на чтение к этому файлу, даже если
	не получит права <code class="systemitem">root</code> на запись.</p><p>Ваши скрипты безопасности должны всегда проверять и составлять
	отчет об изменениях файла паролей (обратитесь к разделу <a class="link" href="securing-freebsd.html#security-integrity" title="14.3.6. Проверка целостности файлов: исполняемые, конфигурационные файлы и т.д.">Проверка целостности файлов</a>
	ниже по тексту).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88211280"></a>14.3.5. Защита ядра, raw устройств и файловых
	систем</h3></div></div></div><p>Если атакующий взломает <code class="systemitem">root</code>, он сможет
	сделать практически все, но есть способы усложнить его задачу.
	Например, в большинстве современных ядер встроено устройство
	перехвата пакетов.  В FreeBSD оно называется
	<code class="filename">bpf</code>.  Нарушитель обычно пытается запустить
	перехват пакетов на взломанной машине.  Вы не должны предоставлять
	ему такой возможности, на большинстве систем устройство
	<code class="filename">bpf</code> не должно быть встроено в ядро.</p><a id="idp88213840" class="indexterm"></a><p>Но даже если вы выключите устройство <code class="filename">bpf</code>,
	все еще остаются проблемы, связанные с устройствами
	<code class="filename">/dev/mem</code> и
	<code class="filename">/dev/kmem</code>.
	Нарушитель все еще может писать на дисковые raw устройства.
	Есть также другая возможность ядра, загрузка модулей, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.
	Активный нарушитель может использовать KLD модуль для установки
	собственного устройства <code class="filename">bpf</code> или другого
	перехватывающего устройства на работающее ядро.  Для решения этих
	проблем запускайте ядро с большим уровнем безопасности, как минимум 1.
	Уровень безопасности может быть установлен с помощью
	<code class="command">sysctl</code> через переменную
	<code class="varname">kern.securelevel</code>.  После установки уровня
	безопасности в 1 доступ на запись в raw устройства будет запрещена и
	полностью заработают специальные флаги <code class="command">chflags</code>,
	такие как <code class="literal">schg</code>.  Убедитесь также, что
	флаг <code class="literal">schg</code> установлен на критически важных
	загрузочных исполняемых файлах, каталогах и файлах скриптов -
	на всем, что запускается до установке уровня безопасности.
	Это требует большого объема работы, и обновление системы на более
	высоком уровне безопасности может стать гораздо сложнее.  Вы можете
	пойти на компромисс и запускать систему на высоком уровне безопасности,
	но не устанавливать флаг <code class="literal">schg</code> для каждого
	существующего системного файла и каталога.  Другая возможность
	состоит в монтировании <code class="filename">/</code> и
	<code class="filename">/usr</code> только для чтения.  Необходимо заметить,
	что такие правила слишком жесткие и могут помешать обнаружению
	вторжения.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>14.3.6. Проверка целостности файлов: исполняемые, конфигурационные файлы
	и т.д.</h3></div></div></div><p>Вы можете защищать только ядро, файлы настройки и управления
	системой только до тех пор, пока эта защита не вступит в конфликт
	с удобством работы в системе.  Например, использование
	<code class="command">chflags</code> для установки бита
	<code class="literal">schg</code> на большинство файлов в <code class="filename">/</code>
	вероятно может только навредить, поскольку хотя и может защитить
	файлы, препятствует обнаружению.  Последний слой системы безопасности,
	возможно, наиболее важный - обнаружение.  Остальные меры
	безопасности практически бесполезны (или, что еще хуже, могут дать
	вам ложное ощущение безопасности) если вы не обнаружите потенциальное
	вторжение.  Половина функций системы безопасности направлена на
	замедление атакующего, а не на его остановку, для того, чтобы дать
	системе обнаружения возможность поймать нарушителя на месте
	преступления.</p><p>Лучший способ обнаружения вторжения - отслеживание
	измененных, отсутствующих, или неожиданно появившихся файлов.
	Для наблюдения за измененными файлами лучше всего использовать
	другую (зачастую централизованную) систему с ограниченным
	доступом.  Добавление написанных вами скриптов к этой дополнительно
	защищенной системе с ограниченным доступом делает ее практически
	невидимой для потенциальных взломщиков, и это важно.  В целях
	достижения максимального эффекта вам может потребоваться предоставить
	этой системе доступ к другим машинам в сети, обычно с помощью
	NFS экспорта только для чтения или сгенерировав пары ключей ssh
	для доступа к другим машинам по ssh.  Помимо большого объема
	сетевого трафика, NFS более скрытый метод - он позволяет
	контролировать файловые системы на каждом клиентском компьютере
	практически незаметно.  Если ваш сервер с ограниченным доступом
	подключен к клиентским компьютерам через коммутатор, NFS метод
	это зачастую лучший выбор.  При соединении через концентратор, или
	через несколько маршрутизаторов, NFS метод может стать слишком
	небезопасным и использование ssh может стать лучшим выбором даже
	несмотря на то, что ssh оставляет следы своей работы.</p><p>Как только у вас появился сервер с ограниченным доступом,
	и как минимум доступ на чтение в клиентских системах, потребуется
	написать скрипты для выполнения мониторинга.  При наличии доступа
	по NFS вы можете написать скрипты с помощью простых системных утилит,
	таких как <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> и <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a>.  Лучше всего подсчитывать
	md5 файлов на клиентском компьютере как минимум один раз в день,
	а файлы, контролирующие запуск из <code class="filename">/etc</code> и
	<code class="filename">/usr/local/etc</code> даже более часто.  При
	обнаружении расхождений в md5, контролирующий компьютер должен
	просигналить системному администратору проверить изменившиеся
	файлы.  Хороший скрипт безопасности проверит также наличие
	несоответствующих исполняемых suid файлов и новых или измененных
	файлов в системных разделах <code class="filename">/</code> и
	<code class="filename">/usr</code>.</p><p>При использовании ssh вместо NFS, написать скрипты безопасности
	гораздо сложнее.  Вам обязательно потребуется скопировать
	(<code class="command">scp</code>) скрипты на клиентский компьютер,
	сделать из невидимыми, и для безопасности потребуется также
	скопировать исполняемые файлы (такие как find), которые будут
	использоваться скриптом.  Приложение <span class="application">ssh</span>
	на клиентском компьютере может быть уже взломано.  В конечном итоге,
	без ssh не обойтись при работе через небезопасные соединения,
	но его гораздо сложнее использовать.</p><p>Хороший скрипт безопасности проверит также изменения в файлах
	настройки, работающих при подключении пользователей и служебных учётных
	записей:
	<code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
	<code class="filename">.ssh/authorized_keys</code> и так далее...
	файлы, которые могли не попасть в область проверки
	<code class="literal">MD5</code>.</p><p>Если для пользователей выделен большой объем дискового
	пространства, проверка каждого файла на таких разделах может занять
	слишком много времени.  В таком случае установка флагов монтирования
	для запрета suid исполняемых файлов и устройств на таких разделах
	это хорошая идея.  Примените параметры <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>
	<code class="literal">nodev</code> и <code class="literal">nosuid</code>.  Проверяйте
	эти разделы в любом случае, хотя бы раз в неделю, поскольку
	необходимо обнаруживать попытки взлома, независимо от того,
	эффективны они или нет.</p><p>Учет процессов (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>) это относительно несложная
	возможность операционной системы, которая может помочь
	как механизм обнаружения состоявшихся вторжений.  Она особенно
	полезна для обнаружения пути проникновения нарушителя в систему,
	если файл не был затронут проникновением.</p><p>Наконец, скрипты безопасности должны обработать лог файлы,
	которые необходимо создавать настолько защищенным способом, насколько
	это возможно - подключение syslog удаленно может быть очень
	полезным.  Злоумышленник попытается уничтожить следы взлома,
	и лог файлы критически важны для системного администратора,
	пытающегося отследить время и метод первого проникновения.
	Один из надежных способов получения лог файлов является подключение
	системной консоли к последовательному порту и постоянный
	сбор информации через защищенную машину, отслеживающую
	консоли.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88245968"></a>14.3.7. Паранойя</h3></div></div></div><p>Немного паранойи никогда не повредит.  Как правило, системный
	администратор может добавлять элементы безопасности в любом
	количестве, пока это не влияет на удобство, а также некоторое
	количество элементов безопасности, <span class="emphasis"><em>влияющих</em></span>
	на удобство.  Что даже более важно, системный администратор должен
	немного изменить их - если вы используете рекомендации, например
	те, что даны в этом документе, они становятся известны атакующему,
	который также имеет доступ к этому документу.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88247504"></a>14.3.8. Атаки DoS</h3></div></div></div><a id="idp88248144" class="indexterm"></a><p>Этот раздел охватывает DoS атаки.  DoS атаки это обычно
	пакетные атаки.  Хотя против современной атаки с подделкой пакетов,
	которая перегружает сеть, мало что можно сделать, вы можете
	ограничить повреждения, убедившись, что атака не может
	обрушить ваши сервера.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ограничение количества порождаемых процессов.</p></li><li class="listitem"><p>Уменьшение последствий springboard атак (ICMP ответ,
	    широковещательный ping и т.д.).</p></li><li class="listitem"><p>Кэш маршрутизации ядра.</p></li></ol></div><p>Обычная DoS атака против порождающего процессы сервера пытается
	исчерпать ресурсы сервера по процессам, файловым дескрипторам и
	памяти до тех пор, пока машина не <span class="quote"><<<span class="quote">повиснет</span>>></span>.  У
	<span class="application">inetd</span> (обратитесь к <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>)
	есть несколько параметров, позволяющих ограничить такие атаки.
	Необходимо учесть, что хотя можно предотвратить падение системы, в
	общем случае невозможно предотвратить прекращение работы сервиса.
	Внимательно прочтите страницу справочника и обратите особое внимание
	на параметры <code class="option">-c</code>, <code class="option">-C</code>, и
	<code class="option">-R</code>.  Учтите, что параметр <code class="option">-C</code> не
	работает в случае атак с использованием поддельных IP пакетов,
	поэтому как правило необходимо использование комбинации параметров.
	Некоторые standalone сервисы используют собственные параметры,
	ограничивающие порождение процессов.</p><p>У <span class="application">Sendmail</span> есть собственный параметр
	<code class="option">-OMaxDaemonChildren</code>, которая работает гораздо лучше,
	чем параметр sendmail, ограничивающий нагрузку. Вам необходимо задать
	параметр запуска <span class="application">sendmail</span>
	<code class="literal">MaxDaemonChildren</code> достаточно большим, чтобы
	обслуживать ожидаемую нагрузку, но так, чтобы компьютер мог обслужить
	такое количество приложений <span class="application">sendmail</span> без
	падения системы.  Хорошей мерой является запуск sendmail в режиме
	очереди (<code class="option">-ODeliveryMode=queued</code>) и запуск даемона
	(<code class="command">sendmail -bd</code>) отдельно от очереди
	(<code class="command">sendmail -q15m</code>).  Если вы все же хотите
	организовать доставку в режиме реального времени, запускайте
	очередь с меньшим интервалом <code class="option">-q1m</code>, но убедитесь
	в правильной установке параметра sendmail
	<code class="literal">MaxDaemonChildren</code> для предотвращения
	ошибок.</p><p><span class="application">Syslogd</span> может быть атакован
	непосредственно, настоятельно рекомендуется использовать параметр
	<code class="option">-s</code> если это возможно и параметр <code class="option">-a</code>
	в остальных случаях.</p><p>Вы также должны быть очень осторожны с сервисами, совершающими
	обратное подключение, например, с <span class="application">TCP
	Wrapper</span> и его обратным identd-запросом, который может
	быть атакован напрямую.  По этой причине возможность <span class="application">TCP
	Wrapper</span> генерировать обратный ident обычно не следует
	использовать.</p><p>Правильным будет запрет доступа к внутренним сервисам из внешней
	сети путем соответствующей настройки брандмауэра на внешнем
	маршрутизаторе.  Идея в том, чтобы предотвратить перегрузку сервисов
	атаками из внешней сети, а кроме того защитить
	<code class="systemitem">root</code> от взлома через сеть.  Всегда настраивайте
	исключающий брандмауэр, т.е. <span class="quote"><<<span class="quote">закрыть все
	<span class="emphasis"><em>кроме</em></span> портов A, B, C, D, и M-Z</span>>></span>.
	Этим способом вы можете закрыть все порты нижнего диапазона,
	кроме явно указанных, таких как <span class="application">named</span>
	(если вы поддерживаете интернет-зону),
	<span class="application">ntalkd</span>,
	<span class="application">sendmail</span>, и других сервисов, доступных
	из интернет.  Если вы попробуете настроить брандмауэр другим
	способом - включающий, или разрешающий брандмауэр, есть
	большой шанс забыть <span class="quote"><<<span class="quote">закрыть</span>>></span> пару сервисов, или
	добавить новый внутрисетевой сервис и забыть обновить брандмауэр.
	Вы можете открыть диапазон портов с большими номерами
	для обычных приложений без угрозы портам нижнего диапазона.
	Учтите также, что FreeBSD позволяет вам контролировать диапазоны
	портов, используемые для динамической привязки через различные
	переменные <code class="command">sysctl</code>
	<code class="varname">net.inet.ip.portrange</code> (<code class="command">sysctl -a | fgrep
	portrange</code>), что позволяет упростить настройку
	брандмауэра.  Например, вы можете использовать обычный
	диапазон портов со значениями от 4000 до 5000, и диапазон портов с
	большими номерами от 49152 до 65535, а затем заблокировать все до
	4000 порта (конечно оставив доступ из интернет к определенным
	портам.</p><p>Другой распространенный тип DoS атак называется springboard
	- сервер атакуется таким образом, что генерируемые ответы
	перегружают его, локальную сеть или какие-то другие компьютеры.
	Наиболее распространенная атака этого вида это
	<span class="emphasis"><em>широковещательная ICMP ping атака</em></span>.
	Атакующий подделывает пакеты ping, подставляя IP адрес машины, которую
	он намеревается атаковать, и отправляет их на широковещательный
	адрес вашей локальной сети.  Если ваш внешний маршрутизатор не
	настроен на отбрасывание пакетов ping на широковещательные адреса,
	ваша сеть начинает генерировать соответствующие ответы на
	поддельный адрес, что приводит к перегрузке хоста-жертвы, особенно
	если атакующий использует этот же трюк с множеством
	широковещательных адресов в множестве сетей одновременно.
	Были зарегистрированы широковещательные атаки свыше ста двадцати
	мегабит.  Другая распространенная springboard атака направлена на
	ICMP систему сообщения об ошибках.  Конструируя пакеты, вызывающие
	ICMP сообщения об ошибках, атакующий может нагрузить входящее
	соединение сервера и вынудить сервер нагрузить исходящее соединение
	ICMP ответами.  Этот тип атаки может также обрушить сервер, когда
	тот исчерпает mbuf, обычно если сервер не может ограничить число
	ответов ICMP, когда они генерируются слишком быстро.
	Используйте переменную <span class="application">sysctl</span>
	<code class="literal">net.inet.icmp.icmplim</code>.  Последний
	основной класс springboard атак относится к определенным
	внутренним сервисам <span class="application">inetd</span>, таким как
	сервис udp echo.  Атакующий просто подделывает адрес источника
	и адрес назначения UDP пакетов, устанавливая в их качестве
	соответственно echo порт сервера A и B, оба этих сервера принадлежат
	вашей локальной сети.  Эти два сервера начинают перебрасываться
	этим пакетом друг с другом.  Атакующий может вызвать перегрузку
	обеих серверов и их сетей, просто отправив несколько пакетов таким
	способом.  Аналогичные проблемы существуют с портом
	<span class="application">chargen</span>.  Компетентный системный
	администратор должен отключить эти тестовые сервисы inetd.</p><p>Атаки с поддельными пакетами могут также использоваться для
	переполнения кэша маршрутизации ядра.  Обратитесь к параметрам
	<code class="command">sysctl</code> <code class="varname">net.inet.ip.rtexpire</code>,
	<code class="varname">rtminexpire</code>, и <code class="varname">rtmaxcache</code>.
	Атака с поддельными пакетами, использующая произвольный IP адрес
	источника, заставит ядро сгенерировать временный кэшированный
	маршрут в таблице маршрутизации, который можно увидеть с помощью
	<code class="command">netstat -rna | fgrep W3</code>.  Эти маршруты обычно
	удаляются через 1600 секунд или около того.  Если ядро определит,
	что кэшированная маршрутная таблица стала слишком большой, оно
	динамически уменьшит <code class="varname">rtexpire</code>, но никогда не
	станет делать его меньше чем <code class="varname">rtminexpire</code>.
	С этим связаны две проблемы:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ядро не отреагирует достаточно быстро, когда легко нагруженный
	    сервер будет внезапно атакован.</p></li><li class="listitem"><p>Значение <code class="varname">rtminexpire</code> недостаточно мало
	    для поддержки работоспособности в условиях продолжительной
	    атаки.</p></li></ol></div><p>Если ваши серверы подключены к интернет через линию T3 или
	более быструю, предусмотрительно будет изменить оба значения
	<code class="varname">rtexpire</code> и <code class="varname">rtminexpire</code>
	с помощью <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a>.  Никогда не устанавливайте ни один из этих
	параметров в нуль (если только вы не хотите обрушить систему).
	Установка обеих параметров в значение 2 секунды должна предотвратить
	таблицу маршрутизации от атак.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp88284752"></a>14.3.9. Проблемы, связанные с доступом к Kerberos и SSH</h3></div></div></div><a id="idp88285392" class="indexterm"></a><a id="idp88286032" class="indexterm"></a><p>При использовании Kerberos и ssh необходимо учесть несколько
	возможных проблем.  Kerberos V это отличный протокол
	аутентификации, но в адаптированных к нему приложениях
	<span class="application">telnet</span> и
	<span class="application">rlogin</span> есть несколько ошибок, которые
	могут сделать их непригодными к работе с бинарными потоками.
	К тому же, по умолчанию Kerberos не шифрует сессию, если вы не
	используете параметр <code class="option">-x</code>.
	<span class="application">ssh</span> шифрует все по умолчанию.</p><p>ssh работает очень хорошо во всех ситуациях, но пересылает
	ключи по умолчанию.  Это означает, что если вы работаете с
	защищенной рабочей станции, ключи на которой дают доступ к
	остальной сети, и заходите по ssh на незащищенный компьютер,
	эти ключи могут быть использованы для взлома.  Атакующему
	не удастся получить сами ключи, но поскольку ssh открывает порт
	во время входа в систему, то если на незащищенной машине
	взломан <code class="systemitem">root</code>, эти ключи могут быть использованы
	для доступа к другим компьютерам, на которых они действуют.</p><p>Мы рекомендуем использовать ssh в комбинации с Kerberos
	для служебных учётных записей если это возможно.
	<span class="application">ssh</span> может быть собран с поддержкой
	Kerberos.  Это уменьшает зависимость от потенциально подверженных
	взлому ssh ключей, и в то же время защищает пароли через
	Kerberos.  Ключи ssh должны использоваться только для работы
	скриптов на защищенных компьютерах (там, где Kerberos использовать
	не получится).  Мы также рекомендуем или выключить передачу ключей
	в настройках ssh, или использовать параметр
	<code class="literal">from=IP/DOMAIN</code>, поддерживаемый ssh в файле
	<code class="filename">authorized_keys</code>, который позволяет использовать
	ключи только с определенных компьютеров.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Введение </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> 14.4. DES, MD5, и шифрование</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>