<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>12.12. Оптимизация дисков</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Руководство FreeBSD" /><link rel="up" href="config-tuning.html" title="Глава 12. Настройка и оптимизация" /><link rel="prev" href="configtuning-sysctl.html" title="12.11. Настройка с помощью sysctl" /><link rel="next" href="configtuning-kernel-limits.html" title="12.13. Изменение ограничений, накладываемых ядром" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.12. Оптимизация дисков</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Пред.</a> </td><th width="60%" align="center">Глава 12. Настройка и оптимизация</th><td width="20%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="configtuning-disk"></a>12.12. Оптимизация дисков</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86885968"></a>12.12.1. Переменные Sysctl</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86886608"></a>12.12.1.1. <code class="varname">vfs.vmiodirenable</code></h4></div></div></div><a id="idp86887376" class="indexterm"></a><p>Значением переменной <code class="varname">vfs.vmiodirenable</code>
	  может быть установлено в 0 (выключено) или 1 (включено); по
	  умолчанию 1.  Эта переменная отвечает за метод кэширования
	  каталогов.  Размер большинства каталогов невелик.  Они могут
	  поместиться в одном фрагменте (обычно 1K), и могут занимать
	  ещё меньше места (обычно 512 байт) в кэше буфера.
	  При отключении этой переменной (при установке значения 0)
	  буфер прокэширует только заданное число
	  каталогов даже если у вас много памяти.  При включении (при
	  установке значения 1) эта переменная
	  sysctl позволит использовать страничное кэширование VM,
	  делая доступным для кэширования каталогов
	  весь объём памяти.  Однако,
	  минимальный объём памяти, используемой для
	  кэширования каталогов стал равен объёму страницы (обычно 4 K)
	  вместо 512 байт.  Мы рекомендуем оставлять эту опцию включенной,
	  если ваш компьютер исполняет программы, манипулирующие значительным
	  количеством файлов.  Примером таких программ могут быть кэширующие
	  прокси-серверы, большие почтовые серверы и серверы новостей.  Обычно
	  включение этой опции не понижает производительности, однако лучше
	  поэкспериментировать, чтобы узнать оптимальное значение для вашей
	  машины.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86889168"></a>12.12.1.2. <code class="varname">vfs.write_behind</code></h4></div></div></div><a id="idp86889936" class="indexterm"></a><p>Переменная sysctl <code class="varname">vfs.write_behind</code> по
	  умолчанию установлена в <code class="literal">1</code> (включено).  Она
	  указывает системе выполнять запись на носитель по кластерам,
	  что обычно делается для больших файлов.  Идея в том, чтобы
	  избежать заполнения кэша неполными буферами, когда это не
	  увеличивает производительность.  Однако, это может заблокировать
	  процессы и в некоторых случаях вам может понадобиться отключить
	  этот параметр.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86892112"></a>12.12.1.3. <code class="varname">vfs.hirunningspace</code></h4></div></div></div><a id="idp86892880" class="indexterm"></a><p>Переменная sysctl <code class="varname">vfs.hirunningspace</code>
	  определяет число запросов записи на диск, которые могут
	  быть поставлены в очередь.  Значение по умолчанию обычно подходит,
	  но на компьютерах с большим количеством дисков вы можете
	  увеличить его до четырех или пяти <span class="emphasis"><em>мегабайт</em></span>.
	  Учтите, что установка слишком большого значения (превышающего
	  размер буфера записи) может привести к очень значительному
	  падению общей производительности.  Не делайте это значение
	  произвольно большим!  Большие значения могут привести к
	  задержкам чтения, выполняемого в то же время</p><p>Есть много других переменных sysctl, относящихся к кэшированию
	  в буфер и страничному кэшированию VM.  Мы не рекомендуем изменять
	  эти значения, поскольку система VM делает отличную
	  работу по автоматической самонастройке.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86907856"></a>12.12.1.4. <code class="varname">vm.swap_idle_enabled</code></h4></div></div></div><a id="idp86908624" class="indexterm"></a><p>Переменная sysctl <code class="varname">vm.swap_idle_enabled</code>
	  полезна в больших многопользовательских системах, где есть
	  много пользователей, входящих и выходящих из системы, и
	  множество ожидающих процессов.  Такие системы обычно генерируют
	  большое количество запросов на выделение памяти.  Включение этой
	  переменной и настройка задержки выгрузки (swapout hysteresis,
	  в секундах) установкой переменных
 	  <code class="varname">vm.swap_idle_threshold1</code> и
 	  <code class="varname">vm.swap_idle_threshold2</code> позволит освобождать
	  страницы памяти, занятые ожидающими процессами, более быстро,
	  чем при нормальном алгоритме выгрузки.  Это помогает даемону
	  выгрузки страниц.  Не включайте этот параметр, пока он на самом
	  деле вам не понадобится, поскольку его действие в сущности
	  заключается в более ранней выгрузке страниц из памяти; это
	  повышает нагрузку на подкачку и диск.  В малых системах
	  эффект от включения этого параметра предсказуем, но в больших
	  системах нагруженной на подкачкой этот параметр позволяет
	  системе VM проще загружать и выгружать процессы из памяти.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86911184"></a>12.12.1.5. <code class="varname">hw.ata.wc</code></h4></div></div></div><a id="idp86911952" class="indexterm"></a><p>Во FreeBSD 4.3 кэширование записи на IDE диски было отключено.
	  Это понижало производительность IDE дисков в тестах, но было
	  необходимо для лучшей сохранности данных.  Проблема состоит в том,
	  что IDE диски неправильно указывают время завершения записи на диск.
	  При включенном кэшировании IDE диски могут не только записать данные
	  в неправильном порядке - при большой нагрузке на диск некоторые
	  блоки могут задержаться до бесконечности.  Сбой, или отключение
	  питания могут могут стать причиной серьёзных повреждений в файловой
	  системе.  Поэтому для безопасности системы значение по умолчанию
	  этого параметра было изменено.  К сожалению, результатом этого стало
	  столь значительная потеря производительности, что после выхода
	  релиза значение этого параметра было возвращено в первоначальное
	  состояние.  Вам следует проверить значение переменной sysctl
	  <code class="varname">hw.ata.wc</code> на вашей машине.  Если кэширование
	  выключено - вы можете включить его, установив значение переменной
	  ядра, равное 1.  Это должно быть сделано при помощи загрузчика при
	  загрузке.  Если вы сделаете это позже - изменения не будут иметь
	  силы.</p><p>За более подробной информацией обращайтесь к <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ata&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ata</span>(4)</span></a>.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86980560"></a>12.12.1.6. <code class="literal">SCSI_DELAY</code>
	(<code class="varname">kern.cam.scsi_delay</code>)</h4></div></div></div><a id="idp86981840" class="indexterm"></a><a id="idp86982736" class="indexterm"></a><p>Параметр настройки ядра <code class="literal">SCSI_DELAY</code> может
	  использоваться для уменьшения времени загрузки системы.
	  Значение по умолчанию велико и может составлять более
	  <code class="literal">15</code> секунд в процессе загрузки.  Уменьшение
	  его до <code class="literal">5</code> секунд обычно работает (особенно
	  с современными дисками).  В новых версиях FreeBSD (5.0 и выше) должен
	  использоваться параметр <code class="varname">kern.cam.scsi_delay</code>,
	  настраиваемый во время загрузки.  Этот параметр и параметр
	  настройки ядра принимают значения в
	  <span class="emphasis"><em>миллисекундах</em></span>, а <span class="emphasis"><em>не</em></span> в
	  <span class="emphasis"><em>секундах</em></span>.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="soft-updates"></a>12.12.2. Soft Updates</h3></div></div></div><a id="idp86988240" class="indexterm"></a><a id="idp86988752" class="indexterm"></a><p>Программа <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a> используется для настройки файловой
	системы.  Эта программа может принимать большое количество параметров,
	но мы рассмотрим лишь один из них - включение и выключение
	Soft Updates, что может быть достигнуто следующим образом:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>tunefs -n enable /filesystem</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>tunefs -n disable /filesystem</code></strong></pre><p>Нельзя изменять файловую систему с помощью <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tunefs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">tunefs</span>(8)</span></a> когда
	она смонтирована.  Самое подходящее время для включения "Soft Updates"
	- перед монтированием разделов, в однопользовательском режиме.</p><p>Soft Updates существенно увеличивают скорость создания и удаления
	файлов путём использования кэширования.  Мы рекомендуем использовать Soft
	Updates на всех ваших файловых системах.  Однако у Soft Updates есть
	и обратные стороны: во-первых, Soft Updates гарантирует целостность
	файловой системы в случае сбоя, но может наблюдаться задержка в
	несколько секунд (или даже минуту!) перед записью на жесткий диск.
	Если система зависнет - вы можете потерять
	больше, чем, если бы вы не включили Soft Updates.  Во-вторых,
	Soft Updates задерживает освобождение блоков файловой системы.
	Если ваша файловая система заполнена, выполнение значительного
	обновления, например,
	<code class="command">make installworld</code>, может вызвать
	переполнение.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp86994000"></a>12.12.2.1. Дополнительная информация о Soft Updates</h4></div></div></div><a id="idp86994640" class="indexterm"></a><p>Есть два традиционных способа записи метаданных файловых систем
	  на диск (пример метаданных: индексные дескрипторы и
	  каталоги).</p><p>Исторически, поведение по умолчанию заключается в синхронном
	  обновлении метаданных.  Если каталог был изменен, система
	  ждет, пока изменение не будет физически записано на диск.
	  Содержимое файлов проходит через кэш и записывается на
	  диск асинхронно.  Преимущество этого способа в его
	  надежности.  При сбое во время обновления метаданные
	  остаются в нормальном состоянии.  Файл либо создается целиком,
	  либо вообще не создается.  Если блоки данных не были записаны
	  в файл из буфера во время сбоя, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a> сможет определить
	  это и восстановить файловую систему, установив длину файла в 0.
	  Кроме того, реализация этого способа проста и понятна.
	  Недостаток в том, что обновление метаданных занимает много
	  времени.  Команда <code class="command">rm -r</code>, например,
	  последовательно удаляет все файлы в каталоге, и каждое изменение
	  в каталоге (удаление файла) будет синхронно записано на диск.
	  Сюда включаются обновления самого каталога, таблицы индексных
	  дескрипторов, и возможно блоков, занятых файлом.  Те же
	  соглашения работают при распаковке больших иерархий
	  (<code class="command">tar -x</code>).</p><p>Другой вариант это асинхронное обновление метаданных.  Это
	  поведение по умолчанию для Linux/ext2fs и *BSD ufs с параметром
  	  <code class="command">mount -o async</code>.  Все обновления метаданных
	  просто пропускаются через кэш буфера, как и содержимое файлов.
	  Преимущество этой реализации в том, что нет необходимости ждать
	  каждый раз, пока метаданные будут записаны на диск, поэтому
	  все операции с большим объемом обновления метаданных будут
	  происходить гораздо быстрее, чем при синхронном обновлении.
	  Кроме того, реализация все еще проста и понятна, поэтому
	  риск появления ошибок в коде невелик.  Недостаток в том,
	  что нет никаких гарантий исправности файловой системы.  Если
	  во время обновления большого объема метаданных произойдет
	  сбой (например, отключение питания, или нажатие кнопки reset),
	  файловая система останется в непредсказуемом состоянии.
	  Нет возможности определить состояние файловой системы после
	  такого сбоя; блоки данных файла могут быть уже записаны на диск,
	  а обновления таблицы индексных дескрипторов нет.  Невозможно
	  реализовать <code class="command">fsck</code>, которая могла бы
	  исправить получившийся хаос (поскольку необходимой информации
	  нет на диске).  Если файловая система была уничтожена во
	  время восстановления, единственный способ восстановления
	  - запустить <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=newfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">newfs</span>(8)</span></a> и воспользоваться
	  резервной копией.</p><p>Обычное решение этой проблемы состояло в реализации
	  <span class="emphasis"><em>протоколировании проблемной области (dirty region
	  logging)</em></span>, известном как
	  <span class="emphasis"><em>журналирование</em></span>, хотя этот термин
	  использовался неправильно и порой также применялся к другим
	  формам протоколирования транзакций.  Обновление метаданных
	  как и прежде происходит синхронно, но в отдельную область
	  диска.  Позже они перемещаются туда, где должны быть.
	  Поскольку область протоколирования это небольшая,
	  последовательная область диска, головкам жесткого диска
	  не приходится перемещаться на большие расстояния даже
	  во время значительных обновлений, поэтому такой способ
	  быстрее, чем синхронные обновления.
	  Кроме того, сложность реализации довольно ограничена, поэтому
	  риск внесения ошибок невелик.  Недостаток в том, что
	  все обновления метаданных записываются дважды (один раз
	  в область протоколирования и один раз окончательно),
	  поэтому при обычной работе производительность может
	  понизиться.  С другой стороны, в случае сбоя все
	  незаконченные действия с метаданными могут быть быстро
	  отменены, или завершены после загрузки системы,
	  поэтому система после сбоя загружается быстрее.</p><p>Kirk McKusick, разработчик Berkeley FFS, решил эту проблему
	  с помощью Soft Updates: все незавершенные обновления метаданных
	  находятся в памяти и записываются на диск в упорядоченном
	  виде (<span class="quote"><<<span class="quote">упорядоченное обновления метаданных</span>>></span>).
	  При значительных обновлениях метаданных более поздние обновления
	  <span class="quote"><<<span class="quote">присоединяются</span>>></span> к предыдущим, если они все еще
	  находятся в памяти и еще не записаны на диск.  Поэтому все
	  операции, скажем, над каталогом, обычно выполняются в памяти
	  перед записью обновления на диск (блоки данных сортируются
	  в соответствии с их положением, так что они не будут записаны
	  на диск до метаданных.  При крахе операционной системы выполняется
	  <span class="quote"><<<span class="quote">откат</span>>></span>: считается, что все операции, не записанные на
	  диск, никогда не происходили.  Файловая система находится в
	  том состоянии, в котором она была за 30-60 секунд до сбоя.
	  Используемый алгоритм гарантирует, что все используемые ресурсы
	  маркированы соответствующим образом в своих областях: блоки и
	  индексные дескрипторы.  После сбоя могут остаться только ошибки
	  выделения ресурсов, они помечаются как <span class="quote"><<<span class="quote">используемые</span>>></span>,
	  хотя на самом деле <span class="quote"><<<span class="quote">свободны</span>>></span>.  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a>
	  разбирается в ситуации и освобождает более не используемые
	  ресурсы.  После сбоя система может быть безопасно смонтирована
	  с опцией <code class="command">mount -f</code>.  Для освобождения ресурсов,
	  которые могут не использоваться, в дальнейшем потребуется
	  запустить <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fsck&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fsck</span>(8)</span></a>.  Эта идея лежит в основе
	  <span class="emphasis"><em>background (фоновая) fsck</em></span>: во время запуска системы
	  записывается только <span class="emphasis"><em>снимок</em></span> файловой системы.
	  Все системы могут быть смонтированы в <span class="quote"><<<span class="quote">грязном</span>>></span>
	  состоянии, и система загружается в многопользовательский режим.
	  Затем, фоновые <code class="command">fsck</code> ставятся в очередь для
	  всех систем, где это требуется, чтобы освободить неиспользуемые
	  ресурсы.  (Файловые системы, где не используются Soft Updates,
	  все еще требуют запуска <code class="command">fsck</code> в обычном
	  режиме).</p><p>Преимущество этого способа в том, что обновления метаданных
	  происходят почти так же быстро, как при асинхронных обновлениях
	  (т.е. быстрее, чем при <span class="emphasis"><em>журналировании</em></span>,
	  когда метаданные записываются дважды).  Недостаток в сложности
	  кода (подразумевающим больший риск появления ошибок в области,
	  где вероятность потери данных пользователя особенно высока) и
	  в более высоких требованиях к объему памяти.  К тому же могут
	  возникнуть некоторые странные на первый взгляд ситуации.
	  После сбоя состояние файловой системы несколько более
	  <span class="quote"><<<span class="quote">старое</span>>></span>.  В ситуации, когда стандартный способ
	  синхронизации оставит несколько файлов нулевой длины после
	  выполнения <code class="command">fsck</code>, в файловой системе с
	  Soft Updates их не останется вовсе, поскольку ни метаданные,
	  ни содержимое файлов не были записаны на диск.  Дисковое
	  пространство не будет освобождено пока обновления не будут
	  записаны на диск, что может занять некоторое время после
	  выполнения <code class="command">rm</code>.  Это может повлечь проблемы
	  при установке большого количества файлов на файловую
	  систему, где не хватает места для помещения всех файлов
	  дважды.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configtuning-sysctl.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="config-tuning.html">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="configtuning-kernel-limits.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">12.11. Настройка с помощью sysctl </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> 12.13. Изменение ограничений, накладываемых ядром</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>