<?xml version="1.0" encoding="koi8-r" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=koi8-r" /><title>27.4. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Руководство FreeBSD" /><link rel="up" href="advanced-networking.html" title="Глава 27. Сложные вопросы работы в сети" /><link rel="prev" href="network-wireless.html" title="27.3. Беспроводные сети" /><link rel="next" href="network-bridging.html" title="27.5. Мосты" /><link rel="copyright" href="legalnotice.html" title="Юридическое уведомление" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">27.4. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-wireless.html">Пред.</a> </td><th width="60%" align="center">Глава 27. Сложные вопросы работы в сети</th><td width="20%" align="right"> <a accesskey="n" href="network-bridging.html">След.</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>27.4. Bluetooth</h2></div><div><span class="authorgroup">Текст предоставил <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pav</span> <span class="surname">Lucistnik</span></span>. </span></div></div></div><a id="idp99891664" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99892176"></a>27.4.1. Введение</h3></div></div></div><p>Bluetooth является беспроводной технологией для создания
	персональных сетей на расстоянии не более 10 метров, работающей на
	частоте 2.4 ГГц, которая не подлежит лицензированию.  Обычно такие
	сети формируются из портативных устройств, таких, как сотовые телефоны,
	КПК и лэптопы.  В отличие от Wi-Fi, другой популярной беспроводной
	технологии, Bluetooth предоставляет более высокий уровень сервиса,
	например, файловые серверы типа FTP, передачу файлов, голоса, эмуляцию
	последовательного порта и другие.</p><p>Стек протоколов Bluetooth во FreeBSD реализован на основе технологии
	Netgraph (обратитесь к <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a>).  Широкий спектр USB-устройств
	Bluetooth поддерживается драйвером <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a>.  Устройства
	Bluetooth на основе набора микросхем Broadcom BCM2033 поддерживается
	драйвером <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a>.  Устройства Bluetooth, работающие через
	последовательные и UART-порты, поддерживаются драйверами <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>,
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a> и <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>. В этом разделе описывается
	использование Bluetooth-устройств, подключаемых через USB.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99906640"></a>27.4.2. Подключение устройства</h3></div></div></div><p>По умолчанию драйверы устройств Bluetooth поставляются в виде
	модулей ядра.  Перед подключением устройства вам необходимо подгрузить
	драйвер в ядро:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>Если Bluetooth-устройство в момент запуска системы подключено, то
	загружайте модуль из файла
	<code class="filename">/boot/loader.conf</code>:</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>Подключите ваше USB-устройство.  На консоли (или в журнале
	syslog) появится примерно такое сообщение:</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><div xmlns="" class="note"><h3 class="admontitle">Примечание: </h3><p xmlns="http://www.w3.org/1999/xhtml">Стек протоколов Bluetooth запускается вручную во FreeBSD 6.0, и во
	  FreeBSD 5.X, перед 5.5.  Это делается автоматически через <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>
	  во FreeBSD 5.5, 6.1 и в более новых версиях.</p><p xmlns="http://www.w3.org/1999/xhtml">Скопируйте файл
	<code class="filename">/usr/share/examples/netgraph/bluetooth/rc.bluetooth</code>
	в какое-нибудь подходящее место, например, в файл
	<code class="filename">/etc/rc.bluetooth</code>.  Этот скрипт используется для
	запуска и остановки работы Bluetooth-стека.  Перед отключением
	устройства рекомендуется остановить его работы, хотя (обычно) это не
	фатально.  При запуске стека вы получите сообщения, подобные
	следующим:</p><pre xmlns="http://www.w3.org/1999/xhtml" class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99914448"></a>27.4.3. Host Controller Interface (HCI)</h3></div></div></div><a id="idp99915088" class="indexterm"></a><p>Host Controller Interface (HCI) предоставляет интерфейс для
	управления контроллером передатчика и менеджером соединений, а также
	доступ к данным о состоянии оборудования и его управляющим регистрам.
	Этот интерфейс предоставляет унифицированный метод доступа к
	передающим возможностям Bluetooth.  Уровень HCI на управляющей машине
	обменивается данными и командами с микрокодом HCI в оборудовании
	Bluetooth.  Драйвер для Host Controller Transport Layer (то есть
	физической шины) предоставляет обоим слоям HCI возможность обмениваться
	данными друг с другом.</p><p>Для одного Bluetooth-устройства создаётся один узел Netgraph типа
	<span class="emphasis"><em>hci</em></span>.  HCI-узел обычно подключается к узлу драйвера
	устройства Bluetooth (входящий поток) и к узлу L2CAP (исходящий поток).
	Все операции с HCI должны выполняться на узле HCI, но не на узле
	драйвера устройства.  В качестве имени по умолчанию для узла HCI
	используется <span class="quote"><<<span class="quote">devicehci</span>>></span>.  Дополнительные подробности
	можно найти на справочной странице <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a>.</p><p>Одной из самой часто выполняемой задач является обнаружение
	Bluetooth-устройств в радиусе RF-доступности.  Эта операция называется
	<span class="emphasis"><em>опросом</em></span> (inquiry).  Опрос и другие операции,
	связанные с HCI, выполняются при помощи утилиты <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a>.
	Пример ниже показывает, как найти доступные устройства Bluetooth.
	Список таких устройств должен быть получен в течение нескольких секунд.
	Заметьте, что удалённые устройства будут отвечать на опрос, если только
	они находятся в режиме <span class="emphasis"><em>обнаруживаемости</em></span>
	(discoverable).</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> является уникальным адресом устройства
	Bluetooth, вроде MAC-адресов сетевых адаптеров.  Этот адрес необходим
	для дальнейшей работы с устройством.  Адресу BD_ADDR можно присвоить
	удобное для чтения имя.  Файл <code class="filename">/etc/bluetooth/hosts</code>
	содержит информацию об известных хостах Bluetooth.  В следующем примере
	показано, как получить имя, назначенное удалённому устройству:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>Если вы выполните опрос на другом Bluetooth-устройстве, но ваш
	компьютер будет опознан как <span class="quote"><<<span class="quote">your.host.name (ubt0)</span>>></span>.
	Имя, назначаемое локальному устройству, может быть в любой момент
	изменено.</p><p>Система Bluetooth предоставляет услуги по соединениям типа
	точка-точка (при этом задействованы только два устройства Bluetooth)
	или точка-ко-многим-точкам.  В последнем случае соединение используется
	совместно несколькими устройствам Bluetooth.  В следующем примере
	показывается, как получить список активных для локального устройства
	соединений:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p>Идентификатор соединения (<span class="emphasis"><em>connection handle</em></span>)
	полезен, когда необходимо прекратить соединение.  Заметьте, что обычно
	нет нужды делать это вручную.  Стек будет автоматически разрывать
	неактивные соединения.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>Обратитесь к помощи посредством <code class="command">hccontrol help</code>
	для получения полного списка доступных HCI-команд.  Большинство команд
	HCI для выполнения не требуют прав администратора системы.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99931984"></a>27.4.4. Logical Link Control and Adaptation Protocol (L2CAP)</h3></div></div></div><a id="idp99932624" class="indexterm"></a><p>Протокол L2CAP (Logical Link Control and Adaptation Protocol)
	предоставляет услуги по работе с данными, как ориентированные на
	соединения, так и без ориентации на них, протоколам более высокого
	уровня с возможностями мультиплексирования и обеспечением операций по
	сегментации и обратной сборке.  L2CAP позволяет протоколам более
	высокого уровня и приложениям передавать и получать пакеты данных
	L2CAP длиной до 64 Кбайт.</p><p>L2CAP основан на концепции <span class="emphasis"><em>каналов</em></span>.  Каналом
	является логическое соединение поверх соединения по радиоканалу.
	Каждый канал привязан к некоторому протоколу по принципу
	многие-к-одному.  Несколько каналов могут быть привязаны к одному и
	тому же протоколу, но канал не может быть привязан к нескольким
	протоколам.  Каждый пакет L2CAP, получаемый каналом, перенаправляется
	к соответствующему протоколу более высокого уровня.  Несколько каналов
	могут совместно использовать одно и то же радиосоединение.</p><p>Для одного Bluetooth-устройства создается один узел Netgraph типа
	<span class="emphasis"><em>l2cap</em></span>.  Узел L2CAP обычно подключается к узлу
	Bluetooth HCI (нижестоящий) и узлам Bluetooth-сокетов (вышестоящие).
	По умолчанию для узла L2CAP используется имя
	<span class="quote"><<<span class="quote">devicel2cap</span>>></span>.  Для получения дополнительной информации
	обратитесь к справочной странице по <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a>.</p><p>Полезной является программа <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a>, которая может
	использоваться для проверки связи с другими устройствами.  Некоторые
	реализации Bluetooth могут не возвращать все данные, посылаемые им,
	так что <code class="literal">0 bytes</code> в следующем примере - это
	нормально.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p>Утилита <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> используется для выполнения различных
	операций с узлами L2CAP.  В этом примере показано, как получить список
	логических соединений (каналов) и перечень радиосоединений локального
	устройства:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p>Ещё одним диагностическим инструментом является <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a>.
	Она выполняет действия, подобные тем, что обычно выполняет
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>, но со структурами данных, связанных с работой в сети
	Bluetooth.  В примере ниже описывается то же самое логическое
	соединение, что и с <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> выше.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99954128"></a>27.4.5. Протокол RFCOMM</h3></div></div></div><a id="idp99954768" class="indexterm"></a><p>Протокол RFCOMM эмулирует последовательные порты поверх протокола
	L2CAP.  Он основан на ETSI-стандарте TS 07.10.  RFCOMM представляет
	собой простой транспортный протокол, с дополнительными возможностями по
	эмуляции 9 цепей последовательных портов RS-232 (EIATIA-232-E).
	Протокол RFCOMM поддерживает одновременно до 60 соединений (каналов
	RFCOMM) между двумя устройствами Bluetooth.</p><p>В рамках RFCOMM полный коммуникационный маршрут включает два
	приложения, работающие на разных устройствах (конечные коммуникационные
	точки) с коммуникационным сегментом между ними.  RFCOMM предназначен
	для сокрытия приложений, использующих последовательные порты устройств,
	в которых они расположены.  Коммуникационный сегмент по сути является
	Bluetooth-связью от одного устройства к другому (прямое
	соединение).</p><p>RFCOMM имеет дело с соединением между устройствами в случае прямого
	соединения, или между устройством и модемом в сетевом случае.  RFCOMM
	может поддерживать и другие конфигурации, такие, как модули, работающие
	через беспроводную технологию Bluetooth с одной стороны и
	предоставляющие проводное соединение с другой стороны.</p><p>Во FreeBSD протокол RFCOMM реализован на уровне сокетов
	Bluetooth.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp99956944"></a>27.4.6. Pairing of Devices</h3></div></div></div><a id="idp99957584" class="indexterm"></a><p>По умолчанию связь Bluetooth не аутентифицируется, поэтому любое
	устройство может общаться с любым другим.  Устройство Bluetooth
	(например, сотовый телефон) может задать обязательность аутентификации
	для предоставления определённого сервиса (в частности, услугу доступа
	по коммутируемой линии).  Bluetooth-аутентификация обычно выполняется
	через <span class="emphasis"><em>PIN-коды</em></span>.  PIN-код представляет из себя
	ASCII-строку длиной до 16 символов.  Пользователь обязан ввести один и
	тот же PIN-код на обоих устройствах.  Как только он введёт PIN-код,
	оба устройства сгенерируют <span class="emphasis"><em>ключ связи</em></span>.  После
	этого ключ может быть сохранён либо в самом устройстве, либо на
	постоянном носителе.  В следующий раз оба устройства будут использовать
	ранее сгенерированный ключ соединения.  Процедура, описанная выше,
	носит название <span class="emphasis"><em>подгонки пары</em></span> (pairing).  Заметьте,
	что если ключ связи потерян любой из сторон, то подбор пары должен быть
	повторен.</p><p>За обработку всех запросов на Bluetooth-аутентификацию отвечает
	даемон <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a>.  По умолчанию файл конфигурации называется
	<code class="filename">/etc/bluetooth/hcsecd.conf</code>.  Пример раздела,
	содержащего информацию о сотовом телефоне с явно заданным PIN-кодом
	<span class="quote"><<<span class="quote">1234</span>>></span> приведен ниже:</p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>Кроме длины, на PIN-коды не накладывается никаких ограничений.
	Некоторые устройства (например, Bluetooth-гарнитуры) могут иметь
	фиксированный встроенный PIN-код.  Параметр <code class="option">-d</code>
	позволяет запустить <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a> как нефоновый процесс, что облегчает
	просмотр происходящих событий.  Задайте получение парного ключа на
	удалённом устройстве и инициируйте Bluetooth-соединение с этим
	устройством.  Удалённое устройство должно подтвердить получение пары и
	запросить PIN-код.  Введите тот же самый код, что находится в
	<code class="filename">hcsecd.conf</code>.  Теперь ваш ПК и удалённое устройство
	спарены.  Альтернативным способом является инициация процесса создания
	пары на удалённом устройстве.</p><p>Во FreeBSD 5.5, 6.1 и в более новых, следующая строка может быть
	добавлена к <code class="filename">/etc/rc.conf</code>, чтобы
	<span class="application">hcsecd</span> запускался автоматически во время старта
	системы:</p><pre class="programlisting">hcsecd_enable="YES"</pre><p>Ниже даётся пример выдачи протокола
	команды <span class="application">hcsecd</span>:</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100069584"></a>27.4.7. Service Discovery Protocol (SDP)</h3></div></div></div><a id="idp100070352" class="indexterm"></a><p>Протокол обнаружения сервисов SDP даёт возможность клиентским
	приложениям осуществлять поиск услуг, предоставляемых серверными
	приложениями, а также характеристик этих услуг.  В перечень атрибутов
	сервиса включается тип класса предлагаемого сервиса и информация о
	механизме или протоколе, требуемом для использования сервиса.</p><p>SDP подразумевает коммуникации между SDP-сервером и SDP-клиентом.
	Сервер поддерживает список сервисов, в котором описываются параметры
	сервисов, связанных с сервером.  Каждая запись об услуге содержит
	информацию об одном сервисе.  Клиент может запросить информацию об
	определённом сервисе, обслуживаемом SDP-сервером, выдавая SDP-запрос.
	Если клиент или приложение, связанное с клиентом, решат воспользоваться
	сервисом, то для его использования необходимо открыть отдельное
	соединение к устройству, предоставляющему сервис.  SDP предоставляет
	механизм обнаружения услуг и их параметров, но не даёт механизма
	использования этих сервисов.</p><p>Обычно SDP-клиент выполняет поиск услуг на основе некоторых
	желаемых характеристик услуг.  Однако иногда возникает необходимость
	выяснить полный перечень типов услуг, предоставляемых SDP-сервером,
	не имея никакой информации об имеющихся сервисах.  Такой процесс
	всех предлагаемых сервисов называется <span class="emphasis"><em>обзором</em></span>
	(browsing).</p><p>Bluetooth SDP сервер <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> и клиент с интерфейсом
	командной строки <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> включены в стандартную поставку
	FreeBSD.  В следующем примере показано, как выполнять
	запрос на SDP-обзор.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec browse</code></strong>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</pre><p>... и так далее.  Заметьте, что каждый сервис имеет перечень
	атрибутов (например, канал RFCOMM).  В зависимости от сервиса вам может
	потребоваться где-то сохранить эти атрибуты.  Некоторые реализации
	Bluetooth не поддерживают просмотр сервисов и могут возвращать пустой
	список.  В этом случае возможен поиск конкретной услуги.  В примере
	ниже показано, как выполнить поиск службы OBEX Object Push
	(OPUSH):</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></strong></pre><p>Во FreeBSD предоставление сервисов клиентам Bluetooth осуществляется
	сервером <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.  Во FreeBSD 5.5, 6.1 и в более новых, следующая строка
	может быть добавлена в файл <code class="filename">/etc/rc.conf</code>:</p><pre class="programlisting">sdpd_enable="YES"</pre><p>После этого <span class="application">sdpd</span> даемон может быть запущен
	с помощью:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/sdpd start</code></strong></pre><p>Во FreeBSD 6.0, и во FreeBSD 5.X перед 5.5,
	<span class="application">sdpd</span> не интегрирован в скрипты загрузки
	системы.  Он должен запускаться автоматически командой:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpd</code></strong></pre><p>Приложение на локальном сервере, желающее предоставить сервис
	Bluetooth удаленным клиентам, регистрирует сервис через локального
	даемона SDP.  Пример такого приложения - <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.
	После запуска оно регистрирует Bluetooth LAN сервис через локального
	даемона SDP.</p><p>Список сервисов, зарегистрированных через локальный SDP сервер,
	может быть получен путем выдачи запроса на просмотр SDP через
	локальный контрольный канал:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpcontrol -l browse</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100084560"></a>27.4.8. Доступ к сети по коммутируемой линии связи (DUN) и по протоколу
	PPP (LAN)</h3></div></div></div><p>Модуль работы с коммутируемым доступом к сети (DUN - Dial-Up
	Networking) в большинстве случаев используется с модемами и сотовыми
	телефонами.  Этот модуль покрывает следующие случаи:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>сотовый телефон или модем используется вместе с компьютером
	    в качестве беспроводного модема для подключения к серверу
	    коммутируемого доступа в Интернет, или другой коммутируемой
	    услуге;</p></li><li class="listitem"><p>сотовый телефон или модем используется компьютером для приёма
	    входящих соединений.</p></li></ul></div><p>Модуль доступа к сети по протоколу PPP (Network Access with
	PPP - LAN) может использоваться в следующих ситуациях:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>доступ к ЛВС для одного Bluetooth-устройства;</p></li><li class="listitem"><p>доступ к ЛВС для нескольких Bluetooth-устройств;</p></li><li class="listitem"><p>связь между двумя ПК (при помощи протокола PPP поверх
	    эмулируемого последовательного канала связи).</p></li></ul></div><p>Во FreeBSD оба случая реализуются при помощи сервисных программ
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> и <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> - это обработчик, преобразующий
	RFCOMM-соединения Bluetooth в нечто, с чем может работать PPP.  Перед
	тем, как использовать любой модуль, в файле
	<code class="filename">/etc/ppp/ppp.conf</code> должна быть создана новая
	PPP-метка.  Примеры использования можно найти в справочной странице к
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.</p><p>В следующем примере <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> будет использоваться для
	открытия RFCOMM-соединения к удалённому устройству с BD_ADDR
	00:80:37:29:19:a4 на DUN RFCOMM-канале.  Реальный номер RFCOMM-канала
	будет получаться с удалённого устройства через SDP.  Возможно указать
	RFCOMM-канал вручную, и в этом случае <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> не будет
	выполнять SDP-запрос.  Для нахождения RFCOMM-канала на удалённом
	устройстве используйте утилиту <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>Для того, чтобы организовать сервис Network Access with PPP (LAN),
	необходимо запустить сервер <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.  В файле
	<code class="filename">/etc/ppp/ppp.conf</code> должна быть создана новая запись
	для клиентов LAN.  Примеры можно найти в справке по
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.   Наконец, запустите RFCOMM PPP сервер на
	существующем номере канала RFCOMM.  Сервер RFCOMM PPP автоматически
	зарегистрирует Bluetooth LAN сервис через локальный SDP даемон.
	В примере ниже показано, как запустить сервер RFCOMM PPP.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100109264"></a>27.4.9. OBEX Object Push (OPUSH) Profile</h3></div></div></div><a id="idp100109904" class="indexterm"></a><p>OBEX является широко используемым протоколом для простой передачи
	файлов между мобильными устройствами.  В основном он используется в
	коммуникациях через инфракрасный порт для передачи файлов между
	ноутбуками или КПК, а также для пересылки визитных
	карточек или календарных планов между сотовыми телефонами и
	другими устройствами с персональными информационными
	менеджерами.</p><p>Сервер и клиент OBEX реализованы в виде пакета стороннего
	разработчика <span class="application">obexapp</span>, который доступен
	в виде порта <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/obexapp/pkg-descr">comms/obexapp</a>.</p><p>Клиент OBEX используется для посылки или приёма объектов с сервера
	OBEX.  Объектом, к примеру, может быть визитная карточка или
	указание.  Клиент OBEX может получить номер RFCOMM-канала, указав
	вместо него имя сервиса.  Поддерживаются следующие имена сервиса: IrMC,
	FTRN и OPUSH.  Канал RFCOMM можно задать его номером.  Ниже даётся
	пример сеанса OBEX, где с сотового телефона забирается объект с
	информацией об устройстве, а новый объект (визитная карточка)
	передаётся в каталог сотового телефона.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>Для того, чтобы предоставить сервис OBEX Push, должен быть запущен
	сервер <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>.  Должен быть создан
	корневой каталог, в котором будут сохраняться все поступающие объекты.
	По умолчанию корневым каталогом является
	<code class="filename">/var/spool/obex</code>.  Наконец, запустите OBEX
	сервер на существующем номере канала RFCOMM.  OBEX сервер
	автоматически зарегистрирует сервис OBEX Object Push через локального
	даемона SDP.  В примере ниже показано, как запустить
	OBEX-сервер.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100116176"></a>27.4.10. Профиль последовательного порта (SPP)</h3></div></div></div><p>Профиль последовательного порта (SPP - Serial Port Profile) позволяет
	Bluetooth-устройствам осуществлять эмуляцию последовательного порта
	RS232 (или подобного).  Этот профиль покрывает случаи, касающиеся
	работы унаследованных приложений с Bluetooth в качестве замены
	кабельному соединению, при это используется абстракция виртуального
	последовательного порта.</p><p>Утилита <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> реализует профиль
	последовательного порта.  В качестве виртуального последовательного порта
	используется псевдо-терминал.  В примере ниже показано, как подключиться
	к сервису Serial Port удалённого устройства.  Заметьте, что вы не
	указываете RFCOMM-канал - <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> может получить его с
	удалённого устройства через SDP.  Если вы хотите переопределить это,
	укажите RFCOMM-канал явно в командной строке.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>После подключения псевдо-терминал можно использовать как
	последовательный порт:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100129872"></a>27.4.11. Решение проблем</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100130512"></a>27.4.11.1. Удалённое устройство не подключается</h4></div></div></div><p>Некоторые старые Bluetooth-устройства не поддерживают
	  переключение ролей.  По умолчанию, когда FreeBSD подтверждает новое
	  соединение, она пытается выполнить переключение роли и стать ведущим
	  устройством.  Устройства, которые это не поддерживают, не смогут
	  подключиться.  Заметьте, что переключение ролей выполняется при
	  установлении нового соединения, поэтому невозможно выяснить,
	  поддерживает ли удалённое устройство переключение ролей.  На
	  локальной машине имеется возможность отключить переключение ролей при
	  помощи HCI-параметра:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp100132560"></a>27.4.11.2. Что-то идёт не так, можно ли посмотреть, что в точности
	  происходит?</h4></div></div></div><p>Да, можно.  Воспользуйтесь пакетом стороннего разработчика,
	  <span class="application">hcidump</span> который доступен в виде порта
	  <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/hcidump/pkg-descr">comms/hcidump</a>.  Утилита
	  <span class="application">hcidump</span> похожа на <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Она
	  может быть использована для вывода на терминал содержимого
	  Bluetooth-пакетов и сбрасывать пакеты Bluetooth в файл.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-wireless.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="network-bridging.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">27.3. Беспроводные сети </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> 27.5. Мосты</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Этот, и другие документы, могут быть скачаны с
    <a href="http://ftp.FreeBSD.org/pub/FreeBSD/doc/">http://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>.</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>По вопросам, связанным с FreeBSD, прочитайте
    <a href="http://www.FreeBSD.org/ru/docs.html">документацию</a> прежде чем писать в
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    По вопросам, связанным с этой документацией, пишите в рассылку
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.<br></br></small></p></body></html>