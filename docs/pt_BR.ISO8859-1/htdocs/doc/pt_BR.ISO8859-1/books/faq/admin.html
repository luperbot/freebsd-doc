<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 10. Administração do Sistema</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="up" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="prev" href="disks.html" title="Capítulo 9. Discos, Sistemas de Arquivos e Carregadores de Inicialização (Boot Loaders)" /><link rel="next" href="x.html" title="Capítulo 11. O sistema X, sistema de interface gráfica e os Consoles Virtuais" /><link rel="copyright" href="legalnotice.html" title="Nota Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 10. Administração do Sistema</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="disks.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="x.html">Próxima</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="admin"></a>Capítulo 10. Administração do Sistema</h1></div></div></div><div class="qandaset"><a id="idp68923216"></a><dl><dt>10.1. <a href="admin.html#idp68923472">Onde estão os arquivos que configuram a
	    inicialização do sistema ?</a></dt><dt>10.2. <a href="admin.html#idp68937168">Como posso adicionar um usuário de forma
	    simples?</a></dt><dt>10.3. <a href="admin.html#idp68942672">Depois de editar o crontab, mensagens como
	    root: not found ficam aparecendo
	    sempre.  Por que?</a></dt><dt>10.4. <a href="admin.html#idp68965328">Porque o erro you are not in the correct
	      group to su root ocorre, quando eu tento
	    virar root com o su ?</a></dt><dt>10.5. <a href="admin.html#idp69017424">Cometi um erro no rc.conf, ou em
	    algum outro arquivo de inicialização, e
	    agora não posso corrigir essa
	    alteração porque o sistema de arquivos
	    é apenas-leitura.  O que devo fazer?</a></dt><dt>10.6. <a href="admin.html#idp69038160">Porque estou tendo problemas ao configurar minha
	    impressora?</a></dt><dt>10.7. <a href="admin.html#idp69042256">Como posso corrigir o mapeamento de teclados do meu
	    sistema?</a></dt><dt>10.8. <a href="admin.html#idp69049552">O que causa mensagens como: unknown:
	      &lt;PNP0303&gt; can't assign resources na
	    inicialização do sistema?</a></dt><dt>10.9. <a href="admin.html#idp69054032">Porque eu não consigo fazer as quotas de
	    usuários funcionarem de forma correta?</a></dt><dt>10.10. <a href="admin.html#idp69069392">O FreeBSD suporta as primitivas de IPC do System
	    V?</a></dt><dt>10.11. <a href="admin.html#idp69074512">Como posso usar o sendmail para entregar mensagens com
	    UUCP?</a></dt><dt>10.12. <a href="admin.html#idp69139664">Como eu configuro e-mail em uma conexão dialup
	    com a rede?</a></dt><dt>10.13. <a href="admin.html#idp69162832">Que outros servidores de correio eletrônico
	    posso usar no lugar do Sendmail?</a></dt><dt>10.14. <a href="admin.html#idp69168848">Esqueci a senha de root!  O que eu faço?</a></dt><dt>10.15. <a href="admin.html#idp69173712">Como posso evitar que a seqüência de teclas
	    Control+Alt+Delete
	    reinicie o sistema?</a></dt><dt>10.16. <a href="admin.html#idp69188688">Como posso converter arquivos de texto do DOS para o
	    formato do Unix?</a></dt><dt>10.17. <a href="admin.html#idp69196624">Como eu mato processos pelo seu nome?</a></dt><dt>10.18. <a href="admin.html#idp69199440">Por que motivos o su está me atazanando pelo
	    fato de não pertencer à ACL do
	    root?</a></dt><dt>10.19. <a href="admin.html#idp69202000">Como eu desinstalo o Kerberos?</a></dt><dt>10.20. <a href="admin.html#idp69207376">Como posso adicionar pseudo-terminais ao
	    sistema?</a></dt><dt>10.21. <a href="admin.html#idp69222224">Por que motivo não consigo criar a device
	    snd0?</a></dt><dt>10.22. <a href="admin.html#idp69227984">Como posso reler o /etc/rc.conf e
	    reiniciar o /etc/rc sem rebootar o
	    sistema?</a></dt><dt>10.23. <a href="admin.html#idp69237840">O que é uma sandbox?</a></dt><dt>10.24. <a href="admin.html#idp69254352">O que é securelevel
	    (nível de segurança do sistema)?</a></dt><dt>10.25. <a href="admin.html#idp69281104">Tentei atualizar meu sistema para o último
	    -STABLE, mas ele se tornou -RC ou -PRERELEASE!  O que
	    está havendo?</a></dt><dt>10.26. <a href="admin.html#idp69315408">Tentei instalar um novo
	    kernel, mas a rotina de
	    chflags falhou.  O que posso fazer?</a></dt><dt>10.27. <a href="admin.html#idp69324496">Não consigo alterar mais de um segundo na hora
	    no meu sistema.  O que posso fazer?</a></dt><dt>10.28. <a href="admin.html#idp69341520">Por que motivo o rpc.statd
	    está usando 256 megabytes de memória?</a></dt><dt>10.29. <a href="admin.html#idp69348304">Por que eu não posso retirar a flag
	    schg dos arquivos?</a></dt><dt>10.30. <a href="admin.html#idp69352528">Por que a autenticação do SSH via
	    .shosts não funciona por
	    padrão nas versões recentes do
	    FreeBSD?</a></dt><dt>10.31. <a href="admin.html#idp69370448">O que é o vnlru?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp68923472"></a><a id="startup-config-files"></a><p><strong>10.1.</strong></p></td><td align="left" valign="top"><p>Onde estão os arquivos que configuram a
	    inicialização do sistema ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Do FreeBSD 2.0.5R até o 2.2.1R, o arquivo de
	    configurações primário é o
	    <code class="filename">/etc/sysconfig</code>.  Todas as
	    opções devem ser definidas nesse arquivo ou
	    então em outros, como o
	    <code class="filename">/etc/rc</code> (veja o manual para o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>) e o <code class="filename">/etc/netstart</code></p><p>Dê uma olhada no
	    <code class="filename">/etc/sysconfig</code> e altere as
	    variáveis de acordo com o que você quer
	    configurar no seu sistema.  O arquivo é repleto de
	    comentários que auxiliam a correta
	    definição dos valores a serem
	    definidos.</p><p>A partir do 2.2.1 até o 3.0, o
	    <code class="filename">/etc/sysconfig</code> foi renomeado para
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a>, que é auto-descritivo, e cuja
	    sintaxe foi melhorada no processo de
	    substituição.  O
	    <code class="filename">/etc/netstart</code> agora se chama
	    <code class="filename">/etc/rc.network</code>, de forma que todos
	    os arquivos possam ser copiados com um simples comando
	    como um <code class="command">cp /usr/src/etc/rc* /etc</code></p><p>E depois, a partir do FreeBSD 3.1, o
	    <code class="filename">/etc/rc.conf</code> foi alterado para o
	    <code class="filename">/etc/defaults/rc.conf</code>.
	    <span class="emphasis"><em>Não edite esse arquivo!</em></span> Ao
	    invés disso, para todas as entradas que você
	    queira alterar no
	    <code class="filename">/etc/defaults/rc.conf</code>, basta apenas
	    copiar a linha relativa à essa entrada para o
	    <code class="filename">/etc/rc.conf</code> e depois modificar seu
	    valor.</p><p>Por exemplo, caso deseje iniciar o named, o servidor
	    DNS disponível no FreeBSD, a partir do FreeBSD 3.1
	    basta fazer isso:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>echo named_enable="YES" &gt;&gt; /etc/rc.conf</code></strong></pre><p>Para iniciar serviços locais no FreeBSD 3.1 e
	    posteriores, basta colocar os scripts shell de
	    inicialização desses serviços no
	    diretório <code class="filename">/usr/local/etc/rc.d</code>.
	    Tais shell scripts devem ser executáveis e
	    terminarem com a extensão .sh.  No FreeBSD 3.0 ou
	    anteriores, o arquivo <code class="filename">/etc/rc.local</code>
	    era a única opção para iniciar
	    serviços/processos locais automaticamente.</p><p>O arquivo <code class="filename">/etc/rc.serial</code> é
	    usado para a inicialização de portas seriais
	    (por exemplo, para definir as características das
	    portas, e assim por diante).</p><p>O arquivo <code class="filename">/etc/rc.i386</code> é
	    usado para configurações específicas
	    de sistemas Intel e compatíveis, como por exemplo,
	    emulação iBCS2 ou definições
	    do sistema de console dos PC.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68937168"></a><a id="adding-users"></a><p><strong>10.2.</strong></p></td><td align="left" valign="top"><p>Como posso adicionar um usuário de forma
	    simples?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Use o comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=adduser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">adduser</span>(8)</span></a>.  Caso prefira uma forma
	    mais complexa (e mais completa), use o comando
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a>.</p><p>Para remover o usuário do sistema, use o
	    comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rmuser&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rmuser</span>(8)</span></a>.  Mais uma vez, o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a>
	    também funciona muito bem nesse caso.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68942672"></a><a id="root-not-found-cron-errors"></a><p><strong>10.3.</strong></p></td><td align="left" valign="top"><p>Depois de editar o crontab, mensagens como
	    <span class="errorname">root: not found</span> ficam aparecendo
	    sempre.  Por que?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Normalmente esse é um problema causado ao se
	    editar o crontab do sistema
	    (<code class="filename">/etc/crontab</code>) e depois usar o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a> para instala-lo:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab /etc/crontab</code></strong></pre><p>Essa não é a forma correta de fazer as
	    coisas.  O crontab do sistema tem um formato distinto do
	    crontab dos usuários, o qual o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">crontab</span>(1)</span></a>
	    atualiza (o manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=crontab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">crontab</span>(5)</span></a> explica tais
	    diferenças de forma mais detalhada).</p><p>Caso você tenha cometido esse engano, o novo
	    crontab é uma simples cópia do
	    <code class="filename">/etc/crontab</code>, ou seja, com um formato
	    errado.  Apague-o com o comando:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>crontab -r</code></strong></pre><p>Da próxima vez que editar o
	    <code class="filename">/etc/crontab</code>, nenhuma
	    ação precisa ser tomada para avisar o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> das alterações.  Ele vai
	    perceber as mudanças automaticamente.</p><p>Caso queira executar alguma tarefa diária,
	    semanal ou mensal, é mais indicado adicionar alguns
	    scripts de shell sob o
	    <code class="filename">/usr/local/etc/periodic</code> e deixar o
	    programa <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=periodic&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">periodic</span>(8)</span></a>, chamado a partir da tabela cron
	    do sistema, cuidar das suas tarefas assim como ele faz com
	    as outras tarefas pertinentes ao sistema.</p><p>A única razão para esse erro é
	    que a tabela de cron do sistema tem um campo a mais, que
	    especifica o usuário que deve executar o comando.
	    No crontab do sistema padrão do FreeBSD, esse
	    usuário é o <code class="systemitem">root</code>, em
	    todas as entradas.  Quando essa crontab é usada
	    como a tabela de cron do <code class="systemitem">root</code> (que
	    é diferente da tabela de cron do sistema), o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=cron&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">cron</span>(8)</span></a> assume que a string <code class="systemitem">root</code>
	    fosse um primeiro comando, mas esse comando não
	    existe, por isso ocorre o erro.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68965328"></a><a id="su-wheel-group"></a><p><strong>10.4.</strong></p></td><td align="left" valign="top"><p>Porque o erro <span class="errorname">you are not in the correct
	      group to su root</span> ocorre, quando eu tento
	    virar <code class="systemitem">root</code> com o su ?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Essa é uma característica de
	    segurança do FreeBSD.  Para se tornar
	    <code class="systemitem">root</code> com o su (ou qualquer outro
	    usuário com privilégios de super
	    usuário), é preciso fazer parte do grupo
	    <code class="systemitem">wheel</code>.  Sem essa
	    característica, qualquer usuário com uma
	    conta válida no sistema que soubesse a senha de
	    <code class="systemitem">root</code> poderia obter privilégios
	    de super usuário.  Por causa do comportamento
	    atual, essa afirmação não é
	    verdadeira, uma vez que o su não vai nem permitir
	    que o usuário dê a senha de
	    <code class="systemitem">root</code>, caso ele não esteja no
	    grupo <code class="systemitem">wheel</code>.</p><p>Para permitir que algum usuário se torne
	    <code class="systemitem">root</code>, basta que ele faça parte
	    do grupo <code class="systemitem">wheel</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69017424"></a><a id="rcconf-readonly"></a><p><strong>10.5.</strong></p></td><td align="left" valign="top"><p>Cometi um erro no <code class="filename">rc.conf</code>, ou em
	    algum outro arquivo de inicialização, e
	    agora não posso corrigir essa
	    alteração porque o sistema de arquivos
	    é apenas-leitura.  O que devo fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Nessa situação, o comportamento esperado
	    é que o sistema entre em modo monousuário e
	    peça o caminho completo para o seu interpretador de
	    comandos (sua shell).  Basta confirmar a shell
	    padrão, que ele oferece, com um simples
	    <code class="literal">ENTER</code>, e depois executar um
	    <code class="command">mount /</code> para remontar o sistema de
	    arquivos raiz ( / ) em modo leitura/escrita (rw).
	    Também pode ser necessário executar um
	    <code class="command">mount -a -t ufs</code> para montar o sistema
	    de arquivos onde o seu editor de texto preferido vai estar
	    disponível.  Caso seu editor esteja em um sistema
	    de arquivos da rede, será necessário
	    configurar a rede manualmente, ou usar um editor
	    disponível localmente, como o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ed&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ed</span>(1)</span></a>.</p><p>Caso queira usar um editor de tela inteira como o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=vi&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">vi</span>(1)</span></a> ou <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=emacs&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">emacs</span>(1)</span></a>, será necessário
	    definir a variável de ambiente TERM como do tipo
	    cons25, bastando um simples export TERM=cons25, de forma
	    que tais editores possam carregar as
	    informações corretas da base de dados do
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=termcap&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">termcap</span>(5)</span></a>.</p><p>Depois disso, o <code class="filename">/etc/rc.conf</code> pode
	    ser editado normalmente, e a sintaxe problemática,
	    corrigida.  A mensagem de erro apresentada imediatamente
	    após o carregamento do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> indica o
	    número da linha e o arquivo onde o erro
	    aconteceu.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69038160"></a><a id="printer-setup"></a><p><strong>10.6.</strong></p></td><td align="left" valign="top"><p>Porque estou tendo problemas ao configurar minha
	    impressora?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por gentileza, dê uma olhada nas páginas
	    sobre impressão do Manual do FreeBSD.  O
	    documento deve responder a maioria de suas dúvidas.
	    Veja a entrada sobre <a class="link" href="../handbook/printing.html" target="_top">Impressão no
	      Manual do FreeBSD</a>.</p><p>Algumas impressoras precisam de um driver local,
	    baseado em estações, para prover qualquer
	    tipo de impressão.  Essas impressoras são
	    chamadas de <span class="quote">&#8220;<span class="quote">WinPrinters</span>&#8221;</span> e não
	    são suportadas nativamente pelo FreeBSD.  Se sua
	    impressora não funciona sob DOS ou com Windows NT
	    4.0, provavelmente ela é uma WinPrinter.  A
	    única esperança de se obter uma impressora
	    desse tipo funcionando, é verificar se o
	    <code class="literal">port</code> <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/print/pnm2ppa/pkg-descr">print/pnm2ppa</a> tem suporte para
	    ela.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69042256"></a><a id="keyboard-mappings"></a><p><strong>10.7.</strong></p></td><td align="left" valign="top"><p>Como posso corrigir o mapeamento de teclados do meu
	    sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Por gentileza, refira-se à seção
	    usando <a class="link" href="../handbook/using-localization.html" target="_top">localização
	      do Manual do FreeBSD</a>, mais precisamente na
	    parte sobre a <a class="link" href="../handbook/using-localization.html#SETTING-CONSOLE" target="_top">configuração
	      do console</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69049552"></a><a id="pnp-resources"></a><p><strong>10.8.</strong></p></td><td align="left" valign="top"><p>O que causa mensagens como: <span class="errorname">unknown:
	      &lt;PNP0303&gt; can't assign resources</span> na
	    inicialização do sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O trecho a seguir é citação de
	    uma mensagem enviada na lista freebsd-current.</p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>A mensagem <span class="quote">&#8220;<span class="quote">can't assign resources</span>&#8221;</span>
	      indica que os equipamentos em questão são
	      do tipo ISA, e que não existem entradas indicando
	      drivers não-PnP compiladas no
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.  Esses
	      equipamentos podem ser controladoras de teclados,
	      controladora de interrupção
	      programável e várias outras peças
	      da infra-estrutura padrão do sistema.  Os
	      recursos não podem ser atribuídos por
	      já existirem drivers usando tais
	      endereços.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">Garrett Wollman, 24 Abril 2001</span></td></tr></table></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69054032"></a><a id="user-quotas"></a><p><strong>10.9.</strong></p></td><td align="left" valign="top"><p>Porque eu não consigo fazer as quotas de
	    usuários funcionarem de forma correta?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Não habilite quotas na
		<code class="filename">/</code>,</p></li><li class="listitem"><p>Coloque o arquivo de quotas indicando o sistema de
		arquivos onde se deseja estabelecer as quotas, por
		exemplo:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Sistemas de arquivos</th><th>Arquivos de quotas</th></tr></thead><tbody><tr><td><code class="filename">/usr</code></td><td><code class="filename">/usr/admin/quotas</code></td></tr><tr><td><code class="filename">/home</code></td><td><code class="filename">/home/admin/quotas</code></td></tr><tr><td>&#8230;</td><td>&#8230;</td></tr></tbody></table></div></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69069392"></a><a id="sysv-ipc"></a><p><strong>10.10.</strong></p></td><td align="left" valign="top"><p>O FreeBSD suporta as primitivas de IPC do System
	    V?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sim, o FreeBSD suporta IPC ao estilo do System V.
	    Esse suporte inclui compartilhamento de memória,
	    mensagens e semáforos.  É necessário
	    adicionar as seguintes linhas no arquivo de
	    configurações do seu
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, para ativar o
	    suporte:</p><pre class="programlisting">options    SYSVSHM	  # habilita memória compartilhada
options    SYSVSEM          # habilita semáforos
options    SYSVMSG          # habilita mensagens</pre><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">No FreeBSD 3.2 e posteriores, tais
	      opções já fazem parte do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>
	      <span class="emphasis"><em>GENERIC</em></span>, o que significa que tal
	      suporte já deve estar compilado no seu
	      sistema.</p></div><p>Recompile e instale o novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69074512"></a><a id="uucpmail"></a><p><strong>10.11.</strong></p></td><td align="left" valign="top"><p>Como posso usar o sendmail para entregar mensagens com
	    UUCP?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A configuração do sendmail
	    disponível por padrão no FreeBSD é
	    direcionada para sites que estejam conectados à
	    Internet.  Servidores que pretendem entregar suas
	    mensagens via UUCP devem instalar um novo arquivo de
	    configurações do sendmail.</p><p>Alterar o <code class="filename">/etc/mail/sendmail.cf</code>
	    manualmente é considerado tarefa para os mais
	    puristas.  A versão 8 do sendmail tem uma nova
	    abordagem de arquivos de configuração por
	    meio de pré processamento com o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=m4&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">m4</span>(1)</span></a>, onde os
	    modelos de configuração são
	    manipulados em um nível mais alto de
	    abstração.  Use os arquivos de
	    configuração disponíveis sob
	    /usr/src/usr.sbin/sendmail/cf.</p><p>Caso seu sistema não tenha sido instalado com
	    os fontes, os arquivos de configuração do
	    sendmail foram divididos em pacotes separados.  Assumindo
	    que você tenha o CDROM do FreeBSD montado,
	    faça o seguinte:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/src</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</code></strong></pre><p>Não se desespere, são apenas algumas
	    centenas de Kilobytes em tamanho.  O arquivo README no
	    diretório cf serve de introdução
	    básica ao uso do m4.</p><p>Para entregar mensagens via UUCP, o melhor conselho
	    é usar o <code class="literal">mailtertable</code>.  Trata-se
	    de uma base de dados que o sendmail usa para basear suas
	    decisões de roteamento de mensagens.</p><p>Primeiro, é necessário criar seu arquivo
	    <code class="filename">.mc</code>.  O diretório
	    <code class="filename">/usr/src/usr.sbin/sendmail/cf/cf</code>
	    é o diretório home para esse tipo de
	    arquivo.  Dê uma olhada, já existem alguns
	    exemplos disponíveis por lá.  Se assumirmos
	    que você chamou o arquivo de
	    <code class="filename">foo.mc</code>, para converte-lo para um
	    arquivo <code class="filename">sendmail.cf</code> válido
	    basta:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/usr.sbin/sendmail/cf/cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make foo.cf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>cp foo.cf /etc/mail/sendmail.cf</code></strong></pre><p>Um arquivo <code class="filename">.mc</code> típico, se
	    parece com algo mais ou menos assim:</p><pre class="programlisting">VERSIONID(`<em class="replaceable"><code>Número da sua versão</code></em>')
OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable')

define(`UUCP_RELAY', <em class="replaceable"><code>your.uucp.relay</code></em>)
define(`UUCP_MAX_SIZE', 200000)
define(`confDONT_PROBE_INTERFACES')

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <em class="replaceable"><code>your.alias.host.name</code></em>
Cw    <em class="replaceable"><code>youruucpnodename.UUCP</code></em></pre><p>As linhas contendo as entradas
	    <code class="literal">accept_unresolvable_domains</code>,
	    <code class="literal">nocanonify</code>, e
	    <code class="literal">confDONT_PROBE_INTERFACES</code> previnem o
	    uso do DNS durante a entrega das mensagens.  A
	    cláusula <code class="literal">UUCP_RELAY</code> é
	    necessária por razões bizarras, nem pergunte
	    quais.  Apenas coloque o nome de uma estação
	    que possa manipular endereços com
	    pseudo-domínio .UUCP;  normalmente o
	    endereço de relay de e-mail do seu Provedor de
	    Serviço Internet deve servir.</p><p>Depois disso, é necessário usar o
	    arquivo <code class="filename">/etc/mail/mailertable</code>.  Caso
	    exista apenas um link para fora, por onde todos os e-mails
	    são roteados, as seguintes definições
	    são o bastante:</p><pre class="programlisting">#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.	 uucp-dom:<em class="replaceable"><code>your.uucp.relay</code></em></pre><p>Um exemplo mais complexo, se pareceria com:</p><pre class="programlisting">#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre><p>Como pode-se perceber, se trata de um arquivo usado na
	    vida real.  As primeiras três linhas tratam
	    situações especiais onde as mensagens
	    endereçadas aquele domínio não devem
	    ser roteadas pela saída padrão, mas ao
	    invés disso, ser entregues para algum servidor UUCP
	    vizinho, de forma a encurtar o caminho para entrega dos
	    e-mails.  A linha seguinte trata mensagens para rede
	    Ethernet local, para domínios onde os mails possam
	    ser entregues via SMTP.  Finalmente, os vizinhos UUCP
	    são mencionados na notação do
	    pseudo-domínio .UUCP, que permite um
	    <code class="literal">uucp-neighbor!recipient</code>
	    sobrescrever as regras padrão.  A última
	    linha é sempre um ponto, que indica que todos os
	    e-mails que não foram tratados pelas entradas
	    anteriores cuja entrega seja do tipo UUCP, devem ser
	    tratados por um dos vizinhos UUCP que sirva como gateway
	    universal com o resto do mundo.  Todas as
	    estações antecedendo a entrada
	    <code class="literal">uucp-dom:</code> devem ser nomes de vizinhos
	    UUCP válidos, que podem ser checados com o comando
	    <code class="literal">uuname</code>.</p><p>Para lembrar que esse arquivo precisa ser convertido
	    em base de dados do tipo DBM, o comando necessário
	    para tomar essa ação está comentado
	    no início do arquivo mailertable.  Esse comando
	    deve ser executado sempre que o mailertable for
	    alterado.</p><p>Dica final: caso tenha dúvidas se uma rota de
	    e-mail em particular irá funcionar, lembre-se que a
	    opção <code class="option">-bt</code> do sendmail
	    permite que ele seja iniciado em modo de testes de
	    endereço; simplesmente digite
	    <code class="literal">3,0</code> seguido do endereço que
	    você quer testar o roteamento de mensagens.  A
	    última linha irá indicar o agente de
	    transferência interno que foi usado, a
	    estação de destino com a qual esse agente de
	    entrega irá se comunicar, e o seu endereço.
	    Para sair desse modo, digite Control-D.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sendmail -bt</code></strong>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>3,0 foo@example.com</code></strong>
canonify           input: foo @ example . com
...
parse            returns: $# uucp-dom $@ <em class="replaceable"><code>your.uucp.relay</code></em> $: foo &lt; @ example . com . &gt;
<code class="prompt">&gt;</code> <strong class="userinput"><code>^D</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69139664"></a><a id="ispmail"></a><p><strong>10.12.</strong></p></td><td align="left" valign="top"><p>Como eu configuro e-mail em uma conexão dialup
	    com a rede?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Se a sua conexão discada lhe atribui um
	    endereço IP estático, não é
	    necessário configurar nenhuma opção
	    extra.  Ajuste o nome da sua estação para o
	    nome que a identifica na Internet, e o sendmail
	    fará o resto.</p><p>Mas se a conexão PPP lhe atribui
	    endereços dinâmicos, provavelmente o seu
	    Provedor de Serviço Internet oferece uma conta de
	    correio eletrônico em seus servidores.  Vamos
	    assumir que o nome do domínio do seu provedor
	    é <code class="systemitem">example.net</code>, e
	    que o nome do seu usuário é
	    <code class="systemitem">user</code>.  Vamos assumir também
	    que o nome da sua estação seja <code class="systemitem">bsd.home</code> e que o Provedor de
	    Serviço Internet defina que o endereço
	    <code class="systemitem">relay.example.net</code> deva ser
	    usado para relay de mensagens eletrônicas.</p><p>Para acessar as mensagens da sua caixa de correio,
	    é necessário usar um agente de busca.  O
	    <span class="application">Fetchmail</span> é uma boa
	    escolha, já que ele suporta vários
	    protocolos distintos.  Normalmente o provedor em
	    questão oferece serviço de POP3.  Caso sua
	    conexão PPP seja estabelecida à nível
	    de usuário (user-PPP), para acessar suas mensagens
	    automaticamente ao estabelecer-se uma conexão com a
	    rede, basta adicionar a seguinte entrada no arquivo
	    <code class="filename">/etc/ppp/ppp/linkup</code>:</p><pre class="programlisting">MYADDR:
  !bg su user -c fetchmail</pre><p>Caso esteja usando o
	    <span class="application">sendmail</span> (como foi descrito
	    anteriormente) para entregar suas mensagens para
	    endereços não-locais, insira o
	    comando:</p><pre class="programlisting">  !bg su user -c "sendmail -q"</pre><p>depois da entrada apresentada anteriormente.  Esse
	    comando irá forçar o
	    <span class="application">sendmail</span> a processar sua fila
	    de e-mail tão logo uma conexão com a 
	    rede seja estabelecida.</p><p>Assumindo que exista uma conta para o
	    <code class="systemitem">user</code> na máquina <code class="systemitem">bsd.home</code>.  No diretório home
	    do <code class="systemitem">user</code> na estação
	    <code class="systemitem">bsd.home</code>, crie um arquivo
	    <code class="filename">.fetchmailrc</code>  com o seguinte
	    conteúdo:</p><pre class="programlisting">poll example.net protocol pop3 fetchall pass MySecret</pre><p>Esse arquivo não deve ter permissão de
	    leitura para nenhum outro usuário, a não ser
	    o <code class="systemitem">user</code> já que ele
	    contém a <code class="literal">sua senha</code>.</p><p>Para garantir que o cabeçalho
	    <code class="literal">from:</code> esteja sempre correto, é
	    necessário indicar ao
	    <span class="application">sendmail</span> que o endereço
	    <code class="literal">user@example.net</code>  deve ser usado ao
	    invés de <code class="literal">user@bsd.home</code>.
	    Também é interessante configurar o
	    <span class="application">sendmail</span> para entregar suas
	    mensagens via <code class="systemitem">relay.example.net</code>, permitindo
	    transmissão de mensagens de forma mais
	    rápida.</p><p>O seguinte arquivo <code class="filename">.mc</code> deve ser o
	    bastante:</p><pre class="programlisting">VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl</pre><p>Por gentileza, refira-se à seção
	    anterior para obter detalhes sobre como transformar esse
	    arquivo <code class="filename">.mc</code> em um arquivo
	    <code class="filename">sendmail.cf</code>.  Não se
	    esqueça também de reiniciar o
	    <span class="application">sendmail</span> depois de alterar o
	    <code class="filename">sendmail.cf</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69162832"></a><a id="sendmail-alternative"></a><p><strong>10.13.</strong></p></td><td align="left" valign="top"><p>Que outros servidores de correio eletrônico
	    posso usar no lugar do Sendmail?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O <a class="link" href="http://www.sendmail.org/" target="_top">Sendmail</a> é
	    o programa servidor de correio eletrônico
	    padrão no FreeBSD, mas ele pode ser facilmente
	    substituído por qualquer outro MTA (por
	    instância, um MTA instalado a partir do
	    <code class="literal">ports</code>).</p><p>Existem vários MTA's que servem de alternativa
	    ao Sendmail na Coleção de
	    <code class="literal">Ports</code> do FreeBSD, sendo o <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/mail/exim/pkg-descr">mail/exim</a>, <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/mail/postfix/pkg-descr">mail/postfix</a>, <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/mail/qmail/pkg-descr">mail/qmail</a>, <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/mail/zmailer/pkg-descr">mail/zmailer</a>, os mais
	    populares.</p><p>A diversidade é sempre uma boa
	    indicação, e o fato de ter vários
	    servidores de e-mail disponíveis é
	    ótimo.  Conteúdo, evite perguntas como
	    <span class="quote">&#8220;<span class="quote">O Sendmail é melhor que o Qmail?</span>&#8221;</span> nas
	    listas de discussão.  Se você realmente quer
	    saber, procure no histórico das listas.  As
	    vantagens e desvantagens de cada MTA já foram
	    discutidas inúmeras vezes.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69168848"></a><a id="forgot-root-pw"></a><p><strong>10.14.</strong></p></td><td align="left" valign="top"><p>Esqueci a senha de root!  O que eu faço?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Em primeiro lugar, não entre em pânico!
	    Reinicie o seu FreeBSD, digite <strong class="userinput"><code>boot
	      -s</code></strong> na tela do Boot: (ou apenas
	    <strong class="userinput"><code>-s</code></strong> para as versões
	    anteriores à 3.2 do FreeBSD) para entrar e modo
	    monousuário.  Quando o sistema perguntar sobre que
	    shell usar, aperte ENTER.  Você estará em uma
	    prompt de comandos;  digite <code class="command">mount -u /</code>
	    para montar o sistema de arquivos raiz com
	    leitura/escrita, e depois <code class="command">mount -a</code> para
	    remontar todos os seus sistemas de arquivos.  Execute o
	    comando <code class="command">passwd root</code> para modificar a
	    senha de root do sistema, e depois digite <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exit&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">exit</span>(1)</span></a>
	    para continuar  a inicialização em modo
	    multiusuário.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69173712"></a><a id="CAD-reboot"></a><p><strong>10.15.</strong></p></td><td align="left" valign="top"><p>Como posso evitar que a seqüência de teclas
	    <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>Delete</strong></span>
	    reinicie o sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Caso esteja usando o syscons (o driver padrão
	    para o console) em um sistema FreeBSD 2.2.7 ou posterior,
	    construa e instale um novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> com a
	    opção:</p><pre class="programlisting">options SC_DISABLE_REBOOT</pre><p>Caso use o driver de console PCVT em um FreeBSD 2.2.5
	    ou posterior, use a seguinte linha:</p><pre class="programlisting">options PCVT_CTRL_ALT_DEL</pre><p>Em versões anteriores às citadas, edite
	    o mapeamento do seu teclado, usado para o console, e
	    substitua a palavra <code class="literal">boot</code> por
	    <code class="literal">nop</code>.  O mapeamento de teclado
	    padrão está em
	    <code class="filename">/usr/share/syscons/keymaps/us.iso.kbd</code>.
	    O <code class="filename">/etc/rc.conf</code> deve ser
	    instruído de forma que esse arquivo seja lido.  Se
	    você estiver usando um outro mapa específico
	    para o seu país, edite esse mapa ao invés do
	    padrão.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69188688"></a><a id="dos-to-unix-txt"></a><p><strong>10.16.</strong></p></td><td align="left" valign="top"><p>Como posso converter arquivos de texto do DOS para o
	    formato do Unix?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Use esse comando do perl:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>perl -i.bak -npe 's/\r\n/\n/g' file...  </code></strong></pre><p>onde <code class="literal">file</code> indica o arquivo ou
	    arquivos a serem processados.  As
	    modificações são feitas no
	    próprio arquivo e o original é salvo com a
	    extensão .bak.</p><p>O comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tr</span>(1)</span></a> também pode ser
	    usado:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>tr -d '\r' &lt; dos-text-file &gt; unix-file</code></strong></pre><p>Onde <em class="replaceable"><code>dos-text-file</code></em> é
	    o arquivo com o texto em formato DOS, enquanto o
	    <em class="replaceable"><code>unix-file</code></em> armazenará a
	    saída convertida.  Usar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tr&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tr</span>(1)</span></a> é um
	    pouco mais rápido do que usar o perl.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69196624"></a><a id="kill-by-name"></a><p><strong>10.17.</strong></p></td><td align="left" valign="top"><p>Como eu mato processos pelo seu nome?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Use o comando <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=killall&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">killall</span>(1)</span></a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69199440"></a><a id="root-acl"></a><p><strong>10.18.</strong></p></td><td align="left" valign="top"><p>Por que motivos o su está me atazanando pelo
	    fato de não pertencer à ACL do
	    <code class="systemitem">root</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esse erro é proveniente do sistema de
	    autenticação da distrição do
	    Kerberos.  O problema não é uma
	    perturbação fatal.  Basta executar o su com
	    a opção -K ou então desinstalar o
	    Kerberos, como será descrito na próxima
	    questão.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69202000"></a><a id="uninstall-kerberos"></a><p><strong>10.19.</strong></p></td><td align="left" valign="top"><p>Como eu desinstalo o Kerberos?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Para remover o Kerberos do sistema, reinstale a
	    distribuição <code class="literal">bin</code> da
	    versão que está sendo usada.  Caso tenha o
	    CDROM do FreeBSD, monte-o (vamos assumir, em /cdrom) e
	    execute os comandos:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /cdrom/bin</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>./install.sh</code></strong></pre><p>Ou então, apague todas as opções
	    <span class="quote">&#8220;<span class="quote">MAKE_KERBEROS</span>&#8221;</span> do
	    <code class="filename">/etc/make.conf</code> e recompile todo o
	    sistema com um build world.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69207376"></a><a id="add-pty"></a><p><strong>10.20.</strong></p></td><td align="left" valign="top"><p>Como posso adicionar pseudo-terminais ao
	    sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Caso tenha inúmeras conexões telnet,
	    ssh, X, ou tela de usuário, é
	    provável que você atingirá o limite
	    dos seus pseudo-terminais.  Aqui estão as
	    instruções de como adicionar mais
	    pseudo-terminais:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Construa e instale um novo
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> com a
		linha</p><pre class="programlisting">pseudo-device pty 256</pre><p>em seu arquivo de
		configurações.</p></li><li class="step"><p>Execute os comandos</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV pty{1,2,3,4,5,6,7}</code></strong></pre><p>de forma a criar 256 novos devices para os novos
		terminais.</p></li><li class="step"><p>Edite o <code class="filename">/etc/ttys</code>  e adicione
		uma linha para cada um dos 256 terminais.  Tais
		entradas devem ter o formato correspondente às
		entradas já existentes, por exemplo:</p><pre class="programlisting">ttyqc none network</pre><p>A ordem de definição das letras
		é expressa como
		<code class="literal">tty[pqrsPQRS][0-9a-v]</code>, ao
		ilustrarmos em expressões regulares.</p></li><li class="step"><p>Reinicie o sistema com o novo
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, e
		pronto.</p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69222224"></a><a id="create-snd0"></a><p><strong>10.21.</strong></p></td><td align="left" valign="top"><p>Por que motivo não consigo criar a device
	    snd0?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Simples, porque não existe a device
	    <code class="filename">snd</code>.  Esse nome é usado
	    para identificar o conjunto de devices que compõem
	    os drivers de som do FreeBSD, como as devices
	    <code class="filename">mixer</code>,
	    <code class="filename">sequencer</code>, e
	    <code class="filename">dsp</code>.</p><p>Para criar tais devices, basta executar:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV snd0</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69227984"></a><a id="reread-rc"></a><p><strong>10.22.</strong></p></td><td align="left" valign="top"><p>Como posso reler o <code class="filename">/etc/rc.conf</code> e
	    reiniciar o <code class="filename">/etc/rc</code> sem rebootar o
	    sistema?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Vá para o modo monousuário e volte para
	    o modo multiusuário.</p><p>É simples; no console, faça:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>shutdown now</code></strong>
(Note: without -r or -h)

<code class="prompt">#</code> <strong class="userinput"><code>return</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>exit</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69237840"></a><a id="sandbox"></a><p><strong>10.23.</strong></p></td><td align="left" valign="top"><p>O que é uma sandbox?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><span class="quote">&#8220;<span class="quote">Sandbox</span>&#8221;</span> é um jargão usado
	    em discussões pertinentes à segurança
	    de sistemas.  Pode significar duas coisas:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Um processo enquadrado em um conjunto de paredes
		virtuais que são criadas para prevenir que
		algum usuário, ao explorar alguma
		inconformidade do processo, possa também
		explorar e obter privilégios no sistema
		operacional como um todo.</p><p>O processo deve conseguir <span class="quote">&#8220;<span class="quote">rodar</span>&#8221;</span>
		dentro dessas paredes, ou seja, nada que o processo
		possa fazer ao executar seu código, pode ser
		capaz de violar tais paredes.  Dessa forma não
		é necessária uma auditoria detalhada do
		código e das ações do processo
		para que se possa realizar algumas
		afirmações pertinentes à
		segurança de tal sistema.</p><p>Tais paredes podem ser a
		identificação de um usuário
		(userid), por exemplo.  Essa é a
		definição de sandbox usada nas
		páginas de manuais do named e de
		security.</p><p>Observe o serviço <code class="literal">ntalk</code>,
		como exemplo (veja o /etc/inetd.conf).  Esse
		serviço costumava ser executado com userid do
		<code class="systemitem">root</code>.  Hoje em dia o processo
		roda com o userid do <code class="systemitem">tty</code>.  O
		usuário <code class="systemitem">tty</code>, portanto,
		é uma sandbox criada para dificultar qualquer
		atividade de um usuário malicioso que por
		ventura consiga acesso ao sistema por meio do ntalk.
		Com essa sandbox, uma violação de
		segurança bem sucedida via
		<code class="literal">ntalk</code> dificultaria qualquer
		ação tomada além das
		possíveis com o userid do
		<code class="systemitem">tty</code>.</p></li><li class="listitem"><p>Um processo criado dentro de um ambiente de
		simulação.  Essa é uma
		situação mais complexa.  Basicamente
		implica que qualquer pessoa má intencionada que
		consiga explorar tal processo, acreditará que
		pode obter acesso à todo o ambiente, nas na
		verdade, estará apenas acessando um sistema de
		simulação, não alterando nenhum
		dado real.</p><p>A forma mais comum de conseguir criar um ambiente
		simulado como esse, é criando um
		subdiretório à partir de onde o processo
		consiga acessar (uma cópia de) qualquer arquivo
		do sistema que por ventura ele precise, e executar
		esse processo simulando um diretório raiz (ou
		seja, para o processo, o <code class="filename">/</code>
		será o subdiretório determinado, e
		não o verdadeiro <code class="filename">/</code> do
		sistema).</p><p>Outra situação comum é montar
		um sistema de arquivos base com apenas
		permissão de leitura, e depois criar um outro
		sistema de arquivos em uma camada superior, com acesso
		de escrita/leitura, dando ao processo a
		impressão de poder ler/escrever em todo o
		sistema de arquivos.  Apenas o processo em
		questão percebe esse ambiente, enquanto os
		outros não são necessariamente
		ludibriados.</p><p>A intenção é que tais sandbox
		sejam tão transparentes que qualquer
		usuário (ou hacker) não consiga perceber
		que está dentro de uma.</p></li></ul></div><p>Os sistemas Unix costumam implementar esses dois
	    principais tipos de sandbox, um em nível de
	    processo e o outro, muito comum, em nível de
	    userid.</p><p>Cada processo Unix é completamente separado dos
	    outros, por meio de algum tipo de parede de
	    segurança.  Um processo nunca modifica o
	    espaço de endereçamento de outro, diferente
	    do ambiente Windows onde cada processo pode facilmente
	    sobrescrever endereços de outros processos, fazendo
	    o sistema travar.</p><p>Cada processo Unix é de propriedade de um
	    userid em particular.  Caso o userid não seja do
	    <code class="systemitem">root</code>, ele serve de parede de
	    segurança em relação aos processos
	    pertencentes a outros usuários.  Os userid
	    também são usados para proteger dados
	    armazenados em disco.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69254352"></a><a id="securelevel"></a><p><strong>10.24.</strong></p></td><td align="left" valign="top"><p>O que é <code class="literal">securelevel</code>
	    (nível de segurança do sistema)?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p><code class="literal">securelevel</code> (nível de
	    segurança do sistema) é um mecanismo de
	    segurança implementado no
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD.
	    Basicamente, quando o <code class="literal">securelevel</code>
	    é positivo, o <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>
	    restringe algumas tarefas do sistema;  nem mesmo o
	    superusuário (por exemplo, o
	    <code class="systemitem">root</code>) tem permissão de
	    realizar tais tarefas.  Na data que este
	    <code class="literal">FAQ</code> foi escrito, o mecanismo de
	    <code class="literal">securelevel</code> do FreeBSD era capaz de,
	    entre outras coisas, limitar as habilidades de:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>retirar algumas flags de arquivos, como a
		<code class="literal">schg</code> (flag de imutabilidade do
		sistema),</p></li><li class="listitem"><p>escrever na memória do
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span> por meio do
		<code class="filename">/dev/mem</code> e
		<code class="filename">/dev/kmem</code>,</p></li><li class="listitem"><p>carregar módulos do
		<span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, e</p></li><li class="listitem"><p>alterar regras de Firewall do
		<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ipfirewall&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ipfirewall</span>(4)</span></a>.</p></li></ul></div><p>Para verificar o estado do
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema) em um sistema em funcionando,
	    simplesmente execute o seguinte comando:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>A saída apresentará o nome da
	    variável do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> (nesse caso,
	    <code class="varname">kern.securelevel</code>) e um número.
	    Esse último será o valor atual do
	    nível de segurança do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD.  Caso
	    esse valor seja positivo (maior que 0), ao menos algumas
	    das características dos níveis de
	    segurança estarão habilitadas.</p><p>Os níveis de segurança não podem
	    ser diminuídos em um sistema que está
	    funcionando se isso fosse possível o
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema) perderia sua funcionalidade.
	    Caso seja necessário executar alguma tarefa que
	    necessite que o nível de segurança seja
	    não-positivo (por exemplo, um
	    <code class="buildtarget">installworld</code> ou alterar a data do
	    sistema) será preciso alterar as
	    definições de <code class="literal">securelevel</code>
	    (nível de segurança do sistema) no
	    <code class="filename">/etc/rc.conf</code> (mais precisamente, as
	    variáveis <code class="varname">kern_securelevel</code> e
	    <code class="varname">kern_securelevel_enable</code>) e reiniciar o
	    sistema.</p><p>Para obter mais informações quanto aos
	    níveis de segurança e sobre as
	    funções específicas de cada
	    nível, por gentileza, consulte a página de
	    manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>.</p><div xmlns="" class="warning"><h3 class="admontitle">Atenção: </h3><p xmlns="http://www.w3.org/1999/xhtml">O <code class="literal">securelevel</code> (nível de
	      segurança do sistema) não é uma
	      bala de prata;  ele tem várias deficiências
	      óbvias.  A mais frequênte é provocar
	      uma falsa sensação de
	      segurança.</p><p xmlns="http://www.w3.org/1999/xhtml">Um dos maiores problemas, e portanto que deve ser
	      bem observada pelo administrador do sistema, é
	      que, para que o <code class="literal">securelevel</code>
	      (nível de segurança do sistema) se torne
	      efetivo, todos os arquivos usados pelo processo de
	      inicialização até que os
	      níveis de segurança se tornem positivos,
	      devem estar seguros.  Se um usuário que deseja
	      atacar o sistema, conseguir que seu código seja
	      executado antes que o nível de segurança
	      seja definido (o que ocorre pouco depois do processo de
	      inicialização, visto que algumas
	      funções que o sistema precisa realizar,
	      não podem ser iniciadas com um nível
	      elevado de segurança), a proteção
	      do <code class="literal">securelevel</code> (nível de
	      segurança do sistema) será invalidada.
	      Por outro lado, a tarefa de assegurar que todos os
	      arquivos necessários pelo processo de
	      inicialização estejam em conformidade,
	      não é tecnicamente impossível, mas,
	      O processo de manutenção de um ambiente em
	      tais condições se tornaria um pesadelo,
	      visto que seria necessário baixar o sistema, no
	      mínimo para modo monousuário sempre que
	      fosse necessário modificar os arquivos de
	      configuração do mesmo.</p><p xmlns="http://www.w3.org/1999/xhtml">Esse e outros pontos são freqüentemente
	      discutidos nas listas do FreeBSD, em especial na
	      freebsd-security.  Por gentileza, queira fazer uma busca
	      no histórico da lista, <a class="link" href="../../../../search/index.html" target="_top">clicando
		aqui</a>, para uma discussão extensa sobre
	      o assunto.  Algumas pessoas estão
	      esperançosas de que o securelevel logo
	      será afastado, em favor de um mecanismo de
	      segurança mais refinado, mas as coisas ainda
	      estão confusas a este respeito.</p><p xmlns="http://www.w3.org/1999/xhtml">Considere-se advertido.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69281104"></a><a id="release-candidate"></a><p><strong>10.25.</strong></p></td><td align="left" valign="top"><p>Tentei atualizar meu sistema para o último
	    -STABLE, mas ele se tornou -RC ou -PRERELEASE!  O que
	    está havendo?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A resposta mais curta: É só um nome, RC
	    é um acrônimo para <span class="quote">&#8220;<span class="quote">Release
	      Candidate</span>&#8221;</span>.  Significa que uma nova versão
	    está eminente.  No FreeBSD, -PRERELEASE é
	    tipicamente um sinonimo de código congelado antes
	    de uma nova versão.  (Em algumas versões, o
	    título -BETA foi usado sob as mesmas
	    circunstâncias em que o -PRERELEASE seria).</p><p>A resposta longa: O FreeBSD normalmente deriva suas
	    versões de duas fontes de origem.  As
	    versões principais, ponto-zero, como o 3.0-RELEASE
	    e o 4.0-RELEASE que são marcadas inicialmente como
	    o topo da cadeia de desenvolvimento, normalmente chamados
	    de <a class="link" href="introduction.html#current" title="1.7.">-CURRENT</a>.  As
	    versões menores (como 3.1-RELEASE ou 4.2-RELEASE),
	    são criados a partir do
	    <span class="foreignphrase"><em class="foreignphrase">snapshot</em></span> mais recente da
	    ramificação ativa marcada como <a class="link" href="introduction.html#stable" title="1.8.">-STABLE</a>.  A partir do
	    4.3-RELEASE, cada versão conta também com
	    sua própria ramificação, que pode ser
	    acessada por usuários que queiram apenas um
	    nível extremamente conservador de desenvolvimento
	    (tipicamente, apenas consultores de
	    segurança).</p><p>Quando uma versão está para ser criada,
	    a ramificação de onde ela se derivará
	    deve passar por um certo processo.  Parte desse processo
	    é o congelamento do código.  Quando o
	    processo de congelamento do código se inicia, o
	    nome desta ramificação é alterado
	    para indicar que ela está para se tornar uma
	    versão.  Por exemplo, se a
	    ramificação usada chamava-se 4.5-STABLE, ela
	    passa a se chamar 4.6-PRERELEASE para indicar que o
	    código está congelado, e indicar que testes
	    extras, pré versão, estão
	    acontecendo.  Durante esse período
	    alterações pertinentes a
	    correções de problemas são
	    realizadas.  Quando o novo código está
	    pronto para ser lançado, ele passa a ser chamado de
	    -RC (nesse exemplo, 4.6-RC), indicando que provavelmente a
	    nova versão será criada a partir do
	    código atual.  Nesse estágio, apenas os
	    problemas mais sérios são corrigidos.
	    Depois que a versão é finalmente
	    lançado (4.6-RELEASE nesse exemplo) e a nova
	    ramificação com o nome dessa versão
	    foi criada, ela passa a se chamar -STABLE;  4.6-STABLE no
	    nosso exemplo.</p><p>Para obter mais informações sobre a
	    numeração das versões e sobre as
	    várias ramificações CVS, por
	    gentileza, refira-se ao artigo sobre a <a class="link" href="../../articles/releng/article.html" target="_top">Engenharia de
	      Releases</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69315408"></a><a id="kernel-chflag-failure"></a><p><strong>10.26.</strong></p></td><td align="left" valign="top"><p>Tentei instalar um novo
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, mas a rotina de
	    chflags falhou.  O que posso fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A resposta curta: provavelmente você está
	    com o <code class="literal">securelevel</code> (nível de
	    segurança do sistema) acima do 0.  Reinicie o
	    sistema em modo mono usuário e instale o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.</p><p>A resposta mais completa: O FreeBSD não permite
	    que as flags do sistema sejam alteradas caso o
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema) seja maior que 0.  O
	    nível atual do <code class="literal">securelevel</code>
	    (nível de segurança do sistema) pode ser
	    verificado com o comando:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>O <code class="literal">securelevel</code> (nível de
	    segurança do sistema) não pode ser
	    diminuído; é necessário iniciar o
	    sistema em modo mono usuário, ou alterar o
	    nível de segurança em
	    <code class="filename">/etc/rc.conf</code>, depois reiniciar.  Veja
	    a página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> para obter
	    informações mais detalhadas sobre o
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema), e veja também o
	    <code class="filename">/etc/defaults/rc.conf</code> e a
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> para obter mais
	    informações quanto ao rc.conf.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69324496"></a><a id="kernel-securelevel-time"></a><p><strong>10.27.</strong></p></td><td align="left" valign="top"><p>Não consigo alterar mais de um segundo na hora
	    no meu sistema.  O que posso fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A resposta curta: provavelmente o sistema está
	    com <code class="literal">securelevel</code> (nível de
	    segurança do sistema) acima do 1.  Reinicie o
	    sistema em modo mono usuário e altere a
	    data.</p><p>A resposta mais completa: O FreeBSD não permite
	    que a hora do sistema seja alterada por mais de um segundo
	    quando o <code class="literal">securelevel</code> (nível de
	    segurança do sistema) do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> é maior que
	    1.  O nível atual do <code class="literal">securelevel</code>
	    (nível de segurança do sistema) pode ser
	    verificado com o comando:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel</code></strong></pre><p>O <code class="literal">securelevel</code> (nível de
	    segurança do sistema) não pode ser
	    diminuído; é necessário iniciar o
	    sistema em modo mono usuário, ou alterar o
	    nível de segurança em
	    <code class="filename">/etc/rc.conf</code>, depois reiniciar.  Veja
	    a página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> para obter
	    informações mais detalhadas sobre o
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema), e veja também o
	    <code class="filename">/etc/defaults/rc.conf</code> e a
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">rc.conf</span>(5)</span></a> para obter mais
	    informações quanto ao rc.conf.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69341520"></a><a id="statd-mem-leak"></a><p><strong>10.28.</strong></p></td><td align="left" valign="top"><p>Por que motivo o <code class="command">rpc.statd</code>
	    está usando 256 megabytes de memória?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Não, mão existe nenhuma falha no uso da
	    memória, e ele nã é usando 256MB de
	    RAM.  Ele simplesmente gosta de (ele sempre faz isso)
	    mapear uma quantia obscena de memória em seu
	    endereçamento, simplesmente por conveniência.
	    Não existe nada terrivelmente errado com esse
	    comportamento, de um ponto de vista técnico;  a
	    única questão é que assim o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a> e o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> ficam completamente
	    perdidos.</p><p>O <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rpc.statd</span>(8)</span></a> mapeia seu arquivo de status
	    (localizado sob o <code class="filename">/var</code>) no seu
	    endereçamento para economiza
	    preocupações sobre esse remapeamento em um
	    segundo momento, quando o arquivo precisa crescer.  O
	    mapeamento é feito a um valor enorme.  Analisando o
	    código fonte, podemos evidenciar que o tamanho do
	    argumento do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mmap&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a> é
	    <code class="literal">0x10000000</code>, ou exatos 256MB em sistemas
	    de arquitetura IA32.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69348304"></a><a id="unsetting-schg"></a><p><strong>10.29.</strong></p></td><td align="left" valign="top"><p>Por que eu não posso retirar a flag
	    <code class="literal">schg</code> dos arquivos?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O sistema está sendo executado em um
	    nível de segurança elevado (maior que 0).
	    Diminua o nível de segurança e tente
	    novamente.  Para obter mais informações, por
	    gentileza, refira-se à seção sobre
	    <a class="link" href="admin.html#securelevel" title="10.24."><code class="literal">securelevel</code>
	      (nível de segurança do sistema)</a> do
	    <code class="literal">FAQ</code>, e à página de manual
	    do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a></p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69352528"></a><a id="ssh-shosts"></a><p><strong>10.30.</strong></p></td><td align="left" valign="top"><p>Por que a autenticação do SSH via
	    <code class="filename">.shosts</code> não funciona por
	    padrão nas versões recentes do
	    FreeBSD?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O motivo é simples.  A
	    autenticação via
	    <code class="filename">.shosts</code> não funciona mais por
	    padrão porque o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> não está
	    instalado com suid de root por padrão.
	    Razões óbvias de segurança.  Para
	    <span class="quote">&#8220;<span class="quote">corrigir</span>&#8221;</span> isto, pode-se fazer o
	    seguinte:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Para uma alteração permanente,
		defina <code class="varname">ENABLE_SUID_SSH</code> como
		<code class="literal">true</code> no arquivo
		<code class="filename">/etc/make.conf</code> e recompile o ssh
		(ou execute um make world).</p></li><li class="listitem"><p>Uma correção temporária pode
		ser mudar os modos de permissão do 
		<code class="filename">/usr/bin/ssh</code> para
		<code class="literal">4555</code> simplesmente executando o
		comando <code class="command">chmod 4555 /usr/bin/ssh</code>
		logado como <code class="systemitem">root</code>.  Depois, defina
		<code class="varname">ENABLE_SUID_SSH= true</code> no
		<code class="filename">/etc/make.conf</code> para que as
		alterações tenham efeito todas as vezes
		que um make world for feito.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69370448"></a><a id="vnlru"></a><p><strong>10.31.</strong></p></td><td align="left" valign="top"><p>O que é o <code class="literal">vnlru</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O <code class="literal">vnlru</code> limpa e libera os vnodes
	    quando o sistema atinge o limite do
	    <code class="varname">kern.maxvnodes</code>.  Essa thread do
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> se mantém
	    inativa a maior parte do tempo, e só se inicia caso
	    exista uma grande quantidade de memória RAM, e o
	    sistema esteja acessando dezenas de milhares de arquivos
	    pequenos.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="disks.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="x.html">Próxima</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 9. Discos, Sistemas de Arquivos e Carregadores de
      Inicialização (<span class="foreignphrase"><em class="foreignphrase">Boot
	Loaders</em></span>) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td><td width="40%" align="right" valign="top"> Capítulo 11. O sistema X, sistema de interface gráfica e os
      Consoles Virtuais</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Este, e outros documentos, podem ser obtidos em
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Para perguntas sobre FreeBSD, leia a
    <a href="http://www.FreeBSD.org/docs.html">documentação</a> antes de contatar
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Para perguntas sobre esta documentação, envie e-mail para
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>