<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 11. O sistema X, sistema de interface gráfica e os Consoles Virtuais</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="up" href="index.html" title="Perguntas mais freqüentes sobre FreeBSD 2.X, 3.X e 4.X" /><link rel="prev" href="admin.html" title="Capítulo 10. Administração do Sistema" /><link rel="next" href="networking.html" title="Capítulo 12. Redes" /><link rel="copyright" href="legalnotice.html" title="Nota Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 11. O sistema X, sistema de interface gráfica e os
      Consoles Virtuais</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="admin.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="networking.html">Próxima</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x"></a>Capítulo 11. O sistema X, sistema de interface gráfica e os
      Consoles Virtuais</h1></div></div></div><div class="qandaset"><a id="idp69375056"></a><dl><dt>11.1. <a href="x.html#idp69375312">Quero rodar a interface gráfica X, como
	    procedo?</a></dt><dt>11.2. <a href="x.html#idp69392336">Tentei rodar o X, mas o erro
	    KDENABIO failed (Operation not
	      permitted) sempre aparece, quando eu digito
	    o comando startx.  O que posso
	    fazer?</a></dt><dt>11.3. <a href="x.html#idp69417296">Por que meu mouse não funciona com o X?</a></dt><dt>11.4. <a href="x.html#idp69427536">Meu mouse possui aquela bolinha (esfera)
	    simpática de scroll.  Posso usa-lo no X?</a></dt><dt>11.5. <a href="x.html#idp69491152">Por quê os menus e caixas de diálogo do
	    X, sistema de interface gráfica não
	    funcionam direito?</a></dt><dt>11.6. <a href="x.html#idp69499856">O que é um console virtual, e como eu crio mais
	    consoles?</a></dt><dt>11.7. <a href="x.html#idp69525456">Como posso acessar os consoles virtuais quando eu
	    estiver no X?</a></dt><dt>11.8. <a href="x.html#idp69543504">Como eu inicio o XDM no processo de
	    inicialização?</a></dt><dt>11.9. <a href="x.html#idp69559376">Por que eu enfrento um Couldn't open
	      console ao executar o xconsole? </a></dt><dt>11.10. <a href="x.html#idp69567696">Antes eu conseguia usar o XFree86 com um
	    usuário sem privilégios.  Porque agora o
	    servidor diz que eu tenho que ser
	    root?</a></dt><dt>11.11. <a href="x.html#idp69588176">Por que meu mouse PS/2 não se comporta
	    corretamente no X?</a></dt><dt>11.12. <a href="x.html#idp69602896">Por que meu mouse PS/2 da MouseSystems não
	    funciona?</a></dt><dt>11.13. <a href="x.html#idp69615568">Ao compilar uma aplicação X, o
	    imake não consegue encontrar o
	    Imake.tmpl.  Onde ele
	    está?</a></dt><dt>11.14. <a href="x.html#idp69619152">Estou construindo uma aplicação
	    gráfica que depende do XFree86 3.3.X, mas eu estou
	    com o XFree86 4.X instalado.  O que fazer?</a></dt><dt>11.15. <a href="x.html#idp69622480">Como posso inverter as funções dos
	    botões do mouse?</a></dt><dt>11.16. <a href="x.html#idp69625808">Como instalar uma Splash Screen e onde posso
	    encontra-las?</a></dt><dt>11.17. <a href="x.html#idp69667152">Posso usar as teclas do Windows® que meu teclado
	    possui, sob o X?</a></dt><dt>11.18. <a href="x.html#idp69686736">Como posso obter a aceleração de
	    equipamentos 3D para o OpenGL?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp69375312"></a><a id="running-X"></a><p><strong>11.1.</strong></p></td><td align="left" valign="top"><p>Quero rodar a interface gráfica X, como
	    procedo?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A maneira mais fácil é simplesmente
	    especificar o desejo de usar o X durante o processo de
	    instalação do FreeBSD.</p><p>Depois disso, leia e siga as instruções
	    documentadas na ferramenta <code class="command">xf86config</code>,
	    que auxilia o usuário a configurar o XFree86 para
	    os diversos monitores, placas de vídeo, mouse e
	    etc, suportados pelo X, sistema de interface
	    gráfica.</p><p>Também pode ser interessante dar uma olhada no
	    servidor Xaccel.  Confira a seção do
	    <code class="literal">FAQ</code> pertinente à <a class="link" href="commercial.html#xig">Xi Graphics</a> ou <a class="link" href="commercial.html#metrox">Metro Link</a> para obter mais
	    detalhes.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69392336"></a><a id="running-X-securelevels"></a><p><strong>11.2.</strong></p></td><td align="left" valign="top"><p><span class="emphasis"><em>Tentei</em></span> rodar o X, mas o erro
	    <span class="errorname">KDENABIO failed (Operation not
	      permitted)</span> sempre aparece, quando eu digito
	    o comando <code class="command">startx</code>.  O que posso
	    fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Seu sistema está rodando com um
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema) elevado, não
	    está? É impossível iniciar o X com um
	    secureleve elevado.  Para saber exatamente os motivos
	    dessa inviabilidade, por gentileza, de uma olhada na
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>.</p><p>Então, a pergunta pode ser sobre o que
	    você deve fazer nesse caso; basicamente, existem
	    duas escolhas: diminua seu <code class="literal">securelevel</code>
	    (nível de segurança do sistema), colocando-o
	    de volta para zero (normalente via
	    <code class="filename">/etc/rc.conf</code>), ou então inicie
	    o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> durante o processo de
	    inicialização do sistema (antes que o
	    <code class="literal">securelevel</code> (nível de
	    segurança do sistema) seja elevado).</p><p>Veja a pergunta <a class="xref" href="x.html#xdm-boot" title="11.8.">P: 11.8</a>, para obter
	    mais informações sobre como iniciar o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a> durante o boot.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69417296"></a><a id="x-and-moused"></a><p><strong>11.3.</strong></p></td><td align="left" valign="top"><p>Por que meu mouse não funciona com o X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Caso esteja usando o syscons (o driver padrão
	    do console), o FreeBSD pode ser configurado para suportar
	    um cursor de mouse em cada tela virtual.  Com o
	    intúito de evitar conflitos com o X, o syscons
	    suporta um dispositivo virtual, chamado
	    <code class="filename">/dev/sysmouse</code>.  Todos os eventos
	    relacionados ao mouse, que o sistema recebe, são
	    antes enviados para o device sysmouse, por meio do moused.
	    Se a intenção é usar o mouse em um ou
	    mais consoles virtuais, e também usar o X, leia
	    <a class="xref" href="hardware.html#moused" title="4.13.">P: 4.13</a> e
	    configure o moused.</p><p>Depois, edite o <code class="filename">/etc/XF86Config</code> e
	    garanta que existam as seguintes linhas no arquivo:</p><pre class="programlisting">Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
.....</pre><p>O exemplo acima refere-se ao XFree86 3.3.2 e
	    posteriores.  Para versões anteriores, a
	    cláusula <span class="emphasis"><em>Protocol</em></span> deve ser
	    substituída por
	    <span class="emphasis"><em>MouseSystems</em></span>.</p><p>Alguns preferem usar a device
	    <code class="filename">/dev/mouse</code> sob o X.  Para que
	    isso funcione, faça um link de
	    <code class="filename">/dev/mouse</code> para
	    <code class="filename">/dev/sysmouse</code> (veja a
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysmouse&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sysmouse</span>(4)</span></a>).</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>rm -f mouse</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>ln -s sysmouse mouse</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69427536"></a><a id="x-and-wheel"></a><p><strong>11.4.</strong></p></td><td align="left" valign="top"><p>Meu mouse possui aquela bolinha (esfera)
	    simpática de scroll.  Posso usa-lo no X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Pode, mas é necessário customizar os
	    programas do X.  Veja a página do Colas Nahaboo
	    sobre o assunto (<a class="link" href="http://www.inria.fr/koala/colas/mouse-wheel-scroll/" target="_top">
	      http://www.inria.fr/koala/colas/mouse-wheel-scroll/</a>.</p><p>Caso queira usar o programa
	    <span class="application">imwheel</span>, simplesmente siga os
	    seguintes passos:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Traduza os eventos da esfera de scroll:</p><p>O programa <span class="application">imwheel</span>
		funciona assim: ele traduz os botões 4 e 5 do
		mouse em eventos do teclado do computador.  Dessa
		forma é necessário assegurar que o
		driver do mouse esteja traduzindo os eventos da esfera
		de scroll para os eventos dos botões 4 e 5, ou
		seja assimilar suas funções.  Existem
		duas formas de fazer isso, a primeira é usando
		o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> para fazer essas
		assimilações, e a segunda, é usar
		o próprio X para traduzir os eventos.</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Usando o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> para traduzir os
		    eventos da bolinha de scroll.</p><p>Para que o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> faça as
		    assimilações de eventos, basta
		    adicionar as opções <code class="option">-z
		      4</code> nas opções de linhas de
		    comando, usadas para iniciar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>.
		    Por exemplo, se normalmente você inicia o
		    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> via <code class="command">moused -p
		      /dev/psm0</code> basta substituir o comando
		    por <code class="command">moused -p /dev/psm0 -z 4</code>.
		    Se o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> é executado
		    automaticamente durante o processo de
		    inicialização do FreeBSD, por meio
		    das entradas definidas no
		    <code class="filename">/etc/rc.conf</code>, basta adicionar
		    <code class="option">-z 4</code> na variável
		    <code class="varname">moused_flags</code> do
		    <code class="filename">/etc/rc.conf</code>.</p><p>Você precisa agora dizer para o X que
		    você tem o botão 5 no mouse.  Para
		    fazer isto, simplesmente adicione a linha
		    <code class="literal">Buttons 5</code> para a
		    seção <span class="quote">&#8220;<span class="quote">Pointer</span>&#8221;</span> do
		    <code class="filename">/etc/XF86Config</code>.  Por
		    exemplo, você pode seguir a
		    seção <span class="quote">&#8220;<span class="quote">Pointer</span>&#8221;</span> em
		    <code class="filename">/etc/XF86Config</code>.</p><div class="example"><a id="idp69447760"></a><div class="example-title">Exemplo 11.1. Seção <span class="quote">&#8220;<span class="quote">Pointer</span>&#8221;</span>
		      no XF86Config para o mouse com bolinha de
		      scroll, da série 3.3.x do XFree86, usando
		      a tradução se;rie 3.3.x do
		      XFree86, usando a tradução por
		      meio do moused</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
Protocol        "SysMouse"
Device          "/dev/sysmouse"
Buttons         5
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp69449296"></a><div class="example-title">Exemplo 11.2. Seção
		      <span class="quote">&#8220;<span class="quote">InputDevice</span>&#8221;</span> do XF86Config para
		      usar a tradução do X Server na
		      série 4.X do XFree86.</div><div class="example-contents"><pre class="programlisting">Section "InputDevice"
Identifier      "Mouse1"
Driver          "mouse"
Option          "Protocol" "auto"
Option          "Device" "/dev/sysmouse"
Option          "Buttons" "5"
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp69450832"></a><div class="example-title">Exemplo 11.3. Exemplo de <span class="quote">&#8220;<span class="quote">.emacs</span>&#8221;</span> para usar
		      paginamento em mouse com bolinha de
		      scroll.</div><div class="example-contents"><pre class="programlisting">;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</pre></div></div><br class="example-break" /></li><li class="listitem"><p>Usando o X Server para traduzir os eventos da
		    esfera de scroll.</p><p>Se você não usa o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>
		    ou simplesmente não quer que ele
		    faça a tradução de eventos,
		    é possível que o servidor X
		    faça o trabalho, no lugar do
		    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a>.  Essa ação requer
		    algumas alterações no seu arquivo
		    <code class="filename">/etc/XF86Config</code>.  Primeiro,
		    é necessário definir o protocolo
		    apropriado para o mouse.  A maioria dos mouses com
		    esferas de scroll usam o protocolo
		    <span class="quote">&#8220;<span class="quote">IntelliMouse</span>&#8221;</span>.  De qualquer forma, o
		    XFree86 não suporta outros protocolos como
		    o <span class="quote">&#8220;<span class="quote">MouseManPlusPS/2</span>&#8221;</span> dos MouseMan+
		    Logitechfor.  Uma vez definido o protocolo,
		    é necessário criar uma entrada
		    apropriada na seção
		    <span class="quote">&#8220;<span class="quote">Pointer</span>&#8221;</span>.</p><p>Depois, é preciso definir que o
		    servidor X deve remapear os eventos 4 e 5 do
		    mouse.  A opção
		    <code class="varname">ZAxisMapping</code> é usada
		    para essa finalidade.</p><p>Por exemplo, caso não estejas usando o
		    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=moused&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">moused</span>(8)</span></a> e exista um IntelliMouse ligado na
		    PS/2 do seu computador, use o seguinte, no
		    <code class="filename">/etc/XF86Config</code>.</p><div class="example"><a id="idp69459024"></a><div class="example-title">Exemplo 11.4. Seção <span class="quote">&#8220;<span class="quote">Pointer</span>&#8221;</span>
		      do <code class="filename">XF86Config</code> com um mouse
		      com scroll na série 3.3.x do
		      XFree86.</div><div class="example-contents"><pre class="programlisting">Section "Pointer"
Protocol        "IntelliMouse"
Device          "/dev/psm0"
ZAxisMapping    4 5
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp69465168"></a><div class="example-title">Exemplo 11.5. Seção
		      <span class="quote">&#8220;<span class="quote">InputDevice</span>&#8221;</span> do
		      <code class="filename">XF86Config</code> com um mouse com
		      scroll na série 4.x do XFree86.</div><div class="example-contents"><pre class="programlisting">Section "InputDevice"
Identifier      "Mouse1"
Driver          "mouse"
Option          "Protocol" "auto"
Option          "Device" "/dev/psm0"
Option          "ZAxisMapping" "4 5"
EndSection</pre></div></div><br class="example-break" /><div class="example"><a id="idp69467216"></a><div class="example-title">Exemplo 11.6. Arquivo <span class="quote">&#8220;<span class="quote">.emacs</span>&#8221;</span> para usar
		      paginamento em mouse com bolinha de
		      scroll.</div><div class="example-contents"><pre class="programlisting">;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</pre></div></div><br class="example-break" /></li></ol></div></li><li class="listitem"><p>Instale o
		<span class="application">imwheel</span></p><p>Depois, instale o
		<span class="application">imwheel</span> à partir da
		coleção de <code class="literal">ports</code> do
		FreeBSD; ele pode ser encontrado sob a categoria
		<code class="filename">x11</code>.  A finalidade desse programa
		é assimilar os eventos dos botões 4 e 5
		do mouse, com os eventos de alguma tecla do teclado.
		Por exemplo, o programa deve enviar o evento da tecla
		<span class="keycap"><strong>Page Up</strong></span> quando a esfera for deslocada
		para frente.  O <span class="application">imwheel</span> usa
		um arquivo de configurações para
		assimilar esses eventos à uma tecla, de forma
		que possam ser configuradas ações
		diferentes (teclas diferentes) para
		aplicações diferentes.  O arquivo de
		configuração padrão do
		<span class="application">imwheel</span> é instalado
		em <code class="filename">/usr/X11R6/etc/imwheelrc</code>.  Ele
		pode ser copiado para
		<code class="filename">~/.imwheelrc</code> e editado, caso se
		deseja customizar o arquivo de
		configuração.  O formato esperado para o
		arquivo é documentado na página de
		manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=imwheel&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">imwheel</span>(1)</span></a>.</p></li><li class="listitem"><p>Configure o <span class="application">Emacs</span> para
		trabalhar em conjunto com o
		<span class="application">Imwheel</span>
		(<span class="emphasis"><em>optional</em></span>)</p><p>Se você usa o
		<span class="application">emacs</span> ou o
		<span class="application">Xemacs</span>, será
		necessário adicionar uma breve
		seção ao arquivo
		<code class="filename">~/.emacs</code>.  No
		<span class="application">emacs</span>, adicione o
		seguinte:</p><div class="example"><a id="idp69482448"></a><div class="example-title">Exemplo 11.7. Configuração do
		  <span class="application">Emacs</span> para
		  <span class="application">Imwheel</span></div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /><p>Pro <span class="application">Xemacs</span>, adicione o
		seguinte, no seu arquivo
		<code class="filename">~/.emacs</code>:</p><div class="example"><a id="idp69485520"></a><div class="example-title">Exemplo 11.8. Configuração do
		  <span class="application">Xemacs</span> para
		  <span class="application">Imwheel</span></div><div class="example-contents"><pre class="programlisting">;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div><br class="example-break" /></li><li class="listitem"><p>Execute o
		<span class="application">Imwheel</span></p><p>Basta digitar <code class="command">imwheel</code> em algum
		terminal X (xterm) para inicia-lo, uma vez que tudo
		esteja pronto.  Imediatamente o programa vai estar
		efetivo e vai se tornar um processo em segundo plano.
		Caso queira sempre iniciar o
		<span class="application">imwheel</span>, basta adicionar o
		comando no seu arquivo <code class="filename">.xinitrc</code>
		ou no <code class="filename">.xsession</code>.  É
		possível que o
		<span class="application">imwheel</span> mostre algumas
		mensagens de advertência sobre arquivos PID;
		elas podem ser seguramente ignoradas, visto que
		são mensagens que se aplicam à
		versão para Linux.</p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69491152"></a><a id="window-menu-weird"></a><p><strong>11.5.</strong></p></td><td align="left" valign="top"><p>Por quê os menus e caixas de diálogo do
	    X, sistema de interface gráfica não
	    funcionam direito?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Tente desativar a tecla <span class="keycap"><strong>Num
	      Lock</strong></span>.</p><p>Se por padrão seu <span class="keycap"><strong>Num Lock</strong></span>
	    é ativo na hora do processo de
	    inicialização, adicione a seguinte linha a
	    seção <code class="literal">Keyboard</code> do seu
	    arquivo <code class="filename">XF86Config</code>.</p><pre class="programlisting"># Deixar o servidor fazer o trabalho do NumLock.  Deve ser usado apenas em versoes anteriores a R6
    ServerNumLock</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69499856"></a><a id="virtual-console"></a><p><strong>11.6.</strong></p></td><td align="left" valign="top"><p>O que é um console virtual, e como eu crio mais
	    consoles?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Consoles virtuais simplesmente permitem que se tenha
	    várias sessões simultâneas em uma
	    mesma máquina, sem a necessidade de fazer nada
	    complicado como configurar uma rede ou usar um servidor
	    X.</p><p>Quando o sistema é iniciado, a primeira
	    ação é apresentar um prompt de login
	    na tela do usuário, tão logo todas as
	    mensagens do processo de inicialização sejam
	    apresentadas.  Nesse momento é possível
	    entrar com seu nome de usuário e senha para
	    começar trabalhar (ou brincar!) no primeiro console
	    virtual.</p><p>Em algum momento, é provável que se
	    deseje iniciar uma outra sessão, talvez para ler a
	    documentação de alguma
	    aplicação que está sendo usada, ou
	    para ler e-mail enquanto a transferência FTP se
	    conclúi, enfim, qualquer ação
	    (a)típica de um sistema multitarefa.  Nesse caso,
	    basta pressionar <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span>
	    (segure a tecla <span class="keycap"><strong>Alt</strong></span> e depois aperte a
	    tecla <span class="keycap"><strong>F2</strong></span>), e outro prompt de login
	    estará esperando você no segundo
	    <span class="quote">&#8220;<span class="quote">console virtual</span>&#8221;</span>!  Quando quizer alternar de
	    volta à sessão original, digite <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span>.</p><p>A instalação padrão do FreeBSD
	    oferece três consoles virtuais já habilitados
	    (8 a partir do 3.3-RELEASE), e as teclas <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span>,

	    <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span>,
	    e <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F3</strong></span>
	    irá alternar entre esses consoles.</p><p>Para habilitar mais consoles, edite o
	    <code class="filename">/etc/ttys</code> (veja a página de
	    manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a>) e adicione as entradas da
	    <code class="filename">ttyv4</code> à
	    <code class="filename">ttyvc</code> depois do comentário
	    sobre <span class="quote">&#8220;<span class="quote">Virtual terminals</span>&#8221;</span>:</p><pre class="programlisting"># Edite as entradas existentes para ttyv3 e mude de "off" para "on"
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</pre><p>Use quantos consoles desejar.  Quanto mais, maior o
	    uso de recursos; essa é uma
	    consideração relevante quando se tem 8MB de
	    RAM ou menos.  Também pode ser interessante mudar o
	    terminal de <code class="literal">secure</code> para
	    <code class="literal">insecure</code>.</p><div xmlns="" class="important"><h3 class="admontitle">Importante: </h3><p xmlns="http://www.w3.org/1999/xhtml">Caso se deseje usar um servidor X, é
	      necessário garantir que exista ao menos um
	      terminal virtual fora de uso (ou desligado).  Com isso,
	      entenda que, se sua inteção for usar
	      consoles virtuais nas suas doze teclas de
	      funções, nada feito; apenas onze
	      poderão ser usadas caso deseje-se usar o X na
	      mesma máquina.</p></div><p>A maneira mais simples de desabilitar um console,
	    é desligando-o.  Por exemplo, caso existam 12
	    terminais definidos, como mencionado na
	    situação acima, e se queira usar o servidor
	    X, o mais interessante é mudar as
	    configurações do terminal 12 de:</p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"        cons25  on  secure</pre><p>para:</p><pre class="programlisting">ttyvb   "/usr/libexec/getty Pc"        cons25  off  secure</pre><p>Caso seu teclado tenha apenas dez teclas de
	    funções, basta encerrar as
	    definições com:</p><pre class="programlisting">ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</pre><p>(Claro que as linhas poderiam simplesmente ser
	    apagadas.)</p><p>Uma vez editado o <code class="filename">/etc/ttys</code>, o
	    passo seguinte é garantir que existam devices o
	    bastante pros terminais virtuais.  A forma mais
	    fácil de fazer isso é:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /dev</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sh MAKEDEV vty12</code></strong></pre><p>Em seguida, a maneira mais fácil (e mais limpa)
	    de ativar cada um dos consoles virtuais é reiniciar
	    o sistema.  Mas se reiniciar o FreeBSD não é
	    a intenção, basta desligar o servidor X,
	    sistema de interface gráfica e executar (logado
	    como <code class="systemitem">root</code>):</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP 1</code></strong></pre><p>É obrigatório tirar por completo o X,
	    sistema de interface gráfica do ar antes de dar
	    esse comando, caso o X esteja sendo usado.  Se isso
	    não for feito, o sistema vai parecer que
	    travou.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69525456"></a><a id="vty-from-x"></a><p><strong>11.7.</strong></p></td><td align="left" valign="top"><p>Como posso acessar os consoles virtuais quando eu
	    estiver no X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Use <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> para alternar de volta para algum console
	    virtual.  Por exemplo,
	    <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> retornaria ao primeiro console virtual.</p><p>Uma vez de volta ao console textual, pode-se usar
	    <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F<em class="replaceable"><code>n</code></em></strong></span> normalmente, para alternar entre os consoles
	    virtuais.</p><p>Pra voltar para sessão X basta alternar para o
	    console virtual onde o X está sendo executado.
	    Caso o X tenha sido iniciado por linha de comando (por
	    exemplo, com o comando <code class="command">startx</code>) a
	    sessão terá sido assimilada ao
	    próximo console virtual fora de uso, e não
	    ao console onde o comando foi digitado.  Caso existam oito
	    terminais virtuais ativos, o X estará sendo
	    executado no nono.  Nesse caso as teclas
	    <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F9</strong></span> retornarão ao sistema
	    gráfico.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69543504"></a><a id="xdm-boot"></a><p><strong>11.8.</strong></p></td><td align="left" valign="top"><p>Como eu inicio o XDM no processo de
	    inicialização?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Existem duas formas clássicas de iniciar o
	    <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm" target="_top">xdm</a>.
	    A primeira consiste em inciá-lo a partir do
	    <code class="filename">/etc/ttys</code> (veja a página de
	    manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ttys&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">ttys</span>(5)</span></a>) usando o exemplo disponível
	    no arquivo; a segunda forma é simplesmente executar
	    o xdm a partir do <code class="filename">rc.local</code> (veja a
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>) ou então por
	    um script <code class="filename">X.sh</code> em
	    <code class="filename">/usr/local/etc/rc.d</code>.  As duas
	    maneiras são igualmente válidas, mas algumas
	    podem ser mais eficientes em algumas
	    situações, onde a outra forma não
	    seria ideal.  Nos dois casos, o resultado será o
	    mesmo: o X iniciará o mostrando uma tela de login:
	    gráfica.</p><p>O método de inicialização via
	    ttys oferece a vantagem de definir explicitamente em qual
	    vtyX o servidor gráfico vai ser carregado, passando
	    a responsabilidade da reinicialização do X
	    para o init, no momento do logout.  O método via
	    rc.local oferece facilidades caso seja necessário
	    encerrar o processo xdm, no caso, por exemplo, de
	    ocorrerem problemas ao carregar o servidor
	    gráfico.</p><p>Ao usar o rc.local para carregar o
	    <code class="command">xdm</code>, ele não deve ser
	    acompanhado de nenhum argumento (deve ser iniciado como um
	    daemon e deve ser iniciado DEPOIS que o getty já
	    estiver em execussão, senão é
	    provável que ocorram conflitos entre ambos, podendo
	    travar o console.  A melhor forma de assegurar o correto
	    funcionamento desse método é fazer com que o
	    script espere 10 segundos (por exemplo, com um sleep 10;)
	    antes de iniciar o xdm.</p><p>Se a inteção é iniciar o
	    <code class="command">xdm</code> a partir do
	    <code class="filename">/etc/ttys</code>, ainda existe a
	    probabilidade de conflitos entre o <code class="command">xdm</code>
	    e o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=getty&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">getty</span>(8)</span></a>.  Uma forma interessante de evitar esse
	    tipo de desconforto, é definir, no arquivo
	    <code class="filename">/usr/X11R6/lib/X11/xdm/Xservers</code>, o
	    número do <code class="literal">vt</code> onde o X deve ser
	    iniciado, da seguinte forma:</p><pre class="programlisting">:0 local /usr/X11R6/bin/X vt4</pre><p>O exemplo acima indica que o servidor X será
	    ativado no <code class="filename">/dev/ttyv3</code>.  Note que
	    existe um offset de um vt, já que o X começa
	    a contar os terminais (vty) a partir do um, enquando o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> do FreeBSD os conta
	    a partir do zero.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69559376"></a><a id="xconsole-failure"></a><p><strong>11.9.</strong></p></td><td align="left" valign="top"><p>Por que eu enfrento um <span class="errorname">Couldn't open
	      console</span> ao executar o xconsole? </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Se o <span class="application">X</span> for iniciado com um
	    <code class="command">startx</code>, as permissões do
	    <code class="filename">/dev/console</code> não
	    serão redefinidas, resultando em
	    situações onde um <code class="command">xterm
	      -C</code> ou mesmo o <code class="command">xconsole</code>
	    não funcionarão corretamente.</p><p>O motivo disso é a forma como as
	    permissões são definidas por padrão.
	    Em sistemas multiusuário, normalmente não se
	    espera que qualquer pessoa possa escrever no console do
	    sistema.  Para os usuários que estão se
	    logando diretamente na máquina, em algum VTY,
	    existe o arquivo <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a> que resolve esse tipo de
	    problema.</p><p>Se for apropriado, garanta que exista uma linha
	    assim</p><pre class="programlisting">/dev/ttyv0 0600 /dev/console</pre><p>No arquivo <code class="filename">/etc/fbtab</code> (veja a
	    página de manual do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fbtab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fbtab</span>(5)</span></a>).   Essa linha
	    garantirá que qualquer usuário que se logar
	    no <code class="filename">/dev/ttyv0</code> será
	    também proprietário do console.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69567696"></a><a id="xfree86-root"></a><p><strong>11.10.</strong></p></td><td align="left" valign="top"><p>Antes eu conseguia usar o XFree86 com um
	    usuário sem privilégios.  Porque agora o
	    servidor diz que eu tenho que ser
	    <code class="systemitem">root</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Todo servidor gráfico precisa ser executado
	    como <code class="systemitem">root</code> para que o sistema permita
	    acesso direto aos equipamentos de vídeo.  Acontece
	    que nas versões mais antigas, o XFree86
	    (versões &lt;= 3.3.6) instalava o servidor de forma
	    que ele era automaticamente executado como
	    <code class="systemitem">root</code> (setuid de
	    <code class="systemitem">root</code>).  Óbviamente esse
	    comportamente implica em riscos de segurança em
	    qualquer caso onde o programa em questão seja
	    complexo e grande; esse é o caso dos servidores X.
	    As versões mais atuais do XFree86 não
	    instalam os servidores gráficos com todo esse
	    poder, exatamente por esse motivo.</p><p>É claro que rodar o X como usuário
	    <code class="systemitem">root</code> não é uma
	    idéia muito aceitável, especialmente em
	    relação à segurança.  Existem
	    duas formas de usar o X como usuário comum.  A
	    primeira é usar o <code class="command">xdm</code> ou
	    qualquer outro gerenciador de display (como o
	    <code class="command">kdm</code>); a segunda é usar o
	    <code class="command">Xwrapper</code>.</p><p>O <code class="command">xdm</code> é um daemon que
	    controla logins gráficos.  Normalmente ele é
	    iniciado no processo de inicialização e
	    é responsável pela
	    autenticação dos usuários, e por
	    inciar suas sessões; essencialmente é a
	    união gráfica do <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=getty&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">getty</span>(8)</span></a> como o
	    <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=login&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">login</span>(1)</span></a>.  Para mais informações sobre
	    o <code class="command">xdm</code>, por gentileza, refira-se
	    à <a class="link" href="http://www.xfree86.org/support.html" target="_top">documentação
	      do XFree86</a> e à questão do <a class="link" href="x.html#xdm-boot" title="11.8."><code class="literal">FAQ</code> sobre
	      xdm</a>.</p><p>O <code class="command">Xwrapper</code> é um
	    intermediador do servidor gráfico; é um
	    programa bem pequeno que possibilita a
	    inicialização manual do servidor
	    gráfico por qualquer usuário, garantindo
	    razoável segurança à
	    operação.  O programa ainda faz algumas
	    verificações na linha de comando definida
	    pelo usuário, para garantir a sanidade das
	    intenções do mesmo.  Se todas as
	    intenções forem aprovadas, ele executa o X.
	    Se por qualquer razão, a idéia de usar um
	    gerenciador de displays não te agrada, o
	    <code class="command">Xwrapper</code> é feito para
	    você.  Caso a coleção de
	    <code class="literal">Ports</code> esteja instalada, o programa pode
	    ser encontrado em
	    <code class="filename">/usr/ports/x11/wrapper</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69588176"></a><a id="ps2-x"></a><p><strong>11.11.</strong></p></td><td align="left" valign="top"><p>Por que meu mouse PS/2 não se comporta
	    corretamente no X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O seu mouse e a device que o controla devem ter
	    desincronizado.</p><p>Nas versões 2.2.5 e anteriores, a simples
	    alternância entre o X e o terminal, e voltar para o
	    X, força a resincronização do mouse.
	    Se o problema se tornar frequênte, adicione a
	    seguinte opção ao arquivo de
	    configuração do seu
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, e o
	    recompile:</p><pre class="programlisting">options PSM_CHECKSYNC</pre><p>Veja a seção sobre a <a class="link" href="kernelconfig.html#make-kernel" title="8.1.">compilação do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span></a>, caso
	    você não tenha experiência com
	    isso.</p><p>Com essa opção as chances de ter
	    problemas com a sincronia do mouse são bem
	    pequenas.  Contudo, se ainda assim o problema persistir,
	    clique em qualquer botão durante o movimento do
	    mouse.  É o bastante para resincroniza-lo.</p><p>Infelizmente essa opção pode não
	    funcionar em alguns sistemas, dependendo de qual driver
	    controle o seu mouse PS/2; especialmente se a device de
	    controle for do tipo ALPS GlidePoint.</p><p>Na versão 2.2.6 e posteriores, a
	    verificação de sincronia se tornou
	    razoávelmente melhor, e é padrão nos
	    mouses PS/2.  Deve funcionar corretamente com GlidePoint,
	    inclusive (como o código de
	    verificação de sincronia ter se tornado
	    padrão, a opção PSM_CHECKSYNC
	    não existe mais).  Contudo, em
	    situações muito raras, o driver de controle
	    do mouse pode, errôneamente reportar problemas de
	    sincronização, mostrando a seguinte mensagem
	    do <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>:</p><pre class="programlisting">psmintr: out of sync (xxxx != yyyy)</pre><p>Pensando que seu mouse não está
	    funcionando corretamente.</p><p>Se for o caso, desligue o código de
	    verificação de sincronia do mouse PS/2,
	    definindo a flag 0x100 na device de controle do mesmo.
	    Entre no modo <span class="emphasis"><em>UserConfig</em></span> definindo a
	    opção <code class="option">-c</code> na tela do
	    processo de inicialização:</p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><p>Depois, na linha de comando do
	    <span class="emphasis"><em>UserConfig</em></span>, digite:</p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x100</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69602896"></a><a id="ps2-mousesystems"></a><p><strong>11.12.</strong></p></td><td align="left" valign="top"><p>Por que meu mouse PS/2 da MouseSystems não
	    funciona?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Existem notícias que alguns modelos de mouse
	    PS/2 da MouseSystems funcionam corretamente apenas em modo
	    de alta resolução.  Do contrário, o
	    cursor do mouse costuma pular para diagonal superior
	    esquerda da tela com certa frequência.</p><p>Infelizmente não existe solução
	    à esse problema, nas versões 2.0.X e 2.1.X.
	    Contudo, das versões 2.2 à 2.2.5, basta
	    aplicar o seguinte patch, no
	    <code class="filename">/sys/i386/isa/psm.c</code> e recompilar o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>.  Veja a
	    seção sobre <a class="link" href="kernelconfig.html#make-kernel" title="8.1.">
	      compilação do
	      <span class="foreignphrase"><em class="foreignphrase">kernel</em></span></a> caso
	    não tenha experiência com o assunto.</p><pre class="programlisting">@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
         log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
             unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);        /* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);                /* stream mode */</pre><p>Na versão 2.2.6 e versões posteriores,
	    basta especificar a flag 0x04 para device de controle do
	    mouse PS/2, colocando-o em modo de alta
	    resolução.  Entre no modo
	    <span class="emphasis"><em>UserConfig</em></span> com a opçãp
	    <code class="option">-c</code> na tela do processo de
	    inicialização:</p><pre class="screen">boot: <strong class="userinput"><code>-c</code></strong></pre><p>Depois, na linha de comando do
	    <span class="emphasis"><em>UserConfig</em></span> digite:</p><pre class="screen">UserConfig&gt; <strong class="userinput"><code>flags psm0 0x04</code></strong>
UserConfig&gt; <strong class="userinput"><code>quit</code></strong></pre><p>Veja a pergunta anterior, sobre outra causa
	    possível de problemas com o mouse.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69615568"></a><a id="imake-tmpl"></a><p><strong>11.13.</strong></p></td><td align="left" valign="top"><p>Ao compilar uma aplicação X, o
	    <code class="command">imake</code> não consegue encontrar o
	    <code class="filename">Imake.tmpl</code>.  Onde ele
	    está?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>O <code class="filename">Imake.tmpl</code> é parte do
	    pacote Imake, uma aplicação padrão
	    para construção de aplicações
	    gráficas.  O <code class="filename">Imake.tmpl</code>, assim
	    como vários outros arquivos de cabeçalhos
	    necessários para compilar aplicações
	    gráficas, é parte da
	    distribuição do X.  Eles podem ser
	    instalados pelo sysinstall ou manualmente a partir dos
	    arquivos da distribuição.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69619152"></a><a id="xfree86-version"></a><p><strong>11.14.</strong></p></td><td align="left" valign="top"><p>Estou construindo uma aplicação
	    gráfica que depende do XFree86 3.3.X, mas eu estou
	    com o XFree86 4.X instalado.  O que fazer?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Pra definir que a construção do
	    <code class="literal">Port</code> deve ser linkada às
	    bibliotecas do XFree86 4.X, adicione o seguinte, no seu
	    <code class="filename">/etc/make.conf</code>, (se o arquivo
	    não existir, crie-o):</p><pre class="programlisting">XFREE86_VERSION=	4</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69622480"></a><a id="mouse-button-reverse"></a><p><strong>11.15.</strong></p></td><td align="left" valign="top"><p>Como posso inverter as funções dos
	    botões do mouse?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Execute o comando <code class="command">xmodmap -e "pointer = 3 2
	      1"</code> à partir do
	    <code class="filename">.xinitrc</code> ou do
	    <code class="filename">.xsession</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69625808"></a><a id="install-splash"></a><p><strong>11.16.</strong></p></td><td align="left" valign="top"><p>Como instalar uma Splash Screen e onde posso
	    encontra-las?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A partir da lançamento do FreeBSD 3.1, uma nova
	    característica foi adicionada ao sistema,
	    permitindo que alguns arquivos de imagens sejam usados
	    como <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span> durante as mensagens do
	    processo de inicialização.  Tais imagens
	    devem ser arquivos do tipo bitmap com 256 cores
	    (<code class="filename">*.BMP</code>) ou então ZSoft PCX
	    (<code class="filename">*.PCX</code>).  Devem ainda ter
	    resolução de 320x200 pixels (ou menos), para
	    funcionarem corretamente em adaptadores de vídeo
	    VGA tradicionais.  Caso o
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span> tenha sido compilado
	    com suporte à VESA, então podem ser usados
	    bitmaps maiores, até 1024.768 px.  O suporte
	    à VESA pode ser diretamente compilado no
	    <span class="foreignphrase"><em class="foreignphrase">kernel</em></span>, com a
	    opção VESA no arquivo de
	    configuração, ou carregado como
	    módulo, com o kld, durante o processo de
	    inicialização do sistema.</p><p>Para definir a <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span>, basta
	    modificar alguns arquivos de inicialização
	    que controlam o processo de inicialização do
	    FreeBSD.  Tais arquivos foram alterados na versão
	    3.2 do FreeBSD, existindo portanto duas formas de carregar
	    uma <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>No FreeBSD 3.1</p><p>O primeiro passo é escolher o seu bitmap, e
		sua versão.  Até o FreeBSD 3.1, apenas
		os bitmaps do tipo Windows eram suportados.  Assim que
		escolher (ou criar) sua <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span>,
		copie-a para <code class="filename">/boot/splash.bmp</code>.
		Depois, basta editar (ou criar, caso não
		exista) o arquivo <code class="filename">/boot/loader.rc</code>
		e adicionar as seguintes linhas:</p><pre class="programlisting">load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</pre></li><li class="listitem"><p>No FreeBSD 3.2 e posteriores</p><p>Além de adicionar suporte a <span class="quote">&#8220;<span class="quote">Splash
		  Screens</span>&#8221;</span> de formato PCX, o FreeBSD 3.2 passou
		a oferecer uma maneira mais interessante de configurar
		o processo de inicialização.  Caso
		prefira, o método descrito acima, para o
		FreeBSD 3.1 também funciona.  Nesse caso, se a
		imagem for do tipo PCX basta substituir a entrada
		<code class="literal">splash_bmp</code> por
		<code class="literal">splash_pcx</code>.  Caso queira usar a
		nova configuração do processo de
		inicialização, basta criar um arquivo
		<code class="filename">/boot/loader.rc</code> com o seguinte
		conteúdo:</p><pre class="programlisting">include /boot/loader.4th
start</pre><p>e depois, um
		<code class="filename">/boot/loader.conf</code> com o
		seguinte:</p><pre class="programlisting">splash_bmp_load="YES"
bitmap_load="YES"</pre><p>Essa configuração assume que o
		<code class="filename">/boot/splash.bmp</code> deve ser usado
		como sua <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span>.  Caso prefira
		usar um arquivo PCX, copie para o
		<code class="filename">/boot/splash.pcx</code>, e crie um
		<code class="filename">/boot/loader.rc</code>, da forma como
		foi indicado anteriormente; depois crie um
		<code class="filename">/boot/loader.conf</code> com o
		seguinte:</p><pre class="programlisting">splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</pre></li></ul></div><p>Agora você só precisa de uma imagem, para
	    servir de <span class="quote">&#8220;<span class="quote">Splash Screens</span>&#8221;</span>.  Pra isso,
	    dê uma navegada na galeria disponível em
	    <a class="link" href="http://www.baldwin.cx/splash/" target="_top">http://www.baldwin.cx/splash/</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69667152"></a><a id="windows-keys"></a><p><strong>11.17.</strong></p></td><td align="left" valign="top"><p>Posso usar as teclas do Windows® que meu teclado
	    possui, sob o X?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Pode.  Basta usar o <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xmodmap&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xmodmap</span>(1)</span></a> para redefinir a
	    função das teclas.</p><p>Assumindo que todos os teclados <span class="quote">&#8220;<span class="quote"><span class="trademark">Windows</span>®</span>&#8221;</span> sejam
	    padrão, os códigos de mapeamento pras 3
	    teclas são:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>115 - <span class="trademark">Windows</span>®, entre a
		tecla Ctr e a Alt do lado esquerdo.</p></li><li class="listitem"><p>116 - <span class="trademark">Windows</span>®, à
		direita a tecla AltGr.</p></li><li class="listitem"><p>117 - <span class="keycap"><strong>Menu</strong></span>, do lado esquerdo da
		tecla Ctrl esquerda</p></li></ul></div><p>Por exemplo, para fazer com que a tecla Windows®
	    esquerda imprima uma vírgula, faça o
	    seguinte:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>xmodmap -e "keycode 115 = comma"</code></strong></pre><p>É provável que seu gerenciador de
	    janelas tenha que ser reiniciado, para visualizar o
	    resultado.</p><p>Pra forçar o carregamento automático do
	    mapeamento das teclas <span class="trademark">Windows</span>®, coloque os
	    comandos do <code class="command">xmodmap</code> no arquivo
	    <code class="filename">~/.xinitrc</code> ou de preferência,
	    crie um arquivo <code class="filename">~/.xmodmaprc</code> e inclua
	    as opções do <code class="command">xmodmap</code> uma
	    por linha, nesse arquivo.  Depois adicione:</p><pre class="programlisting">xmodmap $HOME/.xmodmaprc</pre><p>No seu <code class="filename">~/.xinitrc</code>.</p><p>Por exemplo, pode-se mapear as 3 teclas em
	    questão para fazer o papel das teclas
	    <span class="keycap"><strong>F13</strong></span>, <span class="keycap"><strong>F14</strong></span>, e
	    <span class="keycap"><strong>F15</strong></span>, respectivamente.  Dessa forma, seria
	    fácil mapear as aplicações de forma
	    que as teclas tivessem ações no seu sistema,
	    como veremos agora.</p><p>Adicione o seguinte conteúdo, no arquivo
	    <code class="filename">~/.xmodmaprc</code>.</p><pre class="programlisting">keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre><p>Se o gerenciador de janelas em questão for o
	    <code class="command">fvwm2</code>, por exemplo, pode-se mapear as
	    teclas de forma que o <span class="keycap"><strong>F13</strong></span> minimize (ou
	    maximize) a janela que o cursor está apontando, a
	    tecla <span class="keycap"><strong>F14</strong></span> de forma que ela traga a janela
	    marcada pelo cursor para frente (ou volte para
	    trás, caso já esteja à frente), e o
	    <span class="keycap"><strong>F15</strong></span> pode alternar o menu da área
	    detrabalho principal, o que é bem útil
	    quando a tela não é visível.</p><p>As seguintes definições no
	    <code class="filename">~/.fvwmrc</code> implementam a
	    configuração acima descrita:</p><pre class="programlisting">Key F13	FTIWS    A	Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69686736"></a><a id="x-3d-acceleration"></a><p><strong>11.18.</strong></p></td><td align="left" valign="top"><p>Como posso obter a aceleração de
	    equipamentos 3D para o OpenGL?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>A disponibilidade da aceleração 3D
	    depende da versão do XFree86 e da placa de
	    vídeo.  Caso a placa seja NVIDIA, verifique a
	    página da <a class="link" href="http://nvidia.netexplorer.org/" target="_top">Iniciativa de
	      Driver NVIDIA para o FreeBSD</a>, que discute a
	    aceleração 3D em chips NVIDIA com XFree86-4.
	    Pra outras placas em conjunto com o XFree86-4, incluindo a
	    Matrox G200/G400, a ATI Rage 128/Radeon, as 3dfx Voodoo 3,
	    4, 5, e Banshee, refira-se à página sobre
	    <a class="link" href="http://gladstone.uoregon.edu/~eanholt/dri/" target="_top">Renderização
	      Direta do XFree86-4 no FreeBSD</a>.  Usuários
	    do XFree86 na versão 3.3 podem usar o
	    <code class="literal">port</code> do Utah-GLX que pode ser
	    encontrado em <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/graphics/utah-glx/pkg-descr">graphics/utah-glx</a> para
	    conseguir alguma (limitada) aceleração 3D
	    para o OpenGL em placas Matrox Gx00, ATI Rage Pro, SiS
	    6326, i810, Savage, e algumas NVIDIA antigas.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="admin.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="networking.html">Próxima</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 10. Administração do Sistema </td><td width="20%" align="center"><a accesskey="h" href="index.html">Principal</a></td><td width="40%" align="right" valign="top"> Capítulo 12. Redes</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Este, e outros documentos, podem ser obtidos em
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Para perguntas sobre FreeBSD, leia a
    <a href="http://www.FreeBSD.org/docs.html">documentação</a> antes de contatar
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Para perguntas sobre esta documentação, envie e-mail para
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>