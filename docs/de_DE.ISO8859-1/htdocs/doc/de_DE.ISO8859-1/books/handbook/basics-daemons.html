<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>4.8. Dämonen, Signale und Stoppen von Prozessen</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="basics.html" title="Kapitel 4. Grundlagen des UNIX Betriebssystems" /><link rel="prev" href="basics-processes.html" title="4.7. Prozesse" /><link rel="next" href="shells.html" title="4.9. Shells" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.8. Dämonen, Signale und Stoppen von Prozessen</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="basics-processes.html">Zurück</a> </td><th width="60%" align="center">Kapitel 4. Grundlagen des UNIX Betriebssystems</th><td width="20%" align="right"> <a accesskey="n" href="shells.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="basics-daemons"></a>4.8. Dämonen, Signale und Stoppen von Prozessen</h2></div></div></div><p>Wenn Sie einen Editor starten, können Sie ihn leicht bedienen
      und Dateien laden.  Sie können das, weil der Editor dafür
      Vorsorge getroffen hat und auf einem <em class="firstterm">Terminal</em>
      läuft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und lösen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Web-Server zum Beispiel verbringt den ganzen Tag
      damit, auf Anfragen zu antworten und erwartet keine Eingaben von Ihnen.
      Programme, die E-Mail von einem Ort zu einem anderen Ort transportieren
      sind ein weiteres Beispiel für diesen Typ von Anwendungen.</p><p>Wir nennen diese Programme <em class="firstterm">Dämonen</em>.
      Dämonen stammen aus der griechischen Mythologie und waren
      weder gut noch böse.  Sie waren kleine dienstbare Geister,
      die meistens nützliche Sachen für die Menschheit vollbrachten.
      Ähnlich wie heutzutage Web-Server und Mail-Server nützliche
      Dienste verrichten.  Seit langer Zeit ist daher das BSD Maskottchen
      dieser fröhlich aussehende Dämon mit Turnschuhen
      und Dreizack.</p><p>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <span class="quote">&#8222;<span class="quote">d</span>&#8220;</span> am Ende benannt.
      <span class="application">BIND</span> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber
      <code class="command">named</code>.  Der Apache Webserver wird
      <code class="command">httpd</code> genannt, der Druckerspool-Dämon heißt
      <code class="command">lpd</code> usw.  Dies ist allerdings eine Konvention
      und keine unumstößliche Regel: Der Dämon der
      Anwendung <span class="application">sendmail</span> heißt
      <code class="command">sendmail</code> und nicht <code class="command">maild</code>, wie
      Sie vielleicht gedacht hatten.</p><p>Manchmal müssen Sie mit einem Dämon kommunizieren.  Dazu
      verwenden Sie <em class="firstterm">Signale</em>.  Sie können
      mit einem Dämonen oder jedem anderen laufenden Prozess
      kommunizieren, indem Sie diesem ein Signal schicken.  Sie können
      verschiedene Signale verschicken &#8211; manche haben eine festgelegte
      Bedeutung, andere werden von der Anwendung interpretiert.  Die
      Dokumentation zur fraglichen Anwendung wird erklären, wie
      die Anwendung Signale interpretiert.  Sie können nur Signale
      zu Prozessen senden,  die Ihnen gehören.  Normale Benutzer haben
      nicht die Berechtigung, Prozessen anderer Benutzer mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>
      oder <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">kill</span>(2)</span></a> Signale zu schicken.  Der Benutzer
      <code class="systemitem">root</code> darf jedem Prozess Signale schicken.</p><p>In manchen Fällen wird FreeBSD Signale senden.  Wenn eine
      Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf
      den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess
      das <em class="firstterm">Segmentation Violation</em> Signal
      (<code class="literal">SIGSEGV</code>).  Wenn eine Anwendung den <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=alarm&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">alarm</span>(3)</span></a>
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<code class="literal">SIGALRM</code>)
      gesendet.</p><p>Zwei Signale können benutzt werden, um Prozesse zu stoppen:
      <code class="literal">SIGTERM</code> und <code class="literal">SIGKILL</code>.  Mit
      <code class="literal">SIGTERM</code> fordern Sie den Prozess höflich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und merken,
      dass er sich beenden soll.  Er hat dann Gelegenheit Logdateien
      zu schließen und die Aktion, die er vor der Aufforderung
      sich zu beenden durchführte, abzuschließen.  Er kann
      sogar <code class="literal">SIGTERM</code> ignorieren, wenn er eine Aktion
      durchführt, die nicht unterbrochen werden darf.</p><p><code class="literal">SIGKILL</code> kann von keinem Prozess ignoriert
      werden.  Das Signal lässt sich mit <span class="quote">&#8222;<span class="quote">Mich interessiert
      nicht, was du gerade machst, hör sofort auf damit!</span>&#8220;</span>
      umschreiben.  Wenn Sie einem Prozess <code class="literal">SIGKILL</code>
      schicken, dann wird FreeBSD diesen sofort beenden<a href="#ftn.idp70508240" class="footnote" id="idp70508240"><sup class="footnote">[4]</sup></a>.</p><p>Andere Signale, die Sie vielleicht verschicken wollen, sind
      <code class="literal">SIGHUP</code>, <code class="literal">SIGUSR1</code> und
      <code class="literal">SIGUSR2</code>.  Diese Signale sind für allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden unterschiedlich
      auf diese Signale reagieren.</p><p>Nehmen wir an, Sie haben die Konfiguration Ihres Webservers
      verändert und möchten dies dem Server mitteilen.  Sie
      könnten den Server natürlich stoppen und
      <code class="command">httpd</code> wieder starten.  Die Folge wäre eine
      kurze Zeit, in der der Server nicht erreichbar ist.  Die meisten
      Dämonen lesen Ihre Konfigurationsdatei beim Empfang eines
      <code class="literal">SIGHUP</code> neu ein.  Da es keinen Standard gibt, der
      vorschreibt, wie auf diese Signale zu reagieren ist, lesen
      Sie bitte die Dokumentation zu dem in Frage kommenden Dämon.</p><p>Mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> können Sie, wie unten gezeigt, Signale
      verschicken.</p><div class="procedure"><a id="idp70513104"></a><div class="procedure-title">Prozedur 4.1. Verschicken von Signalen</div><p>Das folgende Beispiel zeigt, wie Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> ein
	Signal schicken.  Die Konfigurationsdatei von
	<code class="command">inetd</code> ist <code class="filename">/etc/inetd.conf</code>.
	Diese Konfigurationsdatei liest <code class="command">inetd</code> ein,
	wenn er ein <code class="literal">SIGHUP</code> empfängt.</p><ol class="procedure" type="1"><li class="step"><p>Suchen Sie die Prozess-ID des Prozesses, dem Sie ein
          Signal schicken wollen.  Benutzen Sie
          dazu <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pgrep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">pgrep</span>(1)</span></a>.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>pgrep -l inetd</code></strong>
198 inetd -wW</pre><p>Die Prozess-ID von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> ist 198.</p></li><li class="step"><p>Senden Sie das Signal mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>.  Da <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>
	  unter dem Benutzer <code class="systemitem">root</code> läuft, müssen
	  Sie zuerst mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> <code class="systemitem">root</code> werden:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">Password:</code>
<code class="prompt">#</code> <strong class="userinput"><code>/bin/kill -s HUP 198</code></strong></pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> wird, wie andere Kommandos von <span class="trademark">UNIX</span>® Systemen auch, keine Ausgabe
	  erzeugen, wenn das Kommando erfolgreich war.  Wenn Sie versuchen,
	  einem Prozess, der nicht Ihnen gehört, ein Signal zu
	  senden, dann werden Sie die Meldung
	  <span class="errorname">kill: <em class="replaceable"><code>PID</code></em>: Operation not
	  permitted</span> sehen.  Wenn Sie sich bei der Eingabe der
	  PID vertippen, werden Sie das Signal dem falschen Prozess
	  schicken, was schlecht sein kann.  Wenn Sie Glück haben,
	  existiert der Prozess nicht und Sie werden mit der Ausgabe
	  <span class="errorname">kill: <em class="replaceable"><code>PID</code></em>: No such
	  process</span> belohnt.</p><div xmlns="" class="note"><h3 class="admontitle">Warum soll ich <code xmlns="http://www.w3.org/1999/xhtml" class="command">/bin/kill</code> benutzen?: </h3><p xmlns="http://www.w3.org/1999/xhtml">Viele Shells stellen <code class="command">kill</code> als internes
	    Kommando zur Verfügung, das heißt die Shell sendet
	    das Signal direkt, anstatt <code class="filename">/bin/kill</code>
	    zu starten.  Das kann nützlich sein, aber die
	    unterschiedlichen Shells benutzen eine verschiedene Syntax,
	    um die Namen der Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <code class="command">/bin/kill
	    ...</code> direkt aufzurufen.</p></div></li></ol></div><p>Andere Signale senden Sie auf die gleiche Weise, ersetzen
      Sie nur <code class="literal">TERM</code> oder <code class="literal">KILL</code>
      entsprechend.</p><div xmlns="" class="important"><h3 class="admontitle">Wichtig: </h3><p xmlns="http://www.w3.org/1999/xhtml">Es kann gravierende Auswirkungen haben, wenn Sie zufällig
	Prozesse beenden.  Insbesondere <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> mit der Prozess-ID
	ist ein Spezialfall.  Mit <code class="command">/bin/kill -s KILL 1</code>
	können Sie Ihr System schnell herunterfahren.
	Überprüfen Sie die Argumente von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>
	<span class="emphasis"><em>immer</em></span> zweimal <span class="emphasis"><em>bevor</em></span>
	Sie <span class="keycap"><strong>Return</strong></span> drücken.</p></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp70508240" class="footnote"><p><a href="#idp70508240" class="para"><sup class="para">[4] </sup></a>
	Das stimmt nicht ganz: Es gibt Fälle, in denen ein Prozess
	nicht unterbrochen werden kann.  Wenn der Prozesss zum Beispiel
	eine Datei von einem anderen Rechner auf dem Netzwerk liest und dieser
	Rechner aus irgendwelchen Gründen nicht erreichbar ist
	(ausgeschaltet, oder ein Netzwerkfehler), dann ist der Prozess
	nicht zu unterbrechen.  Wenn der Prozess den Lesezugriff
	nach einem Timeout von typischerweise zwei Minuten aufgibt,
	dann wird er beendet.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="basics-processes.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="basics.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="shells.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">4.7. Prozesse </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 4.9. Shells</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>