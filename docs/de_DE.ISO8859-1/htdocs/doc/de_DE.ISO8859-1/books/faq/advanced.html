<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Kapitel 18. Weiterführende Themen</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="up" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="prev" href="funnies.html" title="Kapitel 17. Nicht ganz ernstgemeinte Fragen" /><link rel="next" href="acknowledgments.html" title="Kapitel 19. Danksagung" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Kapitel 18. Weiterführende Themen</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="funnies.html">Zurück</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="acknowledgments.html">Weiter</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="advanced"></a>Kapitel 18. Weiterführende Themen</h1></div></div></div><div class="qandaset"><a id="idp70646608"></a><dl><dt>18.1. <a href="advanced.html#idp70646864">Wie kann ich mehr über die Interna von FreeBSD
	    erfahren?</a></dt><dt>18.2. <a href="advanced.html#idp70655824">Wie kann ich bei der Entwicklung von FreeBSD mitarbeiten?</a></dt><dt>18.3. <a href="advanced.html#idp70658384">Was sind Snapshots und RELEASEs?</a></dt><dt>18.4. <a href="advanced.html#idp70692560">Wie kann ich meine eigene, angepasstes Release
            erstellen?</a></dt><dt>18.5. <a href="advanced.html#idp70695120">Wieso überschreibt make
            world
            das installierte System?</a></dt><dt>18.6. <a href="advanced.html#idp70708560">Warum ist cvsup.FreeBSD.org
	    kein Round-Robin-Eintrag im DNS, so dass Anfragen
	    auf alle CVsup-Server verteilt
	    werden?</a></dt><dt>18.7. <a href="advanced.html#idp70712784">Kann ich -CURRENT mit begrenztem Internetzugang
            folgen?</a></dt><dt>18.8. <a href="advanced.html#idp70724048">Wie haben Sie die Distribution in 1392 KB-Dateien
            aufgespalten?</a></dt><dt>18.9. <a href="advanced.html#idp70728400">Ich habe eine Kernelerweiterung geschrieben.  An wen
            sende ich sie?</a></dt><dt>18.10. <a href="advanced.html#idp70731472">Wie werden Plug&amp;Play ISA-Karten erkannt und
            initialisiert?</a></dt><dt>18.11. <a href="advanced.html#idp70744272">Wie bekomme ich eine Major-Number für einen
            Gerätetreiber, den ich geschrieben habe?</a></dt><dt>18.12. <a href="advanced.html#idp70747344">Gibt es alternative Layoutverfahren für
            Verzeichnisse?</a></dt><dt>18.13. <a href="advanced.html#idp70750160">Wie kann ich optimalen Nutzen aus einer kernel panic
            ziehen?</a></dt><dt>18.14. <a href="advanced.html#idp70951504">Wieso funktioniert dlsym() nicht mehr
            für ELF-Executables?</a></dt><dt>18.15. <a href="advanced.html#idp70956624">Wie kann ich den Adressraum des Kernels auf i386
            vergrössern oder verkleinern?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp70646864"></a><a id="learn-advanced"></a><p><strong>18.1.</strong></p></td><td align="left" valign="top"><p>Wie kann ich mehr über die Interna von FreeBSD
	    erfahren?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Zurzeit gibt es nur ein Buch über die Interna von
            FreeBSD, <span class="quote">&#8222;<span class="quote">The Design and Implementation of the FreeBSD
            Operating System</span>&#8220;</span> von Marshall Kirk McKusick und
            George V. Neville-Neil, ISBN 0-201-70245-2, das sich auf
            FreeBSD 5.<em class="replaceable"><code>X</code></em> konzentriert.</p><p>Allgemeines Wissen über <span class="trademark">UNIX</span>® kann
            allerdings in den meisten Fällen auf FreeBSD
            angewendet werden.</p><p>Eine Liste finden Sie im entsprechenden Abschnitt der <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/bibliography-osinternals.html" target="_top">
            Bibliographie</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70655824"></a><a id="how-to-contribute"></a><p><strong>18.2.</strong></p></td><td align="left" valign="top"><p>Wie kann ich bei der Entwicklung von FreeBSD mitarbeiten?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Genauere Informationen finden Sie im Artikel <a class="link" href="../../../../doc/de_DE.ISO8859-1/articles/contributing/article.html" target="_top">FreeBSD
            unterstützen</a>.  Wir können Hilfe
            immer gut gebrauchen!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70658384"></a><a id="define-snap-release"></a><p><strong>18.3.</strong></p></td><td align="left" valign="top"><p>Was sind Snapshots und RELEASEs?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Derzeit existieren vier aktive/halbaktive Zweige im
            <a class="link" href="http://www.de.FreeBSD.org/cgi/cvsweb.cgi" target="_top">
            FreeBSD-CVS-Repository</a>. In früheren Zweigen
	    ändert sich wenig, daher gibt es nur vier
	    aktive Entwicklungszweige:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="symbol">RELENG_7</span> bzw. <span class="emphasis"><em>7-STABLE</em></span></p></li><li class="listitem"><p><span class="symbol">RELENG_8</span> bzw. <span class="emphasis"><em>8-STABLE</em></span></p></li><li class="listitem"><p><span class="symbol">RELENG_9</span> bzw. <span class="emphasis"><em>9-STABLE</em></span></p></li><li class="listitem"><p><span class="symbol">HEAD</span> bzw.
                <span class="emphasis"><em>-CURRENT</em></span> oder
                <span class="emphasis"><em>10-CURRENT</em></span></p></li></ul></div><p><code class="literal">HEAD</code> ist keine wirkliche
            Bezeichnung für einen Zweig, wie die anderen.
            Es ist lediglich eine symbolische Konstante für
            <span class="quote">&#8222;<span class="quote"><span class="emphasis"><em>den aktuellen, nicht verzweigten
            Entwicklungsstrom</em></span></span>&#8220;</span>, auf den wir uns
            einfach als <span class="emphasis"><em>-CURRENT</em></span> beziehen.</p><p>Derzeit steht <span class="emphasis"><em>-CURRENT</em></span> für den
            10.<em class="replaceable"><code>X</code></em>-Entwicklungsstrom. Der <span class="emphasis"><em>9-STABLE</em></span>-Zweig
            (<span class="symbol">RELENG_9</span>) wurde von <span class="emphasis"><em>-CURRENT</em></span> im
            September 2011 und der <span class="emphasis"><em>8-STABLE</em></span>-Zweig (<span class="symbol">RELENG_8</span>) im
            August 2009 von <span class="emphasis"><em>-CURRENT</em></span>
            abgespalten.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70692560"></a><a id="custrel"></a><p><strong>18.4.</strong></p></td><td align="left" valign="top"><p>Wie kann ich meine eigene, angepasstes Release
            erstellen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Eine Anleitung dazu finden Sie im Artikel <a class="link" href="../../../../doc/en_US.ISO8859-1/articles/releng/article.html" target="_top">
            FreeBSD Release Engineering</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70695120"></a><a id="makeworld-clobbers"></a><p><strong>18.5.</strong></p></td><td align="left" valign="top"><p>Wieso überschreibt <code class="command">make
            world</code>
            das installierte System?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das ist beabsichtigt.  Wie der Name schon andeutet,
            erstellt <code class="command">make world</code>
            alle Systemdateien von Grund auf neu.  Sie können also sicher
            sein, am Ende eine saubere, konsistente Umgebung zu haben (das ist
            der Grund, warum es so lange dauert).</p><p>Falls die Umgebungsvariable <code class="envar">DESTDIR</code>
            während der Ausführung von <code class="command">make
            world</code> oder
            <code class="command">make install</code>
            definiert ist, werden die neu erstellten Binaries unter
            <code class="literal">${DESTDIR}</code> in einem zum
            installierten identischen Verzeichnisbaum abgelegt.
            Einige zufällige Kombinationen von Änderungen
            von Shared Libraries und Neuerstellungen von Programmen
            können hierbei jedoch ein Scheitern von <code class="command">make
            world</code> verursachen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70708560"></a><a id="cvsup-round-robin"></a><p><strong>18.6.</strong></p></td><td align="left" valign="top"><p>Warum ist <code class="systemitem">cvsup.FreeBSD.org</code>
	    kein Round-Robin-Eintrag im DNS, so dass Anfragen
	    auf alle <span class="application">CVsup</span>-Server verteilt
	    werden?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die <span class="application">CVsup</span>-Server gleichen sich
	    stündlich mit dem Hauptserver ab.  Allerdings findet der
	    Abgleich nicht zur gleichen Zeit statt, daher
	    können einige Server neuere Quellen bereitstellen
	    als andere Server.  Alle Server stellen jedoch
	    Quellen bereit, die maximal eine Stunde alt sind.
	    Wäre <code class="systemitem">cvsup.FreeBSD.org</code>
	    ein Round-Robin-Eintrag im DNS, der Benutzern einen
	    zufälligen Server zuteilt, könnten beim
	    zweiten Lauf von <span class="application">CVsup</span> ältere
	    Quellen als beim ersten Lauf heruntergeladen werden.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70712784"></a><a id="ctm"></a><p><strong>18.7.</strong></p></td><td align="left" valign="top"><p>Kann ich -CURRENT mit begrenztem Internetzugang
            folgen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ja, Sie können das tun, <span class="emphasis"><em>ohne</em></span>
            den gesamten Quellbaum herunterzuladen, indem Sie die
            Einrichtung <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/synching.html#CTM" target="_top">CTM</a>
            benutzen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70724048"></a><a id="split-1392k"></a><p><strong>18.8.</strong></p></td><td align="left" valign="top"><p>Wie haben Sie die Distribution in 1392 KB-Dateien
            aufgespalten?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Bei neueren BSD-basierten Systemen gibt es eine Option
            <code class="option">-b</code> zu <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=split&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">split</span>(1)</span></a>, die das Splitten von
            Dateien an willkürlichen Bytegrenzen erlaubt.</p><p>Hier ist ein Beispiel aus
            <code class="filename">/usr/src/release/Makefile</code>.</p><pre class="programlisting">ZIPNSPLIT=              gzip --no-name -9 -c | split -b 1392k -</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70728400"></a><a id="submitting-kernel-extensions"></a><p><strong>18.9.</strong></p></td><td align="left" valign="top"><p>Ich habe eine Kernelerweiterung geschrieben.  An wen
            sende ich sie?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Lesen Sie bitte den Artikel <a class="link" href="../../../../doc/de_DE.ISO8859-1/articles/contributing/article.html" target="_top">
            FreeBSD unterstützen</a>.</p><p>Und Danke, dass Sie darüber
            nachdenken!</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70731472"></a><a id="pnp-initialize"></a><p><strong>18.10.</strong></p></td><td align="left" valign="top"><p>Wie werden Plug&amp;Play ISA-Karten erkannt und
            initialisiert?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Von: Frank Durda IV
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:uhclem@nemesis.lonestar.org">uhclem@nemesis.lonestar.org</a>&gt;</code></p><p>Kurz gesagt gibt es nur wenige I/O-Ports über die
            PnP-Karten antworten, wenn der Host fragt, ob jemand da
            ist.  Wenn die PnP-Erkennungsroutine startet, fragt sie,
            ob irgendwelche PnP-Karten vorhanden sind und alle
            PnP-Karten antworten mit ihrer Modellnummer auf demselben
            Port, von dem sie auch gelesen haben.  Die
            Erkennungsroutine erhält also ein geodertes
            <span class="quote">&#8222;<span class="quote">Ja</span>&#8220;</span> auf diese Frage.  Mindestens ein Bit
            wird bei dieser Antwort gesetzt sein.  Die
            Erkennungsroutine ist dann in der Lage, dafür zu
            sorgen, dass Karten mit Modellnummern (zugeordnet von
            <span class="trademark">Microsoft</span>®/<span class="trademark">Intel</span>®) kleiner als <code class="literal">X</code>
            <span class="quote">&#8222;<span class="quote">off-line</span>&#8220;</span> gesetzt werden.  Sie prüft dann, ob
            immer noch Karten da sind, die auf die Frage antworten.  Falls die
            Antwort <code class="literal">0</code> war, sind keine Karten mit IDs
            größer <code class="literal">X</code> vorhanden.  Die
            Erkennungsroutine wird daraufhin anfragen, ob Karten unterhalb
            <code class="literal">X</code> vorhanden sind.  Schließlich setzt die
            Erkennungsroutine alle Karten größer als
            <code class="literal">X - (limit / 4)</code> off-line
            und wiederholt die Frage.  Wenn diese
            halbbinäre Suche nach IDs in Folge genügend oft
            wiederholt worden ist, wird die Erkennungsroutine
            schließlich alle in einem Rechner befindlichen
            PnP-Karten identifiziert haben und das mit einer
            Iterationszahl sehr viel kleiner als
            2<sup>64</sup>.</p><p>Die IDs bestehen aus zwei 32-Bit-Feldern (daher
            2<sup>64</sup>) + acht Bit Prüfsumme.  Die
            ersten 32 Bit sind die Herstellerkennung.  Es wurde zwar nicht
            bestätigt, aber es wird angenommen, dass unterschiedliche
            Kartentypen desselben Herstellers unterschiedliche 32-Bit
            Herstellerkennungen besitzen können.  32 Bit nur
            für eindeutige Hersteller zu benötigen, scheint
            etwas übertrieben.</p><p>Die niedrigen 32 Bit sind eine Seriennummer oder etwas
            anderes, das die betreffende Karte einzigartig macht.  Die
            Hersteller dürfen niemals eine zweite Karte mit denselben
            niedrigen 32 Bit herstellen, es sei denn, die höheren
            32 Bit sind unterschiedlich.  Sie können also mehrere
            Karten des selben Typs im Rechner haben und die gesamten
            64 Bit bleiben stets eindeutig.</p><p>Die 32-Bit-Gruppen können niemals nur aus Nullen
            bestehen.  Das erlaubt es, bei der binären Suche zu
            Beginn nur auf von Null verschiedene Bits zu achten.</p><p>Wenn das System alle vorhandenen Karten-IDs
            identifiziert hat, reaktiviert es jede Karte - eine nach
            der anderen (über dieselben I/O-Ports) und ermittelt,
            welche Ressourcen von der jeweiligen Karte benötigt
            werden, welche Wahlmöglichkeiten für Interrupts
            bestehen usw.  Alle Karten werden abgefragt, um diese
            Informationen zusammenzustellen.</p><p>Diese Informationen werden dann mit Informationen aus
            allen ECU-Dateien auf der Festplatte oder mit im MLB-BIOS
            verdrahteten Informationen verknüpft.  Die ECU- und
            BIOS-PnP-Unterstützung für Hardware auf dem MLB
            ist für gewöhnlich künstlich und was die
            Peripheriegeräte tun ist nicht wirklich echtes PnP.
            Durch die Untersuchung der BIOS-Informationen und der
            ECU-Informationen können die Erkennungsroutinen
            jedoch die von PnP-Geräten benutzten Ressourcen so
            ändern, dass vermieden wird, dass bereits
            von anderen Geräten benutzte Ressourcen verwendet
            werden.</p><p>Dann werden die PnP-Geräte nochmals besucht und
            ihre I/O, DMA, IRQ und Memory-Map-Adressen werden
            zugeordnet.  Die Geräte werden an diesen Stellen
            sichtbar werden und dort bis zum nächsten Reboot
            verbleiben.  Allerdings hindert Sie auch nichts daran, sie
            zu verschieben, wohin Sie wollen.</p><p>Im obigen Teil wurde sehr viel vereinfacht, aber die
            grundlegende Idee sollte klar geworden sein.</p><p><span class="trademark">Microsoft</span>® hat einige der primären
            Druckerstatusports für PnP übernommen, da keine
            Karte diese Adressen für die entgegengesetzten
            I/O-Zyklen decodiert.  Ich habe während der
            frühen Überprüfungsperiode des
            PnP-Vorschlags eine echte IBM Druckerkarte gefunden, die
            Schreibzugriffe auf dem Statusport decodiert hat, aber <span class="trademark">Microsoft</span>®
            hat nur <span class="quote">&#8222;<span class="quote">tough</span>&#8220;</span> gesagt.  Also schreiben sie
            auf den Druckerstatusport, um Adressen zu setzen, benutzen
            zusätzlich diese Adresse + <code class="literal">0x800</code>
            und einen dritten I/O-Port zum Lesen, der irgendwo
            zwischen <code class="literal">0x200</code> und
            <code class="literal">0x3ff</code> liegen kann.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70744272"></a><a id="major-numbers"></a><p><strong>18.11.</strong></p></td><td align="left" valign="top"><p>Wie bekomme ich eine Major-Number für einen
            Gerätetreiber, den ich geschrieben habe?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FreeBSD Versionen stellen seit Februar 2003
	    Major-Numbers für Geräte automatisch zur Laufzeit
	    bereit (lesen Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devfs&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">devfs</span>(5)</span></a>), damit ist das nicht mehr
	    nötig.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70747344"></a><a id="alternate-directory-layout"></a><p><strong>18.12.</strong></p></td><td align="left" valign="top"><p>Gibt es alternative Layoutverfahren für
            Verzeichnisse?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Als Antwort auf die Frage nach alternativen
            Layoutverfahren für Verzeichnisse ist das Schema, das
            derzeit benutzt wird, unverändert von dem, das ich
            1983 geschrieben habe.  Ich habe das Vorgehen für das
            originale Fast-Filesystem geschrieben und es niemals
            überarbeitet.  Es funktioniert gut, wenn es darum
            geht, zu verhindern, dass Zylindergruppen volllaufen.
            Wie viele von Ihnen angemerkt haben, funktioniert es
            schlecht für find.  Die meisten Dateisysteme werden
            von Archiven erstellt, die mit einer Tiefensuche (also
            ftw) erstellt wurden.  Diese Verzeichnisse werden
            über die Zylindergruppen hinweg entfaltet und
            erzeugen denkbar ungünstigste Voraussetzungen
            für zukünftige Tiefensuchen.  Falls man die
            Gesamtzahl der zu erstellenden Verzeichnisse wüsste,
            wäre die Lösung die,
            <code class="literal">(gesamt / fs_ncg)</code> pro
            Zylindergruppe zu erstellen, bevor fortgefahren wird.
            Offensichtlich müsste man eine Heuristik
            erstellen, um die Zahl zu schätzen.  Sogar die
            Benutzung einer kleinen, fixen Zahl, z.B. 10, würde
            eine Verbesserung um Größenordnungen ausmachen.
            Um Wiederherstellungen von normalem Betrieb (wo der
            derzeitige Algorithmus vermutlich sinnvoller ist) zu
            unterscheiden, könnten Sie die Clusterung von bis zu
            10 benutzen, wenn sie alle innerhalb eines
            10-Sekunden-Fensters durchgeführt würden.
            Jedenfalls ist mein Schluss, dass dies ein
            fruchtbares Gebiet für Experimente ist.</p><p>Kirk McKusick, September 1998</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70750160"></a><a id="kernel-panic-troubleshooting"></a><p><strong>18.13.</strong></p></td><td align="left" valign="top"><p>Wie kann ich optimalen Nutzen aus einer kernel panic
            ziehen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Hier ist eine typische Kernel-Panic</p><pre class="programlisting">Fatal trap 12: page fault while in kernel mode

fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault</pre><p>Wenn Sie eine Meldung wie diese sehen, reicht es
            nicht, sie einfach zu reproduzieren und sie einzusenden.
            Der Wert des Instruktionszeigers ist wichtig; leider ist er auch
            konfigurationsabhängig.  Mit anderen Worten variieren
            die Werte abhängig von dem Kernel-Image, das Sie
            tatsächlich benutzen.  Wenn Sie ein
            <code class="filename">GENERIC</code> Kernelimage von einem der Snapshots benutzen, dann ist es
            für jemand anderen möglich, die fehlerhafte
            Instruktion herauszufinden, aber wenn Sie einen
            angepassten Kernel benutzen, können nur
            <span class="emphasis"><em>Sie</em></span> uns sagen, wo der Fehler
            auftrat.</p><p>Was Sie tun sollten, ist folgendes:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Notieren Sie sich den Wert des
                Instruktionszeigers.  Beachten Sie, dass der Teil
                <code class="literal">0x8:</code> am Anfang in diesem Fall nicht
                von Bedeutung ist; der Teil
                <code class="literal">0xf0xxxxxx</code> ist der, den wir
                wollen.</p></li><li class="step"><p>Tun Sie folgendes, wenn das System
                rebootet:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</code></strong></pre><p>wobei <code class="literal">0xf0xxxxxx</code> der Wert des
                Instruktionszeigers ist.  Es besteht die
                Möglichkeit, dass Sie keinen exakten Treffer
                erzielen, weil die Symbole in der Symboltabelle des
                Kernels Funktionseinstiegspunkte sind und die Adresse
                des Instruktionszeigers irgendwo innerhalb einer
                Funktion liegen wird und nicht am Anfang.  Falls sie
                keinen exakten Treffer erzielen, lassen Sie den
                letzten Teil des Werts des Instruktionszeigers weg und
                versuchen es noch einmal, z.B.:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</code></strong></pre><p>Falls das kein Ergebnis liefert, hacken Sie eine
                weitere Ziffer ab.  Wiederholen Sie die Schritte, bis
                Sie irgendeine Ausgabe erhalten.  Das Ergebnis wird
                eine Liste möglicher Funktionen sein, die die
                Panik verursacht haben.  Das ist zwar kein absolut
                genauer Mechanismus, um die Fehlerursache ausfindig zu
                machen, aber es ist besser als gar nichts.</p></li></ol></div><p>Wie dem auch sei, der beste Weg, den Grund für eine Panik
            herauszufinden, ist der, einen Crash-Dump festzuhalten und
            dann <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> zu benutzen, um den Stack im Crash-Dump
            zurückzuverfolgen.</p><p>Jedenfalls ist die Methode, die ich normalerweise
            benutze, folgende:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Sorgen Sie dafür, dass die folgende Zeile in der
                Kernelkonfigurationsdatei
                (<code class="filename">/usr/src/sys/arch/conf/MYKERNEL</code>) enthalten ist:</p><pre class="programlisting">makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</pre></li><li class="step"><p>Wechseln Sie in das Verzeichnis <code class="filename">usr/src</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src</code></strong></pre></li><li class="step"><p>Erstellen Sie den Kernel:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>make buildkernel KERNCONF=MYKERNEL</code></strong></pre></li><li class="step"><p>Warten Sie, bis <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a> den Kernel fertig kompiliert
                hat.</p></li><li class="step"><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>make installkernel KERNCONF=MYKERNEL</code></strong></pre></li><li class="step"><p>Starten Sie das System neu.</p></li></ol></div><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Falls Sie die make-Variable <code class="varname">KERNCONF</code>
              nicht verwenden, wird ein <code class="filename">GENERIC</code> Kernel
              gebaut und installiert.</p></div><p>Der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=make&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">make</span>(1)</span></a>-Prozess wird zwei Kernel
            erstellt haben:
            <code class="filename">/usr/obj/usr/src/sys/MYKERNEL/kernel</code>
            und
            <code class="filename">/usr/obj/usr/src/sys/MYKERNEL/kernel.debug</code>.
            <code class="filename">kernel</code> wurde als
            <code class="filename">/boot/kernel</code> installiert, während
            <code class="filename">kernel.debug</code> als Quelle für
            Debuggersymbole für <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> benutzt werden
            kann.</p><p>Um sicherzustellen, dass ein Crash-Dump erhalten
            bleibt, müssen Sie
            <code class="filename">/etc/rc.config</code> editieren und
            <code class="literal">dumpdev</code> so setzen, dass es auf
            Ihre Swap-Partition zeigt.  Das bewirkt, dass die
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>-Skripte den Befehl <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> benutzen, um
            Crash-Dumps zu ermöglichen.  Sie können
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dumpon&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dumpon</span>(8)</span></a> auch manuell ausführen.  Nach einer
            Panik kann der Crash-Dump mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a>
            wiederhergestellt werden;  wenn <code class="literal">dumpdev</code>
            in <code class="filename">/etc/rc.conf</code> gesetzt ist, werden
            die <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>-Skripte <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> automatisch
            ausführen und den Crash-Dump unter <code class="filename">/var/crash</code> ablegen.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Crash-Dumps von FreeBSD sind für
              gewöhnlich genauso groß wie der physikalische
              Hauptspeicher Ihres Rechners.  Das heißt, wenn Sie
              512MB RAM haben, werden sie einen 512MB Crash-Dump
              erhalten.  Deshalb müssen Sie dafür sorgen, dass
              genügend Speicherplatz in
              <code class="filename">/var/crash</code> zur Verfügung
              steht, um den Dump aufnehmen zu können.  Alternativ
              führen Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=savecore&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">savecore</span>(8)</span></a> manuell aus und lassen
              es den Crash-Dump in einem anderen Verzeichnis
              wiederherstellen, in dem Sie mehr Platz haben.  Es ist
              möglich, die Größe des Crash-Dumps zu
              begrenzen, indem <code class="literal">options
              MAXMEM=N</code>, wobei
              <em class="replaceable"><code>N</code></em> die Größe des verwendeten
              Kernelspeichers in KBs ist.  Wenn Sie z.B. 1 GB RAM haben,
              können Sie die Speicherbenutzung des Kernels damit auf
              128 MB begrenzen, so dass die Größe Ihres
              Crash-Dumps 128 MB anstatt 1 GB betragen wird.</p></div><p>Wenn Sie den Crash-Dump wiederhergestellt haben,
            können Sie den Stack mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> so
            zurückverfolgen:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0</code></strong>
<code class="prompt">(kgdb)</code> <strong class="userinput"><code>backtrace</code></strong></pre><p>Beachten Sie, dass es mehrere Seiten mit
            wertvollen Informationen geben könnte; idealerweise
            sollten Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=script&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">script</span>(1)</span></a> benutzen, um sie alle
            festzuhalten.  Wenn Sie das vollständige Kernelimage
            mit allen Debugginginformationen benutzen,
            müssten Sie exakt die Zeile des
            Kernel-Sourcecodes finden, wo die Panik aufgetreten ist.
            Für gewöhnlich müssen Sie den Stack von
            unten an zurückverfolgen, um die genaue
            Ereignisabfolge, die zum Crash führte,
            zurückzuverfolgen.  Sie können <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> auch
            zum Ausdrucken der Inhalte verschiedener Variablen oder
            Strukturen benutzen, um den Systemstatus zum Zeitpunkt des
            Absturzes zu untersuchen.</p><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml">Wenn Sie nun wirklich verrückt sind und einen
              zweiten Computer haben, können Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> auch
              für entferntes Debugging konfigurieren, so dass
              Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kgdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kgdb</span>(1)</span></a> auf einem System benutzen können, um
              den Kernel auf einem anderen System zu debuggen,
              einschließlich dem Setzen von Haltepunkten und dem
              Bewegen in Einzelschritten durch den Kernelcode, genauso,
              wie Sie es mit einem normalen Benutzerprogramm tun
              können.</p></div><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Wenn Sie <code class="literal">DDB</code> aktiviert haben
              und der Kernel im Debugger landet, können Sie eine Panik
              (und einen Crash-Dump) erzwingen, indem Sie einfach
              <code class="literal">panic</code> am <code class="literal">ddb</code>-Prompt
              eingeben.  Er könnte während der Panikphase
              wieder im Debugger stoppen.  Falls er das tut, geben Sie
              <code class="literal">continue</code> ein, dann wird er den Crash-Dump
              beenden.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70951504"></a><a id="dlsym-failure"></a><p><strong>18.14.</strong></p></td><td align="left" valign="top"><p>Wieso funktioniert <code class="function">dlsym()</code> nicht mehr
            für ELF-Executables?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die ELF-Werkzeuge machen die in einem Executable
            definierten Symbole dem dynamischen Linker nicht
            standardmäßig sichtbar.  Konsequenterweise
            werden <code class="function">dlsym()</code>-Suchen nach Handlern
            aus Aufrufen von <code class="function">dlopen(NULL, flags)</code>
            diese Symbole nicht finden können.</p><p>Wenn Sie mit <code class="function">dlsym()</code> nach im
            Hauptexecutable eines Prozesses vorhandenen Symbolen
            suchen wollen, müssen Sie das Executable mit der
            Option <code class="option">--export-dynamic</code> von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ld&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ld</span>(1)</span></a>
            linken.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp70956624"></a><a id="change-kernel-address-space"></a><p><strong>18.15.</strong></p></td><td align="left" valign="top"><p>Wie kann ich den Adressraum des Kernels auf i386
            vergrössern oder verkleinern?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Standardmäßig beträgt der
            Adressraum des Kernels 1 GB (2 GB für PAE)
            auf i386.  Wenn Sie einen netzwerkintensiven Server
            (z.B. einen großen FTP- oder HTTP-Server) betreiben, oder
            ZFS verwenden möchten, kann es sein, dass Sie der Meinung
            sind, dass das nicht ausreichen.</p><p>Fügen Sie die folgende Zeile zu ihrer
            Kernelkonfigurationsdatei hinzu, um den verfügbaren Speicher
            zu erhöhen und erstellen Sie dann einen neuen Kernel:</p><pre class="programlisting">options KVA_PAGES=<em class="replaceable"><code>N</code></em></pre><p>Um den richtigen Wert von <em class="replaceable"><code>N</code></em> zu
            bestimmen, teilen Sie den gewünschte Größe
            des Addressraumes (in Megabyte) durch vier (z.B. beträgt er
            <code class="literal">512</code> für 2 GB).</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="funnies.html">Zurück</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="acknowledgments.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">Kapitel 17. Nicht ganz ernstgemeinte Fragen </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> Kapitel 19. Danksagung</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>