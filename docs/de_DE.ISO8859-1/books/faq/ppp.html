<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Kapitel 14. PPP</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="up" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="prev" href="security.html" title="Kapitel 13. Sicherheit" /><link rel="next" href="serial.html" title="Kapitel 15. Serielle Verbindungen" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Kapitel 14. PPP</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security.html">Zurück</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="serial.html">Weiter</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ppp"></a>Kapitel 14. PPP</h1></div></div></div><div class="qandaset"><a id="idp69483984"></a><dl><dt>14.1. <a href="ppp.html#idp69484240">Ich bekomme ppp(8) nicht zum Laufen.  Was mache
            ich falsch?</a></dt><dt>14.2. <a href="ppp.html#idp69496400">Warum hängt sich ppp auf, wenn ich es
            benutze?</a></dt><dt>14.3. <a href="ppp.html#idp69502160">Warum wählt ppp(8) im
          -auto-Modus nicht?</a></dt><dt>14.4. <a href="ppp.html#idp69518544">Was bedeutet No route to
            host?</a></dt><dt>14.5. <a href="ppp.html#idp69524304">Wieso werden meine Verbindungen nach ca. drei Minuten
            beendet?</a></dt><dt>14.6. <a href="ppp.html#idp69532112">Wieso bricht meine Verbindung bei hoher Auslastung
            ab?</a></dt><dt>14.7. <a href="ppp.html#idp69535312">Warum brechen meine Verbindungen nach unbestimmter
            Zeit zusammen?</a></dt><dt>14.8. <a href="ppp.html#idp69547856">Warum hängen meine Verbindung nach einer
            unbestimmten Zeit?</a></dt><dt>14.9. <a href="ppp.html#idp69559248">Was kann ich machen, wenn die Gegenstelle nicht
            antwortet?</a></dt><dt>14.10. <a href="ppp.html#idp69566288">Was kann ich tun, wenn sich ppp(8)
            aufhängt?</a></dt><dt>14.11. <a href="ppp.html#idp69588432">Warum passiert nach der Nachricht &#8222;Login
            OK!&#8220; nichts?</a></dt><dt>14.12. <a href="ppp.html#idp69593936">Ich sehe ständig Fehlermeldungen über
            gleiche &#8222;Magic Numbers&#8220;  Was heißt
            das?</a></dt><dt>14.13. <a href="ppp.html#idp69623888">Die LCP-Verhandlungen dauern an, bis die Verbindung
            geschlossen wird.  Was mache ich falsch?</a></dt><dt>14.14. <a href="ppp.html#idp69651792">Warum reagiert ppp(8) nicht mehr, wenn ich es mit
            shell verlassen habe?</a></dt><dt>14.15. <a href="ppp.html#idp69659728">Warum wird ppp(8) niemals beendet, wenn ich es
            über ein Nullmodem-Kabel benutze?</a></dt><dt>14.16. <a href="ppp.html#idp69664080">Warum wählt ppp(8) im Modus -auto
            ohne Grund?</a></dt><dt>14.17. <a href="ppp.html#idp69684048">Was bedeuten diese CCP-Fehler?</a></dt><dt>14.18. <a href="ppp.html#idp69688016">Warum loggt ppp die Geschwindigkeit meiner Verbindung
            nicht?</a></dt><dt>14.19. <a href="ppp.html#idp69696592">Warum ignoriert ppp(8) das Zeichen
            \ in meinem Chat-Skript?</a></dt><dt>14.20. <a href="ppp.html#idp69714896">Warum gibt es die Datei ppp.core
            nicht, wenn ppp(8) einen Segmentation
            fault erzeugt hat?</a></dt><dt>14.21. <a href="ppp.html#idp69741392">Warum bekommt das Programm, das eine Anwahl im Modus
          -auto ausgelöst hat, keine Verbindung?</a></dt><dt>14.22. <a href="ppp.html#idp69789264">Warum laufen die meisten Spiele mit dem -nat
	    Schalter nicht?</a></dt><dt>14.23. <a href="ppp.html#idp69812688">Hat jemand eine Liste mit nützlichen Portnummern
            erstellt?</a></dt><dt>14.24. <a href="ppp.html#idp69836368">Was sind FCS-Fehler?</a></dt><dt>14.25. <a href="ppp.html#PPPoEwithNAT">Wieso hängen die Verbindungen meiner Mac OS®- und
            Windows® 98-Maschinen (und eventuell auch andere
            Microsoft® Betriebssysteme), wenn auf meinem Gateway
            PPPoE läuft?</a></dt><dt>14.26. <a href="ppp.html#idp69876944">Nichts von alledem hilft - ich bin
            verzweifelt!  Was soll ich machen?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp69484240"></a><a id="userppp"></a><p><strong>14.1.</strong></p></td><td align="left" valign="top"><p>Ich bekomme <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> nicht zum Laufen.  Was mache
            ich falsch?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sie sollten zuerst <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> (die Manualpage zu ppp)
            und den <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/ppp-and-slip.html#USERPPP" target="_top">Abschnitt zu
            PPP im Handbuch</a> lesen.  Aktivieren Sie das Logging
            mit folgendem Befehl:</p><pre class="programlisting">set log Phase Chat Connect Carrier lcp ipcp ccp command</pre><p>Dieser Befehl kann an der Eingabeaufforderung von
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> eingegeben oder in die Konfigurationsdatei
            <code class="filename">/etc/ppp/ppp.conf</code> eingetragen werden
            (der beste Ort hierfür ist der Anfang des Abschnitts
            <code class="literal">default</code>.  Stellen Sie sicher, dass
            die Datei <code class="filename">/etc/syslog.conf</code> die
            folgenden Zeilen enthält und die Datei
            <code class="filename">/var/log/ppp.log</code> existiert:</p><pre class="programlisting">!ppp
*.*              /var/log/ppp.log
          </pre><p>Sie können nun über die Logfiles eine Menge
            darüber herausfinden, was geschieht.  Es macht
            nichts, wenn die Einträge in den Logfiles Ihnen gar
            nichts sagen.  Wenn Sie jemandem um Hilfe bitten
            müssen, könnten sie für ihn von Nutzen
            sein.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69496400"></a><a id="ppp-hangs"></a><p><strong>14.2.</strong></p></td><td align="left" valign="top"><p>Warum hängt sich ppp auf, wenn ich es
            benutze?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das liegt meistens daran, dass Ihr Rechnername
            nicht aufgelöst werden kann.  Um dieses Problem zu
            lösen, müssen Sie sicherstellen, dass die
            Datei <code class="filename">/etc/hosts</code> von Ihrem Resolver
            zuerst genutzt wird.  Dazu muss in der Datei
            <code class="filename">/etc/host.conf</code> der Eintrag
            <code class="literal">hosts</code> an die erste Stelle gesetzt
            werden.  Erstellen Sie dann einfach für Ihren lokalen
            Rechner einen Eintrag in der Datei
            <code class="filename">/etc/hosts</code>.  Falls Sie kein lokales
            Netzwerk besitzen, ändern Sie die
            <code class="systemitem">localhost</code>-Zeile:</p><pre class="programlisting">127.0.0.1    foo.example.com foo localhost</pre><p>Andernfalls fügen Sie einfach einen weiteren
            Eintrag für Ihren lokalen Rechner hinzu.  Weitere
            Details finden Sie in den betreffenden
            Manualpages.</p><p>Wenn Sie fertig sind sollten Sie <code class="command">ping -c1
            `hostname`</code> erfolgreich ausführen
            können.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69502160"></a><a id="ppp-nodial-auto"></a><p><strong>14.3.</strong></p></td><td align="left" valign="top"><p>Warum wählt <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> im
          <code class="literal">-auto</code>-Modus nicht?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Überprüfen Sie zunächst, ob Sie einen
            Standard-Gateway eingestellt haben.  Wenn Sie
            <code class="command">netstat -rn</code> ausführen, sollten Sie
            zwei Einträge ähnlich den folgenden
            sehen:</p><pre class="programlisting">
Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0
          </pre><p>Hier wird angenommen, dass Sie die Adressen aus
            dem Handbuch, der Manualpage oder aus der Datei
            <code class="filename">ppp.conf.sample</code> benutzt haben.
            Falls Sie keine Standardroute haben, kann es daran liegen, dass Sie
            vergessen haben, die Zeile <code class="literal">HISADDR</code> in der Datei
            <code class="filename">ppp.conf</code> hinzuzufügen.</p><p>Ein weiterer Grund dafür, dass die Zeile
            für die Standardroute fehlt, könnte der sein,
            dass Sie fälschlicherweise eine Standardroute in
            der Datei <code class="filename">/etc/rc.conf</code> eingetragen
            und die folgende Zeile in <code class="filename">ppp.conf</code>
            ausgelassen haben:</p><pre class="programlisting">delete ALL</pre><p>Lesen Sie in diesem Fall den Abschnitt <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/userppp.html#USERPPP-FINAL" target="_top">
            Abschließende Systemkonfiguration</a> des
            Handbuchs.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69518544"></a><a id="no-route-to-host"></a><p><strong>14.4.</strong></p></td><td align="left" valign="top"><p>Was bedeutet <span class="errorname">No route to
            host</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dieser Fehler beruht für gewöhnlich auf
            einem fehlenden Abschnitt in Ihrer Datei
            <code class="filename">/etc/ppp/ppp.linkup</code>:</p><pre class="programlisting">MYADDR:
  delete ALL
  add 0 0 HISADDR
          </pre><p>Er ist nur notwendig, wenn Sie eine dynamische IP-Adresse
            besitzen oder die Adresse Ihres Gateways nicht kennen.  Wenn Sie
            den interaktiven Modus benutzen, können Sie folgendes
            eingeben, nachdem Sie in den <code class="literal">packet
            mode</code> gelangt sind (den Paket Modus erkennen Sie
            an <acronym class="acronym">PPP</acronym> im Prompt):</p><pre class="programlisting">
delete ALL
add 0 0 HISADDR
          </pre><p>Weitere Details finden Sie im Abschnitt <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/userppp.html#USERPPP-DYNAMICIP" target="_top">PPP
            und Dynamische IP-Adressen</a> des Handbuchs.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69524304"></a><a id="connection-threeminutedrop"></a><p><strong>14.5.</strong></p></td><td align="left" valign="top"><p>Wieso werden meine Verbindungen nach ca. drei Minuten
            beendet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Der Standardtimeout für <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> beträgt
            drei Minuten.  Er kann durch die folgende Zeile eingestellt werden,
            wobei <em class="replaceable"><code>NNN</code></em> die Inaktivität in
            Sekunden angibt, bevor die Verbindung geschlossen wird:</p><pre class="programlisting">set timeout <em class="replaceable"><code>NNN</code></em></pre><p>Falls <em class="replaceable"><code>NNN</code></em> Null ist, wird die
            Verbindung niemals aufgrund eines Timeouts geschlossen.
            Es ist möglich, diesen Befehl in die Datei
            <code class="filename">ppp.conf</code> einzubinden, oder ihn an der
            Eingabeaufforderung im interaktiven Modus einzugeben.
            Durch eine Verbindung zum Server-Socket von
            <span class="application">ppp</span> über <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a>
            oder <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppctl</span>(8)</span></a>  ist es auch möglich, den Timeout
            bei aktiver Verbindung anzupassen.  Weitere Details finden
            Sie in der Manualpage <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69532112"></a><a id="ppp-drop-heavy-load"></a><p><strong>14.6.</strong></p></td><td align="left" valign="top"><p>Wieso bricht meine Verbindung bei hoher Auslastung
            ab?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Falls Sie Link-Quality-Reporting (LQR) konfiguriert
            haben, ist es möglich, dass zu viele LQR-Pakete
            zwischen Ihrer Maschine und dem verbundenen Rechner
            verloren gehen.  Das <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>-Programm folgert daraus, dass die
            Verbindung nicht in Ordnung ist und schließt sie.
            Vor FreeBSD Version 2.2.5 war LQR standardmäßig
            aktiviert; nun ist es standardmäßig
            deaktiviert.  Es kann durch die folgende Zeile deaktiviert
            werden:</p><pre class="programlisting">disable lqr</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69535312"></a><a id="ppp-drop-random"></a><p><strong>14.7.</strong></p></td><td align="left" valign="top"><p>Warum brechen meine Verbindungen nach unbestimmter
            Zeit zusammen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Wenn die Qualität Ihrer Telefonleitung zu
            schlecht oder bei Ihrem Anschluss die Option
            (Telekomdeutsch: das Leistungsmerkmal) Anklopfen aktiviert
            ist, kann es manchmal vorkommen, dass Ihr Modem
            auflegt, weil es (fälschlicherweise) annimmt,
            dass es das Trägersignal verloren hat.</p><p>Bei den meisten Modems gibt es eine
            Einstellmöglichkeit, um anzugeben, wie tolerant es
            gegenüber vorübergehenden Verlusten des
            Trägersignals sein soll.  Bei einem
            <span class="trademark">U.S. Robotics</span>® <span class="trademark">Sportster</span>® wird dies zum Beispiel im Register
            S10 in Zehntelsekunden angegeben.  Um Ihr Modem toleranter zu
            machen, können Sie zu Ihrem Wählbefehl die folgende
            Sende-Empfangs-Sequenz hinzufügen:</p><pre class="programlisting">set dial "...... ATS10=10 OK ......"</pre><p>Weitere Information sollten Sie dem Handbuch Ihres
            Modems entnehmen können.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69547856"></a><a id="ppp-hangs-random"></a><p><strong>14.8.</strong></p></td><td align="left" valign="top"><p>Warum hängen meine Verbindung nach einer
            unbestimmten Zeit?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Viele Leute machen Erfahrungen mit hängenden
            Verbindungen ohne erkennbaren Grund.  Als erstes muss
            festgestellt werden, welche Seite der Verbindung
            hängt.</p><p>Wenn Sie ein externes Modem benutzen, können Sie
            einfach versuchen, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ping</span>(8)</span></a> zu benutzen, um zu sehen,
            ob die <acronym class="acronym">TD</acronym>-Anzeige aufleuchtet, wenn Sie
            Daten übertragen.  Falls sie aufleuchtet (und die
            <acronym class="acronym">RD</acronym>-Anzeige nicht), liegt das Problem am
            anderen Ende.  Falls <acronym class="acronym">TD</acronym> nicht
            aufleuchtet, handelt es sich um ein lokales Problem.  Bei
            einem internen Modem müssen Sie den Befehl
            <code class="literal">set server</code> in Ihrer Datei
            <code class="filename">ppp.conf</code> benutzen.  Stellen Sie
            über <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pppctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pppctl</span>(8)</span></a> eine Verbindung zu <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            her, wenn die Verbindung hängt.  Falls Ihre
            Netzwerkverbindung plötzlich wieder funktioniert (ppp
            wurde durch die Aktivität auf dem Diagnose-Socket
            wiederbelebt) oder Sie keine Verbindung bekommen
            (vorausgesetzt, der Befehl <code class="literal">set socket</code>
            wurde beim Start erfolgreich ausgeführt), handelt es
            sich um ein lokales Problem.  Falls Sie eine Verbindung
            bekommen und die externe Verbindung weiterhin hängt,
            aktivieren Sie lokales asynchrones Logging mit
            <code class="literal">set log local async</code> und benutzen Sie
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ping</span>(8)</span></a> von einem anderen Fenster oder Bildschirm
            aus, um die externe Verbindung zu benutzen.  Das
            asynchrone Logging zeigt Ihnen, welche Daten über die
            Verbindung gesendet und empfangen werden.  Falls Daten
            hinausgehen, aber nicht zurückkommen, handelt es sich
            um ein externes Problem.</p><p>Wenn Sie festgestellt haben, ob es sich um ein lokales
            oder um ein externes Problem handelt, haben Sie zwei
            Möglichkeiten:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Wenn es ein externes Problem ist, lesen Sie bitte bei
	        <a class="xref" href="ppp.html#ppp-remote-not-responding" title="14.9.">F: 14.9</a> weiter.</p></li><li class="listitem"><p>Handelt es sich um ein lokales Problem, lesen Sie bitte
		<a class="xref" href="ppp.html#ppp-hung" title="14.10.">F: 14.10</a>.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69559248"></a><a id="ppp-remote-not-responding"></a><p><strong>14.9.</strong></p></td><td align="left" valign="top"><p>Was kann ich machen, wenn die Gegenstelle nicht
            antwortet?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Hier können Sie wenig tun.  Die meisten ISPs
            werden ablehnen, Ihnen zu helfen, wenn Sie kein
            Betriebssystem von <span class="trademark">Microsoft</span>® benutzen.  Sie können
            <code class="literal">enable lqr</code> in Ihrer Datei
            <code class="filename">ppp.conf</code> angeben, wodurch <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            ermöglicht wird, ein externes Versagen zu erkennen
            und aufzulegen, aber diese Erkennung ist relativ langsam
            und deshalb nicht besonders nützlich.  Evtl. sagen
            Sie Ihrem ISP nicht, dass Sie user-PPP
            benutzen.</p><p>Versuchen Sie zunächst, jegliche Datenkompression
            auszuschalten, indem Sie folgendes zu Ihrer Konfiguration
            hinzufügen:</p><pre class="programlisting">
disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj
          </pre><p>Stellen Sie nun wieder eine Verbindung her, um
            festzustellen, ob sich etwas geändert hat.  Falls es
            nun besser läuft oder falls das Problem
            vollständig behoben ist, versuchen Sie durch
            schrittweises Ändern der Einstellungen festzustellen,
            welche Einstellung den Unterschied bewirkt.  Hierdurch
            erhalten Sie schlüssige Fakten für ein Gespräch
            mit Ihrem ISP (andererseits wird hierdurch offensichtlich,
            dass Sie kein <span class="trademark">Microsoft</span>®-Produkt benutzen).</p><p>Aktivieren Sie asynchrones Logging und warten Sie, bis
            die Verbindung wieder hängt, bevor Sie sich an Ihren
            ISP wenden.  Hierzu kann einiges an Plattenplatz
            nötig sein.  Die Daten, die als letztes von dem Port
            gelesen wurden, könnten von Interesse sein.  Für
            gewöhnlich handelt es sich um ASCII-Text, der sogar
            den Fehler beschreiben kann (<span class="errorname">Memory fault, Core
            dumped</span>).</p><p>Falls Ihr ISP hilfsbereit ist, sollte er in der Lage
            sein, an seinem Ende das Logging zu aktivieren und wenn
            das nächste Mal die Verbindung abbricht, könnte
            er Ihnen mitteilen, worin das Problem auf seiner Seite
            besteht.  Gerne können Sie Details auch an Brian Somers
            schicken, oder Ihren ISP bitten, sich direkt an ihn zu
            wenden.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69566288"></a><a id="ppp-hung"></a><p><strong>14.10.</strong></p></td><td align="left" valign="top"><p>Was kann ich tun, wenn sich <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            aufhängt?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>In diesem Fall erstellen Sie am besten <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            mit Debugging-Informationen neu und benutzen dann <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a>, um
            von dem hängenden <span class="application">ppp</span> Prozess eine
            Aufzeichnung des Stacks zu erstellen.  Um die
            <span class="application">ppp</span> Anwendung mit
            Debugging-Informationen zu übersetzen, geben Sie folgendes
            ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/usr.sbin/ppp</code></strong><code class="prompt">#</code> <strong class="userinput"><code>env DEBUG_FLAGS='-g' make clean</code></strong>
 	<code class="prompt">#</code> <strong class="userinput"><code>env DEBUG_FLAGS='-g' make install</code></strong></pre><p>Anschliessend sollten Sie <span class="application">ppp</span> neu
            starten und darauf warten, dass es wieder hängt.  Wenn die
            Debug-Version von <span class="application">ppp</span> hängt,
            starten Sie <span class="application">gdb</span> für den
            steckengebliebenen Prozess, indem Sie folgendes eingeben:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>gdb ppp `pgrep ppp`</code></strong></pre><p>An der Eingabeaufforderung von <span class="application">gdb</span>
            können Sie die Befehle <code class="command">bt</code> oder
            <code class="command">where</code> benutzen, um eine Aufzeichnung des Stacks
            zu erhalten.  Speichern Sie die Ausgabe der
            <span class="application">gdb</span>-Sitzung und
            <span class="quote">&#8222;<span class="quote">trennen</span>&#8220;</span> Sie den laufenden Prozess über den
            <code class="command">quit</code> Befehl von
            <span class="application">gdb</span>.</p><p>Schicken Sie zum Schluss das Log der
 	    <span class="application">gdb</span>-Sitzung an Brian Somers.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69588432"></a><a id="ppp-loginok-thennothing"></a><p><strong>14.11.</strong></p></td><td align="left" valign="top"><p>Warum passiert nach der Nachricht <span class="quote">&#8222;<span class="quote">Login
            OK!</span>&#8220;</span> nichts?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Bei FreeBSD-Versionen vor 2.2.5 wartete <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            darauf, dass der Partner das Line Control Protocol
            (LCP) initiiert.  Viele ISPs starten nicht mit der
            Initiierung, sondern erwarten dies vom Client.  Benutzen
            Sie die folgende Zeile, um <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> zu veranlassen, LCP
            zu initiieren:</p><pre class="programlisting">set openmode active</pre><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Für gewöhnlich schadet es nicht, wenn
              beide Seiten versuchen, Verhandlungen einzuleiten.
              Deshalb ist openmode nun standardmäßig aktiv.
              Im nächsten Abschnitt wird allerdings erklärt,
              in welchen Fällen es <span class="emphasis"><em>doch</em></span>
              schadet.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69593936"></a><a id="ppp-same-magic"></a><p><strong>14.12.</strong></p></td><td align="left" valign="top"><p>Ich sehe ständig Fehlermeldungen über
            gleiche <span class="quote">&#8222;<span class="quote">Magic Numbers</span>&#8220;</span>  Was heißt
            das?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Nach dem Aufbau einer Verbindung kann es sein,
            dass Sie in der Logdatei gelegentlich Meldungen mit
            dem Hinweis <span class="errorname">magic is the same</span> sehen.
            Manchmal sind diese Meldungen harmlos und manchmal bricht
            die eine oder andere Seite die Verbindung ab.  Die meisten
            Implementationen von PPP können dieses Problem nicht
            handhaben und Sie werden wiederholte
            Konfigurationsanforderungen und -bestätigungen in der
            Logdatei finden, bis <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> schließlich aufgibt
            und die Verbindung beendet.</p><p>Dies geschieht normalerweise auf Servern mit langsamen
            Festplatten, bei denen ein getty auf dem Port
            ausgeführt und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> nach dem Einloggen von
            einem Login-Skript oder einem Programm aus gestartet wird.
            Es wurde auch schon berichtet, dass dies bei der
            Benutzung von slirp regelmäßig auftritt.  Der
            Grund hierfür ist, dass das <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> auf der
            Client-Seite in der Zeit, die benötigt wird, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=getty&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">getty</span>(8)</span></a> zu
            beenden und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> zu starten, bereits beginnt, Line Control
            Protocol (LCP) Pakete zu senden.  Da ECHO auf dem
            Serverport weiterhin eingeschaltet ist, werden diese
            Pakete zum <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> auf der Client-Seite
            <span class="quote">&#8222;<span class="quote">reflektiert</span>&#8220;</span>.</p><p>Ein Teil der LCP-Verhandlungen ist die Einrichtung
            einer <span class="quote">&#8222;<span class="quote">Magic Number</span>&#8220;</span> für jede Seite der
	    Verbindung, damit <span class="quote">&#8222;<span class="quote">Echos</span>&#8220;</span> erkannt werden können.
            Das Protokoll besagt, dass, wenn der Partner
            versucht, die gleiche <span class="quote">&#8222;<span class="quote">Magic Number</span>&#8220;</span> auszuhandeln,
	    ein NAK zurückgesendet und eine neue "Magic Number"
            gewählt werden soll.  Während der Server das
            ECHO eingeschaltet hat, sendet der Client LCP Pakete,
            sieht die gleiche <span class="quote">&#8222;<span class="quote">Magic Number</span>&#8220;</span> im reflektierten
	    Paket und erzeugt ein NAK.  Er sieht auch das reflektierte NAK
            (was bedeutet, dass <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> seine "Magic Number"
            ändern muss).  Hierdurch wird eine Vielzahl von
            Änderungen der <span class="quote">&#8222;<span class="quote">Magic Number</span>&#8220;</span> hervorgerufen,
	    die sich allesamt im tty-Puffer des Servers ansammeln.  Sobald
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> auf dem Server startet, wird es mit
            Änderungen der <span class="quote">&#8222;<span class="quote">Magic Number</span>&#8220;</span> überflutet
	    und entscheidet, dass  es sich zur Genüge mit den
            LCP-Verhandlungen beschäftigt hat und gibt auf.  Und
            während sich der Client noch darüber freut,
            dass er keine weiteren Reflexionen sieht, wird ihm
            gemeldet, dass der Server auflegt.</p><p>Dies kann verhindert werden, indem dem Partner durch
            die folgende Zeile in der Datei
            <code class="filename">ppp.conf</code> erlaubt wird, mit der
            Verhandlung zu beginnen:</p><pre class="programlisting">set openmode passive</pre><p>Hierdurch wird <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> mitgeteilt, darauf zu
            warten, dass der Server mit den LCP-Verhandlungen
            beginnt.  Einige Server starten jedoch nie mit der
            Verhandlungen;  falls dies der Fall ist, können Sie
            folgendes tun:</p><pre class="programlisting">set openmode active 3</pre><p>Hierdurch bleibt <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> für drei Sekunden
            passiv und fängt dann erst an, LCP-Anforderungen zu
            senden.  Falls der Partner während dieser Zeit
            beginnt, Anforderungen zu senden, wird <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> direkt
            antworten und nicht erst, nachdem die drei Sekunden
            abgelaufen sind.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69623888"></a><a id="ppp-lcp-constant"></a><p><strong>14.13.</strong></p></td><td align="left" valign="top"><p>Die LCP-Verhandlungen dauern an, bis die Verbindung
            geschlossen wird.  Was mache ich falsch?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Es gibt eine Fehlfunktion in der Implementierung von
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>, die darin besteht, dass LCP-, CCP- &amp;
            IPCP-Antworten nicht mit den ursprünglichen
            Anforderungen assoziiert werden.  Für den Fall,
            dass eine Implementation von PPP mehr als sechs
            Sekunden langsamer ist, als die andere Seite, resultiert
            das darin, dass die andere Seite zwei weitere
            LCP-Konfigurationsanforderungen sendet, was fatale
            Auswirkungen hat.</p><p>Stellen Sie sich vor, wir hätten es mit zwei
            Implementierungen <code class="systemitem">A</code> und
            <code class="systemitem">B</code> zu tun.  <code class="systemitem">A</code> beginnt
            unmittelbar nach der Verbindung, LCP-Anforderungen zu
            senden und <code class="systemitem">B</code> benötigt sieben
            Sekunden, zu starten.  Wenn <code class="systemitem">B</code> startet,
            hat <code class="systemitem">A</code> bereits drei LCP-Anforderungen
            gesendet.  Wir nehmen an, dass ECHO ausgeschaltet
            ist; andernfalls würden wir Probleme mit der "Magic
            Number" beobachten, wie bereits im vorherigen Abschnitt
            beschrieben.  <code class="systemitem">B</code> sendet eine Anforderung
            und anschließend eine Bestätigung der ersten
            Anforderung von <code class="systemitem">A</code>.  Dies führt dazu,
            dass <code class="systemitem">A</code> in den Zustand
            <acronym class="acronym">OPENED</acronym> übergeht und eine
            Bestätigung (die erste) zurück an
            <code class="systemitem">B</code> sendet.  In der Zwischenzeit sendet
            <code class="systemitem">B</code> zwei weitere Bestätigungen als
            Antwort auf die zusätzlichen Anforderungen, die von
            <code class="systemitem">A</code> gesendet worden sind, bevor
            <code class="systemitem">B</code> gestartet ist.  <code class="systemitem">B</code>
            empfängt dann die erste Bestätigung von
            <code class="systemitem">A</code> und geht in den Zustand
            <acronym class="acronym">OPENED</acronym> über.  <code class="systemitem">A</code>
            empfängt die zweite Bestätigung von
            <code class="systemitem">B</code>, geht zurück in den Zustand
            <acronym class="acronym">REQ-SENT</acronym> und sendet eine
            weitere (vierte) Anforderung entsprechend dem RFC.
            <code class="systemitem">A</code> empfängt dann die dritte
            Bestätigung und geht in den Zustand
            <acronym class="acronym">OPENED</acronym> über.  In der Zwischenzeit
            empfängt <code class="systemitem">B</code> die vierte Anforderung
            von <code class="systemitem">A</code>, wechselt in den Zustand
            <acronym class="acronym">ACK-SENT</acronym> und sendet eine weitere
            (zweite) Anforderung und (vierte) Bestätigung
            entsprechend dem RFC.  <code class="systemitem">A</code> erhält die
            Anforderung, geht in den Zustand
            <acronym class="acronym">REQ-SENT</acronym> über, sendet eine weitere
            Anforderung, erhält unverzüglich die
            nächste Bestätigung und geht in
            <acronym class="acronym">OPENED</acronym> über.</p><p>Das geht so weiter, bis eine Seite erkennt, dass
            man zu keinem Ergebnis gelangt und aufgibt.</p><p>Am besten verhindert man solche Situationen, indem man
            eine Seite als <code class="literal">passiv</code> konfiguriert,
            also dafür sorgt, dass eine Seite darauf
            wartet, dass die andere mit den Verhandlungen beginnt.  Das
            kann durch den folgenden Befehl geschehen:</p><pre class="programlisting">set openmode passive</pre><p>Diese Option sollten Sie mit Vorsicht genießen.
            Folgenden Befehl sollten Sie benutzen, um
            die Wartezeit auf den Beginn der Verhandlungen des
            Partners von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> zu begrenzen:</p><pre class="programlisting">set stopped <em class="replaceable"><code>N</code></em></pre><p>Alternativ kann der folgende Befehl (wobei
            <em class="replaceable"><code>N</code></em> die Wartezeit in Sekunden vor Beginn
            der Verhandlungen angibt) benutzt werden:</p><pre class="programlisting">set openmode active <em class="replaceable"><code>N</code></em></pre><p>Weitere Details finden Sie in den Manualpages.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69651792"></a><a id="ppp-shell-test-lockup"></a><p><strong>14.14.</strong></p></td><td align="left" valign="top"><p>Warum reagiert <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> nicht mehr, wenn ich es mit
            shell verlassen habe?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Wenn Sie den Befehl <code class="command">shell</code> oder
            <code class="command">!</code> benutzen, führt <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> eine
            Shell aus (falls Sie Argumente übergeben haben,
            führt <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> diese Argumente aus).  Das Programm
            <span class="application">ppp</span> wartet auf die Beendigung des
            Befehls, bevor es seine Arbeit fortsetzt.  Falls Sie versuchen,
            die PPP-Verbindung während der Programmausführung zu
            benutzen, wird es so aussehen, als wäre die Verbindung
            eingefroren.  Das liegt daran, dass <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> auf die
            Beendigung des Befehls wartet.</p><p>Falls Sie solche Befehle verwenden möchten,
            benutzen Sie stattdessen den Befehl
            <code class="command">!bg</code>.  Hierdurch wird der angegebene
            Befehl im Hintergrund ausgeführt und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> kann
            fortfahren, die Verbindung zu bedienen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69659728"></a><a id="ppp-null-modem"></a><p><strong>14.15.</strong></p></td><td align="left" valign="top"><p>Warum wird <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> niemals beendet, wenn ich es
            über ein Nullmodem-Kabel benutze?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Es gibt keine Möglichkeit für <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>,
            automatisch festzustellen, ob eine direkte Verbindung
            beendet worden ist.  Das liegt an den Leitungen, die bei
            einem seriellen Nullmodem-Kabel benutzt werden.  Wenn Sie
            diese Art der Verbindung verwenden, sollte LQR immer mit der
            folgenden Zeile aktiviert werden:</p><pre class="programlisting">enable lqr</pre><p>LQR wird standardmäßig akzeptiert, wenn es
            vom Partner ausgehandelt wird.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69664080"></a><a id="ppp-auto-noreasondial"></a><p><strong>14.16.</strong></p></td><td align="left" valign="top"><p>Warum wählt <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> im Modus <code class="option">-auto</code>
            ohne Grund?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Falls <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> unerwarteterweise wählt,
            müssen Sie den Grund herausfinden und Wählfilter
            (dfilters) einsetzen, um dies zu verhindern.</p><p>Benutzen Sie die folgende Zeile, um den Grund
            herauszufinden:</p><pre class="programlisting">set log +tcp/ip</pre><p>Dadurch wird jeglicher Verkehr über die
            Verbindung geloggt.  Wenn das nächste mal unerwartet
            eine Verbindung hergestellt wird, werden Sie den Grund
            zusammen mit einer hilfreichen Zeitangabe in der Logdatei
            finden.</p><p>Sie können nun das Wählen aufgrund dieser
            Bedingungen verhindern.  Normalerweise wird diese Art von
            Problemen durch Anfragen an den DNS verursacht.  Um zu
            verhindern, dass DNS-Anfragen den Aufbau der
            Verbindung hervorrufen (das verhindert
            <span class="emphasis"><em>nicht</em></span>, dass Pakete über
            eine bestehende Verbindung gesendet werden), benutzen Sie
            die folgenden Zeilen:</p><pre class="programlisting">
set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0
          </pre><p>Dies ist nicht immer brauchbar, weil es effektiv Ihre
            Fähigkeit, auf Anforderung wählen zu können
            einschränkt - die meisten Programme müssen eine
            DNS-Anfrage durchführen, bevor Sie andere, das
            Netzwerk betreffenden Dinge tun können.</p><p>Im Fall von DNS sollten Sie versuchen, herauszufinden,
            welches Programm tatsächlich versucht, einen
            Hostnamen aufzulösen.  Sehr oft handelt es sich hier
            um <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendmail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sendmail</span>(8)</span></a>.  Sie sollten
            sicherstellen, dass Sie <span class="application">sendmail</span>
            in der Konfigurationsdatei sagen, dass keine DNS-Anfragen
            durchführen soll.  Weitere Details enthält
            der Abschnitt <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/smtp-dialup.html" target="_top">E-Mail
            über Einwahl-Verbindungen</a> des Handbuchs.
            Sie könnten z.B. die folgende Zeile in
            Ihre <code class="filename">.mc</code>-Datei einfügen:</p><pre class="programlisting">define(`confDELIVERY_MODE', `d')dnl</pre><p>Das veranlasst <span class="application">sendmail</span> dazu, alles
            in eine Warteschlange einzureihen, bis die Warteschlange
            verarbeitet wird (normalerweise wird sendmail mit
            <code class="option">-bd -q30m</code> aufgerufen, was besagt,
            dass die Warteschlange alle 30 Minuten abgearbeitet
            wird) oder, bis ein <code class="command">sendmail -q</code>
            ausgeführt wird (z.B. aus Ihrer Datei
            <code class="filename">ppp.linkup</code> heraus).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69684048"></a><a id="ccp-errors"></a><p><strong>14.17.</strong></p></td><td align="left" valign="top"><p>Was bedeuten diese CCP-Fehler?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ich sehe ständig folgende Fehler in meiner
            Logdatei:</p><pre class="programlisting">
CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)
          </pre><p>Das liegt daran, dass <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> versucht, die
            Komprimierung Predictor1 auszuhandeln und der Partner
            über keinerlei Komprimierung verhandeln will.  Die
            Meldungen sind harmlos, aber wenn Sie sie beseitigen
            möchten, können Sie die Komprimierung Predictor1
            auch lokal ausschalten:</p><pre class="programlisting">disable pred1</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69688016"></a><a id="ppp-connectionspeed"></a><p><strong>14.18.</strong></p></td><td align="left" valign="top"><p>Warum loggt ppp die Geschwindigkeit meiner Verbindung
            nicht?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Um alle Zeilen Ihrer <span class="quote">&#8222;<span class="quote">Modemkonversation</span>&#8220;</span>
            mitzuloggen, müssen Sie folgendes einstellen:</p><pre class="programlisting">set log +connect</pre><p>Dies veranlasst <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> dazu, alles bis zur
            letzten angeforderten <span class="quote">&#8222;<span class="quote">expect</span>&#8220;</span>-Zeile
            mitzuloggen.</p><p>Falls Sie die Geschwindigkeit Ihrer Verbindung
            erfahren möchten und PAP oder CHAP (und deshalb nach
            dem CONNECT im Wählskript nichts mehr zu
            <span class="quote">&#8222;<span class="quote">chatten</span>&#8220;</span> haben - kein <code class="literal">set
            login</code>-Skript), müssen Sie sicherstellen,
            dass Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> anweisen, die gesamte
            CONNECT-Zeile zu <span class="quote">&#8222;<span class="quote">erwarten</span>&#8220;</span>, etwa so:</p><pre class="programlisting">set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</pre><p>Hier bekommen wir unser CONNECT, senden nichts,
            erwarten dann einen Line-Feed, der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> zwingt, die
            gesamte CONNECT-Antwort zu lesen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69696592"></a><a id="ppp-ignores-backslash"></a><p><strong>14.19.</strong></p></td><td align="left" valign="top"><p>Warum ignoriert <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> das Zeichen
            <code class="literal">\</code> in meinem Chat-Skript?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das Programm <span class="application">ppp</span> analysiert jede
            Zeile in Ihrer Konfigurationsdatei, damit es Zeichenketten wie z.B.
            <code class="literal">set phone "123 456 789"</code> korrekt
            interpretieren kann (und erkennen, dass es sich bei
            der Nummer tatsächlich nur um
            <span class="emphasis"><em>ein</em></span> Argument handelt).  Um das
            Zeichen <code class="literal">"</code> anzugeben, müssen
            Sie ihm einen Backslash (<code class="literal">\</code>)
            voranstellen.</p><p>Wenn der Chat-Interpreter jedes Argument analysiert,
            reinterpretiert er die Argumente, um irgendwelche
            speziellen Escape-Sequenzen wie z.B. <code class="literal">\P</code>
            oder <code class="literal">\T</code> (sehen Sie in die Manualpage)
            zu finden.  Das Ergebnis dieser Doppelanalyse ist,
            dass Sie daran denken müssen, die richtige
            Anzahl an Escape-Zeichen zu verwenden.</p><p>Falls Sie tatsächlich das Zeichen
            <code class="literal">\</code> z.B. zu Ihrem Modem senden
            möchten, brauchen Sie etwas ähnliches,
            wie:</p><pre class="programlisting">set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</pre><p>Woraus sich folgende Zeichen ergeben:</p><pre class="programlisting">
ATZ
OK
AT\X
OK
          </pre><p>Oder:</p><pre class="programlisting">
set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"
          </pre><p>Was folgende Zeichen ergibt:</p><pre class="programlisting">
ATZ
OK
ATDT1234567
          </pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69714896"></a><a id="ppp-segfault-nocore"></a><p><strong>14.20.</strong></p></td><td align="left" valign="top"><p>Warum gibt es die Datei <code class="filename">ppp.core</code>
            nicht, wenn <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> einen <span class="errorname">Segmentation
            fault</span> erzeugt hat?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Weder <span class="application">ppp</span> noch andere Programme
            sollten Core-Dumps erzeugen.  Da <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> mit der effektiven
            Benutzerkennung <code class="literal">0</code> ausgeführt wird, wird das
            Betriebssystem das Coreimage von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> nicht auf die
            Festplatte schreiben, bevor es <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>  beendet hat.
            Falls <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> jedoch tatsächlich aufgrund einer
            Speicherverletzung abbricht <span class="emphasis"><em>und</em></span> Sie
            die aktuellste Version (siehe Anfang dieses Kapitels)
            benutzen, dann sollten Sie die Systemquellen installieren und
            folgendes tun:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cd /usr/src/usr.sbin/ppp</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>echo STRIP= &gt;&gt; /etc/make.conf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>echo CFLAGS+=-g &gt;&gt; /etc/make.conf</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>make install clean</code></strong></pre><p>Nun ist die installierte Version von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> mit
            einem Debugger ausführbar.  Sie können
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> nun nur noch als <code class="systemitem">root</code>
            ausführen, da alle vorherigen Zugriffsrechte
            aufgehoben worden sind.  Achten Sie darauf, in welchem
            Verzeichnis Sie sich gerade befinden, wenn Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            starten.</p><p>Wenn nun wieder eine Speicherverletzung auftreten
            sollte, wird <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> einen Speicherauszug erzeugen,
            den Sie in der Datei <code class="filename">ppp.core</code> finden.
            Sie sollten dann folgendes tun:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>gdb /usr/sbin/ppp ppp.core</code></strong>
<code class="prompt">(gdb)</code> <strong class="userinput"><code>bt</code></strong>
.....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>f 0</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>i args</code></strong>
....
<code class="prompt">(gdb)</code> <strong class="userinput"><code>l</code></strong>
.....</pre><p>Mit Hilfe all dieser Informationen sollte es
            möglich sein, das Problem zu diagnostizieren.</p><p>Falls Sie mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> vertraut sind,
            könnten Sie weitere Einzelheiten herausfinden, z.B.
            wodurch der Fehler tatsächlich hervorgerufen wurde
            oder die Adressen und Werte der betreffenden Variablen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69741392"></a><a id="ppp-autodialprocess-noconnect"></a><p><strong>14.21.</strong></p></td><td align="left" valign="top"><p>Warum bekommt das Programm, das eine Anwahl im Modus
          <code class="option">-auto</code> ausgelöst hat, keine Verbindung?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dies war ein bekanntes Problem bei
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>-Konfigurationen, bei denen im Modus
            <code class="option">-auto</code> dynamische, lokale IP-Adressen mit dem
            Partner ausgehandelt werden.  Das Problem ist bereits seit einiger
            Zeit behoben - suchen Sie in den Manualpages nach
            <code class="literal">iface</code>.</p><p>Das Problem bestand darin, dass, wenn das erste
            Programm <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=connect&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a> aufruft, die IP-Adresse der
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tun&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">tun</span>(4)</span></a>-Schnittstelle dem Socketendpunkt zugeordnet wird.  Der
            Kernel erstellt das erste ausgehende Paket und schreibt es
            in das <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tun&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">tun</span>(4)</span></a>-Gerät.  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>  liest dann das Paket
            und baut eine Verbindung auf.  Falls die
            Schnittstellenadresse sich nun aufgrund <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>s
            dynamischer Adresszuordnung ändert, wird der
            originale Socketendpunkt ungültig.  Alle weiteren
            Pakete, die zum Partner gesendet werden, werden für
            gewöhnlich verworfen.  Selbst wenn sie nicht
            verworfen werden würden, würden alle Antworten
            nicht an den betreffenden Rechner gelangen, weil die
            IP-Adresse nicht mehr zu diesem Rechner
            gehört.</p><p>Theoretisch gibt es mehrere Möglichkeiten, dieses
            Problem anzugehen.  Am schönsten wäre es, wenn
            der Partner die gleiche IP-Adresse wieder zuordnen
            würde, wenn möglich. Die derzeitige Version von
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> tut das, aber die meisten anderen Implementierungen
            nicht.</p><p>Die einfachste Maßnahme von unserer Seite
            wäre die, niemals die IP-Adresse der
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tun&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">tun</span>(4)</span></a>-Schnittstelle zu ändern, sondern stattdessen alle
            ausgehenden Pakete so zu ändern, dass als
            Absender-IP-Adresse anstelle der IP-Adresse der
            Schnittstelle die ausgehandelte IP-Adresse gesetzt wird.
            Das ist im wesentlichen das, was durch die Option
            <code class="literal">iface-alias</code> in der aktuellsten Version
            von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> bewirkt wird (mit Unterstützung von
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a> und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>'s <code class="option">-nat</code>
            Schalter) - alle Schnittstellenadressen werden beibehalten
            und auf die letzte ausgehandelte Adresse
            umgesetzt.</p><p>Eine andere Alternative (und wahrscheinlich die
            zuverlässigste) wäre die, einen Systemaufruf zu
            implementieren der die IP-Adressen aller verbundenen
            Sockets von einer Adresse in eine andere ändert.
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> würde diesen Aufruf benutzen, um die
            Sockets aller laufenden Programme zu ändern, nachdem
            eine neue IP-Adresse ausgehandelt worden ist.  Der gleiche
            Systemaufruf könnte von <acronym class="acronym">DHCP</acronym>-Clients
            benutzt werden, wenn sie gezwungen werden, die
            <code class="function">bind()</code>-Funktion auf ihren Sockets
            auszuführen.</p><p>Noch eine andere Möglichkeit wäre die, das
            Aktivieren von Schnittstellen ohne IP-Adresse zu erlauben.
            Ausgehende Paketen würde die IP-Adresse
            <code class="systemitem">255.255.255.255</code> gegeben, bis der
            erste <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ioctl&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> mit <code class="literal">SIOCAIFADDR</code> erfolgt.
            Dies würde in der vollständigen Verbindung des Sockets
            resultieren.  Es wäre die Aufgabe von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>, die
            Absender-IP-Adresse zu ändern, allerdings nur dann,
            wenn sie <code class="systemitem">255.255.255.255</code> lautet und
            nur die IP-Adresse und IP-Prüfsumme müssten geändert
            werden.  Dies wäre allerdings keine besonders elegante
            Lösung, da der Kernel fehlerhafte Pakete an eine
            unzureichend konfigurierte Schnittstelle senden würde, in der
            Annahme, dass andere Mechanismen in der Lage sind, diese Dinge
            rückwirkend zu beheben.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69789264"></a><a id="ppp-nat-games"></a><p><strong>14.22.</strong></p></td><td align="left" valign="top"><p>Warum laufen die meisten Spiele mit dem <code class="option">-nat</code>
	    Schalter nicht?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Der Grund dafür, dass Spiele und andere
            Programme nicht funktionieren, wenn <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a> benutzt wird,
            ist der, dass der Rechner außerhalb des lokalen
            Netzes versucht, eine Verbindung aufzubauen und
            (unaufgefordert) UDP-Pakete an den Rechner innerhalb des
            lokalen Netzes zu senden.  Die Software, die für die
            NAT zuständig ist, weiß nicht, dass sie
            diese Pakete an den internen Rechner weiterleiten
            soll.</p><p>Um dies zu beheben, stellen Sie zunächst sicher,
            dass die Software, mit der Sie Probleme haben, die
            einzige ist, die gerade läuft.  Benutzen Sie dann
            entweder <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a> auf der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tun&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">tun</span>(4)</span></a>-Schnittstelle des
            Gateways oder aktivieren Sie auf dem Gateway das Logging von TCP/IP
            (<code class="literal">set log +tcp/ip</code>) unter
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>.</p><p>Wenn Sie nun das betreffende Programm starten, sollten
            Sie sehen, wie Pakete den Gateway-Rechner passieren.  Wenn
            von außen etwas zurückkommt, wird es ignoriert
            (das ist das Problem).  Merken Sie sich die Portnummer
            dieser Pakete und beenden Sie das betreffende Programm.
            Wiederholen Sie diesen Schritt einige Male, um
            festzustellen, ob die Portnummern konsistent sind.  Falls
            dem so ist, wird die folgende Zeile im entsprechenden
            Abschnitt von <code class="filename">/etc/ppp/ppp.conf</code>
            dafür sorgen, dass das Programm
            funktioniert:</p><pre class="programlisting">nat port <em class="replaceable"><code>proto</code></em> <em class="replaceable"><code>internalmachine</code></em>:<em class="replaceable"><code>port</code></em> <em class="replaceable"><code>port</code></em></pre><p>wobei für <em class="replaceable"><code>proto</code></em>
            entweder <code class="literal">tcp</code> oder
            <code class="literal">udp</code> zu setzen ist,
            <em class="replaceable"><code>internalmachine</code></em> den Rechner
            bezeichnet, an den die Pakete geschickt werden sollen und
            <em class="replaceable"><code>port</code></em> die betreffende
            Portnummer.</p><p>Sie können das Programm nicht auf einem anderen
            Rechner benutzen, ohne die obige Zeile abzuändern und
            die Benutzung des Programms auf zwei internen Rechnern
            steht außer Frage - schließlich sieht die
            Außenwelt Ihr gesamtes internes Netz so, als
            wäre es ein einzelner Rechner.</p><p>Falls die Portnummern nicht konsistent sind, gibt es
            drei weitere Optionen:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ermöglichen Sie die Unterstützung durch
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=libalias&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">libalias</span>(3)</span></a>.  Beispiele für <span class="quote">&#8222;<span class="quote">spezielle
                Fälle</span>&#8220;</span> finden Sie in
                <code class="filename">/usr/src/sys/netinet/libalias/alias_*.c</code>
                (<code class="filename">alias_ftp.c</code> ist ein schöner
                Prototyp).  Hierzu gehört für
                gewöhnlich das Lesen bestimmter, erkannter,
                ausgehender Pakete, die Identifizierung der
                Instruktion, die den entfernten Rechner dazu
                veranlasst, auf einem bestimmten (wahlfreien)
                Port eine Verbindung zurück zum lokalen Rechner
                herzustellen, sowie das Erstellen einer
                <span class="quote">&#8222;<span class="quote">Route</span>&#8220;</span> in der Aliastabelle, so dass
                nachfolgende Pakete wissen, wohin sie
                gehören.</p><p>Dieses ist zwar die komplizierteste Lösung,
                aber die beste, die auch dafür sorgt, dass
                die Software auf mehreren Rechnern
                funktioniert.</p></li><li class="listitem"><p>Benutzen Sie einen Proxy.  Die Anwendung
                könnte z.B. <code class="literal">socks5</code> unterstützen,
                oder (wie im Fall von <code class="command">cvsup</code>) eine Option
                <span class="quote">&#8222;<span class="quote">passiv</span>&#8220;</span> besitzen, die stets verhindert,
                dass verlangt wird, dass der Partner eine
                Verbindung zurück zur lokalen Maschine
                aufbaut.</p></li><li class="listitem"><p>Leiten Sie mit <code class="literal">nat addr</code> alles
                zur lokalen Maschine um.  Dieses Vorgehen ähnelt
                dem mit einem Vorschlaghammer.</p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69812688"></a><a id="useful-port-numbers"></a><p><strong>14.23.</strong></p></td><td align="left" valign="top"><p>Hat jemand eine Liste mit nützlichen Portnummern
            erstellt?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Noch nicht, aber hieraus könnte eine solche
            entstehen (falls Interesse besteht).  In jedem Beispiel
            sollte <em class="replaceable"><code>internal</code></em> durch die
            IP-Adresse der Maschine ersetzt werden, auf der das Spiel
            laufen soll.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="application">Asheron's Call</span></p><p><code class="literal">nat port udp
                internal:65000
                65000</code></p><p>Konfigurieren Sie das Spiel manuell auf Port
                <code class="literal">65000</code> um.  Wenn Sie von mehreren Rechner aus
                spielen wollen, weisen Sie jedem eine eindeutige Portnummer zu
                (also <code class="literal">65001</code>, <code class="literal">65002</code>,
                u.s.w.) und fügen Sie für jede
                Maschine eine eigene <code class="literal">nat port</code> Zeile
                ein.</p></li><li class="listitem"><p><span class="application">Half Life</span></p><p><code class="literal">nat port udp
                internal:27005
                27015</code></p></li><li class="listitem"><p><span class="application">PCAnywhere 8.0</span></p><p><code class="literal">nat port udp
                internal:5632
                5632</code></p><p><code class="literal">nat port tcp
                internal:5631
                5631</code></p></li><li class="listitem"><p><span class="application">Quake</span></p><p><code class="literal">nat port udp
                internal:6112
                6112</code></p></li><li class="listitem"><p><span class="application">Quake 2</span></p><p><code class="literal">nat port udp
                internal:27901
                27910</code></p><p><code class="literal">nat port udp
                internal:60021
                60021</code></p><p><code class="literal">nat port udp
                internal:60040
                60040</code></p></li><li class="listitem"><p><span class="application">Red Alert</span></p><p><code class="literal">nat port udp
                internal:8675
                8675</code></p><p><code class="literal">nat port udp
                internal:5009
                5009</code></p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69836368"></a><a id="fcs-errors"></a><p><strong>14.24.</strong></p></td><td align="left" valign="top"><p>Was sind FCS-Fehler?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FCS steht für <code class="literal">F</code>rame
            <code class="literal">C</code>heck <code class="literal">S</code>equence.
            Jedes PPP-Paket besitzt eine Checksumme, um
            sicherzustellen, dass die empfangenen Daten dieselben
            sind, wie die versendeten.  Falls die FCS eines
            ankommenden Paketes fehlerhaft ist, wird das Paket
            verworfen und der Zähler HDLC FCS wird erhöht.
            Der HDLC-Fehlerwert kann durch den Befehl <code class="literal">show
            hdlc</code> angezeigt werden.</p><p>Falls Ihre Leitung schlecht ist (oder falls Ihr
            serieller Treiber Pakete verwirft), werden sie
            gelegentliche FCS-Fehler sehen.  Normalerweise lohnt es
            sich nicht, sich hierüber Gedanken zu machen, obwohl
            das Kompressionsprotokoll hierdurch wesentlich langsamer
            wird.  Wenn Sie ein externes Modem besitzen, stellen Sie
            sicher, dass Ihr Kabel ausreichend gegen
            Interferenzen abgeschirmt ist - das könnte das
            Problem beseitigen.</p><p>Falls Ihre Leitung einfriert, sobald die Verbindung
            steht, und viele FCS-Fehler auftreten, könnte das
            daran liegen, dass Ihre Leitung nicht 8-Bit-rein ist.
            Stellen Sie sicher, dass Ihr Modem keinen
            Software-Flow-Control (XON/XOFF) verwendet.  Falls Ihre
            Datenschnittstelle Software-Flow-Control verwenden
            <span class="emphasis"><em>muss</em></span>, benutzen Sie den Befehl
            <code class="literal">set accmap 0x000a0000</code>, um <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a>
            zu sagen, dass es die Zeichen <code class="literal">^Q</code>
            und <code class="literal">^S</code> maskieren soll.</p><p>Ein weiterer Grund dafür, dass zu viele
            FCS-Fehler auftreten, könnte der sein, dass das
            andere Ende aufgehört hat, <acronym class="acronym">ppp</acronym> zu
            sprechen.  Aktivieren Sie <code class="literal">async</code>
            Logging, um festzustellen, ob es sich bei den eingehenden
            Daten tatsächlich um einen login- oder Shell-Prompt
            handelt.  Wenn Sie am anderen Ende einen Shell-Prompt
            haben, ist es möglich, durch den Befehl
            <code class="command">close lcp</code> <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> zu beenden, ohne
            die Verbindung zu beenden (ein folgender
            <code class="command">term</code>-Befehl wird Sie wieder mit der
            Shell auf dem entfernten Rechner verbinden.</p><p>Falls nichts in Ihrer Logdatei darauf hindeutet, warum
            die Verbindung beendet wurde, sollten Sie den
            Administrator des externen Rechners (Ihren ISP?) fragen,
            warum die Sitzung beendet worden ist.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="PPPoEwithNAT"></a><a id="macos-win98-pppoe-freeze"></a><p><strong>14.25.</strong></p></td><td align="left" valign="top"><p>Wieso hängen die Verbindungen meiner <span class="trademark">Mac OS</span>®- und
            <span class="trademark">Windows</span>® 98-Maschinen (und eventuell auch andere
            <span class="trademark">Microsoft</span>® Betriebssysteme), wenn auf meinem Gateway
            PPPoE läuft?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Vielen Dank an Michael Wozniak
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:mwozniak@netcom.ca">mwozniak@netcom.ca</a>&gt;</code> für die
            Erklärung und an Dan Flemming
            <code class="email">&lt;<a xmlns="" class="email" href="mailto:danflemming@mac.com">danflemming@mac.com</a>&gt;</code> für die
            Lösung für <span class="trademark">Mac OS</span>®.</p><p>Die Ursache des Problems ist ein so genannter
            <span class="quote">&#8222;<span class="quote">Black Hole Router</span>&#8220;</span>.  <span class="trademark">Mac OS</span>® und <span class="trademark">Windows</span>® 98
            (und wahrscheinlich auch die anderen Betriebssysteme von
            <span class="trademark">Microsoft</span>®) senden TCP Pakete, bei denen zum einen die
            angeforderte Segmentgröße zu groß
            für einen PPPoE-Rahmen ist (die Default-MTU für
            Ethernet beträgt <code class="literal">1500</code> Byte)
            <span class="emphasis"><em>und</em></span> bei denen das <span class="quote">&#8222;<span class="quote">don't
            fragment</span>&#8220;</span> Bit gesetzt
            ist (das ist bei TCP allerdings Standard).  Außerdem
            sendet der Router beim Provider nicht die eigentlich
            notwendigen <span class="quote">&#8222;<span class="quote">must fragment</span>&#8220;</span>-Meldungen zu dem
            Webserver, von dem Sie gerade eine Seite laden wollen.  Es
            ist auch möglich, dass diese Meldung zwar
            erzeugt, aber danach von einem Firewall vor dem Webserver
            abgefangen wird.  Wenn Ihnen dieser Webserver nun ein
            Paket schickt, das nicht in einen PPPoE-Rahmen passt,
            dann verwirft der Router dieses Paket und die Seite wird
            nicht geladen (einige Seiten/Grafiken werden geladen, weil
            ihre Größe kleiner ist als die MSS).  Dies
            scheint leider der Normalfall zu sein.</p><p>Eine der möglichen Lösungen für dieses
            Problem ist die Erzeugung des folgenden Schlüssels in
            der Registry des Windows-Clients mit
            <span class="application">regedit</span>:</p><pre class="programlisting">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</pre><p>Der Schlüssels sollte vom Typ String sein und den
            Wert <code class="literal">1436</code> haben, da einige ADSL-Router
            nicht mit größeren Paketen umgehen können.
            Wenn Sie <span class="trademark">Windows</span>® 2000 verwenden, müssen Sie
            hingegen den Schlüssel
            <code class="literal">Tcpip\Parameters\Interfaces\ID der
            Netzwerkkarte\MTU</code> benutzen,
            außerdem müssen Sie als Typ <code class="literal">DWORD</code>
            verwenden.</p><p>Die Knowledge Base von <span class="trademark">Microsoft</span>® enthält weitere
            Informationen darüber, wie sie die MTU einer
            <span class="trademark">Windows</span>®-Maschine ändern, damit diese mit einem
            NAT-Router korrekt zusammenarbeitet.  Vom besonderen
            Interesse sind die Artikel <a class="link" href="http://support.microsoft.com/support/kb/articles/Q158/4/74.asp" target="_top">Q158474
            - <span class="trademark">Windows</span>® TCPIP Registry Entries</a> und <a class="link" href="http://support.microsoft.com/support/kb/articles/Q120/6/42.asp" target="_top">Q120642
            - TCPIP &amp; NBT Configuration Parameters for
            <span class="trademark">Windows NT</span>®</a>.</p><p>Bei <span class="trademark">Windows</span>® 2000 können Sie alternativ auch, wie
            im Artikel 120642 beschrieben, mit regedit das
            <code class="literal">DWORD</code>
            <code class="literal">Tcpip\Parameters\Interfaces\ID der
            Netzwerkkarte\EnablePMTUBHDetect</code>
            auf <code class="literal">1</code> setzen.</p><p>Mit den Bordmitteln von <span class="trademark">Mac OS</span>® ist es leider nicht
            möglich, die TCP/IP-Einstellungen zu verändern.
            Es gibt jedoch kommerzielle Lösungen, mit denen man die
            TCP/IP-Einstellungen bearbeiten kann.  Wenn Sie als
            <span class="trademark">Mac OS</span>®-Anwender NAT benutzen, suchen Sie ihre MTU-Einstellungen
            und geben Sie dort <code class="literal">1450</code> statt
            <code class="literal">1500</code> ein.</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> kennt seit Version 2.3 den Befehl
            <code class="command">enable tcpmssfixup</code>, mit dem die MSS
            automatisch korrigiert wird.  Wenn Sie einen ältere
            Version von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> benutzen müssen, könnte
            der Port <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/net/tcpmssd/pkg-descr">net/tcpmssd</a> für
            Sie interessant sein.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp69876944"></a><a id="desperation"></a><p><strong>14.26.</strong></p></td><td align="left" valign="top"><p>Nichts von alledem hilft - ich bin
            verzweifelt!  Was soll ich machen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Falls alles andere fehlschlägt, senden Sie
            möglichst umfangreiche Informationen,
            einschließlich Ihrer Konfigurationsdateien, wie Sie
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> starten, die relevanten Teile Ihrer Logdateien
            und die Ausgabe des Befehls <code class="command">netstat -rn</code>
            (vor und nach Aufbau der Verbindung) an die
            Mailingliste 'Fragen und Antworten zu FreeBSD'
  <code class="email">&lt;<a xmlns="" class="email" href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;</code>  oder die Newsgroup <a class="link" href="news:de.comp.os.unix.bsd" target="_top">de.comp.os.unix.bsd</a>.
            Irgend jemand sollte Ihnen dann weiterhelfen.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security.html">Zurück</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="serial.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">Kapitel 13. Sicherheit </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> Kapitel 15. Serielle Verbindungen</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>