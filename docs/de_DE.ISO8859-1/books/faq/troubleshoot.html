<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Kapitel 5. Fehlerbehebung</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="up" href="index.html" title="Häufig gestellte Fragen zu FreeBSD 7.X, 8.X und 9.X" /><link rel="prev" href="compatibility-other.html" title="4.8. Sonstige Hardware" /><link rel="next" href="commercial.html" title="Kapitel 6. Kommerzielle Anwendungen" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Kapitel 5. Fehlerbehebung</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="compatibility-other.html">Zurück</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="commercial.html">Weiter</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="troubleshoot"></a>Kapitel 5. Fehlerbehebung</h1></div></div></div><div class="qandaset"><a id="idp67430992"></a><dl><dt>5.1. <a href="troubleshoot.html#idp67431248">Warum zeigt FreeBSD eine falsche Speichergröße auf
	    i386&#8482; Hardware an?</a></dt><dt>5.2. <a href="troubleshoot.html#idp67437008">Was sollte ich tun, wenn auf meiner Festplatte
            fehlerhafte Blöcke sind?</a></dt><dt>5.3. <a href="troubleshoot.html#idp67471184">Wieso wird der SCSI-Controller meines HP Netserver nicht
            erkannt?</a></dt><dt>5.4. <a href="troubleshoot.html#idp67479248">Was bedeuten die ständigen Meldungen
            ed1: timeout?</a></dt><dt>5.5. <a href="troubleshoot.html#idp67483728">Warum funktioniert meine 3Com® 3C509 plötzlich
            nicht mehr?</a></dt><dt>5.6. <a href="troubleshoot.html#idp67499088">Mein an der parallel Schnittstelle angeschlossener
            Drucker ist unglaublich langsam.  Was kann ich
            tun?</a></dt><dt>5.7. <a href="troubleshoot.html#idp67502416">Wieso brechen meine Programme gelegentlich mit
            Signal 11-Fehlern ab?</a></dt><dt>5.8. <a href="troubleshoot.html#idp67520080">Mein System stürzt mit der Meldung
            Fatal trap 12: page fault in kernel
            mode oder panic: ab und
            gibt eine Menge zusätzlicher Informationen aus.  Was
            kann ich tun?</a></dt><dt>5.9. <a href="troubleshoot.html#idp67527632">Wieso wird beim Booten der Bildschirm schwarz und reagiert
            nicht mehr?</a></dt><dt>5.10. <a href="troubleshoot.html#idp67539024">Wieso verwendet FreeBSD nur 64 MB Hauptspeicher,
            obwohl in meinem Rechner 128 MB sind?</a></dt><dt>5.11. <a href="troubleshoot.html#idp67543248">Ich habe mehr als 1 GB RAM.  Trotzdem stürzt
            mein System mit der Meldung
            kmem_map too small ab.  Was läuft hier
            schief?</a></dt><dt>5.12. <a href="troubleshoot.html#idp67547344">Ich habe weniger als 1 GB Hauptspeicher.  Dennoch
            stürzt mein System mit der Meldung
            kmem_map too small ab!</a></dt><dt>5.13. <a href="troubleshoot.html#idp67550288">Wieso erhalte ich die Meldung kernel:
            proc: table is full?</a></dt><dt>5.14. <a href="troubleshoot.html#idp67586000">Wieso erhalte ich die Meldung CMAP busy
            panic, wenn ich mein System mit einem neuen
            Kernel starte?</a></dt><dt>5.15. <a href="troubleshoot.html#idp67590096">Was soll mir die Meldung ahc0: brkadrint,
            Illegal Host Access at seqaddr 0x0
            sagen?</a></dt><dt>5.16. <a href="troubleshoot.html#idp67593424">Wenn ich mein System starte, erhalte ich die Meldung
            ahc0: illegal cable configuration,
            obwohl die Verkabelung korrekt ist.  Woran liegt
            das?</a></dt><dt>5.17. <a href="troubleshoot.html#idp67597008">Wieso meldet sendmail
            mail loops back to myself?</a></dt><dt>5.18. <a href="troubleshoot.html#idp67600336">Wieso funktionieren bildschirmorientierte Anwendungen beim
            Zugriff über ein Netzwerk nicht richtig?</a></dt><dt>5.19. <a href="troubleshoot.html#idp67632720">Warum wird meine PnP-Karte nicht (oder nur noch als
            unknown) erkannt?</a></dt><dt>5.20. <a href="troubleshoot.html#idp67672272">Warum erhalte ich die Meldung nlist
            failed, wenn ich Programme wie
            top oder systat
            benutze?</a></dt><dt>5.21. <a href="troubleshoot.html#idp67680592">Wieso dauert es so lange, bis eine Verbindung
            (ssh(1) oder telnet(1)) aufgebaut wird?</a></dt><dt>5.22. <a href="troubleshoot.html#idp67729232">Was bedeutet stray IRQ?</a></dt><dt>5.23. <a href="troubleshoot.html#idp67740880">Warum sehe ich in der Ausgabe von dmesg(8) häufig
            die Meldung file: table is full?</a></dt><dt>5.24. <a href="troubleshoot.html#idp67745232">Warum werden ständig Meldungen wie
  	    calcru: negative runtime oder
            calcru: runtime went backwards auf die
            Konsole geschrieben?</a></dt><dt>5.25. <a href="troubleshoot.html#idp67751376">Warum ist die Uhrzeit auf meinem Computer immer
            falsch?</a></dt><dt>5.26. <a href="troubleshoot.html#idp67767376">Warum erkennt mein Laptop PC-Cards nicht?</a></dt><dt>5.27. <a href="troubleshoot.html#idp67771344">Wieso hängt sich FreeBSD nach dem BIOS-Bildschirm
            mit der Meldung Read error
            auf?</a></dt><dt>5.28. <a href="troubleshoot.html#idp67778512">Ein anderes Betriebssystem hat meinen Bootmanager
            zerstört.  Wie kann ich ihn wiederherstellen?</a></dt><dt>5.29. <a href="troubleshoot.html#idp67819856">Was soll mir die Meldung swap_pager: indefinite
            wait buffer: sagen?</a></dt><dt>5.30. <a href="troubleshoot.html#idp67823056">Was sind UDMA ICRC Fehler und
	    wie behebe ich sie?</a></dt><dt>5.31. <a href="troubleshoot.html#idp67828944">Was ist ein lock order
            reversal?</a></dt><dt>5.32. <a href="troubleshoot.html#idp67831888">Warum erhalte ich die Meldung Called ... with
            the following non-sleepable locks held?</a></dt><dt>5.33. <a href="troubleshoot.html#idp67836880">Warum bricht
            buildworld/installworld
            mit der Meldung touch: not found ab?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp67431248"></a><a id="pae"></a><p><strong>5.1.</strong></p></td><td align="left" valign="top"><p>Warum zeigt FreeBSD eine falsche Speichergröße auf
	    <span class="trademark">i386</span>&#8482; Hardware an?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das liegt sehr wahrscheinlich an den Unterschieden zwischen
	    physikalischen und virtuellen Speicheraddressen.</p><p>Bei moderner PC-Hardware ist es üblich, den
	    Speicherbereich zwischen 3,5 und 4 Gigabyte für
	    spezielle Aufgaben (normalerweise für PCI) zu
	    reservieren.  Dieser Adressbereich wird dabei dazu
	    verwendet, um auf PCI-Hardware zuzugreifen.  Dadurch
	    kann in diesem Speicherbereich kein physikalischer
	    Speicher verwaltet werden.</p><p>Was mit dem in diesen Bereich gehörenden
	    physikalischen Speicher passiert, hängt von der von
	    Ihnen eingesetzten Hardware ab.  Unglücklicherweise
	    gibt es noch immer Hardware, die hier gar nichts macht.
	    In diesem Fall ist Ihr System nicht in der Lage, auf diese
	    500 Megabyte des RAMs zuzugreifen.</p><p>Ein Großteil der heute existierenden Hardware
	    ist aber inzwischen in der Lage, diesen Speicherbereich
	    in einen höheren Speicherbereich umzulenken, damit
	    Sie weiterhin darauf zugreifen können.  Allerdings
	    kann es durch dieses Umlenken zu verwirrende Meldungen
	    während des Systemstarts kommen.</p><p>Unter 32-Bit-Versionen von FreeBSD scheint dieser
	    Speicherbereich nicht verfügbar zu sein, da er in einen
	    Bereich oberhalb von 4 Gigabyte übertragen wurde, auf den
	    ein 32-Bit-Kernel allerdings nicht zugreifen kann.  Ist dies
	    bei Ihnen der Fall, müssen Sie die PAE-Unterstützung
	    in Ihren Kernel kompilieren.  Lesen Sie dazu auch die
	    entsprechenden <a class="link" href="install.html#memory-limits" title="3.23.">Einträge über
	    Speicherbegrenzungen</a> und <a class="link" href="compatibility-memory.html#memory-upper-limitation" title="4.2.1.">unterschiedliche
	    Speicherbegrenzungen auf verschiedenen Plattformen</a>.</p><p>Verwenden Sie hingegen eine 64-Bit-Version von FreeBSD
	    oder einen 32-Bit-Kernel mit aktivierter
	    PAE-Unterstützung, ist FreeBSD in der Lage, diesen
	    Speicherbereich korrekt zu erkennen und umzulenken, damit Sie
	    weiterhin darauf zugreifen können.   Allerdings wird, aufgrund
	    der beschriebenen Umbelegung, in diesem Fall beim Systemstart mehr
	    Speicher angezeigt, als tatsächlich auf Ihrem System vorhanden
	    ist.  Dies ist aber normal und wird nach dem Ende des Systemstarts
	    automatisch korrigiert.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67437008"></a><a id="awre"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>Was sollte ich tun, wenn auf meiner Festplatte
            fehlerhafte Blöcke sind?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>SCSI-Laufwerke sollten in der Lage sein, diese
            automatisch zu verlagern.  Bei einigen Laufwerken ist
            diese Eigenschaft jedoch aus unerfindlichen Gründen
            bei der Auslieferung ausgeschaltet...</p><p>Um sie einzuschalten, müssen Sie den Page-Mode
            des ersten Gerätes editieren.  Unter FreeBSD
            können Sie das (als <code class="systemitem">root</code>) mit
            folgendem Befehl tun</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>camcontrol modepage sd0 -m 1 -e -P 3</code></strong></pre><p>und die Werte für AWRE und ARRE von 0 auf 1
            ändern:</p><pre class="programlisting">
AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1
          </pre><p>Moderne IDE-Controller sind in der Lage, fehlerhafte
            Blöcke automatisch zu verlagern.  Diese Funktionen
            sind bereits ab Werk aktiviert.</p><p>Werden dennoch fehlerhafte Blöcke gemeldet (egal
            auf welchem Laufwerk), sollten Sie über den Kauf einer
            neuen Platte nachdenken.  Zwar könnte es Ihnen mit
            Diagnoseprogrammen des Plattenherstellers gelingen, diese
            fehlerhaften Blöcke zu sperren.  Allerdings können
            Sie damit den endgültigen Ausfall der Platte bestenfalls
            hinauszögern.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67471184"></a><a id="hpnetserver-scsi-failure"></a><p><strong>5.3.</strong></p></td><td align="left" valign="top"><p>Wieso wird der SCSI-Controller meines HP Netserver nicht
            erkannt?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Hierbei handelt es sich um ein bekanntes Problem.  Der
            auf dem Board befindliche EISA-SCSI-Controller auf dem HP
            Netserver belegt die EISA-Slotnummer 11, wodurch sich alle
            <span class="quote">&#8222;<span class="quote">wirklichen</span>&#8220;</span> EISA-Slots vor ihm befinden.
            Leider kollidiert der Adressraum von EISA-Slots
            &gt;=10 mit dem Adressraum, der PCI zugeordnet ist und
            die Autokonfiguration von FreeBSD kann mit dieser
            Situation derzeit nicht besonders gut umgehen.</p><p>Die einfachste Alternative ist, diese Kollision
            einfach zu leugnen.  Setzen Sie dazu die Kerneloption
            <code class="literal">EISA_SLOTS</code> auf den Wert 12.
            Konfigurieren und kompilieren Sie den Kernel, wie im <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/kernelconfig.html" target="_top">Handbucheintrag
            zur Kernelkonfiguration</a> beschrieben.</p><p>Dies bringt Ihnen natürlich das klassische
            Huhn-Ei-Problem, wenn Sie auf einer solchen Maschine
            installieren wollen.  Um dieses Problem zu umgehen,
            existiert ein spezieller Hack in
            <span class="emphasis"><em>UserConfig</em></span>.  Benutzen Sie nicht die
            <span class="quote">&#8222;<span class="quote">visuelle</span>&#8220;</span> Schnittstelle, sondern die rohe
            Kommandozeilenschnittstelle.  Geben Sie einfach den folgenden
            Befehl am Prompt ein und Sie können Ihr System ganz
            normal installieren:</p><pre class="programlisting">eisa 12
quit
          </pre><p>Sie sollten auf jeden Fall einen angepassten Kernel zu
            kompilieren und installieren.</p><p>Zukünftige Versionen werden hoffentlich eine
            passende Lösung für dieses Problem
            beinhalten.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Sie können keine <code class="literal">dangerously
              dedicated</code> Platte auf einem HP Netserver
              verwenden.  Lesen Sie weitere Informationen finden Sie
              in <a class="link" href="disks.html#dedicate">diesem
              Hinweis</a>.</p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67479248"></a><a id="ed1-timeout"></a><p><strong>5.4.</strong></p></td><td align="left" valign="top"><p>Was bedeuten die ständigen Meldungen
            <code class="literal">ed1: timeout</code>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dies wird meistens durch einen Interruptkonflikt
            verursacht (z.B., wenn zwei Karten den selben Interrupt
            benutzen).  Booten Sie mit der Option <code class="option">-c</code>
            und ändern Sie die Einträge zu
            <code class="filename">ed0</code>/<code class="filename">de0</code>/...
            (d.h. Ihrem Board entsprechend).</p><p>Wenn Sie den BNC-Anschluss Ihrer Netzwerkkarte
            benutzen, könnte es auch sein, dass es sich
            Geräte-Timeouts aufgrund fehlerhafter Terminierung
            handelt.  Um dies zu überprüfen, verbinden Sie
            einen Terminator direkt mit der Netzwerkkarte (ohne Kabel)
            und beobachten Sie, ob die Fehlermeldungen
            verschwinden.</p><p>Einige NE2000 kompatible Karten melden diesen Fehler,
            wenn keine Verbindung am UTP-Eingang existiert oder wenn
            das Kabel nicht eingesteckt ist.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67483728"></a><a id="bad-3c509"></a><p><strong>5.5.</strong></p></td><td align="left" valign="top"><p>Warum funktioniert meine <span class="trademark">3Com</span>® 3C509 plötzlich
            nicht mehr?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Diese Karte ist dafür berüchtigt, ihre
            Konfiguration zu vergessen.  Sie müssen die Karte mit
            dem DOS-Programm <code class="command">3c5x9.exe</code> neu
            konfigurieren.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67499088"></a><a id="printer-slow"></a><p><strong>5.6.</strong></p></td><td align="left" valign="top"><p>Mein an der parallel Schnittstelle angeschlossener
            Drucker ist unglaublich langsam.  Was kann ich
            tun?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Falls das einzige Problem ist, dass er
            schrecklich langsam ist, dann sollte Sie versuchen, die
            <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE" target="_top">
            Kommunikationseinstellungen der parallelen Schnittstellen</a>
            zu ändern, wie es im Kapitel <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/printing.html" target="_top">Drucken</a>
            des Handbuchs beschrieben ist.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67502416"></a><a id="signal11"></a><p><strong>5.7.</strong></p></td><td align="left" valign="top"><p>Wieso brechen meine Programme gelegentlich mit
            <span class="errorname">Signal 11</span>-Fehlern ab?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das Signal 11 wird generiert, wenn ein Prozess
            versucht, auf Speicher zuzugreifen, obwohl er vom
            Betriebssystem dazu nicht befugt wurde.  Wenn Ihnen das
            scheinbar zufällig immer wieder passiert, sollten Sie
            der Sache einmal auf der Grund gehen.</p><p>Das Problem hat in der Regel eine der folgenden
            Ursachen:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Wenn das Problem nur in einer bestimmten
                Anwendung auftritt, die Sie selbst entwickeln, dann
                ist es wahrscheinlich ein Fehler in Ihren
                Sourcen.</p></li><li class="listitem"><p>Wenn das Problem in einem Teil von FreeBSD
                auftritt, könnte es natürlich auch ein
                Fehler sein; aber in den meisten
                Fällen werden diese Probleme gefunden und behoben,
                bevor die typischen Leser der FAQ (wir) diese Teile
                der Sourcen benutzen können (dafür gibt es
                schließlich -CURRENT).</p></li></ol></div><p>Wenn der Fehler auftritt, wenn Sie ein Programm
            compilieren aber dabei immer wieder an anderer Stelle
            auftritt, dann ist das ein ganz eindeutiger Hinweis,
            dass das Problem <span class="emphasis"><em>nicht</em></span> bei
            FreeBSD liegt.</p><p>Nehmen wir zum Beispiel an, dass Sie <code class="command">make
            buildworld</code>
            ausführen und die Compilierung von
            <code class="filename">ls.c</code> in <code class="filename">ls.o</code>
            abbricht.  Wenn Sie nochmal <code class="command">make
            buildworld</code>
            durchführen und die Compilierung an der gleichen
            Stelle abbricht, handelt es sich um einen Fehler in den
            Sourcen.  Aktualisieren Sie Ihre Sourcen und versuchen Sie
            es noch einmal.  Wenn der Fehler jedoch an einer anderen
            Stelle auftritt, liegt das Problem mit an Sicherheit
            grenzender Wahrscheinlichkeit bei Ihrer Hardware.</p><p>Was Sie tun sollten:</p><p>Im ersten Fall können Sie einen Debugger wie z.B.
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=gdb&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">gdb</span>(1)</span></a> benutzen, um die Stelle im Programm zu finden,
            an der auf eine falsche Adresse zugegriffen wird und danach
            den Fehler beheben.</p><p>Im zweiten Fall müssen Sie sicherstellen,
            dass das Problem nicht von Ihrer Hardware verursacht
            wird.</p><p>Typische Ursachen dafür sind unter
            anderem:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Es könnte sein, dass Ihren Festplatten
                zu warm werden:  Überprüfen Sie, ob die
                Lüfter in Ihrem Gehäuse noch funktionieren,
                damit Ihre Festplatten (und andere Hardware) nicht
                heißlaufen.</p></li><li class="listitem"><p>Der Prozessor überhitzt, weil Sie Ihn
                übertaktet haben oder der CPU-Kühler
                ausgefallen ist.  Sie müssen sicherstellen,
                dass Sie Ihre Hardware unter den Bedingungen
                betreiben, für die sie spezifiziert ist,
                zumindest während Sie versuchen, das Problem
                zu lösen.  Mit anderen Worten:  Betreiben Sie
                Ihre CPU mit der normalen Taktfrequenz.</p><p>Wenn Sie übertakten, sollten Sie daran
                denken, dass ein langsames System deutlich
                billiger ist als ein defektes System.  Die große
                Masse hat nicht sehr häufig Mitgefühl mit
                Problemen bei übertakteten System, auch wenn Sie
                es für ungefährlich halten.</p></li><li class="listitem"><p>Unzuverlässiger Speicher: Wenn Sie mehr als
                ein SIMM/DIMM installiert haben, sollten Sie sie alle
                ausbauen und die Maschine testweise mit jedem SIMM
                oder DIMM einzeln betreiben.  So können Sie
                feststellen, ob die Ursache ein einzelnes SIMM/DIMM
                oder auch eine Kombination von Modulen ist.</p></li><li class="listitem"><p>Zu optimistische Einstellung des Mainboards: In
                Ihrem BIOS und mit den Jumpern auf dem Mainboard
                können Sie diverse Timings ändern.  In den
                meisten Fällen reichen die Defaults aus, aber
                manchmal kann es durch zu wenig wait states, die
                Einstellung <span class="quote">&#8222;<span class="quote">RAM Speed: Turbo</span>&#8220;</span> oder
                ähnliches zu merkwürdigen Problemen kommen.
                Ein möglicher Ansatz ist, die BIOS defaults zu
                laden, allerdings könnte es sinnvoll sein, die
                aktuellen Einstellungen vorher zu notieren.</p></li><li class="listitem"><p>Schlechte oder fehlerhafte Stromversorgung des
                Mainboards: Wenn Sie unbenutzte Steckkarten, Platten
                oder CD-ROMs in Ihrem System haben, sollten Sie sie
                testweise ausbauen oder die Stromversorgung abziehen.
                Dadurch können Sie prüfen, ob Ihr Netzteil
                eventuell mit einer geringeren Last besser
                zurechtkommt.  Sie können auch testweise ein
                anderes, am besten ein leistungsfähigeres,
                Netzteil ausprobieren.  Wenn Sie zurzeit ein
                250 W-Netzteil benutzen, sollten Sie testweise ein
                300 W-Netzteil einbauen.</p></li></ol></div><p>Die sollten ebenfalls die SIG11 FAQ (unten
            aufgeführt) lesen, da sie gute Erklärungen
            für alle diese Probleme enthält (allerdings aus
            <span class="trademark">Linux</span>®-Sicht).  Sie erklärt ebenfalls, warum sowohl
            Programme als auch Geräte zur Speicherprüfung
            fehlerhaften Speicher teilweise nicht erkennen.</p><p>Wenn alle diese Schritte nicht helfen, ist es
            möglich, dass Sie einen Fehler in FreeBSD
            gefunden haben.  Folgen Sie einfach den Anweisungen
            für die Erstellung eines Problem Reports.</p><p>Es existiert eine ausführliche FAQ hierzu unter
            <a class="link" href="http://www.bitwizard.nl/sig11/" target="_top">der
            SIG11-Problem-FAQ</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67520080"></a><a id="trap-12-panic"></a><p><strong>5.8.</strong></p></td><td align="left" valign="top"><p>Mein System stürzt mit der Meldung
            <span class="errorname">Fatal trap 12: page fault in kernel
            mode</span> oder <span class="errorname">panic:</span> ab und
            gibt eine Menge zusätzlicher Informationen aus.  Was
            kann ich tun?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die Entwickler von FreeBSD interessieren sich für
            solchen Meldungen, allerdings brauchen Sie deutlich mehr
            Informationen als die, die Ihnen angezeigt werden.
            Kopieren Sie die komplette Meldungen und lesen Sie nun den
            FAQ-Eintrag über <a class="link" href="advanced.html#kernel-panic-troubleshooting" title="18.13.">kernel panics</a>.
            Erzeugen sie einen Kernel mit den zusätzlichen Daten
            zur Fehlersuche, und dann einen backtrace.  Das hört
            sich komplizierter an, als es ist.  Sie brauchen keine
            Programmier-Erfahrung, Sie müssen einfach nur den
            Anweisungen folgen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67527632"></a><a id="screen-loses-sync"></a><p><strong>5.9.</strong></p></td><td align="left" valign="top"><p>Wieso wird beim Booten der Bildschirm schwarz und reagiert
            nicht mehr?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dies ist ein bekanntes Problem mit der ATI Mach64
            Videokarte.  Das Problem besteht darin, dass diese
            Karte die Adresse <code class="literal">2e8</code> benutzt und die
            vierte serielle Schnittstelle ebenfalls.  Aufgrund eines
            Fehlers (einer Besonderheit?) im <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>-Treiber wird
            diese Schnittstelle angesprochen, auch wenn Sie gar keine
            vierte serielle Schnittstelle besitzen und
            <span class="emphasis"><em>sogar</em></span>, wenn Sie
            <code class="filename">sio3</code> (die vierte Schnittstelle),
            die normalerweise diese Adresse verwendet, deaktivieren.</p><p>Bis der Fehler behoben ist, können Sie folgende
            Abhilfe verwenden:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Geben Sie am Bootprompt <code class="option">-c</code> ein.
                (Dies bringt den Kernel in den
                Konfigurationsmodus).</p></li><li class="listitem"><p>Deaktivieren Sie <code class="filename">sio0</code>,
                <code class="filename">sio1</code>,
                <code class="filename">sio2</code> und
                <code class="filename">sio3</code> (alle).  Auf diese Weise
                wird der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>-Treiber nicht aktiviert und das
                Problem tritt nicht mehr auf.</p></li><li class="listitem"><p>Geben Sie exit ein, um den Bootvorgang
                fortzusetzen.</p></li></ol></div><p>Falls sie in der Lage sein wollen Ihre seriellen
            Schnittstellen zu benutzen, müssen Sie einen neuen
            Kernel mit folgenden Modifikationen erstellen: suchen Sie
            in <code class="filename">/usr/src/sys/sio/sio.c</code> (oder in
            <code class="filename">/usr/src/sys/pc98/cbus/sio.c</code> für pc98)
            nach der Zeichenkette <code class="literal">0x2e8</code> und löschen
            Sie sie und das vorhergehende Komma (nicht das folgende
            Komma).  Nun folgen Sie der normalen Prozedur zur
            Erstellung eines neuen Kernels.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67539024"></a><a id="reallybigram"></a><p><strong>5.10.</strong></p></td><td align="left" valign="top"><p>Wieso verwendet FreeBSD nur 64 MB Hauptspeicher,
            obwohl in meinem Rechner 128 MB sind?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Aufgrund der Art und Weise, wie FreeBSD die
            Hauptspeichergröße vom BIOS mitgeteilt bekommt,
            kann es lediglich 16-Bit Werte in kByte-Größe
            (65535 kByte = 64 MB) erkennen (oder weniger... einige
            BIOSe setzen die Hauptspeichergröße auf 16 MB).
            Falls Sie mehr als 64 MB besitzen, wird FreeBSD versuchen,
            das zu erkennen, was aber nicht immer
            funktioniert.</p><p>Um dieses Problem zu umgehen, müssen Sie die
            untenstehende Kerneloption verwenden.  Es gibt einen Weg,
            vollständige Hauptspeicherinformationen vom BIOS zu
            erhalten, aber in den Bootblöcken ist nicht
            genügend Platz dafür vorhanden.  Wenn der
            Platzmangel in den Bootblöcken eins Tages behoben
            ist, werden wir die erweiterten BIOS-Funktionen dazu
            nutzen, die vollständigen Hauptspeicherinformationen
            zu erhalten... aber zurzeit sind wir auf die Kerneloption
            angewiesen.</p><pre class="programlisting">options MAXMEM=<em class="replaceable"><code>n</code></em></pre><p>Hierbei ist <code class="literal">n</code> Ihre
            Hauptspeichergröße in Kilobyte.  Bei einer
            128 MB-Maschine müßten Sie
            <code class="literal">131072</code> benutzen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67543248"></a><a id="kmem-map-too-small"></a><p><strong>5.11.</strong></p></td><td align="left" valign="top"><p>Ich habe mehr als 1 GB RAM.  Trotzdem stürzt
            mein System mit der Meldung
            <span class="errorname">kmem_map too small</span> ab.  Was läuft hier
            schief?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Im Normalfall bestimmt FreeBSD einige Kernelparameter,
            darunter die maximale Anzahl der Dateien, die gleichzeitig
            geöffnet sein können, aus der Größe
            des im System installierten Hauptspeichers.  Auf Systemen
            mit mindestens 1 GB Hauptspeicher kann dieser
            <span class="quote">&#8222;<span class="quote">auto sizing</span>&#8220;</span>-Mechanismus diese Werte
            fälschlicherweise zu hoch ansetzen:  Beim Systemstart
            fordert der Kernel dann verschiedene Tabellen und andere
            Strukturen an, die den Großteil des verfügbaren
            Kernelspeichers verbrauchen.  Dies führt dazu, dass
            der Kernel während des Betriebs keine dynamischen
            Speicheranforderungen mehr ausführen kann und mit
            einer Kernelpanik abstürzt.</p><p>Bauen Sie in diesem Fall Ihren eigenen Kernel.  Dazu
            setzen Sie <code class="option">VM_KMEM_SIZE_MAX</code>
            in Ihrer Kernelkonfigurationsdatei auf 400 MB
            (<code class="option">options VM_KMEM_SIZE_MAX=419430400</code>).
            400 MB sollten für Maschinen bis 6 GB
            Hauptspeicher ausreichend sein.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67547344"></a><a id="panic-kmemmap-too-small"></a><p><strong>5.12.</strong></p></td><td align="left" valign="top"><p>Ich habe weniger als 1 GB Hauptspeicher.  Dennoch
            stürzt mein System mit der Meldung
            <span class="errorname">kmem_map too small</span> ab!</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Diese Meldung zeigt an, dass der virtuelle
            Speicher für Netzwerkpuffer (spezieller mbuf-Cluster)
            aufgebraucht ist.  Sie können die für mbuf
            verfügbare Größe an VM erhöhen, indem
            Sie den Anweisungen des Abschnitts <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/configtuning-kernel-limits.html#NMBCLUSTERS" target="_top">
            Netzwerk-Limits</a> des Handbuchs folgen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67550288"></a><a id="proc-table-full"></a><p><strong>5.13.</strong></p></td><td align="left" valign="top"><p>Wieso erhalte ich die Meldung <span class="errorname">kernel:
            proc: table is full</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Der FreeBSD-Kernel beschränkt die Anzahl der
            gleichzeitig laufenden Prozesse.  Die Anzahl errechnet
            sich aus dem Wert der Variablen
            <code class="literal">MAXUSERS</code> in der Konfigurationsdatei des
            Kernels.  Auch andere Einstellungen wie die Anzahl der
            Puffer für Netzwerkoperationen (Details dazu
            finden Sie in <a class="link" href="troubleshoot.html#panic-kmemmap-too-small" title="5.12.">diesem
            Abschnitt</a>).  werden durch
            <code class="varname">MAXUSERS</code> beeinflusst.  Wenn Ihr
            System stark belastet ist, sollten Sie den Wert von
            <code class="varname">MAXUSERS</code> erhöhen.  Dadurch werden
            diverse Einstellung des Systems angepasst und die
            maximale Anzahl gleichzeitig laufender Prozesse
            erhöht.</p><p>Um den Wert von <code class="varname">MAXUSERS</code> anzupassen,
            folgen Sie den Anweisungen des Abschnitts <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/configtuning-kernel-limits.html#KERN-MAXFILES" target="_top">
            Datei- und Prozesslimits</a> des Handbuchs.  Dieser
            Abschnitt spricht zwar nur von Dateien, für Prozesse
            gelten aber die gleichen Beschränkungen.</p><p>Wenn Ihr System nicht besonders stark ausgelastet ist
            und Sie einfach nur mehr gleichzeitig laufende Prozesse
            erlauben wollen, können Sie den Wert der Variable
            <code class="varname">kern.maxproc</code> in der Datei
            <code class="filename">/boot/loader.conf</code> anpassen.  Um die
            Änderung zu aktivieren, müssen Sie Ihr System
            neu starten.  Wollen Sie Ihr System zusätzlich
            optimieren, sollten Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">loader.conf</span>(5)</span></a> und
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">sysctl.conf</span>(5)</span></a> lesen.
            Wenn diese Prozesse von einem einzigen Benutzer
            ausgeführt werden, müssen Sie den Wert von
            <code class="varname">kern.maxprocperuid</code> ebenfalls
            erhöhen.  Dieser Wert muss immer mindestens um
            eins geringer sein als der Wert von
            <code class="varname">kern.maxproc</code> (der Grund
            für diese Einschränkung ist, dass ein
            Systemprogramm, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>, immer ausgeführt werden
            muss).</p><p>Damit Änderungen einer sysctl-Variable dauerhaft
            erhalten bleiben, nehmen Sie diese in
            <code class="filename">/etc/sysctl.conf</code> auf.  Weitere
            Informationen zur Optimierung Ihres Systems finden Sie im
            Abschnitt <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/configtuning-sysctl.html" target="_top">
            Einstellungen mit sysctl</a> des Handbuchs.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67586000"></a><a id="cmap-busy-panic"></a><p><strong>5.14.</strong></p></td><td align="left" valign="top"><p>Wieso erhalte ich die Meldung <span class="errorname">CMAP busy
            panic</span>, wenn ich mein System mit einem neuen
            Kernel starte?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die Logik, die versucht, veraltete
            <code class="filename">/var/db/kvm_*.db</code>-Dateien zu erkennen,
            versagt manchmal und die Benutzung einer unpassenden Datei
            kann zu Paniksituationen führen.</p><p>Falls das passiert, rebooten Sie in den Single-User-Modus
            und löschen Sie die Dateien:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rm /var/db/kvm_*.db</code></strong></pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67590096"></a><a id="brkadrint-illegal-host-access"></a><p><strong>5.15.</strong></p></td><td align="left" valign="top"><p>Was soll mir die Meldung <span class="errorname">ahc0: brkadrint,
            Illegal Host Access at seqaddr 0x0</span>
            sagen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dies ist ein Konflikt mit einem Ultrastor SCSI
            Hostadapter.</p><p>Rufen Sie während des Bootprozesses das
            Kernelkonfigurationsmenü auf und deaktivieren Sie
            <code class="filename">uha0</code>, welches das Problem
            verursacht.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67593424"></a><a id="aci0-illegal-cable"></a><p><strong>5.16.</strong></p></td><td align="left" valign="top"><p>Wenn ich mein System starte, erhalte ich die Meldung
            <span class="errorname">ahc0: illegal cable configuration</span>,
            obwohl die Verkabelung korrekt ist.  Woran liegt
            das?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Auf Ihrem Mainboard fehlen ein paar Logikbausteine,
            die für die Unterstützung der automatischen
            Terminierung notwendig sind.  Stellen Sie in Ihrem
            SCSI-BIOS manuell die korrekte Terminierung für Ihr
            System ein, anstatt sich auf die automatische Terminierung
            zu verlassen.  Der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ahc&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ahc</span>(4)</span></a>-Treiber kann nicht
            erkennen, ob die externen Logikbausteine für die
            Erkennung der Kabel (und damit automatische Terminierung)
            vorhanden sind.  Der Treiber muss sich darauf
            verlassen, dass diese vorhanden sind, wenn in der
            Konfiguration <span class="quote">&#8222;<span class="quote">automatische Terminierung</span>&#8220;</span>
	    eingestellt ist.  Ohne die externen Bausteine ist es sehr
	    wahrscheinlich, dass  der Treiber die Terminierung
	    falsch einstellt, was die Zuverlässigkeit des
	    SCSI-Busses herabsetzen kann.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67597008"></a><a id="mail-loopback"></a><p><strong>5.17.</strong></p></td><td align="left" valign="top"><p>Wieso meldet <span class="application">sendmail</span>
            <span class="errorname">mail loops back to myself</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sie finden eine detaillierte Antwort auf diese Frage im
          <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/mail-trouble.html#Q29.6.2." target="_top">Handbuch</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67600336"></a><a id="remote-fullscreen"></a><p><strong>5.18.</strong></p></td><td align="left" valign="top"><p>Wieso funktionieren bildschirmorientierte Anwendungen beim
            Zugriff über ein Netzwerk nicht richtig?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die entfernte Maschine scheint den Terminaltyp auf
            etwas anderes als den Typ <code class="literal">cons25</code>, der
            von FreeBSD verlangt wird, zu setzen.</p><p>Es gibt mehrere mögliche Abhilfen für dieses
            Problem:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Setzen Sie die Shell-Variable <code class="envar">TERM</code>
                nach dem Einloggen auf der entfernten Maschine auf
                <code class="literal">ansi</code> oder <code class="literal">sco</code>,
                sofern die entfernte Maschine diese Terminaltypen
                kennt.</p></li><li class="listitem"><p>Benutzen Sie einen VT100-Emulator wie
                <span class="application">screen</span> auf der
                FreeBSD-Konsole.  <span class="application">screen</span>
                bietet Ihnen die Möglichkeit, mehrere
                gleichzeitige Sitzungen von einem Bildschirm aus
                laufen zu lassen.  Es ist ein sehr nettes Programm.
                Jedes <span class="application">screen</span>-Fenster
                verhält sich, wie ein VT100-Terminal, weshalb die
                Variable <code class="envar">TERM</code> am entfernten Ende auf
                <code class="literal">vt100</code> gesetzt werden
                sollte.</p></li><li class="listitem"><p>Installieren Sie den Eintrag
                <code class="literal">cons25</code> in der Bildschirmdatenbank
                der entfernten Maschine.  Wie das zu geschehen hat,
                hängt vom Betriebssystem der entfernten Maschine
                ab.  Das Systemadministrationshandbuch für das
                entfernte System sollte Ihnen hierbei helfen
                können.</p></li><li class="listitem"><p>Starten Sie einen X-Server auf der FreeBSD-Seite
                und benutzen Sie einen X-basierten Terminalemulator
                wie <code class="command">xterm</code> oder
                <code class="command">rxvt</code>, um sich auf der entfernten
                Maschine einzuloggen.  Die Variable <code class="envar">TERM</code>
                auf dem entfernten Host sollte auf <code class="literal">xterm</code>
                oder <code class="literal">vt100</code> gesetzt werden.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67632720"></a><a id="pnp-not-found"></a><p><strong>5.19.</strong></p></td><td align="left" valign="top"><p>Warum wird meine PnP-Karte nicht (oder nur noch als
            <code class="literal">unknown</code>) erkannt?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Die Gründe für dieses Verhalten werden in
            der unten zitierten Mail von Peter Wemm
            erklärt.  Diese Mail stammt von der Mailingliste
            <a class="link" href="http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions" target="_top">FreeBSD general
  questions</a> und war eine Antwort auf eine Frage
            bezüglich eines internen Modem, das nach dem Update
            auf FreeBSD 4.<em class="replaceable"><code>X</code></em> nicht mehr
            erkannt wurde.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Die mit <code class="literal">[]</code> gekennzeichneten Kommentare
	      wurden eingefügt, um an einigen Stellen die Bezüge
	      klarzustellen.</p></div><div class="blockquote"><blockquote class="blockquote"><p>Das PnP-BIOS hat es [das Modem] vorkonfiguriert und
              es dann im Adressraum liegenlassen, daher haben es
              die alten ISA-Erkennungsroutinen [in
               3.<em class="replaceable"><code>X</code></em>] <span class="quote">&#8222;<span class="quote">gefunden</span>&#8220;</span>.</p><p>In 4.0 sind die ISA-Routinen deutlich
              PnP-orientierter.  Es war möglich [in
              3.<em class="replaceable"><code>X</code></em>], dass eine ISA-Erkennungsroutine
              ein <span class="quote">&#8222;<span class="quote">zugelaufenes</span>&#8220;</span> Gerät fand;
              während die PnP-Treiber zwar die ID erkannten, das
              Gerät aber wegen des Ressourcekonfliktes nicht
              benutzen konnten.  Daher werden die programmierbaren
              Karten zunächst einmal abgeschaltet, um diese
              doppelte Erkennung vermeiden zu können.  Das
              bedeutet allerdings auch, dass die Treiber die
              PnP-ID kennen muss, um PnP-Hardware
              unterstützen zu können.  Wir haben uns
              vorgenommen, den Benutzern eine einfachere
              Möglichkeit zur Manipulation dieser Informationen
              zur Verfügung zu stellen.</p></blockquote></div><p>Damit Ihr Gerät wieder funktioniert, müssen
            Sie seine PnP-ID herausfinden und die ID in die Listen
            eintragen, die zur Erkennung von PnP-Geräten
            genutzten werden.  Zu diesem Zweck wird das Gerät mit
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> analysiert.  Das Beispiel zeigt die
            Ausgaben von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> für ein internes
            Modem:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pnpinfo</code></strong>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</pre><p>[weitere TAG Zeilen gestrichen]</p><pre class="screen">TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</pre><p>Sie benötigen die Information aus der Zeile
            <code class="literal">Vendor ID</code> ganz am Anfang.  Die in Klammern
            ausgegebene hexadezimale Zahl (<code class="literal">0x3024a341</code> in
            diesem Beispiel) ist die PnP ID und die unmittelbar davor
            stehende Zeichenkette (<code class="literal">PMC2430</code>) ist eine
            eindeutige Herstellerkennung.</p><p>Benutzen Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pciconf&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pciconf</span>(8)</span></a> wenn <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a> die Karte
	    nicht anzeigt.  Der Teil der Ausgabe von
	    <code class="command">pciconf -vl</code> für eine auf dem
	    Motherboard integrierte Soundkarte sieht zum Beispiel so
	    aus:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>pciconf -vl</code></strong>
chip1@pci0:31:5:        class=0x040100 card=0x00931028 chip=0x24158086 rev=0x02 hdr=0x00
    vendor   = 'Intel Corporation'
    device   = '82801AA 8xx Chipset AC'97 Audio Controller'
    class    = multimedia
    subclass = audio</pre><p>Sie benötigen die Chip-ID <code class="literal">0x24158086</code>,
	    die hinter <code class="varname">chip</code> aufgeführt ist.</p><p>Die <code class="literal">Vendor ID</code> oder
	    <code class="varname">chip</code>-ID müssen in die
            Datei <code class="filename">/usr/src/sys/dev/sio/sio_isa.c</code>
            eingetragen werden.</p><p>Sie sollten zunächst ein Backup von
            <code class="filename">sio_isa.c</code> anlegen, falls etwas schief
            gehen sollte.  Sie werden auch einen Patch erzeugen
            müssen, um ihn zusammen mit Ihrem PR einzusenden.
            (Sie wollten doch einen PR schreiben, oder etwa nicht?)
            Öffnen Sie nun <code class="filename">sio_isa.c</code> mit einem
            Editor und suchen Sie nach der Zeile:</p><pre class="programlisting">static struct isa_pnp_id sio_ids[] = {</pre><p>Blättern Sie dann nach unten, um die passende
            Stelle für Ihr Gerät zu finden.  Unten finden
            Sie Beispiel für die Einträge, diese sind nach
            der Herstellerkennung sortiert.  Diese sollte in dem
            Kommentar auf der rechten Seite aufgenommen werden, dazu
            kommt die Gerätebeschreibung (<span class="emphasis"><em>Device
            Description</em></span>) aus der Ausgabe von
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pnpinfo</span>(8)</span></a>:</p><pre class="programlisting">
{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */
         </pre><p>Fügen Sie die hexadezimale Gerätekennung an
            der richtigen Stelle ein, speichern Sie die Datei ab,
            erzeugen Sie einen neuen Kernel und starten Sie Ihr System
            neu.  Ihr Gerät sollte nun als
            <code class="filename">sio</code> Gerät erkannt werden.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67672272"></a><a id="nlist-failed"></a><p><strong>5.20.</strong></p></td><td align="left" valign="top"><p>Warum erhalte ich die Meldung <span class="errorname">nlist
            failed</span>, wenn ich Programme wie
            <code class="command">top</code> oder <code class="command">systat</code>
            benutze?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das Programm sucht nach einem speziellen Symbol im
            Kernel, kann es aber aus irgendeinem Grunde nicht finden.
            Dieser Fehler wird von einem dieser Probleme
            verursacht:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ihr Kernel und die sonstigen Programme (das
                <span class="quote">&#8222;<span class="quote">Userland</span>&#8220;</span>) sind nicht mehr auf dem
                gleichen Stand.  Mit anderen Worten, Sie haben zwar
                einen neuen Kernel erzeugt, aber kein
                <code class="buildtarget">installworld</code> (oder
                umgekehrt);  darum weicht die Symboltabelle von dem
                ab, was die Anwendung erwartet.  Wenn dies der Fall ist,
                müssen Sie lediglich die noch fehlenden Schritte
                des Upgrades durchführen.  Die richtige
                Vorgehensweise kann
                <code class="filename">/usr/src/UPDATING</code> entnommen
                werden.</p></li><li class="listitem"><p>Um Ihren Kernel zu laden, benutzen Sie nicht
                <code class="command">/boot/loader</code>, sondern laden ihn
                direkt mit <code class="filename">boot2</code> (siehe
                <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=boot&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">boot</span>(8)</span></a>).  Es ist zwar nicht immer ein Fehler,
                <code class="command">/boot/loader</code> zu umgehen; allerdings
                ist er in der Regel besser dazu geeignet, die Symbole des
                Kernels für normale Anwendungen verfügbar zu
                machen.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67680592"></a><a id="connection-delay"></a><p><strong>5.21.</strong></p></td><td align="left" valign="top"><p>Wieso dauert es so lange, bis eine Verbindung
            (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> oder <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=telnet&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">telnet</span>(1)</span></a>) aufgebaut wird?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Das Symptom: Nach dem Aufbau des TCP-Verbindung
            vergeht einige Zeit, bis endlich die Abfrage des
            Passwortes (bzw. der Login-Prompt bei Telnet)
            erscheint.</p><p>Das Problem: In den meisten Fällen versucht der
            Server in der Zwischenzeit, die IP-Adresse des Clients in
            einen Rechnernamen zu übersetzen.  Viele Server
            (darunter die <span class="application">Telnet</span>- und
            <span class="application">SSH</span>-Server von FreeBSD) machen
            das, um den Hostnamen z.B. für spätere
            Verwendung durch den Systemadministrator in eine
            Protokolldatei schreiben zu können.</p><p>Die Lösung: wenn das Problem bei jedem Server
            auftritt, den Sie von Ihrem Computer (dem Client)
            ansprechen, dann wird das Problem vom Client verursacht.
            Wenn das Problem aber nur auftritt, wenn jemand Ihren
            Rechner (den Server) anspricht, dann liegt die Ursache
            beim Server.</p><p>Wenn das Problem vom Client verursacht wird,
            müsssen Sie die Einträge im DNS korrigieren,
            damit der Server Ihre IP-Adresse übersetzen kann.
            Wenn das Problem in Ihrem lokalen Netzwerk auftritt,
            sollten Sie es als Problem des Servers behandeln und
            weiterlesen; wenn es allerdings im Internet auftritt,
            werden Sie sich wahrscheinlich an Ihrem ISP wenden
            müssen, damit dieser das Problem für Sie
            korrigiert.</p><p>Wenn das Problem vom Server verursacht wird und Sie
            sich in einem lokalen Netzwerk befinden, dann müssen
            Sie Ihren Server so konfigurieren, dass er die lokal
            genutzten IP-Adressen in Rechnernamen übersetzen kann.
            Weitere Informationen erhalten Sie in den Onlinehilfen zu
            <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a> und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.  Wenn dieses Problem im
            Internet auftritt, könnte die Ursache auch darin
            liegen, dass die Namensauflösung auf dem Server
            nicht funktioniert.  Versuchen Sie, einen anderen
            Hostnamen wie z.B. <code class="systemitem">www.yahoo.com</code>
            aufzulösen.  Wenn das nicht funktioniert, liegt das
            Problem bei Ihrem System.</p><p>Haben Sie FreeBSD gerade erst installiert, kann es auch
            sein, dass die Domänen- und Nameserverinformationen
            noch nicht in <code class="filename">/etc/resolv.conf</code>
            vorhanden sind.  Dadurch kommt es häufig zu
            Verzögerungen beim Einsatz von
            <span class="application">SSH</span>, weil die Option
            <code class="literal">UseDNS</code> in der Voreinstellung auf
            <code class="literal">yes</code> gesetzt ist (in der Datei
            <code class="filename">sshd_config</code> im Verzeichnis <code class="filename">/etc/ssh</code>).  Ist dies bei
            Ihnen der Fall, müssen Sie entweder die fehlenden
            Informationen in <code class="filename">/etc/resolv.conf</code> eintragen
            oder als temporäre Maßnahme <code class="literal">UseDNS</code>
            auf <code class="literal">no</code> setzen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67729232"></a><a id="stray-irq"></a><p><strong>5.22.</strong></p></td><td align="left" valign="top"><p>Was bedeutet <span class="errorname">stray IRQ</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Stray IRQs sind ein Zeichen für Probleme bei der
            Behandlung von Hardware-IRQs.  Sie werden meistens von
            Geräten verursacht, die ihren Interrupt Request
            zurückziehen, obwohl gerade der interrupt request
            acknowledge-Zyklus läuft.</p><p>Sie können drei Dinge tun:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ertragen Sie die Warnungen.  Sie erhalten nur die
                ersten 5 für jeden IRQ, alle anderen werden
                unterdrückt.</p></li><li class="listitem"><p>Eliminieren Sie die Meldungen, indem Sie den Wert von
                <code class="varname">MAX_STRAY_LOG</code> von <code class="literal">5</code>
                auf <code class="literal">0</code> in der für ihre Plattform
                (z.B. <span class="trademark">i386</span>&#8482;) zuständigen Datei
                <code class="filename">intr_machdep.c</code> ändern. Bauen Sie
                anschliessend den Kernel neu, um alle Meldungen zu
                unterdrücken.</p></li><li class="listitem"><p>Eliminieren Sie die Meldungen, indem Sie Hardware
                für den Parallelport installieren, die IRQ 7
                nutzt und vom PPP Treiber verwendet wird (das passiert
                auf den meisten Systemen), und installieren Sie eine
                IDE-Platte oder andere Hardware sowie einen dazu
                passenden Treiber, um IRQ 15 zu nutzen.</p></li></ul></div></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67740880"></a><a id="file-table-full"></a><p><strong>5.23.</strong></p></td><td align="left" valign="top"><p>Warum sehe ich in der Ausgabe von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dmesg</span>(8)</span></a> häufig
            die Meldung <span class="errorname">file: table is full</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Diese Fehlermeldung besagt, dass Sie die zur
            Verfügung stehenden File-Handles des Systems
            verbraucht haben.  Was das genau bedeutet und wie Sie
            dieses Problem lösen können, steht im Abschnitt
            <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/configtuning-kernel-limits.html#KERN-MAXFILES" target="_top">
            kern.maxfiles</a> im Kapitel <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/configtuning-kernel-limits.html" target="_top">Anpassung
            der Kernelkonfiguration</a> des Handbuchs.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67745232"></a><a id="calcru-negative-runtime"></a><p><strong>5.24.</strong></p></td><td align="left" valign="top"><p>Warum werden ständig Meldungen wie
  	    <span class="errorname">calcru: negative runtime</span> oder
            <span class="errorname">calcru: runtime went backwards</span> auf die
            Konsole geschrieben?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Es existiert ein bekanntes Problem wenn <span class="trademark">Intel</span>® Enhanced
            SpeedStep im BIOS aktiviert wird.  Das führt dazu, dass der
            Kernel <span class="errorname">calcru</span>-Nachrichten wie die folgende
            ausgibt:</p><pre class="screen">calcru: runtime went backwards from 6 usec to 3 usec for pid 37 (pagezero)
calcru: runtime went backwards from 6 usec to 3 usec for pid 36 (vmdaemon)
calcru: runtime went backwards from 170 usec to 138 usec for pid 35 (pagedaemon)
calcru: runtime went backwards from 553 usec to 291 usec for pid 15 (swi6: task queue)
calcru: runtime went backwards from 15521 usec to 10366 usec for pid 2 (g_event)
calcru: runtime went backwards from 25 usec to 12 usec for pid 11 (swi1: net)
calcru: runtime went backwards from 4417 usec to 3960 usec for pid 1 (init)
calcru: runtime went backwards from 2084385 usec to 1793542 usec for pid 1 (init)
calcru: runtime went backwards from 408 usec to 204 usec for pid 0 (swapper)</pre><p>Der Grund dafür besteht darin, dass <span class="trademark">Intel</span>® SpeedStep
           (EIST) in manchen Mainboards inkompatibel ist.</p><p>Abhilfe: Deaktivieren Sie die EIST-Eigenschaft im BIOS.  Sie
           können trotzdem noch ihre Prozessorfrequenz ACPI-basiert
           mittels <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=powerd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">powerd</span>(8)</span></a> drosseln.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67751376"></a><a id="computer-clock-skew"></a><p><strong>5.25.</strong></p></td><td align="left" valign="top"><p>Warum ist die Uhrzeit auf meinem Computer immer
            falsch?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ihr Computer verfügt über mehr als eine Uhr
            und FreeBSD benutzt leider die falsche.</p><p>Starten Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=dmesg&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">dmesg</span>(8)</span></a> und achten Sie auf die
            Zeilen, in denen das Wort <code class="literal">Timecounter</code>
            vorkommt.  Die von FreeBSD benutzte Uhr findet sich in der Zeile
            mit dem höchsten quality-Wert.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>dmesg | grep Timecounter</code></strong>
 Timecounter "i8254" frequency 1193182 Hz quality 0
 Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
 Timecounter "TSC" frequency 2998570050 Hz quality 800
 Timecounters tick every 1.000 msec</pre><p>Sie können das überprüfen, indem Sie
            den Wert der Systemvariablen
            <code class="varname">kern.timecounter.hardware</code>
            abfragen.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.timecounter.hardware</code></strong>
 kern.timecounter.hardware: ACPI-fast</pre><p>Es kann sich um einen defekten ACPI Timer handeln.  Die
          einfachste Lösung besteht darin, den ACPI Timer in
          <code class="filename">/boot/loader.conf</code> zu deaktivieren:</p><pre class="programlisting">debug.acpi.disabled="timer"</pre><p>Es ist aber auch durchaus möglich, dass das BIOS die
            TSC Uhr ändert, um beispielsweise den CPU-Takt zu
            während des Batteriebetrieb zu ändern, oder im
            Stromsparmodus; leider bemerkt FreeBSD diese
            Änderungen nicht und daher scheint die Uhr falsch zu
            gehen.</p><p>In diesem Beispiel ist die Uhr
            <code class="literal">i8254</code> ebenfalls verfügbar; um sie
            auszuwählen, muss ihr Name in die Systemvariable
            <code class="varname">kern.timecounter.hardware</code> geschrieben
            werden.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl -w kern.timecounter.hardware=i8254</code></strong>
 kern.timecounter.hardware: TSC -&gt; i8254</pre><p>Die Uhrzeit Ihres Computers sollte nun genauer
            funktionieren.</p><p>Damit diese Änderung automatisch beim Start des
            Systems durchgeführt wird, müssen Sie die
            folgende Zeile in die
            <code class="filename">/etc/sysctl.conf</code> eintragen.</p><pre class="programlisting">kern.timecounter.hardware=i8254</pre></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67767376"></a><a id="null-null"></a><p><strong>5.26.</strong></p></td><td align="left" valign="top"><p>Warum erkennt mein Laptop PC-Cards nicht?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dieses Problem tritt häufig auf Laptops mit mehreren
	    Betriebssystemen auf.  Einige nicht-BSD Betriebssysteme lassen
	    die Hardware in einem inkonsistenten Zustand.  Die Karte wird
	    dann von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pccardd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pccardd</span>(8)</span></a> als
	    <span class="errorname">"(null)""(null)"</span> anstelle des
	    tatsächlichen Modells gefunden.</p><p>Um dies zu beheben, müssen Sie die Hardware
	    zurücksetzen, das heißt der PC-Card Einschub
	    muss stromlos sein.  Gehen Sie dazu nicht in den Standby-
	    oder Suspend-Modus und stellen Sie sicher, dass der Laptop
	    wirklich ausgeschaltet ist.  Warten Sie einen Moment und booten
	    dann, Ihre PC-Card sollte jetzt funktionieren.</p><p>Einige Laptops schalten sich nicht wirklich aus.  Wenn der
	    obige Vorschlag nichts genutzt hat, entfernen Sie bitte die
	    Batterie, warten einen Moment und booten erneut.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67771344"></a><a id="boot-read-error"></a><p><strong>5.27.</strong></p></td><td align="left" valign="top"><p>Wieso hängt sich FreeBSD nach dem BIOS-Bildschirm
            mit der Meldung <span class="errorname">Read error</span>
            auf?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Der Bootloader von FreeBSD erkennt die Geometrie Ihrer
            Festplatte nicht richtig.  Sie müssen die Geometrie
            manuell festlegen, wenn sie mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fdisk&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">fdisk</span>(8)</span></a> FreeBSD-Bereiche
            erzeugen oder ändern.</p><p>Die richtigen Werte für die Geometrie können
            Sie im BIOS des Rechners ablesen.  Achten Sie auf die
            Anzahl der Zylinder, Köpfe und Sektoren für Ihre
            Festplatte.</p><p>Im fdisk von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> müssen Sie
            <span class="keycap"><strong>G</strong></span> eingeben, um die Geometrie zu
            definieren.</p><p>Sie erhalten eine Dialogbox, in der Sie die Anzahl der
            Zylinder, Köpfe und Sektoren eingeben können.
            Verwenden Sie die Angaben des BIOS und setzen Sie
            Schrägstriche zwischen die Zahlen.  5000 Zylinder,
            250 Köpfe und 60 Sektoren würden also als
            <strong class="userinput"><code>5000/250/60</code></strong> eingegeben.</p><p>Schließen Sie die Eingabe mit <span class="keycap"><strong>Enter</strong></span>
	    ab und drücken Sie <span class="keycap"><strong>W</strong></span>, um die neue
            Partitionstabelle auf die Festplatte schreiben zu
            lassen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67778512"></a><a id="bootmanager-restore"></a><p><strong>5.28.</strong></p></td><td align="left" valign="top"><p>Ein anderes Betriebssystem hat meinen Bootmanager
            zerstört.  Wie kann ich ihn wiederherstellen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Starten Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysinstall&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysinstall</span>(8)</span></a> und wählen Sie
            <span class="guimenuitem">Configure</span>, dann
            <span class="guimenuitem">Fdisk</span>.  Wählen Sie die
            Platte, auf der sich der Boot Manager befand, mit der
            <span class="keycap"><strong>Leertaste</strong></span> aus.  Drücken Sie
            <span class="keycap"><strong>W</strong></span>, um die Änderungen auf die Platten
            schreiben zu lassen.  Nun erscheint eine Abfrage, welcher
            Bootmanager installiert werden soll.  Wählen Sie
            diesen an und er wird wieder installiert.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67819856"></a><a id="indefinite-wait-buffer"></a><p><strong>5.29.</strong></p></td><td align="left" valign="top"><p>Was soll mir die Meldung <span class="errorname">swap_pager: indefinite
            wait buffer:</span> sagen?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ein Programm wollte Speicher auf Platte auslagern, und
            dieser Vorgang konnte nicht innerhalb von 20 Sekunden
            durchgeführt werden.  Mögliche Gründe sind
            defekte Blöcke auf der Platte, falsche oder
            fehlerhafte Verkabelung sowie Probleme mit anderen
            Komponenten, die am Zugriff auf die Festplatte beteiligt
            sind.  Wenn die Festplatte selbst fehlerhaft sind, sollten
            Sie entsprechende Meldungen in
            <code class="filename">/var/log/messages</code> und den Ausgaben
            von <code class="command">dmesg</code> finden.  Andernfalls sollten
            Sie die Kabel und Verbindungen überprüfen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67823056"></a><a id="udma-icrc"></a><p><strong>5.30.</strong></p></td><td align="left" valign="top"><p>Was sind <span class="errorname">UDMA ICRC</span> Fehler und
	    wie behebe ich sie?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ata&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ata</span>(4)</span></a>-Treiber meldet <span class="errorname">UDMA ICRC</span>
	    Fehler wenn eine DMA-Übertragung zu oder von einem
	    Laufwerk fehlgeschlagen ist.  Der Treiber versucht die
	    Übertragung mehrmals durchzuführen und schaltet,
	    wenn die Versuche fehlschlagen, vom DMA-Modus auf den
	    langsameren PIO-Modus um.</p><p>Der Fehler kann viele Ursachen haben, häufig ist ein
	    Kabel kaputt oder die Geräte sind falsch verkabelt.
	    Prüfen Sie, ob die ATA-Kabel unbeschädigt sind und
	    für den verwendeten Ultra-DMA-Modus tauglich sind.  Ebenso
	    müssen Wechselrahmen für den verwendeten Modus geeignet
	    sein.  Stellen Sie sicher, dass alle Kabel fest
	    angeschlossen sind.  Es gab auch schon Probleme, wenn ein altes
	    Laufwerk zusammen mit einem Ultra-DMA-66 oder einem schnelleren
	    Laufwerk auf einem Kanal betrieben wurde.  Es kann aber auch
	    sein, dass das Laufwerk kaputt ist.  Die meisten Hersteller
	    stellen Test-Programme für ihre Laufwerke zur
	    Verfügung.  Überprüfen Sie damit Ihr Laufwerk und
	    wenn nötig, sichern Sie Ihre Daten und ersetzen das
	    Laufwerk.</p><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=atacontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">atacontrol</span>(8)</span></a> zeigt für jedes ATA-Gerät den
	    verwendeten DMA- oder PIO-Modus an.  Das Kommando
	    <code class="command">atacontrol mode
	      Kanal</code>
	    zeigt die auf einem Kanal verwendeten Modi (die Kanäle
	    werden von <code class="literal">0</code> an nummeriert).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67828944"></a><a id="lock-order-reversal"></a><p><strong>5.31.</strong></p></td><td align="left" valign="top"><p>Was ist ein <span class="errorname">lock order
            reversal</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Eine Antwort auf diese Frage findet sich im FreeBSD-Glossar
            unter <a class="link" href="../../../../doc/de_DE.ISO8859-1/books/handbook/freebsd-glossary.html#LOR-GLOSSARY" target="_top">LOR</a>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67831888"></a><a id="called-with-non-sleepable-locks-held"></a><p><strong>5.32.</strong></p></td><td align="left" valign="top"><p>Warum erhalte ich die Meldung <span class="errorname">Called ... with
            the following non-sleepable locks held</span>?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Diese Meldung erscheint, wenn eine Funktion, die sich
            im Ruhemodus befindet, aufgerufen wird, während ein
            Mutex oder eine andere (nicht in den Ruhemodus versetzbare)
            Sperre aktiv war.</p><p>Der Grund dafür ist, dass ein Mutex nicht für
            längere Zeitspannen aktiv sein soll, sondern nur
            für die Synchronisation von Gerätetreibern mit
            dem Rest des Kernels während eines Interrupts.  Unter
            FreeBSD dürfen Interrupts nicht in den Ruhemodus
            versetzt werden.  Daher ist es von entscheidender Bedeutung,
            dass während des Bestehens eines Mutex kein
            Kernelsubsystem für einen längeren Zeitraum
            blockiert ist.</p><p>Um solche Fehler abzufangen, können Sicherungen
            (<span class="foreignphrase"><em class="foreignphrase">Assertions</em></span>) in den Kernel
            eingebaut werden, die danach mit dem <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=witness&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">witness</span>(4)</span></a>-Subsystem
            interagieren.  Dadurch wird (in Abhängigkeit von Ihrer
            Systemkonfiguration) eine Warnung oder eine Fehlermeldung
            ausgegeben, falls der Aufruf einer Funktion während
            des Bestehens eines Mutex zu einer Blockierung führen
            kann.</p><p>Zusammenfassend kann man sagen, dass diese Warnungen
            in der Regel zwar nicht bedrohlich sind.  Unter bestimmten
            Umständen kann es aber dennoch zu unerwünschten
            Nebenwirkungen, angefangen von einer Erhöhung der
            Reaktionszeit bis hin zu einem kompletten Einfrieren des
            Systems kommen.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp67836880"></a><a id="touch-not-found"></a><p><strong>5.33.</strong></p></td><td align="left" valign="top"><p>Warum bricht
            <code class="buildtarget">buildworld</code>/<code class="buildtarget">installworld</code>
            mit der Meldung <span class="errorname">touch: not found</span> ab?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Dieser Fehler bedeutet nicht, dass <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=touch&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">touch</span>(1)</span></a> nicht
            auf Ihrem System vorhanden ist.  Vielmehr sind Dateien die
            Ursache, deren Erzeugungsdatum in der Zukunft liegt.  Wenn
            Ihre CMOS-Uhr auf Ihre lokale Zeit eingestellt ist,
            müssen Sie <code class="command">adjkerntz -i</code>
            verwenden, um die Kerneluhr anzupassen, wenn Sie in den
            Single-User-Modus booten.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="compatibility-other.html">Zurück</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="commercial.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">4.8. Sonstige Hardware </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> Kapitel 6. Kommerzielle Anwendungen</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>