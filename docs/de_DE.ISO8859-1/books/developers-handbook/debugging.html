<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>2.6. Debuggen</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="tools.html" title="Kapitel 2. Werkzeuge zur Programmierung" /><link rel="prev" href="tools-make.html" title="2.5. Make" /><link rel="next" href="emacs.html" title="2.7. Emacs als Entwicklungsumgebung verwenden" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.6. Debuggen</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="tools-make.html">Zurück</a> </td><th width="60%" align="center">Kapitel 2. Werkzeuge zur Programmierung</th><td width="20%" align="right"> <a accesskey="n" href="emacs.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="debugging"></a>2.6. Debuggen</h2></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64559696"></a>2.6.1. Der Debugger</h3></div></div></div><p>Der Debugger bei FreeBSD heißt
	<code class="command">gdb</code> (<span class="application">GNU
	debugger</span>). Sie können Ihn durch die Eingabe
	von</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb progname</code></strong></pre><p>starten, wobei viele Leute ihn vorzugsweise
	innerhalb von <span class="application">Emacs</span> aufrufen. Sie
	erreichen dies durch die Eingabe von:</p><pre class="screen"><strong class="userinput"><code>M-x gdb RET progname RET</code></strong></pre><p>Die Verwendung eines Debuggers erlaubt Ihnen Ihr
	Programm unter kontrollierteren Bedingungen ausführen zu
	können. Typischerweise können Sie so Zeile für
	Zeile durch Ihr Programm gehen, die Werte von Variablen
	untersuchen, diese verändern, dem Debugger sagen er soll
	das Programm bis zu einem bestimmten Punkt ausführen und
	dann anhalten, und so weiter und so fort. Sie können
	damit sogar ein schon laufendes Programm untersuchen, oder
	eine Datei mit einem Kernspeicherabbild laden um
	herauszufinden, warum das Programm abgestürzt ist. Es ist
	sogar möglich damit den Kernel zu debuggen, wobei dies
	etwas trickreicher als bei den Benutzeranwendungen ist, welche
	wir in diesem Abschnitt behandeln werden.</p><p>Der <code class="command">gdb</code> besitzt eine recht gute
	Online-Hilfe, sowie einen Satz von Info-Seiten, weshalb sich
	dieser Abschnitt auf ein paar grundlegende Befehle
	beschränken wird.</p><p>Falls Sie den textbasierten Kommandozeilen-Stil
	abstoßend finden gibt es ein graphisches Front-End
	dafür (<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/devel/xxgdb/pkg-descr">devel/xxgdb</a>) in der Ports-Sammlung.</p><p>Dieser Abschnitt ist als Einführung in die
	Verwendung des <code class="command">gdb</code> gedacht und beinhaltet
	nicht spezielle Themen wie das Debuggen des Kernels.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64588240"></a>2.6.2. Ein Programm im Debugger ausführen</h3></div></div></div><p>Sie müssen das Programm mit der Option
	<code class="option">-g</code> kompiliert haben um den
	<code class="command">gdb</code> effektiv einsetzen zu können. Es
	geht auch ohne diese Option, allerdings werden Sie dann nur
	den Namen der Funktion sehen, in der Sie sich gerade befinden,
	anstatt direkt den zugehörigen Quelltext. Falls Sie eine
	Meldung wie die folgende sehen:</p><pre class="screen">&#8230; (no debugging symbols found) &#8230;</pre><p>wenn der <code class="command">gdb</code> gestartet wird, dann
	wissen Sie, daß das Programm nicht mit der Option
	<code class="option">-g</code> kompiliert wurde.</p><p>Geben Sie in der Eingabeaufforderung des
	<code class="command">gdb</code> <strong class="userinput"><code>break main</code></strong> ein.
	Dies weist den Debugger an, dass Sie nicht daran interessiert sind,
	den einleitenden Schritten beim Programmstart zuzusehen und dass
	am Anfang Ihres Codes die Ausführung beginnen soll.  Geben Sie
	nun <strong class="userinput"><code>run</code></strong> ein, um das Programm zu starten -
	es wird starten und beim Aufruf von <code class="function">main()</code> vom
	Debugger angehalten werden. (Falls Sie sich jemals gewundert haben von
	welcher Stelle <code class="function">main()</code> aufgerufen wird, dann
	wissen Sie es jetzt!).</p><p>Sie können nun Schritt für Schritt durch Ihr
	Programm gehen, indem Sie <code class="command">n</code> drücken.
	Wenn Sie zu einem Funktionsaufruf kommen können Sie diese
	Funktion durch drücken von <code class="command">s</code> betreten.
	Sobald Sie sich in einem Funktionsaufruf befinden können
	Sie diesen durch drücken von <code class="command">f</code> wieder
	verlassen. Sie können auch <code class="command">up</code> und
	<code class="command">down</code> verwenden, um sich schnell den
	Aufrufer einer Funktion anzusehen.</p><p>Hier ist ein einfaches Beispiel, wie man mit Hilfe des
	<code class="command">gdb</code> einen Fehler in einem Programm findet.
	Dies ist unser eigenes Programm (mit einem absichtlich
	eingebauten Fehler):</p><pre class="programlisting">#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf("This is my program\n");
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf("You gave me %d\n", anint);
	return anint;
}</pre><p>Dieses Programm setzt <span class="symbol">i</span> auf den Wert
	<code class="literal">5</code> und übergibt dies einer Funktion
	<code class="function">bazz()</code>, welche den Wert ausgibt, den Sie
	von uns erhalten hat.</p><p>Wenn wir das Programm kompilieren und ausführen
	erhalten wir</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>cc -g -o temp temp.c</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>./temp</code></strong>
This is my program
anint = 4231</pre><p>Das ist nicht was wir erwartet hatten! Es ist Zeit,
	daß wir sehen was hier passiert!</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb temp</code></strong>
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) <strong class="userinput"><code>break main</code></strong>				<em class="lineannotation"><span class="lineannotation">Skip the set-up code</span></em>
Breakpoint 1 at 0x160f: file temp.c, line 9.	<em class="lineannotation"><span class="lineannotation">gdb puts breakpoint at main()</span></em>
(gdb) <strong class="userinput"><code>run</code></strong>					<em class="lineannotation"><span class="lineannotation">Run as far as main()</span></em>
Starting program: /home/james/tmp/temp		<em class="lineannotation"><span class="lineannotation">Program starts running</span></em>

Breakpoint 1, main () at temp.c:9		<em class="lineannotation"><span class="lineannotation">gdb stops at main()</span></em>
(gdb) <strong class="userinput"><code>n</code></strong>						<em class="lineannotation"><span class="lineannotation">Go to next line</span></em>
This is my program				<em class="lineannotation"><span class="lineannotation">Program prints out</span></em>
(gdb) <strong class="userinput"><code>s</code></strong>						<em class="lineannotation"><span class="lineannotation">step into bazz()</span></em>
bazz (anint=4231) at temp.c:17			<em class="lineannotation"><span class="lineannotation">gdb displays stack frame</span></em>
(gdb)</pre><p>Halt mal! Wieso hat denn <span class="symbol">anint</span> den Wert
	<code class="literal">4231</code>? Haben wir dieser Variablen nicht in
	<code class="function">main()</code> den Wert <code class="literal">5</code>
	zugewiesen? Gehen wir mal zurück zu
	<code class="function">main()</code> und schauen dort nach.</p><pre class="screen">(gdb) <strong class="userinput"><code>up</code></strong>					<em class="lineannotation"><span class="lineannotation">Move up call stack</span></em>
#1  0x1625 in main () at temp.c:11		<em class="lineannotation"><span class="lineannotation">gdb displays stack frame</span></em>
(gdb) <strong class="userinput"><code>p i</code></strong>					<em class="lineannotation"><span class="lineannotation">Show us the value of i</span></em>
$1 = 4231					<em class="lineannotation"><span class="lineannotation">gdb displays 4231</span></em></pre><p>Oh! Anscheinend haben wir vergessen <span class="symbol">i</span> zu
	initialisieren. Wir wollten eigentlich</p><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">&#8230;</span></em>
main() {
	int i;

	i = 5;
	printf("This is my program\n");
<em class="lineannotation"><span class="lineannotation">&#8230;</span></em></pre><p>schreiben, haben aber die Zeile mit
	<code class="literal">i=5;</code> vergessen. Da wir <span class="symbol">i</span>
	nicht initialisiert haben hatte diese Variable gerade den
	Wert, der in dem ihr zugewiesenen Speicherbereich stand als
	wir das Programm gestartet haben, welcher in diesem Fall
	<code class="literal">4231</code> war.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Der <code class="command">gdb</code> zeigt jedes mal, wenn wir
	  eine Funktion betreten oder verlassen, den Inhalt des
	  Stack-Rahmens an, selbst wenn wir uns mit
	  <code class="command">up</code> und <code class="command">down</code> im
	  Aufruf-Stack umher bewegen. Dabei wird der Name der Funktion
	  sowie der übergebenen Argumente angezeigt, was uns
	  dabei hilft, die Übersicht zu behalten. (Der Stack ist
	  ein Speicherbereich, in dem ein Programm Informationen
	  über die an eine Funktion übergebenen Argumente
	  ablegt, sowie die Rücksprungadresse eines
	  Funktionsaufrufes).</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64708304"></a>2.6.3. Eine Kernspeicherdatei untersuchen</h3></div></div></div><p>Eine Kernspeicherdatei ist im Prinzip eine Datei, die den
	vollständigen Zustand eines Prozesses enthält, als
	dieses abgestürzt ist. In <span class="quote">&#8222;<span class="quote">den guten alten
	Zeiten</span>&#8220;</span> mußten Programmierer hexadezimale Listen
	der Kernspeicherdatei ausdrucken und über
	Maschinencodehandbüchern schwitzen, aber heutzutage ist
	das Leben etwas einfacher geworden. Zufälligerweise wird
	die Kernspeicherdatei unter FreeBSD und anderen
	4.4BSD-Systemen
	<code class="filename">progname.core</code>
	anstatt einfach nur <code class="filename">core</code> genannt, um
	deutlich zu machen, zu welchem Programm eine Kernspeicherdatei
	gehört.</p><p>Um eine Kernspeicherdatei zu untersuchen müssen Sie
	den <code class="command">gdb</code> wie gewohnt starten. An Stelle von
	<code class="command">break</code> oder <code class="command">run</code>
	müssen Sie das Folgende eingeben</p><pre class="screen">(gdb) <strong class="userinput"><code>core progname.core</code></strong></pre><p>Wenn Sie sich nicht in demselben Verzeichnis befinden wie
	die Kernspeicherdatei müssen Sie zuerst <strong class="userinput"><code>dir
	/path/to/core/file</code></strong> eingeben.</p><p>Sie sollten dann etwas wie folgt sehen:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>gdb a.out</code></strong>
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) <strong class="userinput"><code>core a.out.core</code></strong>
Core was generated by `a.out'.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)</pre><p>In diesem Fall hieß das Programm
	<code class="filename">a.out</code>, weshalb die Kernspeicherdatei den
	Namen <code class="filename">a.out.core</code> trägt. Wie wir
	sehen können stürzte das Programm in einer Funktion
	namens <code class="function">bazz</code> ab, als es versuchte auf
	einen Speicherbereich zuzugreifen, der dem Programm nicht zur
	Verfügung stand.</p><p>Manchmal ist es ganz nützlich zu sehen, wie eine
	Funktion aufgerufen wurde, da bei komplexen Programmen das
	eigentliche Problem schon sehr viel weiter oben auf dem
	Aufruf-Stack aufgetreten sein könnte. Der Befehl
	<code class="command">bt</code> veranlaßt den
	<code class="command">gdb</code> dazu, einen Backtrace des Aufruf-Stacks
	auszugeben:</p><pre class="screen">(gdb) <strong class="userinput"><code>bt</code></strong>
#0  0x164a in bazz (anint=0x5) at temp.c:17
#1  0xefbfd888 in end ()
#2  0x162c in main () at temp.c:11
(gdb)</pre><p>Die Funktion <code class="function">end()</code> wird aufgerufen,
	wenn ein Programm abstürzt; in diesem Fall wurde die
	Funktion <code class="function">bazz()</code> aus der
	<code class="function">main()</code>-Funktion heraus aufgerufen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp64745552"></a>2.6.4. Ein bereits laufendes Programm untersuchen</h3></div></div></div><p>Eine der tollsten Features des <code class="command">gdb</code>
	ist die Möglichkeit, damit bereits laufende Programme zu
	untersuchen. Dies bedeutet natürlich, daß Sie die
	erforderlichen Rechte dafür besitzen. Ein häufig
	auftretendes Problem ist das Untersuchen eines Programmes,
	welches sich selber forkt. Vielleicht will man den Kindprozess
	untersuchen, aber der Debugger erlaubt einem nur den Zugriff
	auf den Elternprozess.</p><p>Was Sie an solch einer Stelle machen ist, Sie starten
	einen weiteren <code class="command">gdb</code>, ermitteln mit Hilfe von
	<code class="command">ps</code> die Prozess-ID des Kindprozesses, und
	geben</p><pre class="screen">(gdb) <strong class="userinput"><code>attach pid</code></strong></pre><p>im <code class="command">gdb</code> ein, und können dann wie
	üblich mit der Fehlersuche fortfahren.</p><p><span class="quote">&#8222;<span class="quote">Das ist zwar alles sehr schön,</span>&#8220;</span> werden
	Sie jetzt vielleicht denken, <span class="quote">&#8222;<span class="quote">aber in der Zeit, in der
	ich diese Schritte durchführe, ist der Kindprozess schon
	längst über alle Berge</span>&#8220;</span>. Fürchtet euch
	nicht, edler Leser, denn Ihr müßt wie folgt
	vorgehen (freundlicherweise zur Verfügung gestellt von
	den Info-Seite des <code class="command">gdb</code>):</p><pre class="screen"><em class="lineannotation"><span class="lineannotation">&#8230;</span></em>
if ((pid = fork()) &lt; 0)		/* _Always_ check this */
	error();
else if (pid == 0) {		/* child */
	int PauseMode = 1;

	while (PauseMode)
		sleep(10);	/* Wait until someone attaches to us */
	<em class="lineannotation"><span class="lineannotation">&#8230;</span></em>
} else {			/* parent */
	<em class="lineannotation"><span class="lineannotation">&#8230;</span></em></pre><p>Alles was Sie jetzt noch tun müssen ist, sich an
	den Kindprozess ranzuhängen, <span class="symbol">PauseMode</span>
	auf <code class="literal">0</code> zu setzen und auf den
	<code class="function">sleep()</code> Funktionsaufruf zu warten, um
	zurückzukehren!</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tools-make.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="tools.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="emacs.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">2.5. Make </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 2.7. Emacs als Entwicklungsumgebung verwenden</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>