<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>11.13. Die FPU verwenden</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="x86.html" title="Kapitel 11. x86-Assembler-Programmierung" /><link rel="prev" href="x86-one-pointed-mind.html" title="11.12. One-Pointed Mind" /><link rel="next" href="x86-caveats.html" title="11.14. Vorsichtsmassnahmen" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.13. Die <acronym class="acronym">FPU</acronym> verwenden</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="x86-one-pointed-mind.html">Zurück</a> </td><th width="60%" align="center">Kapitel 11. x86-Assembler-Programmierung</th><td width="20%" align="right"> <a accesskey="n" href="x86-caveats.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="x86-fpu"></a>11.13. Die <acronym class="acronym">FPU</acronym> verwenden</h2></div><div><span class="authorgroup">Übersetzt von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Fabian</span> <span class="surname">Borschel</span></span>. </span></div></div></div><p>Seltsamerweise erwähnt die meiste Literatur zu
      Assemblersprachen nicht einmal die Existenz der
      <acronym class="acronym">FPU</acronym>, oder
      <span class="emphasis"><em>floating point unit</em></span>
      (Fließkomma-Recheneinheit), geschweige denn, daß
      auf die Programmierung mit dieser eingegangen wird.</p><p>Dabei kann die Assemblerprogrammierung gerade bei
      hoch optimiertem <acronym class="acronym">FPU</acronym>-Code, der
      <span class="emphasis"><em>nur</em></span> mit einer Assemblersprache realisiert
      werden kann, ihre große Stärke ausspielen.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-fpu-organization"></a>11.13.1. Organisation der <acronym class="acronym">FPU</acronym></h3></div></div></div><p>Die <acronym class="acronym">FPU</acronym> besteht aus 8 80&#8211;bit
	Fließkomma-Registern. Diese sind in Form eines
	Stacks organisiert&#8212;Sie können einen Wert durch
	den Befehl <code class="function">push</code> auf dem
	<acronym class="acronym">TOS</acronym> (<span class="emphasis"><em>top of stack</em></span>)
	ablegen, oder durch <code class="function">pop</code> von diesem
	holen.</p><p>Da also die Befehle <code class="function">push</code>
        und <code class="function">pop</code> schon verwendet
	werden, kann es	keine op-Codes in Assemblersprache mit diesen
	Namen geben.</p><p>Sie können mit einen Wert auf dem
	<acronym class="acronym">TOS</acronym> ablegen, indem Sie
	<code class="function">fld</code>, <code class="function">fild</code>, und <code class="function">fbld</code> verwenden. Mit weiteren op-Codes
	lassen sich <span class="emphasis"><em>Konstanten</em></span>&#8212;wie z.B.
	<span class="emphasis"><em>Pi</em></span>&#8212;auf dem <acronym class="acronym">TOS</acronym>
	ablegen.</p><p>Analog dazu können Sie einen Wert
	holen, indem Sie <code class="function">fst</code>,
	<code class="function">fstp</code>, <code class="function">fist</code>, <code class="function">fistp</code>, und <code class="function">fbstp</code> verwenden. Eigentlich
	holen (<code class="function">pop</code>) nur die op-Codes, die auf
	<span class="emphasis"><em>p</em></span> enden, einen Wert, während die
	anderen den Wert irgendwo speichern (<code class="function">store</code>)
	ohne ihn vom <acronym class="acronym">TOS</acronym> zu entfernen.</p><p>Daten können zwischen dem <acronym class="acronym">TOS</acronym>
	und dem Hauptspeicher als 32&#8211;bit, 64&#8211;bit oder
	80&#8211;bit <span class="emphasis"><em>real</em></span>, oder als 16&#8211;bit,
	32&#8211;bit oder 64&#8211;bit <span class="emphasis"><em>Integer</em></span>,
	oder als 80&#8211;bit <span class="emphasis"><em>packed decimal</em></span>
	übertragen werden.</p><p>Das 80&#8211;bit <span class="emphasis"><em>packed decimal</em></span>-Format
        ist ein Spezialfall des
	<span class="emphasis"><em>binary coded decimal</em></span>-Formates,
	welches üblicherweise bei der Konvertierung zwischen der
	<acronym class="acronym">ASCII</acronym>- und
	<acronym class="acronym">FPU</acronym>-Darstellung von Daten verwendet wird.
	Dieses erlaubt die Verwendung von 18 signifikanten
	Stellen.</p><p>Unabhängig davon, wie Daten im Speicher dargestellt
	werden, speichert die <acronym class="acronym">FPU</acronym> ihre Daten immer
	im 80&#8211;bit <span class="emphasis"><em>real</em></span>-Format in den
	Registern.</p><p>Ihre interne Genauigkeit beträgt mindestens 19
	Dezimalstellen. Selbst wenn wir also Ergebnisse im
	<acronym class="acronym">ASCII</acronym>-Format mit voller 18&#8211;stelliger
	Genauigkeit darstellen lassen, werden immer noch korrekte
	Werte angezeigt.</p><p>Des weiteren können mathematische Operationen auf
	dem <acronym class="acronym">TOS</acronym> ausgeführt werden: Wir
	können dessen <span class="emphasis"><em>Sinus</em></span> berechnen, wir
	können ihn <span class="emphasis"><em>skalieren</em></span> (z.B.
	können wir ihn mit dem Faktor 2 Multiplizieren oder
	Dividieren), wir können dessen
	<span class="emphasis"><em>Logarithmus</em></span> zur Basis 2 nehmen, und viele
	weitere Dinge.</p><p>Wir können auch <acronym class="acronym">FPU</acronym>-Register
	<span class="emphasis"><em>multiplizieren</em></span>,
	<span class="emphasis"><em>dividieren</em></span>, <span class="emphasis"><em>addieren</em></span>
	und <span class="emphasis"><em>subtrahieren</em></span>, sogar einzelne
	Register mit sich selbst.</p><p>Der offizielle Intel op-Code für den
	<acronym class="acronym">TOS</acronym> ist <code class="varname">st</code> und für die
	<span class="emphasis"><em>Register</em></span> <code class="varname">st(0)</code>&#8211; <code class="varname">st(7)</code>. <code class="varname">st</code> und <code class="varname">st(0)</code> beziehen sich dabei auf das
	gleiche Register.</p><p>Aus welchen Gründen auch immer hat sich der
	Originalautor von <span class="application">nasm</span> dafür
	entschieden, andere op-Codes zu verwenden, nämlich
	<code class="varname">st0</code>&#8211; <code class="varname">st7</code>. Mit anderen Worten, es gibt
	keine Klammern, und der <acronym class="acronym">TOS</acronym> ist immer
	<code class="varname">st0</code>, niemals einfach nur
	<code class="function">st</code>.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-fpu-packed-decimal"></a>11.13.1.1. Das Packed Decimal-Format</h4></div></div></div><p>Das <span class="emphasis"><em>packed decimal</em></span>-Format verwendet
	  10 Bytes (80 Bits) zur Darstellung von 18 Ziffern. Die so
	  dargestellte Zahl ist immer ein
	  <span class="emphasis"><em>Integer</em></span>.</p><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml">Sie können durch Multiplikation des
	    <acronym class="acronym">TOS</acronym> mit Potenzen von 10 die einzelnen
	    Dezimalstellen verschieben.</p></div><p>Das höchste Bit des höchsten Bytes (Byte 9)
	  ist das <span class="emphasis"><em>Vorzeichenbit</em></span>:
	  Wenn es gesetzt ist, ist die Zahl
	  <span class="emphasis"><em>negativ</em></span>, ansonsten
	  <span class="emphasis"><em>positiv</em></span>. Die restlichen Bits dieses
	  Bytes werden nicht verwendet bzw. ignoriert.</p><p>Die restlichen 9 Bytes enthalten die 18 Ziffern der
	  gespeicherten Zahl: 2 Ziffern pro Byte.</p><p>Die <span class="emphasis"><em>signifikantere Ziffer</em></span> wird in
	  der <span class="emphasis"><em>oberen Hälfte</em></span> (4 Bits) eines
	  Bytes gespeichert, die andere in der
	  <span class="emphasis"><em>unteren Hälfte</em></span>.</p><p>Vielleicht würden Sie jetzt annehmen, das
	  <code class="constant">-1234567</code> auf die folgende Art im
	  Speicher abgelegt wird (in hexadezimaler Notation):</p><pre class="programlisting">80 00 00 00 00 00 01 23 45 67</pre><p>Dem ist aber nicht so! Bei Intel werden alle Daten im
	  <span class="emphasis"><em>little&#8211;endian</em></span>-Format gespeichert,
	  auch das <span class="emphasis"><em>packed decimal</em></span>-Format.</p><p>Dies bedeutet, daß <code class="constant">-1234567</code>
	  wie folgt gespeichert wird:</p><pre class="programlisting">67 45 23 01 00 00 00 00 00 80</pre><p>Erinnern Sie sich an diesen Umstand, bevor Sie sich
	  aus lauter Verzweiflung die Haare
	  ausreißen.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Das lesenswerte Buch&#8212;falls Sie es finden
	    können&#8212;ist Richard Startz' <a class="link" href="http://www.int80h.org/cgi-bin/isbn?isbn=013246604X" target="_top">
	    8087/80287/80387 for the IBM PC &amp; Compatibles</a>.
	    Obwohl es anscheinend die Speicherung der <span class="emphasis"><em>packed
	    decimal</em></span> im little&#8211;endian-Format für
	    gegeben annimmt. Ich mache keine Witze über meine
	    Verzweiflung, als ich den Fehler im unten stehenden Filter
	    gesucht habe, <span class="emphasis"><em>bevor</em></span> mir einfiel,
	    daß ich einfach mal versuchen sollte, das
	    little&#8211;endian-Format, selbst für diesen Typ von
	    Daten, anzuwenden.</p></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-photography"></a>11.13.2. Ausflug in die Lochblendenphotographie</h3></div></div></div><p>Um sinnvolle Programme zu schreiben, müssen wir nicht
	nur unsere Programmierwerkzeuge beherrschen, sondern auch das
	Umfeld, für das die Programme gedacht sind.</p><p>Unser nächster Filter wird uns dabei helfen, wann
	immer wir wollen, eine <span class="emphasis"><em>Lochkamera</em></span> zu
	bauen. Wir brauchen also etwas Hintergrundwissen über
	die <span class="emphasis"><em>Lochblendenphotographie</em></span>, bevor wir
	weiter machen können.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-camera"></a>11.13.2.1. Die Kamera</h4></div></div></div><p>Die einfachste Form, eine Kamera zu beschreiben, ist
	  die eines abgeschlossenen, lichtundurchlässigen
	  Raumes, in dessen Abdeckung sich ein kleines Loch
	  befindet.</p><p>Die Abdeckung ist normalerweise fest (z.B. eine
	  Schachtel), manchmal jedoch auch flexibel (z.B. ein Balgen).
	  Innerhalb der Kamera ist es sehr dunkel. Nur durch ein
	  kleines Loch kann Licht von einem einzigen Punkt aus in den
	  Raum eindringen (in manchen Fällen sind es mehrere
	  Löcher). Diese Lichtstrahlen kommen von einem Bild,
	  einer Darstellung von dem was sich außerhalb der
	  Kamera, vor dem kleinen Loch, befindet.</p><p>Wenn ein lichtempfindliches Material (wie z.B. ein Film)
	  in der Kamera angebracht wird, so kann dieses das Bild
	  einfangen.</p><p>Das Loch enthält häufig eine
	  <span class="emphasis"><em>Linse</em></span>, oder etwas linsenartiges,
	  häufig auch einfach <span class="emphasis"><em>Objektiv</em></span>
	  genannt.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-the-pinhole"></a>11.13.2.2. Die Lochblende</h4></div></div></div><p>Streng genommen ist die Linse nicht notwendig: Die
	  ursprünglichen Kameras verwendeten keine Linse, sondern
	  eine <span class="emphasis"><em>Lochblende</em></span>. Selbst heutzutage
	  werden noch <span class="emphasis"><em>Lochblenden</em></span> verwendet,
	  zum einen, um die Funktionsweise einer Kamera zu erlernen,
	  und zum anderen, um eine spezielle Art von Bildern zu
	  erzeugen.</p><p>Das Bild, das von einer <span class="emphasis"><em>Lochblende</em></span>
	  erzeugt wird, ist überall scharf. Oder unscharf. Es
	  gibt eine ideale Größe für eine Lochblende:
	  Wenn sie größer oder kleiner ist, verliert das
	  Bild seine Schärfe.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-focal-length"></a>11.13.2.3. Brennweite</h4></div></div></div><p>Dieser ideale Lochblendendurchmesser ist eine Funktion
	  der Quadratwurzel der <span class="emphasis"><em>Brennweite</em></span>,
	  welche dem Abstand der Lochblende von dem Film
	  entspricht.</p><pre class="programlisting">     D = PC * sqrt(FL)</pre><p>Hier ist <code class="varname">D</code> der ideale Durchmesser der
	  Lochblende, <code class="varname">FL</code> die Brennweite und
	  <code class="constant">PC</code> eine Konstante der Brennweite. Nach
	  Jay Bender hat die Konstante den Wert
	  <code class="constant">0.04</code>, nach Kenneth Connors
	  <code class="constant">0.037</code>. Andere Leute
	  haben andere Werte vorgeschlagen. Des weiteren gelten diese
	  Werte nur für Tageslicht: Andere Arten von
	  Licht benötigen andere konstante Werte, welche nur
	  durch Experimente bestimmt werden können.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-f-number"></a>11.13.2.4. Der f&#8211;Wert</h4></div></div></div><p>Der f&#8211;Wert ist eine sehr nützliche
	  Größe, die angibt, wieviel Licht den Film erreicht.
	  Ein Belichtungsmesser kann dies messen, um z.B. für
	  einen Film mit einer Empfindlichkeit von f5.6 eine
	  Belichtungsdauer von 1/1000 Sekunden auszurechnen.</p><p>Es spielt keine Rolle, ob es eine 35&#8211;mm- oder
	  eine 6x9cm-Kamera ist, usw. Solange wir den f&#8211;Wert
	  kennen, können wir die benötigte Belichtungszeit
	  berechnen.</p><p>Der f&#8211;Wert läßt sich einfach wie folgt
	  berechnen:</p><pre class="programlisting">    F = FL / D</pre><p>Mit anderen Worten, der f&#8211;Wert ergibt sich aus
	  der Brennweite (FL), dividiert durch den Durchmesser (D) der
	  Lochblende. Ein großer f&#8211;Wert impliziert also
	  entweder eine kleine Lochblende, oder eine große
	  Brennweite, oder beides. Je größer also der
	  f&#8211;Wert ist, um so länger muß die
	  Belichtungszeit sein.</p><p>Des weiteren sind der Lochblendendurchmesser und die
	  Brennweite eindimensionale Meßgrößen,
	  während der Film und die Lochblende an sich
	  zweidimensionale Objekte darstellen. Das bedeutet, wenn
	  man für einen f&#8211;Wert <code class="varname">A</code>
	  eine Belichtungsdauer <code class="varname">t</code> bestimmt hat,
	  dann ergibt sich daraus für einen f&#8211;Wert
	  <code class="varname">B</code> eine Belichtungszeit von:</p><pre class="programlisting">    t * (B / A)²</pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-normalized-f-number"></a>11.13.2.5. Normalisierte f&#8211;Werte</h4></div></div></div><p>Während heutige moderne Kameras den Durchmesser
	  der Lochblende, und damit deren f&#8211;Wert, weich und
	  schrittweise verändern können, war dies
	  früher nicht der Fall.</p><p>Um unterschiedliche f&#8211;Werte einstellen zu
	  können, besaßen Kameras typischerweise eine
	  Metallplatte mit Löchern unterschiedlichen
	  Durchmessers als Lochblende.</p><p>Die Durchmesser wurden entsprechend obiger Formel
	  gewählt, daß der resultierende f&#8211;Wert
	  ein fester Standardwert war, der für alle Kameras
	  verwendet wurde. Z.B. hat eine sehr alte Kodak Duaflex
	  IV Kamera in meinem Besitz drei solche Löcher
	  für die f&#8211;Werte 8, 11 und 16.</p><p>Eine neuere Kamera könnte f&#8211;Werte wie 2.8,
	  4, 5.6, 8, 11, 16, 22, und 32 (und weitere) besitzen.
	  Diese Werte wurden nicht zufällig ausgewählt:
	  Sie sind alle vielfache der Quadratwurzel aus 2, wobei
	  manche Werte gerundet wurden.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-f-stop"></a>11.13.2.6. Der f&#8211;Stopp</h4></div></div></div><p>Eine typische Kamera ist so konzipiert, daß die
	  Nummernscheibe bei den normalisierten f&#8211;Werten
	  einrastet. Die Nummernscheibe <span class="emphasis"><em>stoppt</em></span>
	  an diesen Positionen. Daher werden diese Positionen auch
	  f&#8211;Stopps genannt.</p><p>Da die f&#8211;Werte bei jedem Stopp vielfache der
	  Quadratwurzel aus 2 sind, verdoppelt die Drehung der
	  Nummernscheibe um einen Stopp die für die gleiche
	  Belichtung benötigte Lichtmenge. Eine Drehung
	  um 2 Stopps vervierfacht die benötigte Belichtungszeit.
	  Eine Drehung um 3 Stopps verachtfacht sie, etc.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-software"></a>11.13.3. Entwurf der Lochblenden-Software</h3></div></div></div><p>Wir können jetzt festlegen, was genau unsere
	Lochblenden-Software tun soll.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="xpinhole-processing-input"></a>11.13.3.1. Verarbeitung der Programmeingaben</h4></div></div></div><p>Da der Hauptzweck des Programms darin besteht, uns
	  beim Entwurf einer funktionierenden Lochkamera zu
	  helfen, wird die <span class="emphasis"><em>Brennweite</em></span>
	  die Programmeingabe sein. Dies ist etwas, das wir ohne
	  zusätzliche Programme feststellen können:
	  Die geeignete Brennweite ergibt sich aus der
	  Größe des Films und der Art des Fotos, ob
	  dieses ein "normales" Bild, ein Weitwinkelbild oder
	  ein Telebild sein soll.</p><p>Die meisten bisher geschriebenen Programme arbeiteten
	  mit einzelnen Zeichen, oder Bytes, als Eingabe: Das
	  <span class="application">hex</span>-Programm konvertierte
	  einzelne Bytes in hexadezimale Werte, das
	  <span class="application">csv</span>-Programm ließ entweder
	  einzelne Zeichen unverändert, löschte oder
	  veränderte sie, etc.</p><p>Das Programm <span class="application">ftuc</span> verwendete
	  einen Zustandsautomaten, um höchstens zwei gleichzeitig
	  eingegebene Bytes zu verarbeiten.</p><p>Das <span class="application">pinhole</span>-Programm dagegen
	  kann nicht nur mit einzelnen Zeichen arbeiten, sondern
	  muß mit größeren syntaktischen Einheiten
	  zurrecht kommen.</p><p>Wenn wir z.B. möchten, daß unser Programm den
	  Lochblendendurchmesser (und weitere Werte, die wir
	  später noch diskutieren werden) für die Brennweiten
	  <code class="constant">100 mm</code>, <code class="constant">150 mm</code> und
	  <code class="constant">210 mm</code> berechnet, wollen wir etwa
	  folgendes eingeben:</p><pre class="screen"><strong class="userinput"><code>100, 150, 210</code></strong></pre><p>Unser Programm muß mit der gleichzeitigen Eingabe
	  von mehr als nur einem einzelnen Byte zurecht kommen. Wenn
	  es eine <code class="constant">1</code> erkennt, muß es wissen,
	  daß dies die erste Stelle einer dezimalen Zahl ist.
	  Wenn es eine <code class="constant">0</code>, gefolgt von einer
	  weiteren <code class="constant">0</code> sieht, muß es wissen,
	  daß dies zwei unterschiedliche Stellen mit der
	  gleichen Zahl sind.</p><p>Wenn es auf das erste Komma trifft, muß es wissen,
	  daß die folgenden Stellen nicht mehr zur ersten
	  Zahl gehören. Es muß die Stellen der ersten
	  Zahl in den Wert <code class="constant">100</code> konvertieren
	  können. Und die Stellen der zweiten Zahl müssen
	  in den Wert <code class="constant">150</code> konvertiert werden.
	  Und die Stellen der dritten Zahl müssen in den Wert
	  <code class="constant">210</code> konvertiert werden.</p><p>Wir müssen festlegen, welche Trennsymbole
	  zulässig sind: Sollen die Eingabewerte durch Kommas
	  voneinander getrennt werden? Wenn ja, wie sollen zwei
	  Zahlen behandelt werden, die durch ein anderes Zeichen
	  getrennt sind?</p><p>Ich persönlich mag es einfach. Entweder etwas ist
	  eine Zahl, dann wird es verarbeitet, oder es ist keine
	  Zahl, dann wird es verworfen. Ich mag es nicht, wenn sich der
	  Computer bei der <span class="emphasis"><em>offensichtlichen</em></span>
	  Eingabe eines zusätzlichen Zeichens beschwert.
	  Duh!</p><p>Zusätzlich erlaubt es mir, die Monotonie des
	  Tippens zu durchbrechen, und eine Anfrage anstelle einer
	  simplen Zahl zu stellen:</p><pre class="screen"><strong class="userinput"><code>Was ist der beste Lochblendendurchmesser
	  bei einer Brennweite von 150?</code></strong></pre><p>Es gibt keinen Grund dafür, die Ausgabe mehrerer
	  Fehlermeldungen aufzuteilen:</p><pre class="screen">Syntax error: Was
Syntax error: ist
Syntax error: der
Syntax error: beste</pre><p>Et cetera, et cetera, et cetera.</p><p>Zweitens mag ich das <code class="constant">#</code>-Zeichen, um
	  Kommentare zu markieren, die ab dem Zeichen bis zum Ende der
	  jeweiligen Zeile gehen. Dies verlangt nicht viel
	  Programmieraufwand, und ermöglicht es mir, Eingabedateien
	  für meine Programme als ausführbare Skripte zu
	  handhaben.</p><p>In unserem Fall müssen wir auch entscheiden, in
	  welchen Einheiten die Dateneingabe erfolgen soll: Wir
	  wählen <span class="emphasis"><em>Millimeter</em></span>, da die meisten
	  Photographen die Brennweite in dieser Einheit messen.</p><p>Letztendlich müssen wir noch entscheiden, ob wir die
	  Verwendung des dezimalen Punktes erlauben (in diesem Fall
	  müssen wir berücksichtigen, daß in vielen
	  Ländern der Welt das dezimale <span class="emphasis"><em>Komma</em></span>
	  verwendet wird).</p><p>In unserem Fall würde das Zulassen eines dezimalen
	  Punktes/Kommas zu einer fälschlicherweise angenommenen,
	  höheren Genauigkeit führen: Der Unterschied
	  zwischen den Brennweiten <code class="constant">50</code> und
	  <code class="constant">51</code> ist fast nicht wahrnehmbar. Die
	  Zulassung von Eingaben wie <code class="constant">50.5</code> ist
	  also keine gute Idee. Beachten Sie bitte, das dies meine
	  Meinung ist. In diesem Fall bin ich der Autor des Programmes.
	  Bei Ihren eigenen Programmen müssen Sie selbst solche
	  Entscheidungen treffen.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-options"></a>11.13.3.2. Optionen anbieten</h4></div></div></div><p>Das wichtigste, was wir zum Bau einer Lochkamera
	  wissen müssen, ist der Durchmesser der Lochblende. Da
	  wir scharfe Bilder schießen wollen, werden wir obige
	  Formel für die Berechnung des korrekten Durchmessers zu
	  gegebener Brennweite verwenden. Da Experten mehrere
	  Werte für die <code class="constant">PC</code>-Konstante
	  anbieten, müssen wir uns hier für einen Wert
	  entscheiden.</p><p>In der Programmierung unter <span class="trademark">UNIX</span>® ist es üblich,
	  zwei Hauptvarianten anzubieten, um Parameter an Programme zu
	  übergeben, und des weiteren eine Standardeinstellung
	  für den Fall zu haben, das der Benutzer gar keine
	  Parameter angibt.</p><p>Warum zwei Varianten, Parameter anzugeben?</p><p>Ein Grund ist, eine (relativ) <span class="emphasis"><em>feste</em></span>
	  Einstellung anzubieten, die automatisch bei jedem
	  Programmaufruf verwendet wird, ohne das wir diese
	  Einstellung immer und immer wieder mit angeben
	  müssen.</p><p>Die feste Einstellung kann in einer Konfigurationsdatei
	  gespeichert sein, typischerweise im Heimatverzeichnis des
	  Benutzers. Die Datei hat üblicherweise denselben Namen
	  wie das zugehörige Programm, beginnt jedoch mit einem
	  Punkt. Häufig wird <span class="emphasis"><em>"rc"</em></span> dem
	  Dateinamen hinzugefügt. Unsere Konfigurationsdatei
	  könnte also <code class="filename">~/.pinhole</code> oder
	  <code class="filename">~/.pinholerc</code> heißen. (Die
	  Zeichenfolge <code class="filename">~/</code> steht für das
	  Heimatverzeichnis des aktuellen Benutzers.)</p><p>Konfigurationsdateien werden häufig von Programmen
	  verwendet, die viele konfigurierbare Parameter besitzen.
	  Programme, die nur eine (oder wenige) Parameter anbieten,
	  verwenden häufig eine andere Methode: Sie erwarten die
	  Parameter in einer <span class="emphasis"><em>Umgebungsvariablen</em></span>.
	  In unserem Fall könnten wir eine Umgebungsvariable mit
	  dem Namen <code class="varname">PINHOLE</code> benutzen.</p><p>Normalerweise verwendet ein Programm entweder die eine,
	  oder die andere der beiden obigen Methoden. Ansonsten
	  könnte ein Programm verwirrt werden, wenn eine
	  Konfigurationsdatei das eine sagt, die Umgebungsvariable
	  jedoch etwas anderes.</p><p>Da wir nur <span class="emphasis"><em>einen</em></span> Parameter
	  unterstützen müssen, verwenden wir die zweite
	  Methode, und benutzen eine Umgebungsvariable mit dem
	  Namen <code class="varname">PINHOLE</code>.</p><p>Der andere Weg erlaubt uns, <span class="emphasis"><em>ad hoc</em></span>
	  Entscheidungen zu treffen: <span class="emphasis"><em>"Obwohl ich
	  normalerweise einen Wert von 0.039 verwende, will ich dieses
	  eine Mal einen Wert von 0.03872 anwenden."</em></span>
	  Mit anderen Worten, dies erlaubt uns, die Standardeinstellung
	  außer Kraft zu setzen.</p><p>Diese Art der Auswahl wird häufig über
	  Kommandozeilenparameter gemacht.</p><p>Schließlich braucht ein Programm
	  <span class="emphasis"><em>immer</em></span> eine
	  <span class="emphasis"><em>Standardeinstellung</em></span>. Der Benutzer
	  könnte keine Parameter angeben. Vielleicht weiß
	  er auch gar nicht, was er einstellen sollte. Vielleicht will
	  er es "einfach nur ausprobieren". Vorzugsweise wird die
	  Standardeinstellung eine sein, die die meisten Benutzer
	  sowieso wählen würden. Somit müssen diese
	  keine zusätzlichen Parameter angeben, bzw. können
	  die Standardeinstellung ohne zusätzlichen Aufwand
	  benutzen.</p><p>Bei diesem System könnte das Programm
	  widersprüchliche Optionen vorfinden, und auf die
	  folgende Weise reagieren:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Wenn es eine <span class="emphasis"><em>ad
	      hoc</em></span>-Einstellung vorfindet (z.B. ein
	      Kommandozeilenparameter), dann sollte es diese
	      Einstellung annehmen. Es muß alle vorher
	      festgelegten sowie die standardmäßige
	      Einstellung ignorieren.</p></li><li class="step"><p><span class="emphasis"><em>Andererseits</em></span>, wenn es eine
	      festgelegte Option (z.B. eine Umgebungsvariable)
	      vorfindet, dann sollte es diese akzeptieren und die
	      Standardeinstellung ignorieren.</p></li><li class="step"><p><span class="emphasis"><em>Ansonsten</em></span> sollte es die
	      Standardeinstellung verwenden.</p></li></ol></div><p>Wir müssen auch entscheiden, welches
	  <span class="emphasis"><em>Format</em></span> unsere
	  <code class="constant">PC</code>-Option haben soll.</p><p>Auf den ersten Blick scheint es einleuchtend, das
	  Format <code class="varname">PINHOLE=0.04</code> für die
	  Umgebungsvariable, und <em class="parameter"><code>-p0.04</code></em>
	  für die Kommandozeile zu verwenden.</p><p>Dies zuzulassen wäre eigentlich eine
	  Sicherheitslücke. Die <code class="constant">PC</code>-Konstante
	  ist eine sehr kleine Zahl. Daher würden wir unsere
	  Anwendung mit verschiedenen, kleinen Werten für
	  <code class="constant">PC</code> testen. Aber was würde
	  passieren, wenn jemand das Programm mit einem sehr
	  großen Wert aufrufen würde?</p><p>Es könnte abstürzen, weil wir das Programm
	  nicht für den Umgang mit großen Werten
	  entworfen haben.</p><p>Oder wir investieren noch weiter Zeit in das Programm,
	  so daß dieses dann auch mit großen Zahlen
	  umgehen kann. Wir könnten dies machen, wenn wir
	  kommerzielle Software für computertechnisch
	  unerfahrene Benutzer schreiben würden.</p><p>Oder wir könnten auch sagen <span class="emphasis"><em>"Pech gehabt!
	  Der Benutzer sollte es besser wissen."</em></span></p><p>Oder wir könnten es für den Benutzer
	  unmöglich machen, große Zahlen einzugeben. Dies
	  ist die Variante, die wir verwenden werden: Wir nehmen einen
	  <span class="emphasis"><em>impliziten 0.</em></span>-Präfix an.</p><p>Mit anderen Worten, wenn der Benutzer den Wert
	  <code class="constant">0.04</code> angeben will, so muß er
	  entweder <em class="parameter"><code>-p04</code></em> als Parameter angeben,
	  oder <code class="varname">PINHOLE=04</code> als Variable in seiner
	  Umgebung definieren. Falls der Benutzer
	  <em class="parameter"><code>-p9999999</code></em> angibt, so wird dies als
	  <code class="constant">0.9999999</code> interpretiert&#8212;zwar
	  immer noch sinnlos, aber zumindest sicher.</p><p>Zweitens werden viele Benutzer einfach die Konstanten
	  von Bender oder Connors benutzen wollen. Um es diesen
	  Benutzern einfacher zu machen, werden wir
	  <em class="parameter"><code>-b</code></em> als <em class="parameter"><code>-p04</code></em>,
	  und <em class="parameter"><code>-c</code></em> als
	  <em class="parameter"><code>-p037</code></em> interpretieren.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-output"></a>11.13.3.3. Die Ausgabe</h4></div></div></div><p>Wir müssen festlegen, was und in welchem Format
	  unsere Anwendung Daten ausgeben soll.</p><p>Da wir als Eingabe beliebig viele Brennweiten
	  erlauben, macht es Sinn, die Ergebnisse in Form
	  einer traditionellen Datenbank&#8211;Ausgabe darzustellen,
	  bei der zeilenweise zu jeder Brennweite der
	  zugehörige berechnete Wert, getrennt durch ein
	  <code class="constant">tab</code>-Zeichen, ausgegeben wird.</p><p>Optional sollten wir dem Benutzer die Möglichkeit
	  geben, die Ausgabe in dem schon beschriebenen
	  <acronym class="acronym">CSV</acronym>-Format festzulegen. In diesem Fall
	  werden wir zu Beginn der Ausgabe eine Zeile einfügen,
	  in der die Beschreibungen der einzelnen Felder, durch
	  Kommas getrennt, aufgelistet werden, gefolgt von der Ausgabe
	  der Daten wie schon beschrieben, wobei das
	  <code class="constant">tab</code>-Zeichen durch ein
	  <code class="constant">Komma</code> ersetzt wird.</p><p>Wir brauchen eine Kommandozeilenoption für das
	  <acronym class="acronym">CSV</acronym>-Format. Wir können nicht
	  <em class="parameter"><code>-c</code></em> verwenden, da diese Option bereits
	  für <span class="emphasis"><em>verwende Connors Konstante</em></span>
	  steht. Aus irgendeinem seltsamen Grund bezeichnen
	  viele Webseiten <acronym class="acronym">CSV</acronym>-Dateien als
	  <span class="emphasis"><em>"Excel Kalkulationstabelle"</em></span> (obwohl das
	  <acronym class="acronym">CSV</acronym>-Format älter ist als Excel). Wir
	  werden daher <em class="parameter"><code>-e</code></em> als Schalter für
	  die Ausgabe im <acronym class="acronym">CSV</acronym>-Format
	  verwenden.</p><p>Jede Zeile der Ausgabe wird mit einer Brennweite
	  beginnen. Dies mag auf den ersten Blick überflüssig
	  erscheinen, besonders im interaktiven Modus: Der Benutzer
	  gibt einen Wert für die Brennweite ein, und das Programm
	  wiederholt diesen.</p><p>Der Benutzer kann jedoch auch mehrere Brennweiten
	  in einer Zeile angeben. Die Eingabe kann auch aus einer Datei,
	  oder aus der Ausgabe eines anderen Programmes, kommen. In
	  diesen Fällen sieht der Benutzer die Eingabewerte
	  überhaupt nicht.</p><p>Ebenso kann die Ausgabe in eine Datei umgelenkt werden,
	  was wir später noch untersuchen werden, oder sie
	  könnte an einen Drucker geschickt werden, oder auch
	  als Eingabe für ein weiteres Programm dienen.</p><p>Es macht also wohl Sinn, jede Zeile mit einer durch den
	  Benutzer eingegebenen Brennweite beginnen zu lassen.</p><p>Halt! Nicht, wie der Benutzer die Daten eingegeben hat.
	  Was passiert, wenn der Benutzer etwas wie folgt
	  eingibt:</p><pre class="screen"><strong class="userinput"><code>00000000150</code></strong></pre><p>Offensichtlich müssen wir die führenden Nullen
	  vorher abschneiden.</p><p>Wir müssen also die Eingabe des Benutzers
	  sorgfältig prüfen, diese dann in der
	  <acronym class="acronym">FPU</acronym> in die binäre Form konvertieren,
	  und dann von dort aus ausgeben.</p><p>Aber...</p><p>Was ist, wenn der Benutzer etwas wie folgt eingibt:</p><pre class="screen"><strong class="userinput"><code>17459765723452353453534535353530530534563507309676764423</code></strong></pre><p>Ha! Das packed decimal-Format der <acronym class="acronym">FPU</acronym>
	  erlaubt uns die Eingabe einer 18&#8211;stelligen
	  Zahl. Aber der Benutzer hat mehr als 18 Stellen eingegeben.
	  Wie gehen wir damit um?</p><p>Wir <span class="emphasis"><em>könnten</em></span> unser Programm
	  so modifizieren, daß es die ersten 18 Stellen liest,
	  der <acronym class="acronym">FPU</acronym> übergibt, dann weitere
	  18 Stellen liest, den Inhalt des <acronym class="acronym">TOS</acronym>
	  mit einem Vielfachen von 10, entsprechend der Anzahl der
	  zusätzlichen Stellen multipliziert, und dann beide
	  Werte mittels <code class="function">add</code> zusammen
	  addiert.</p><p>Ja, wir könnten das machen. Aber in
	  <span class="emphasis"><em>diesem</em></span> Programm wäre es
	  unnötig (in einem anderen wäre es vielleicht
	  der richtige Weg): Selbst der Erdumfang in Millimetern ergibt
	  nur eine Zahl mit 11 Stellen. Offensichtlich können wir
	  keine Kamera dieser Größe bauen (jedenfalls jetzt
	  noch nicht).</p><p>Wenn der Benutzer also eine so große Zahl eingibt,
	  ist er entweder gelangweilt, oder er testet uns, oder er
	  versucht, in das System einzudringen, oder er spielt&#8212;
	  indem er irgendetwas anderes macht als eine Lochkamera
	  zu entwerfen.</p><p>Was werden wir tun?</p><p>Wir werden ihn ohrfeigen, gewissermaßen:</p><pre class="screen">17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</pre><p>Um dies zu erreichen, werden wir einfach alle
	  führenden Nullen ignorieren. Sobald wir eine Ziffer
	  gefunden haben, die nicht Null ist, initialisieren wir
	  einen Zähler mit <code class="constant">0</code> und
	  beginnen mit drei Schritten:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Sende die Ziffer an die Ausgabe.</p></li><li class="step"><p>Füge die Ziffer einem Puffer hinzu, welchen wir
	      später benutzen werden, um den packed decimal-Wert
	      zu erzeugen, den wir an die
	      <acronym class="acronym">FPU</acronym> schicken können.</p></li><li class="step"><p>Erhöhe den Zähler um eins.</p></li></ol></div><p>Während wir diese drei Schritte wiederholen,
	  müssen wir auf zwei Bedingungen achten:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Wenn der Zähler den Wert 18 übersteigt,
	      hören wir auf, Ziffern dem Puffer hinzuzufügen.
	      Wir lesen weiterhin Ziffern und senden sie an die
	      Ausgabe.</p></li><li class="listitem"><p>Wenn, bzw. <span class="emphasis"><em>falls</em></span>, das
	      nächste Eingabezeichen keine Zahl ist, sind wir mit
	      der Bearbeitung der Eingabe erst einmal fertig.</p><p>Übrigends können wir einfach Zeichen, die
	      keine Ziffern sind, verwerfen, solange sie kein
	      <code class="constant">#</code>-Zeichen sind, welches wir an den
	      Eingabestrom zurückgeben müssen. Dieses Zeichen
	      markiert den Beginn eines Kommentars. An dieser Stelle
	      muß die Erzeugung der Ausgabe fertig sein, und wir
	      müssen mit der Suche nach weiteren Eingabedaten
	      fortfahren.</p></li></ul></div><p>Es bleibt immer noch eine Möglichkeit
	  unberücksichtigt: Wenn der Benutzer eine Null (oder
	  mehrere) eingibt, werden wir niemals eine von Null
	  verschiedene Zahl vorfinden.</p><p>Wir können solch einen Fall immer anhand des
	  Zählerstandes feststellen, welcher dann
	  immer bei <code class="constant">0</code> bleibt. In diesem Fall
	  müssen wir einfach eine <code class="constant">0</code> an
	  die Ausgabe senden, und anschließend dem Benutzer
	  erneut eine "Ohrfeige" verpassen:</p><pre class="screen">0	???	???	???	???	???</pre><p>Sobald wir die Brennweite ausgegeben, und die
	  Gültigkeit dieser Eingabe verifiziert haben,
	  (größer als <code class="constant">0</code> und kleiner
	  als 18 Zahlen) können wir den Durchmesser der
	  Lochblende berechnen.</p><p>Es ist kein Zufall, daß
	  <span class="emphasis"><em>Lochblende</em></span> das Wort
	  <span class="emphasis"><em>Loch</em></span> enthält. In der Tat ist eine
	  Lochblende buchstäblich eine
	  <span class="emphasis"><em>Loch Blende</em></span>, also eine Blende, in die
	  mit einer Nadel vorsichtig ein kleines Loch gestochen
	  wird.</p><p>Daher ist eine typische Lochblende sehr klein. Unsere
	  Formel liefert uns das Ergebnis in Millimetern. Wir werden
	  dieses mit <code class="constant">1000</code> multiplizieren, so
	  daß die Ausgabe in <code class="constant">Mikrometern</code>
	  erfolgt.</p><p>An dieser Stelle müssen wir auf eine weitere Falle
	  achten: <span class="emphasis"><em>Zu hohe Genauigkeit.</em></span></p><p>Ja, die <acronym class="acronym">FPU</acronym> wurde für
	  mathematische Berechnungen mit hoher Genauigkeit entworfen.
	  Unsere Berechnungen hier erfordern jedoch keine solche
	  mathematische Genauigkeit. Wir haben es hier mit Physik zu
	  tun (Optik, um genau zu sein).</p><p>Angenommen, wir wollten aus eine Lastkraftwagen eine
	  Lochkamera bauen (wir wären dabei nicht die
	  ersten, die das versuchen würden!). Angenommen, die
	  Länge des Laderaumes beträgt <code class="constant">12</code>
	  Meter lang, so daß wir eine Brennweite von
	  <code class="constant">12000</code> hätten. Verwenden wir
	  Benders Konstante, so erhalten wir durch Multiplizieren
	  von <code class="constant">0.04</code> mit der Quadratwurzel aus
	  <code class="constant">12000</code> einen Wert von
	  <code class="constant">4.381780460</code> Millimetern, oder
	  <code class="constant">4381.780460</code> Micrometern.</p><p>So oder so ist das Rechenergebnis absurd präzise.
	  Unser Lastkraftwagen ist nicht <span class="emphasis"><em>genau</em></span>
	  <code class="constant">12000</code> Millimeter lang. Wir haben
	  diese Länge nicht mit einer so hohen Genauigkeit
	  gemessen, weswegen es falsch wäre zu behaupten,
	  unser Lochblendendurchmesser müsse exakt
	  <code class="constant">4.381780460</code> Millimeter sein. Es
	  reicht vollkommen aus, wenn der Durchmesser
	  <code class="constant">4.4</code> Millimeter beträgt.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Ich habe in obigem Beispiel das Rechenergebnis "nur"
	    auf 10 Stellen genau angegeben. Stellen Sie sich vor,
	    wie absurd es wäre, die vollen uns zur Verfügung
	    stehenden, 18 Stellen anzugeben!</p></div><p>Wir müssen also die Anzahl der signifikanten Stellen
	  beschränken. Eine Möglichkeit wäre, die
	  Mikrometer durch eine ganze Zahl darzustellen. Unser
	  Lastkraftwaren würde dann eine Lochblende mit einem
	  Durchmesser von <code class="constant">4382</code> Mikrometern
	  benötigen. Betrachten wir diesen Wert, dann stellen wir
	  fest, das <code class="constant">4400</code> Mikrometer, oder
	  <code class="constant">4.4</code> Millimeter, immer noch genau
	  genug ist.</p><p>Zusätzlich können wir noch, unabhängig von
	  der Größe eines Rechenergebnisses, festlegen,
	  daß wir nur vier signifikante Stellen anzeigen wollen
	  (oder weniger). Leider bietet uns die <acronym class="acronym">FPU</acronym>
	  nicht die Möglichkeit, das Ergebnis automatisch bis
	  auf eine bestimmte Stelle zu runden (sie sieht die Daten ja
	  nicht als Zahlen, sondern als binäre Daten an).</p><p>Wir müssen also selber einen Algorithmus entwerfen,
	  um die Anzahl der signifikanten Stellen zu reduzieren.</p><p>Hier ist meiner (ich denke er ist peinlich&#8212;wenn
	  Ihnen ein besserer Algorithmus einfällt, verraten sie
	  ihn mir <span class="emphasis"><em>bitte</em></span>):</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Initialisiere einen Zähler mit
	      <code class="constant">0</code>.</p></li><li class="step"><p>Solange die Zahl größer oder gleich
	      <code class="constant">10000</code> ist, dividiere die Zahl durch
	      <code class="constant">10</code>, und erhöhe den Zähler
	      um eins.</p></li><li class="step"><p>Gebe das Ergebnis aus.</p></li><li class="step"><p>Solange der Zähler größer als
	      <code class="constant">0</code> ist, gebe eine
	      <code class="constant">0</code> aus, und reduziere den Zähler
	      um eins.</p></li></ol></div><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Der Wert <code class="constant">10000</code> ist nur für
	    den Fall, daß Sie <span class="emphasis"><em>vier</em></span>
	    signifikante Stellen haben wollen. Für eine andere
	    Anzahl signifikanter Stellen müssen Sie den Wert
	    <code class="constant">10000</code> mit <code class="constant">10</code>,
	    hoch der Anzahl der gewünschten signifikanten Stellen,
	    ersetzen.</p></div><p>Wir können so den Lochblendendurchmesser, auf vier
	  signifikante Stellen gerundet, ausgeben.</p><p>An dieser Stellen kennen wir nun die <span class="emphasis"><em>Brennweite
	  </em></span> und den
	  <span class="emphasis"><em>Lochblendendurchmesser</em></span>. Wir haben also
	  jetzt genug Informationen, um den
	  <span class="emphasis"><em>f&#8211;Wert</em></span> zu bestimmen.</p><p>Wir werden den f&#8211;Wert, auf vier signifikante
	  Stellen gerundet, ausgeben. Es könnte passieren,
	  daß diese vier Stellen recht wenig aussagen. Um die
	  Aussagekraft des f&#8211;Wertes zu erhöhen, könnten
	  wir den nächstliegenden, <span class="emphasis"><em>normalisierten
	  f&#8211;Wert</em></span> bestimmen, also z.B. das
	  nächstliegende Vielfache der Quadratwurzel aus 2.</p><p>Wir erreichen dies, indem wir den aktuellen f&#8211;Wert
	  mit sich selbst multiplizieren, so daß wir dessen
	  Quadrat (<code class="function">square</code>) erhalten.
	  Anschließend berechnen wir den Logarithmus zur Basis 2
	  von dieser Zahl. Dies ist sehr viel einfacher, als direkt den
	  Logarithmus zur Basis der Quadratwurzel aus 2 zu berechnen!
	  Wir runden dann das Ergebnis auf die nächstliegende
	  ganze Zahl. Genau genommen können wir mit Hilfe der
	  <acronym class="acronym">FPU</acronym> diese Berechnung beschleunigen: Wir
	  können den op-Code
	  <code class="function">fscale</code> verwenden, um eine
	  Zahl um 1 zu "skalieren", was dasselbe ist, wie eine Zahl
	  mittels <code class="function">shift</code> um eine
	  Stelle nach links zu verschieben. Am Ende berechnen wir noch
	  die Quadratwurzel aus allem, und erhalten dann den
	  nächstliegenden, normalisierten f&#8211;Wert.</p><p>Wenn das alles jetzt viel zu kompliziert wirkt&#8212;oder
	  viel zu aufwendig&#8212;wird es vielleicht klarer, wenn man
	  den Code selber betrachtet. Wir benötigen insgesamt
	  9 op-Codes:</p><pre class="programlisting">fmul    st0, st0
    fld1
    fld     st1
    fyl2x
    frndint
    fld1
    fscale
    fsqrt
    fstp    st1</pre><p>Die erste Zeile,
	  <code class="function">fmul st0, st0</code>, quadriert
	  den Inhalt des <acronym class="acronym">TOS</acronym> (Top Of Stack, was
	  dasselbe ist wie <code class="varname">st</code>, von
	  <span class="application">nasm</span> auch
	  <code class="varname">st0</code> genannt). Die Funktion
	  <code class="function">fld1</code> fügt eine
	  <code class="constant">1</code> dem <acronym class="acronym">TOS</acronym>
	  hinzu.</p><p>Die nächste Zeile, <code class="function">fld
	  st1</code>, legt das Quadrat auf dem
	  <acronym class="acronym">TOS</acronym> ab. An diesem Punkt befindet sich das
	  Quadrat sowohl in <code class="varname">st</code> als
	  auch in <code class="varname">st(2)</code> (es wird
	  sich gleich zeigen, warum wir eine zweite Kopie auf dem
	  Stack lassen.) <code class="varname">st(1)</code>
	  enthält die <code class="constant">1</code>.</p><p>Im nächsten Schritt, <code class="function">fyl2x</code>, wird der Logarithmus von
	  <code class="varname">st</code> zur Basis 2 berechnet,
	  und anschließend mit <code class="varname">st(1)</code> multipliziert. Deshalb haben
	  wir vorher die <code class="constant">1</code> in <code class="varname">st(1)</code> abgelegt.</p><p>An dieser Stelle enthält
	  <code class="varname">st</code> den gerade berechneten
	  Logarithmus, und <code class="varname">st(1)</code>
	  das Quadrat des aktuellen f&#8211;Wertes, den wir für
	  später gespeichert haben.</p><p><code class="function">frndint</code> rundet den
	  <acronym class="acronym">TOS</acronym> zur nächstliegenden ganzen Zahl.
	  <code class="function">fld1</code> legt eine
	  <code class="constant">1</code> auf dem Stack ab.
	  <code class="function">fscale</code> shiftet die
	  <code class="constant">1</code> auf dem <acronym class="acronym">TOS</acronym> um
	  <code class="varname">st(1)</code> Stellen, wodurch im
	  Endeffekt eine 2 in <code class="varname">st(1)</code>
	  steht.</p><p>Schließlich berechnet
	  <code class="function">fsqrt</code> die Quadratwurzel
	  des Rechenergebnisses, also des nächstliegenden,
	  normalisierten f&#8211;Wertes.</p><p>Wir haben nun den nächstliegenden, normalisierten
	  f&#8211;Wert auf dem <acronym class="acronym">TOS</acronym> liegen, den auf
	  den Logarithmus zur Basis 2 gerundeten, nächstliegenden
	  ganzzahligen Wert in <code class="varname">st(1)</code>, und das Quadrat des
	  aktuellen f&#8211;Wertes in <code class="varname">st(2)</code>. Wir speichern den Wert
	  für eine spätere Verwendung in <code class="varname">st(2)</code>.</p><p>Aber wir brauchen den Inhalt von
	  <code class="varname">st(1)</code> gar nicht mehr. Die
	  letzte Zeile, <code class="function">fstp st1</code>,
	  platziert den Inhalt von <code class="varname">st</code>
	  in <code class="varname">st(1)</code>, und erniedrigt
	  den Stackpointer um eins. Dadurch ist der Inhalt von
	  <code class="varname">st(1)</code> jetzt
	  <code class="varname">st</code>, der Inhalt von
	  <code class="varname">st(2)</code> jetzt
	  <code class="varname">st(1)</code> usw. Der neue
	  <code class="varname">st</code> speichert jetzt den
	  normalisierten f&#8211;Wert. Der neue
	  <code class="varname">st(1)</code> speichert das
	  Quadrat des aktuellen f&#8211;Wertes für die
	  Nachwelt.</p><p>Jetzt können wir den normalisierten f&#8211;Wert
	  ausgeben. Da er normalisiert ist, werden wir ihn nicht auf
	  vier signifikante Stellen runden, sondern stattdessen
	  mit voller Genauigkeit ausgeben.</p><p>Der normalisierte f&#8211;Wert ist nützlich, solange
	  er so klein ist, daß wir ihn auf einem Photometer
	  wiederfinden können. Ansonsten brauchen wir eine andere
	  Methode, um die benötigten Belichtungsdaten zu
	  bestimmen.</p><p>Wir haben weiter oben eine Formel aufgestellt, über
	  die wir einen f&#8211;Wert mit Hilfe eines anderen
	  f&#8211;Wertes und den zugehörigen Belichtungsdaten
	  bestimmen können.</p><p>Jedes Photometer, das ich jemals gesehen habe, konnte
	  die benötigte Belichtungszeit für f5.6 berechnen.
	  Wir werden daher einen
	  <span class="emphasis"><em>"f5.6 Multiplizierer"</em></span> berechnen, der
	  uns den Faktor angibt, mit dem wir die bei f5.6 gemessene
	  Belichtungszeit für unsere Lochkamera multiplizieren
	  müssen.</p><p>Durch die Formel wissen wir, daß dieser Faktor
	  durch Dividieren unseres f&#8211;Wertes (der aktuelle Wert,
	  nicht der normalisierte) durch <code class="constant">5.6</code>
	  und anschließendes Quadrieren, berechnen
	  können.</p><p>Mathematisch äquivalent dazu wäre, wenn wir
	  das Quadrat unseres f&#8211;Wertes durch das Quadrat von
	  <code class="constant">5.6</code> dividieren würden.</p><p>Numerisch betrachtet wollen wir nicht zwei Zahlen
	  quadrieren, wenn es möglich ist, nur
	  eine Zahl zu quadrieren. Daher wirkt die erste Variante
	  auf den ersten Blick besser.</p><p>Aber...</p><p><code class="constant">5.6</code> ist eine
	  <span class="emphasis"><em>Konstante</em></span>. Wir müssen nicht
	  wertvolle Rechenzeit der <acronym class="acronym">FPU</acronym> verschwenden.
	  Es reicht aus, daß wir die Quadrate der einzelnen
	  f&#8211;Werte durch den konstanten Wert
	  <code class="constant">5.6²</code> dividieren. Oder wir
	  können den jeweiligen f&#8211;Wert durch
	  <code class="constant">5.6</code> dividieren, und dann das Ergebnis
	  quadrieren. Zwei Möglichkeiten, die gleich
	  erscheinen.</p><p>Aber das sind sie nicht!</p><p>Erinnern wir uns an die Grundlagen der Photographie
	  weiter oben, dann wissen wir, daß sich die
	  Konstante <code class="constant">5.6</code> aus dem 5-fachen der
	  Quadratwurzel aus 2 ergibt. Eine
	  <span class="emphasis"><em>irrationale</em></span> Zahl. Das Quadrat dieser
	  Zahl ist <span class="emphasis"><em>exakt</em></span>
	  <code class="constant">32</code>.</p><p><code class="constant">32</code> ist nicht nur eine ganze Zahl,
	  sondern auch ein Vielfaches von 2. Wir brauchen also
	  gar nicht das Quadrat eines f&#8211;Wertes durch
	  <code class="constant">32</code> zu teilen. Wir müssen lediglich
	  mittels <code class="function">fscale</code> den
	  f&#8211;Wert um fünf Stellen nach rechts shiften.
	  Aus Sicht der <acronym class="acronym">FPU</acronym> müssen wir also
	  <code class="function">fscale</code> mit
	  <code class="varname">st(1)</code>, welcher gleich
	  <code class="constant">-5</code> ist, auf den f&#8211;Wert anwenden.
	  Dies ist <span class="emphasis"><em>sehr viel schneller</em></span> als die
	  Division.</p><p>Jetzt wird es auch klar, warum wir das Quadrat des
	  f&#8211;Wertes ganz oben auf dem Stack der
	  <acronym class="acronym">FPU</acronym> gespeichert haben. Die Berechnung
	  des f5.6 Multiplizierers ist die einfachste Berechnung
	  des gesamten Programmes! Wir werden das Ergebnis auf vier
	  signifikante Stellen gerundet ausgeben.</p><p>Es gibt noch eine weitere nützliche Zahl, die wir
	  berechnen können: Die Anzahl der Stopps, die unser
	  f&#8211;Wert von f5.6 entfernt ist. Dies könnte
	  hilfreich sein, wenn unser f&#8211;Wert außerhalb des
	  Meßbereiches unseres Photometers liegt, wir aber eine
	  Blende haben, bei der wir unterschiedliche Geschwindigkeiten
	  einstellen können, und diese Blende Stopps
	  benutzt.</p><p>Angenommen, unser f&#8211;Wert ist 5 Stopps von f5.6
	  entfernt, und unser Photometer sagt uns, daß wir eine
	  Belichtungszeit von 1/1000 Sek. einstellen sollen. Dann
	  können wir unsere Blende auf die Geschwindigkeit 1/1000
	  einstellen, und unsere Skala um 5 Stopps verschieben.</p><p>Diese Rechnung ist ebenfalls sehr einfach. Alles, was
	  wir tun müssen, ist, den Logarithmus des f5.6
	  Multiplizierers, den wir schon berechnet haben (wobei wir
	  dessen Wert vor der Rundung nehmen müssen) zur Basis 2
	  zu nehmen. Wir runden dann das Ergebnis zur nächsten
	  ganzen Zahl hin, und geben dies aus. Wir müssen uns
	  nicht darum kümmern, ob wir mehr als vier signifikante
	  Stellen haben: Das Ergebnis besteht
	  höchstwahrscheinlich nur aus einer oder zwei
	  Stellen.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-fpu-optimizations"></a>11.13.4. FPU Optimierungen</h3></div></div></div><p>In Assemblersprache können wir den Code für die
	<acronym class="acronym">FPU</acronym> besser optimieren, als in einer der
	Hochsprachen, inklusive C.</p><p>Sobald eine C-Funktion die Berechnung einer
	Fließkommazahl durchführen will, lädt sie erst
	einmal alle benötigten Variablen und Konstanten in die
	Register der <acronym class="acronym">FPU</acronym>. Dann werden die
	Berechnungen durchgeführt, um das korrekte Ergebnis zu
	erhalten. Gute C-Compiler können diesen Teil des Codes
	sehr gut optimieren.</p><p>Das Ergebnis wird "zurückgegeben", indem dieses auf
	dem <acronym class="acronym">TOS</acronym> abgelegt wird. Vorher wird
	aufgeräumt. Sämtliche Variablen und Konstanten, die
	während der Berechnung verwendet wurden, werden dabei
	aus der <acronym class="acronym">FPU</acronym> entfernt.</p><p>Was wir im vorherigen Abschnitt selber getan haben, kann so
	nicht durchgeführt werden: Wir haben das Quadrat des
	f&#8211;Wertes berechnet, und das Ergebnis für eine
	weitere Berechnung mit einer anderen Funktion auf dem Stack
	behalten.</p><p>Wir <span class="emphasis"><em>wußten</em></span>, daß wir
	diesen Wert später noch einmal brauchen würden. Wir
	wußten auch, daß auf dem Stack genügend Platz
	war (welcher nur Platz für 8 Zahlen bietet), um den Wert
	dort zu speichern.</p><p>Ein C-Compiler kann nicht wissen, ob ein Wert auf dem
        Stack in naher Zukunft noch einmal gebraucht wird.</p><p>Natürlich könnte der C-Programmierer dies wissen.
	Aber die einzige Möglichkeit, die er hat, ist, den Wert
	im verfügbaren Speicher zu halten.</p><p>Das bedeutet zum einen, daß der Wert mit der
	<acronym class="acronym">FPU</acronym>-internen, 80-stelligen
	Genauigkeit in einer normalen C-Variable vom Typ
	<span class="emphasis"><em>double</em></span> (64 Bit) oder vom Typ
	<span class="emphasis"><em>single</em></span> (32 Bit) gespeichert wird.</p><p>Dies bedeutet außerdem, daß der Wert aus dem
	<acronym class="acronym">TOS</acronym> in den Speicher verschoben werden
	muß, und später wieder zurück. Von allen
	Operationen mit der <acronym class="acronym">FPU</acronym> ist der Zugriff
	auf den Speicher die langsamste.</p><p>Wann immer also mit der <acronym class="acronym">FPU</acronym> in einer
	Assemblersprache programmiert wird, sollte nach
	Möglichkeiten gesucht werden, Zwischenergebnisse auf dem
	Stack der <acronym class="acronym">FPU</acronym> zu lassen.</p><p>Wir können mit dieser Idee noch einen Schritt weiter
	gehen! In unserem Programm verwenden wir eine
	<span class="emphasis"><em>Konstante</em></span> (die wir <code class="constant">PC</code>
	genannt haben).</p><p>Es ist unwichtig, wieviele Lochblendendurchmesser wir
	berechnen: 1, 10, 20, 1000, wir verwenden immer dieselbe
	Konstante. Daher können wir unser Programm so optimieren,
	daß diese Konstante immer auf dem Stack belassen
	wird.</p><p>Am Anfang unseres Programmes berechnen wir die oben
	erwähnte Konstante. Wir müssen die Eingabe für
	jede Dezimalstelle der Konstanten durch <code class="constant">10</code>
	dividieren.</p><p>Multiplizieren geht sehr viel schneller als Dividieren.
	Wir teilen also zu Beginn unseres Programmes
	<code class="constant">1</code> durch <code class="constant">10</code>, um
	<code class="constant">0.1</code> zu erhalten, was wir auf dem Stack
	speichern: Anstatt daß wir nun für jede einzelne
	Dezimalstelle die Eingabe wieder durch <code class="constant">10</code>
	teilen,	multiplizieren wir sie stattdessen mit
	<code class="constant">0.1</code>.</p><p>Auf diese Weise geben wir <code class="constant">0.1</code> nicht
	direkt ein, obwohl wir dies könnten. Dies hat einen Grund:
	Während <code class="constant">0.1</code> durch nur eine einzige
	Dezimalstelle dargestellt werden kann, wissen wir nicht,
	wieviele <span class="emphasis"><em>binäre</em></span> Stellen benötigt
	werden. Wir überlassen die Berechnung des binären
	Wertes daher der <acronym class="acronym">FPU</acronym>, mit dessen eigener,
	hoher Genauigkeit.</p><p>Wir verwenden noch weitere Konstanten: Wir multiplizieren
	den Lochblendendurchmesser mit <code class="constant">1000</code>, um
	den Wert von Millimeter in Micrometer zu konvertieren. Wir
	vergleichen Werte mit <code class="constant">10000</code>, wenn wir
	diese auf vier signifikante Stellen runden wollen. Wir
	behalten also beide Konstanten, <code class="constant">1000</code>
	und <code class="constant">10000</code>, auf dem Stack. Und
	selbstverständlich verwenden wir erneut die gespeicherte
	<code class="constant">0.1</code>, um Werte auf vier signifikante
	Stellen zu runden.</p><p>Zu guter letzt behalten wir <code class="constant">-5</code> noch
	auf dem Stack. Wir brauchen diesen Wert, um das Quadrat des
	f&#8211;Wertes zu skalieren, anstatt diesen durch
	<code class="constant">32</code> zu teilen. Es ist kein Zufall, daß
	wir diese Konstante als letztes laden. Dadurch wird diese
	Zahl die oberste Konstante auf dem Stack. Wenn später
	das Quadrat des f&#8211;Wertes skaliert werden muß,
	befindet sich die <code class="constant">-5</code> in
	<code class="varname">st(1)</code>, also genau da, wo
	die Funktion <code class="function">fscale</code> diesen
	Wert erwartet.</p><p>Es ist üblich, einige Konstanten per Hand zu erzeugen,
	anstatt sie aus dem Speicher zu laden. Genau das machen wir
	mit der <code class="constant">-5</code>:</p><pre class="programlisting">
    	fld1			; TOS =  1
    	fadd	st0, st0	; TOS =  2
    	fadd	st0, st0	; TOS =  4
    	fld1			; TOS =  1
    	faddp	st1, st0	; TOS =  5
    	fchs			; TOS = -5</pre><p>Wir können all diese Optimierungen in einer Regel
	zusammenfassen: <span class="emphasis"><em>Behalte wiederverwendbare Werte auf
	dem Stack!</em></span></p><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml"><span class="emphasis"><em><span class="trademark">PostScript</span>®</em></span> ist eine
	  Stack-orientierte Programmiersprache. Es gibt weit mehr
	  Bücher über <span class="trademark">PostScript</span>®, als über die
	  Assemblersprache der <acronym class="acronym">FPU</acronym>: Werden Sie
	  in <span class="trademark">PostScript</span>® besser, dann werden Sie auch automatisch
	  in der Programmierung der <acronym class="acronym">FPU</acronym>
	  besser.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-the-code"></a>11.13.5. <span class="application">pinhole</span>&#8212;Der Code</h3></div></div></div><pre class="programlisting">
;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	'system.inc'

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	'PINHOLE='	; Exactly 8 bytes, or 2 dwords long
pinhole	db	'04,', 		; Bender's constant (0.04)
connors	db	'037', 0Ah	; Connors' constant
usg	db	'Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]', 0Ah
usglen	equ	$-usg
iemsg	db	"pinhole: Can't open input file", 0Ah
iemlen	equ	$-iemsg
oemsg	db	"pinhole: Can't create output file", 0Ah
oemlen	equ	$-oemsg
pinmsg	db	"pinhole: The PINHOLE constant must not be 0", 0Ah
pinlen	equ	$-pinmsg
toobig	db	"pinhole: The PINHOLE constant may not exceed 18 decimal places", 0Ah
biglen	equ	$-toobig
huhmsg	db	9, '???'
separ	db	9, '???'
sep2	db	9, '???'
sep3	db	9, '???'
sep4	db	9, '???', 0Ah
huhlen	equ	$-huhmsg
header	db	'focal length in millimeters,pinhole diameter in microns,'
	db	'F-number,normalized F-number,F-5.6 multiplier,stops '
	db	'from F-5.6', 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], '-'
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, 'o'
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, 'i'
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, 'p'
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, '0'
	jl	near usage
	cmp	ah, '9'
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, 'c'
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, 'b'
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, 'e'
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, ','
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for "PINHOLE="
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with 'PINHOLE='
	mov	edi, envar
	mov	cl, 2		; 'PINHOLE=' is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, '0'
	jl	.default
	cmp	al, '9'
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], '0'

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, '9'
	ja	.setconst
	cmp	al, '0'
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], ','
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got '#'
	cmp	al, '#'
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, '0'
	jl	.bigloop
	cmp	al, '9'
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, '0'
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0's
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, '#'
	je	.ungetc
	cmp	al, '0'
	jl	.work
	cmp	al, '9'
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, '0'
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, '-'
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print '0' and return
	mov	al, '0'
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, '0'
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, '0'
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, '0'
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, '0'
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, '0'
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</pre><p>Der Code folgt demselben Aufbau wie alle anderen Filter,
	die wir bisher gesehen haben, bis auf eine Kleinigkeit:</p><div class="blockquote"><blockquote class="blockquote"><p>Wir nehmen nun nicht mehr an, daß das Ende
	  der Eingabe auch das Ende der nötigen Arbeit bedeutet,
	  etwas, das wir für <span class="emphasis"><em>zeichenbasierte</em></span>
	  Filter automatisch angenommen haben.</p><p>Dieser Filter verarbeitet keine Zeichen. Er verarbeitet
	  eine <span class="emphasis"><em>Sprache</em></span> (obgleich eine sehr
	  einfache, die nur aus Zahlen besteht).</p><p>Wenn keine weiteren Eingaben vorliegen, kann das zwei
	  Ursachen haben:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Wir sind fertig und können aufhören. Dies
	      ist dasselbe wie vorher.</p></li><li class="listitem"><p>Das Zeichen, das wir eingelesen haben, war eine Zahl.
	      Wir haben diese am Ende unseres <acronym class="acronym">ASCII</acronym>
	      &#8211;zu&#8211;float Kovertierungspuffers gespeichert.
	      Wir müssen nun den gesamten Pufferinhalt in eine
	      Zahl konvertieren, und die letzte Zeile unserer Ausgabe
	      ausgeben.</p></li></ul></div><p>Aus diesem Grund haben wir unsere <code class="function">getchar
	  </code>- und <code class="function">read</code>-Routinen
	  so angepaßt, daß sie das
	  <code class="varname">carry flag</code>
	  <span class="emphasis"><em>clear</em></span> immer dann zurückgeben, wenn
	  wir ein weiteres Zeichen aus der Eingabe lesen, und das
	  <code class="varname">carry flag</code>
	  <span class="emphasis"><em>set</em></span> immer dann zurückgeben, wenn
	  es keine weiteren Eingabedaten gibt.</p><p>Selbstverständlich verwenden wir auch hier die
	  Magie der Assemblersprache! Schauen Sie sich
	  <code class="function">getchar</code> näher an. Dieses gibt
	  <span class="emphasis"><em>immer</em></span> das
	  <code class="varname">carry flag</code>
	  <span class="emphasis"><em>clear</em></span> zurück.</p><p>Dennoch basiert der Hauptteil unseres Programmes auf dem
	  <code class="varname">carry flag</code>, um diesem eine
	  Beendigung mitzuteilen&#8212;und es funktioniert.</p><p>Die Magie passiert in <code class="function">read</code>. Wann
	  immer weitere Eingaben durch das System zur Verfügung
	  stehen, ruft diese Funktion <code class="function">getchar</code>
	  auf, welche ein weiteres Zeichen aus dem Eingabepuffer
	  einliest, und anschließend das
	  <code class="varname">carry flag</code>
	  <span class="emphasis"><em>clear</em></span>t.</p><p>Wenn aber <code class="function">read</code> keine weiteren
	  Eingaben von dem System bekommt, ruft dieses
	  <span class="emphasis"><em>nicht</em></span> <code class="function">getchar</code>
	  auf. Stattdessen addiert der op-Code
	  <code class="function">add esp, byte 4</code>
	  <code class="constant">4</code> zu
	  <code class="varname">ESP</code> hinzu,
	  <span class="emphasis"><em>setzt</em></span> das
	  <code class="varname">carry flag</code>, und
	  springt zurück.</p><p>Wo springt diese Funktion hin? Wann immer ein Programm
	  den op-Code <code class="function">call</code>
	  verwendet, <code class="function">push</code>t der
	  Mikroprozessor die Rücksprungandresse, d.h. er
	  speichert diese ganz oben auf dem Stack (nicht auf dem
	  Stack der <acronym class="acronym">FPU</acronym>, sondern auf dem Systemstack,
	  der sich im Hauptspeicher befindet). Wenn ein Programm den
	  op-Code <code class="function">ret</code> verwendet,
	  <code class="function">pop</code>t der
	  Mikroprozessor den Rückgabewert von dem Stack, und
	  springt zu der Adresse, die dort gespeichert wurde.</p><p>Da wir aber <code class="constant">4</code> zu
	  <code class="varname">ESP</code> hinzuaddiert haben
	  (welches das Register der Stackzeiger ist), haben wir
	  effektiv dem Mikroprzessor eine kleine
	  <span class="emphasis"><em>Amnesie</em></span> verpaßt: Dieser erinnert
	  sich nun nicht mehr daran, daß
	  <code class="function">getchar</code> durch
	  <code class="function">read</code> aufgerufen wurde.</p><p>Und da <code class="function">getchar</code> nichts vor dem
	  Aufruf von <code class="function">read</code> auf dem Stack abgelegt
	  hat, enthält der Anfang des Stacks nun die
	  Rücksprungadresse von der Funktion, die
	  <code class="function">getchar</code> aufgerufen hat. Soweit es den
	  Aufrufer betrifft, hat dieser <code class="function">getchar</code>
	  ge<code class="function">call</code>t, welche mit
	  einem gesetzten
	  <code class="varname">carry flag</code>
	  <code class="function">ret</code>urned.</p></blockquote></div><p>Des weiteren wird die Routine <code class="function">bcdload</code>
	bei einem klitzekleinen Problem zwischen der Big&#8211;Endian-
	und Little&#8211;Endian-Codierung aufgerufen.</p><p>Diese konvertiert die Textrepräsentation einer
	Zahl in eine andere Textrepräsentation: Der Text wird
	in der Big&#8211;Endian-Codierung gespeichert, die
	<span class="emphasis"><em>packed decimal</em></span>-Darstellung jedoch in der
	Little&#8211;Endian-Codierung.</p><p>Um dieses Problem zu lösen haben wir vorher den
	op-Code <code class="function">std</code> verwendet. Wir machen diesen
	Aufruf später mittels <code class="function">cld</code> wieder
	rückgängig: Es ist sehr wichtig, daß wir keine
	Funktion mittels <code class="function">call</code> aufrufen, die von
	einer Standardeinstellung des
	<span class="emphasis"><em>Richtungsflags</em></span> abhängig ist,
	während <code class="function">std</code> ausgeführt
	wird.</p><p>Alles weitere in dem Programm sollte leicht zu verstehen
	sein, vorausgesetzt, daß Sie das gesamte vorherige
	Kapitel gelesen haben.</p><p>Es ist ein klassisches Beispiel für das Sprichwort,
	daß das Programmieren eine Menge Denkarbeit, und nur
	ein wenig Programmcode benötigt. Sobald wir uns über
	jedes Detail im klaren sind, steht der Code fast schon
	da.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-using"></a>11.13.6. Das Programm <span class="application">pinhole</span>
	verwenden</h3></div></div></div><p>Da wir uns bei dem Programm dafür entschieden haben,
	alle Eingaben, die keine Zahlen sind, zu ignorieren (selbst
	die in Kommentaren), können wir jegliche
	<span class="emphasis"><em>textbasierten Eingaben</em></span> verarbeiten. Wir
	<span class="emphasis"><em>müssen</em></span> dies nicht tun, wir
	<span class="emphasis"><em>könnten</em></span> aber.</p><p>Meiner bescheidenen Meinung nach wird ein Programm durch
	die Möglichkeit, anstatt einer strikten Eingabesyntax
	textbasierte Anfragen stellen zu können, sehr viel
	benutzerfreundlicher.</p><p>Angenommen, wir wollten eine Lochkamera für einen
	4x5 Zoll Film bauen. Die standardmäßige Brennweite
	für diesen Film ist ungefähr 150mm.
	Wir wollen diesen Wert <span class="emphasis"><em>optimieren</em></span>, so
	daß der Lochblendendurchmesser eine möglichst
	runde Zahl ergibt. Lassen Sie uns weiter annehmen, daß
	wir zwar sehr gut mit Kameras umgehen können, dafür
	aber nicht so gut mit Computern. Anstatt das wir nun eine
	Reihe von Zahlen eingeben, wollen wir lieber ein paar
	<span class="emphasis"><em>Fragen</em></span> stellen.</p><p>Unsere Sitzung könnte wie folgt aussehen:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>pinhole

Computer,

Wie groß müßte meine Lochblende bei einer Brennweite
von 150 sein?</code></strong>
150	490	306	362	2930	12
<strong class="userinput"><code>Hmmm... Und bei 160?</code></strong>
160	506	316	362	3125	12
<strong class="userinput"><code>Laß uns bitte 155 nehmen.</code></strong>
155	498	311	362	3027	12
<strong class="userinput"><code>Ah, laß uns 157 probieren...</code></strong>
157	501	313	362	3066	12
<strong class="userinput"><code>156?</code></strong>
156	500	312	362	3047	12
<strong class="userinput"><code>Das ist es! Perfekt! Vielen Dank!
^D</code></strong></pre><p>Wir haben herausgefunden, daß der
	Lochblendendurchmesser bei einer Brennweite von 150 mm
	490 Mikrometer, oder 0.49 mm ergeben würde. Bei einer fast
	identischen Brennweite von 156 mm würden wir
	einen Durchmesser von genau einem halben Millimeter
	bekommen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-pinhole-scripting"></a>11.13.7. Skripte schreiben</h3></div></div></div><p>Da wir uns dafür entschieden haben, das Zeichen
	<code class="constant">#</code> als den Anfang eines Kommentares zu
	interpretieren, können wir unser
	<span class="application">pinhole</span>-Programm auch als
	<span class="emphasis"><em>Skriptsprache</em></span> verwenden.</p><p>Sie haben vielleicht schon einmal
	<span class="application">shell</span><span class="emphasis"><em>-Skripte</em></span>
	gesehen, die mit folgenden Zeichen begonnen haben:</p><pre class="programlisting">#! /bin/sh</pre><p>...oder...</p><pre class="programlisting">#!/bin/sh</pre><p>... da das Leerzeichen hinter dem <code class="function">#!</code>
	optional ist.</p><p>Wann immer <span class="trademark">UNIX</span>® eine Datei ausführen soll, die mit
	einem <code class="function">#!</code> beginnt, wird angenommen, das
	die Datei ein Skript ist. Es fügt den Befehl an das Ende
	der ersten Zeile an, und versucht dann, dieses
	auszuführen.</p><p>Angenommen, wir haben unser Programm
	<span class="application">pinhole</span> unter
	<span class="application">/usr/local/bin/</span> installiert, dann
	können wir nun Skripte schreiben, um unterschiedliche
	Lochblendendurchmesser für mehrere Brennweiten
	zu berechnen, die normalerweise mit 120er Filmen verwendet
	werden.</p><p>Das Skript könnte wie folgt aussehen:</p><pre class="programlisting">#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</pre><p>Da ein 120er Film ein Film mittlerer Größe ist,
	könnten wir die Datei <span class="application">medium</span>
	nennen.</p><p>Wir können die Datei ausführbar machen und dann
	aufrufen, als wäre es ein Programm:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>chmod 755 medium</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>./medium</code></strong></pre><p><span class="trademark">UNIX</span>® wird den letzten Befehl wie folgt
	interpretieren:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>/usr/local/bin/pinhole -b -i ./medium</code></strong></pre><p>Es wird den Befehl ausführen und folgendes
	ausgeben:</p><pre class="screen">80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</pre><p>Lassen Sie uns nun das folgende eingeben:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./medium -c</code></strong></pre><p><span class="trademark">UNIX</span>® wird dieses wie folgt behandeln:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>/usr/local/bin/pinhole -b -i ./medium -c</code></strong></pre><p>Dadurch erhält das Programm zwei
	widersprüchliche Optionen: <em class="parameter"><code>-b</code></em> und
	<em class="parameter"><code>-c</code></em> (Verwende Benders Konstante und
	verwende Connors Konstante). Wir haben unser Programm so
	geschrieben, daß später eingelesene Optionen die
	vorheringen überschreiben&#8212;unser Programm wird also
	Connors Konstante für die Berechnungen verwenden:</p><pre class="screen">80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</pre><p>Wir entscheiden uns am Ende doch für Benders
	Konstante. Wir wollen die Ergebnisse im CSV-Format in
	einer Datei speichern:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>./medium -b -e &gt; bender</code></strong>
<code class="prompt">%</code> <strong class="userinput"><code>cat bender</code></strong>
focal length in millimeters,pinhole diameter in microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
<code class="prompt">%</code></pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="x86-one-pointed-mind.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="x86.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="x86-caveats.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">11.12. One-Pointed Mind </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 11.14. Vorsichtsmassnahmen</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>