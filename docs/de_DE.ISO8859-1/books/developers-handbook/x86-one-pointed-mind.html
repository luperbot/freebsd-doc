<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>11.12. One-Pointed Mind</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD Developers' Handbook" /><link rel="up" href="x86.html" title="Kapitel 11. x86-Assembler-Programmierung" /><link rel="prev" href="x86-files.html" title="11.11. Arbeiten mit Dateien" /><link rel="next" href="x86-fpu.html" title="11.13. Die FPU verwenden" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">11.12. One-Pointed Mind</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="x86-files.html">Zurück</a> </td><th width="60%" align="center">Kapitel 11. x86-Assembler-Programmierung</th><td width="20%" align="right"> <a accesskey="n" href="x86-fpu.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="x86-one-pointed-mind"></a>11.12. One-Pointed Mind</h2></div><div><span class="authorgroup">Übersetzt von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Daniel</span> <span class="surname">Seuffert</span></span>. </span></div></div></div><p>Als ein Zen-Schüler liebe ich die Idee eines
      fokussierten Bewußtseins: Tu nur ein Ding zur gleichen
      Zeit, aber mache es richtig.</p><p>Das ist ziemlich genau die gleiche Idee, welche <span class="trademark">UNIX</span>®
      richtig funktionieren lässt. Während eine typische
      <span class="trademark">Windows</span>®-Applikation versucht alles Vorstellbare zu tun (und
      daher mit Fehler durchsetzt ist), versucht eine
      <span class="trademark">UNIX</span>®-Applikation nur eine Funktion zu erfüllen und das
      gut.</p><p>Der typische <span class="trademark">UNIX</span>®-Nutzer stellt sich sein eigenes System
      durch Shell-Skripte zusammen, die er selbst schreibt, und welche
      die Vorteile bestehender Applikationen dadurch kombinieren,
      indem sie die Ausgabe eines Programmes als Eingabe in ein
      anderes Programm durch eine Pipe übergeben.</p><p>Wenn Sie ihre eigene <span class="trademark">UNIX</span>®-Software schreiben, ist es
      generell eine gute Idee zu betrachten, welcher Teil der
      Problemlösung durch bestehende Programme bewerkstelligt
      werden kann. Man schreibt nur die Programme selbst, für die
      keine vorhandene Lösung existiert.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-csv"></a>11.12.1. CSV</h3></div></div></div><p>Ich will dieses Prinzip an einem besonderen Beispiel
	aus der realen Welt demonstrieren, mit dem ich kürzlich
	konfrontiert wurde:</p><p>Ich mußte jeweils das elfte Feld von jedem
	Datensatz aus einer Datenbank extrahieren, die ich von einer
	Webseite heruntergeladen hatte. Die Datenbank war eine
	<acronym class="acronym">CSV</acronym>-Datei, d.h. eine Liste von
	<span class="emphasis"><em>Komma-getrennten Werten</em></span>. Dies ist ein
	ziemlich gewöhnliches Format für den Code-Austausch
	zwischen Menschen, die eine unterschiedliche
	Datenbank-Software nutzen.</p><p>Die erste Zeile der Datei enthält eine Liste der
	Felder durch Kommata getrennt. Der Rest der Datei enthält
	die einzelnen Datensätze mit durch Kommata getrennten
	Werten in jeder Zeile.</p><p>Ich versuchte <span class="application">awk</span> unter
	Nutzung des Kommas als Trenner. Da aber einige Zeilen durch in
	Bindestriche gesetzte Kommata getrennt waren, extrahierte
	<span class="application">awk</span> das falsche Feld aus diesen
	Zeilen.</p><p>Daher mußte ich meine eigene Software schreiben,
	um das elfte Feld aus der <acronym class="acronym">CSV</acronym>-Datei
	auszulesen. Aber durch Anwendung der <span class="trademark">UNIX</span>®-Philosophie
	mußte ich nur einen einfachen Filter schreiben, das
	Folgende tat:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Entferne die erste Zeile aus der Datei.</p></li><li class="listitem"><p>Ändere alle Kommata ohne Anführungszeichen
	    in einen anderen Buchstaben.</p></li><li class="listitem"><p>Entferne alle Anführungszeichen.</p></li></ul></div><p>Streng genommen könnte ich
	<span class="application">sed</span> benutzen, um die erste Zeile
	der Datei zu entfernen, aber das zu Bewerkstelligen war in
	meinem Programm sehr einfach, also entschloss ich mich dazu
	und reduzierte dadurch die Größe der
	Pipeline.</p><p>Unter Berücksichtigung aller Faktoren kostete mich
	das Schreiben dieses Programmes ca. 20 Minuten. Das Schreiben
	eines Programmes, welches jeweils das elfte Feld aus einer
	<acronym class="acronym">CSV</acronym>-Datei extrahiert hätte wesentlich
	länger gedauert und ich hätte es nicht
	wiederverwenden können, um ein anderes Feld aus irgendeiner
	anderen Datenbank zu extrahieren.</p><p>Diesmal entschied ich mich dazu, etwas mehr Arbeit zu
	investieren, als man normalerweise für ein typisches
	Tutorial verwenden würde:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Es parst die Kommandozeilen nach Optionen.</p></li><li class="listitem"><p>Es zeigt die richtige Nutzung an, falls es ein
	    falsches Argument findet.</p></li><li class="listitem"><p>Es gibt vernünftige Fehlermeldungen aus.</p></li></ul></div><p>Hier ist ein Beispiel für seine Nutzung:</p><pre class="screen">Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]</pre><p>Alle Parameter sind optional und können in beliebiger
	Reihenfolge auftauchen.</p><p>Der <em class="parameter"><code>-t</code></em>-Parameter legt fest, was
	zu die Kommata zu ersetzen sind. Der <code class="constant">tab</code>
	ist die Vorgabe hierfür. Zum Beispiel wird
	<em class="parameter"><code>-t;</code></em> alle unquotierten Kommata mit
	Semikolon ersetzen.</p><p>Ich brauche die <em class="parameter"><code>-c</code></em>-Option nicht,
	aber sie könnte zukünftig nützlich sein. Sie
	ermöglicht mir festzulegen, daß ich einen anderen
	Buchstaben als das Kommata mit etwas anderem ersetzen
	möchte. Zum Beispiel wird der Parameter
	<em class="parameter"><code>-c@</code></em> alle @-Zeichen ersetzen
	(nützlich, falls man eine Liste von Email-Adressen in
	Nutzername und Domain aufsplitten will).</p><p>Die <em class="parameter"><code>-p</code></em>-Option erhält die
	erste Zeile, d.h. die erste Zeile der Datei wird nicht
	gelöscht. Als Vorgabe löschen wir die erste Zeile,
	weil die <acronym class="acronym">CSV</acronym>-Datei in der ersten Zeile
	keine Daten, sondern Feldbeschreibungen enthält.</p><p>Die Parameter <em class="parameter"><code>-i</code></em>- und
	<em class="parameter"><code>-o</code></em>-Optionen erlauben es mir, die
	Ausgabe- und Eingabedateien festzulegen. Vorgabe sind
	<code class="filename">stdin</code> und <code class="filename">stdout</code>,
	also ist es ein regulärer <span class="trademark">UNIX</span>®-Filter.</p><p>Ich habe sichergestellt, daß sowohl <em class="parameter"><code>-i
	filename</code></em> und <em class="parameter"><code>-ifilename</code></em>
	akzeptiert werden. Genauso habe ich dafür Sorge getragen,
	daß sowohl Eingabe- als auch Ausgabedateien festgelegt
	werden können.</p><p>Um das elfte Feld jeden Datensatzes zu erhalten kann ich
	nun folgendes eingeben:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>csv '-t;' data.csv | awk '-F;' '{print $11}'</code></strong></pre><p>Der Code speichert die Optionen (bis auf die
	Dateideskriptoren) in <code class="varname">EDX</code>:
	Das Kommata in <code class="varname">DH</code>, den
	neuen Feldtrenner in <code class="varname">DL</code> und
	das Flag für die <em class="parameter"><code>-p</code></em>-Option in dem
	höchsten Bit von <code class="varname">EDX</code>.
	Ein kurzer Abgleich des Zeichens wird uns also eine schnelle
	Entscheidung darüber erlauben, was zu tun ist.</p><p>Hier ist der Code:</p><pre class="programlisting">
;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	'system.inc'

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	'Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]', 0Ah
usglen	equ	$-usg
iemsg	db	"csv: Can't open input file", 0Ah
iemlen	equ	$-iemsg
oemsg	db	"csv: Can't create output file", 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (',' &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], '-'
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, 'o'
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, 'i'
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, 'p'
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, 't'		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, 'c'
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, '"'
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, '"'
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre><p>Vieles daraus ist aus <code class="filename">hex.asm</code>
	entnommen worden. Aber es gibt einen wichtigen Unterschied:
	Ich rufe nicht länger <code class="function">write</code> auf,
	wann immer ich eine Zeilenvorschub ausgebe. Nun kann der Code
	sogar interaktiv genutzt werden.</p><p>Ich habe eine bessere Lösung gefunden für das
	Interaktivitätsproblem seit ich mit dem Schreiben dieses
	Kapitels begonnen habe. Ich wollte sichergehen, daß jede
	Zeile einzeln ausgegeben werden kann, falls erforderlich. Aber
	schlussendlich gibt es keinen Bedarf jede Zeile einzeln
	auszugeben, falls nicht-interaktiv genutzt.</p><p>Die neue Lösung besteht darin, die Funktion
	<code class="function">write</code> jedesmal aufzurufen, wenn ich den
	Eingabepuffer leer vorfinde. Auf diesem Wege liest das
	Programm im interaktiven Modus eine Zeile aus der Tastatur des
	Nutzers, verarbeitet sie und stellt fest, ob deren
	Eingabepuffer leer ist, dann leert es seine Ausgabe und liest
	die nächste Zeile.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="x86-buffered-dark-side"></a>11.12.1.1. Die dunkle Seite des Buffering</h4></div></div></div><p>Diese Änderung verhindert einen mysteriösen
	  Aufhänger in einem speziellen Fall. Ich bezeichne dies
	  als die <span class="emphasis"><em>dunkle Seite des Buffering</em></span>,
	  hauptsächlich, weil es eine nicht offensichtliche
	  Gefahr darstellt.</p><p>Es ist unwahrscheinlich, daß dies mit dem
	  <span class="application">csv</span>-Programm oben geschieht aber
	  lassen Sie uns einen weiteren Filter betrachten: Nehmen wir
	  an ihre Eingabe sind rohe Daten, die Farbwerte darstellen,
	  wie z.B. die Intensität eines Pixel mit den Farben
	  <span class="emphasis"><em>rot</em></span>, <span class="emphasis"><em>grün</em></span> und
	  <span class="emphasis"><em>blau</em></span>. Unsere Ausgabe wird der negative
	  Wert unserer Eingabe sein.</p><p>Solch ein Filter würde sehr einfach zu schreiben
	  sein. Der größte Teil davon würde so
	  aussehen wie all die anderen Filter, die wir bisher
	  geschrieben haben, daher beziehe ich mich nur auf den Kern
	  der Prozedur:</p><pre class="programlisting">.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre><p>Da dieser Filter mit rohen Daten arbeitet ist es
	  unwahrscheinlich, daß er interaktiv genutzt werden
	  wird.</p><p>Aber das Programm könnte als
	  Bildbearbeitungssoftware tituliert werden. Wenn es nicht
	  <code class="function">write</code> vor jedem Aufruf von
	  <code class="function">read</code> durchführt, ist die
	  Möglichkeit gegeben, das es sich aufhängt.</p><p>Dies könnte passieren:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Der Bildeditor wird unseren Filter laden mittels der
	    C-Funktion <code class="function">popen()</code>.</p></li><li class="step"><p>Er wird die erste Zeile von Pixeln laden aus einer
	      Bitmap oder Pixmap.</p></li><li class="step"><p>Er wird die erste Zeile von Pixeln geschrieben in
	      die <span class="emphasis"><em>Pipe</em></span>, welche zur Variable
	      <code class="varname">fd.in</code> unseres Filters
	      führt.</p></li><li class="step"><p>Unser Filter wird jeden Pixel auslesen von der
	      Eingabe, in in seinen negativen Wert umkehren und ihn in
	      den Ausgabepuffer schreiben.</p></li><li class="step"><p>Unser Filter wird die Funktion
	      <code class="function">getchar</code> aufrufen, um das
	      nächste Pixel abzurufen.</p></li><li class="step"><p>Die Funktion <code class="function">getchar</code> wird einen
	      leeren Eingabepuffer vorfinden und daher die Funktion
	      <code class="function">read</code> aufrufen.</p></li><li class="step"><p><code class="function">read</code> wird den Systemaufruf
	      <code class="function">SYS_read</code>
	      starten.</p></li><li class="step"><p>Der <span class="emphasis"><em>Kernel</em></span> wird unseren Filter
	      unterbrechen, bis der Bildeditor mehr Daten zur Pipe
	      sendet.</p></li><li class="step"><p>Der Bildedior wird aus der anderen Pipe lesen,
	      welche verbunden ist mit <code class="varname">fd.out</code>
	      unseres Filters, damit er die erste Zeile des
	      auszugebenden Bildes setzen kann
	      <span class="emphasis"><em>bevor</em></span> er uns die zweite Zeile der
	      Eingabe einliest.</p></li><li class="step"><p>Der <span class="emphasis"><em>Kernel</em></span> unterbricht den
	      Bildeditor, bis er eine Ausgabe unseres Filters
	      erhält, um ihn an den Bildeditor
	      weiterzureichen.</p></li></ol></div><p>An diesem Punkt wartet unser Filter auf den
	  Bildeditor, daß er ihm mehr Daten zur Verarbeitung
	  schicken möge. Gleichzeitig wartet der Bildeditor
	  darauf, daß unser Filter das Resultat der Berechnung
	  ersten Zeile sendet. Aber das Ergebnis sitzt in unserem
	  Ausgabepuffer.</p><p>Der Filter und der Bildeditor werden fortfahren bis in
	  die Ewigkeit aufeinander zu warten (oder zumindest bis sie
	  per kill entsorgt werden). Unsere Software hat den eine
	  <a class="link" href="secure-race-conditions.html" title="3.7. Race-Conditions">Race Condition</a>
	  erreicht.</p><p>Das Problem tritt nicht auf, wenn unser Filter seinen
	  Ausgabepuffer leert <span class="emphasis"><em>bevor</em></span> er vom
	  <span class="emphasis"><em>Kernel</em></span> mehr Eingabedaten
	  anfordert.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="x86-files.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="x86.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="x86-fpu.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">11.11. Arbeiten mit Dateien </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 11.13. Die <acronym class="acronym">FPU</acronym> verwenden</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>