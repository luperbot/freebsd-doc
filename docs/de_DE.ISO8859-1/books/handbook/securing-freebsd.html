<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>15.3. Absichern von FreeBSD</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="security.html" title="Kapitel 15. Sicherheit" /><link rel="prev" href="security-intro.html" title="15.2. Einführung" /><link rel="next" href="crypt.html" title="15.4. DES, Blowfish, MD5, und Crypt" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">15.3. Absichern von FreeBSD</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security-intro.html">Zurück</a> </td><th width="60%" align="center">Kapitel 15. Sicherheit</th><td width="20%" align="right"> <a accesskey="n" href="crypt.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="securing-freebsd"></a>15.3. Absichern von FreeBSD</h2></div></div></div><a id="idp78077392" class="indexterm"></a><div xmlns="" class="note"><h3 class="admontitle">Kommandos und Protokolle: </h3><p xmlns="http://www.w3.org/1999/xhtml">In diesem Abschnitt werden Anwendungen
	<span class="application">fett</span> gekennzeichnet, spezifische
	Kommandos werden in einer <code class="command">Fixschrift</code>
	dargestellt und Protokolle verwenden die normale Schriftart.
	Diese typographische Konvention hilft, Begriffe wie ssh
	zu unterscheiden, die sowohl Protokoll als auch Kommando
	sein können.</p></div><p>Die folgenden Abschnitte behandeln die im
      <a class="link" href="security-intro.html" title="15.2. Einführung">letzten Abschnitt</a> erwähnten
      Methoden Ihr FreeBSD-System zu sichern.</p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="securing-root-and-staff"></a>15.3.1. Absichern von <code class="systemitem">root</code> und
	Accounts</h3></div></div></div><a id="idp78082896" class="indexterm"></a><p>Zuallererst, kümmern Sie sich nicht um die Absicherung
	von Accounts, wenn Sie <code class="systemitem">root</code>
	noch nicht abgesichert haben.  Auf den meisten Systemen ist
	<code class="systemitem">root</code> ein Passwort zugewiesen.  Sie
	sollten <span class="emphasis"><em>immer</em></span> davon ausgehen, dass
	dieses Passwort kompromittiert ist.  Das heißt nicht,
	dass Sie das Passwort entfernen sollten, da es meist
	für den Konsolenzugriff notwendig ist.  Vielmehr heißt
	es, dass Sie das Passwort nicht außerhalb der
	Konsole, auch nicht zusammen mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a>, verwenden sollten.
	Stellen Sie sicher, dass Ihre PTYs in <code class="filename">ttys</code> als
	unsicher markiert sind und damit Anmeldungen von
	<code class="systemitem">root</code> mit <code class="command">telnet</code> oder
	<code class="command">rlogin</code> verboten sind.  Wenn Sie andere
	Anwendungen wie <span class="application">SSH</span> zum Anmelden
	benutzen, vergewissern Sie sich, dass dort ebenfalls
	Anmeldungen als <code class="systemitem">root</code> verboten sind.  Für
	<span class="application">SSH</span> editieren Sie
	<code class="filename">/etc/ssh/sshd_config</code> und überprüfen,
	dass <code class="literal">PermitRootLogin</code> auf <code class="literal">no</code>
	gesetzt ist.  Beachten Sie jede Zugriffsmethode &#8211; Dienste
	wie FTP werden oft vergessen.  Nur an der Systemkonsole sollte
	ein direktes Anmelden als <code class="systemitem">root</code> möglich
	sein.</p><a id="idp78095184" class="indexterm"></a><p>Natürlich müssen Sie als Systemadministrator
	<code class="systemitem">root</code>-Zugriff erlangen können.  Dieser
	sollte aber durch zusätzliche Passwörter
	geschützt sein.  Ein Weg, Zugang zu <code class="systemitem">root</code>
	zu ermöglichen, ist es, berechtigte Mitarbeiter in
	<code class="filename">/etc/group</code> in die Gruppe
	<code class="systemitem">wheel</code> aufzunehmen.  Die Personen, die
	Mitglieder in der Gruppe <code class="systemitem">wheel</code> sind,
	können mit <code class="command">su</code> zu <code class="systemitem">root</code>
	wechseln.  Ihre Mitarbeiter sollten niemals die Gruppe
	<code class="systemitem">wheel</code> als primäre Gruppe in
	<code class="filename">/etc/passwd</code> besitzen.  Mitarbeiter sollten
	der Gruppe <code class="systemitem">staff</code> angehören und über
	<code class="filename">/etc/group</code> in <code class="systemitem">wheel</code>
	aufgenommen werden.  Es sollten auch nur die Mitarbeiter, die
	wirklich <code class="systemitem">root</code> Zugriff benötigen in
	<code class="systemitem">wheel</code> aufgenommen werden.  Mit anderen
	Authentifizierungsmethoden müssen Sie niemanden in
	<code class="systemitem">wheel</code> aufnehmen.  Wenn Sie z.B.
	<span class="application">Kerberos</span> benutzen, wechseln Sie mit
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ksu&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ksu</span>(1)</span></a> zu <code class="systemitem">root</code> und der Zugriff wird
	mit der Datei <code class="filename">.k5login</code> geregelt.  Dies ist
	vielleicht eine bessere Lösung, da es der
	<code class="systemitem">wheel</code>-Mechanismus einem Angreifer immer
	noch möglich macht, den <code class="systemitem">root</code>-Account
	zu knacken, nachdem er einen Mitarbeiter-Account geknackt hat.
	Obwohl der <code class="systemitem">wheel</code>-Mechanismus besser als
	gar nichts ist, ist er nicht unbedingt die sicherste Lösung.</p><p>Um ein Konto komplett zu sperren, verwenden Sie den Befehl
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=pw&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">pw</span>(8)</span></a>:</p><pre class="screen"><code class="prompt">#</code><strong class="userinput"><code>pw lock staff</code></strong></pre><p>Danach ist es diesem Benutzer nicht mehr möglich (auch
	nicht mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a>), sich anzumelden.</p><p>Eine weitere Möglichkeit, bestimmte Benutzer zu sperren,
	ist es, das verschlüsselte Passwort durch das Zeichen
	<span class="quote">&#8222;<span class="quote"><code class="literal">*</code></span>&#8220;</span> zu ersetzen.  Da ein
	verschlüsseltes Passwort niemals diesem Zeichen entsprechen
	kann, kann sich der betroffene Benutzer ebenfalls nicht mehr
	anmelden.  Beispielsweise müsste dazu das Konto</p><pre class="programlisting">foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>wie folgt abgeändert werden:</p><pre class="programlisting">foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre><p>Durch diese Änderung wird der Benutzer
	<code class="systemitem">foobar</code> daran gehindert, sich auf
	konventionellem Wege am System anzumelden.  Diese
	Maßnahmen greifen allerdings nicht, wenn das betroffene
	System auch eine Anmeldung über
	<span class="application">Kerberos</span> oder <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ssh&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ssh</span>(1)</span></a> erlaubt.</p><p>Diese Sicherheitsmechanismen setzen voraus, dass
	Sie sich von einer restriktiven Maschine auf einer weniger restriktiven
	Maschine anmelden.  Wenn zum Beispiel auf Ihrem Hauptrechner alle
	möglichen Arten von Servern laufen, so sollten auf Ihrer
	Workstation keine Server laufen.  Um Ihre Workstation vernünftig
	abzusichern, sollten auf Ihr so wenig Server wie möglich bis hin
	zu keinem Server laufen.  Sie sollten zudem über einen
	Bildschirmschoner verfügen, der mit einem Passwort
	gesichert ist.  Natürlich kann ein Angreifer, der physikalischen
	Zugang zu einer Maschine hat, jede Art von Sicherheitsmechanismen
	umgehen.  Dieses Problem sollten Sie daher auch in Ihren
	Überlegungen berücksichtigen.  Beachten Sie dabei aber,
	dass der Großteil der Einbrüche über das
	Netzwerk erfolgt und die Einbrecher keinen Zugang zu der Maschine
	besitzen.</p><p>Mit <span class="application">Kerberos</span> können Sie das
	Passwort eines Mitarbeiters an einer Stelle ändern
	und alle Maschinen, auf denen der Mitarbeiter einen Account hat,
	beachten die Änderung sofort.  Wird der Account eines
	Mitarbeiters einmal kompromittiert, so sollte die Fähigkeit, das
	Passwort mit einem Schlag auf allen Maschinen zu ändern,
	nicht unterschätzt werden.  Mit einzelnen Passwörtern
	wird es schwierig, das Passwort auf N Maschinen zu ändern.
	Mit <span class="application">Kerberos</span> können Sie auch
	Beschränkungen für Passwörter festlegen:
	Nicht nur das Ticket kann nach einiger Zeit ungültig werden,
	Sie können auch festlegen, dass ein Benutzer nach einer
	bestimmten Zeit, z.B. nach einem Monat, das Passwort wechseln
	muss.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78124752"></a>15.3.2. Absichern von unter <code class="systemitem">root</code> laufenden
        Servern und SUID/SGID Programmen</h3></div></div></div><a id="idp78125904" class="indexterm"></a><a id="idp78126800" class="indexterm"></a><a id="idp78131920" class="indexterm"></a><a id="idp78132816" class="indexterm"></a><a id="idp78133584" class="indexterm"></a><a id="idp78134480" class="indexterm"></a><a id="idp78135376" class="indexterm"></a><a id="idp78136272" class="indexterm"></a><p>Ein kluger Systemadministrator lässt nur die
	Dienste, die er wirklich braucht, laufen; nicht mehr und auch
	nicht weniger.  Beachten Sie, dass Server von Dritten die
	fehleranfälligsten sind.  Wenn Sie z.B. eine alte Version von
	<span class="application">imapd</span> oder <span class="application">popper</span>
	laufen lassen, ist das so, als würden Sie der ganzen Welt
	freien Zugang zu <code class="systemitem">root</code> geben.  Lassen Sie keine
	Server laufen, die Sie vorher nicht genau überprüft haben.
	Viele Server müssen nicht unter <code class="systemitem">root</code>
	laufen, zum Beispiel können <span class="application">ntalk</span>,
	<span class="application">comsat</span> und <span class="application">finger</span>
        in speziellen <em class="firstterm">Sandkästen</em> unter
	einem Benutzer laufen.  Ein Sandkasten ist keine perfekte Lösung,
	wenn Sie nicht eine Menge Arbeit in die Konfiguration investieren,
	doch bewährt sich hier das Prinzip, die Sicherheit in Schichten
	aufzubauen.  Wenn es einem Angreifer gelingt, in einen Server,
	der in einem Sandkasten läuft, einzubrechen, dann muss
	er immer noch aus dem Sandkasten selber ausbrechen.  Je mehr Schichten
	der Angreifer zu durchbrechen hat, desto kleiner sind seine Aussichten
	auf Erfolg.  In der Vergangenheit wurden praktisch in jedem
	Server, der unter <code class="systemitem">root</code> läuft, Lücken
	gefunden, die zu einem <code class="systemitem">root</code> Zugriff führten.
	Dies betrifft selbst die grundlegenden Systemdienste.  Wenn Sie eine
	Maschine betreiben, auf der man sich nur mit
	<span class="application">SSH</span> anmelden kann, dann stellen Sie die
	Dienste <span class="application">telnetd</span>,
	<span class="application">rshd</span> oder <span class="application">rlogind</span>
	ab!</p><p>In der Voreinstellung laufen unter FreeBSD
	<span class="application">ntalkd</span>, <span class="application">comsat</span>
	und <span class="application">finger</span> nun in einem Sandkasten.  Ein
	weiteres Programm, das in einem Sandkasten laufen sollte, ist
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=named&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">named</span>(8)</span></a>.  In <code class="filename">/etc/defaults/rc.conf</code> sind
	die notwendigen Argumente, um <span class="application">named</span> in
	einem Sandkasten laufen zu lassen, in kommentierter Form schon
	enthalten.  Abhängig davon, ob Sie ein neues System installieren
	oder ein altes System aktualisieren, sind die hierfür
	benötigten Benutzer noch nicht installiert.
	Ein kluger Systemadministrator sollte immer nach Möglichkeiten
	suchen, Server in einem Sandkasten laufen zu lassen.</p><a id="idp78154832" class="indexterm"></a><p>Einige Server wie <span class="application">sendmail</span>,
	<span class="application">popper</span>, <span class="application">imapd</span>
	und <span class="application">ftpd</span> werden normalerweise nicht in
	Sandkästen betrieben.  Zu einigen Servern gibt es Alternativen,
	aber diese wollen Sie vielleicht wegen der zusätzlich nötigen
	Arbeit nicht installieren (ein weiteres Beispiel für den
	Widerspruch zwischen Sicherheit und Benutzerfreundlichkeit).
	In diesem Fall müssen Sie die
	Server unter <code class="systemitem">root</code> laufen lassen und auf die
	eingebauten Mechanismen vertrauen, Einbrüche zu entdecken.</p><p>Weitere potentielle Löcher, die zu einem
	<code class="systemitem">root</code>-Zugriff führen können, sind
        die auf dem System installierten SUID- und SGID-Programme.  Die
	meisten dieser Programme wie <span class="application">rlogin</span> stehen
	in <code class="filename">/bin</code>,
	<code class="filename">/sbin</code>,
	<code class="filename">/usr/bin</code>, oder
	<code class="filename">/usr/sbin</code>.
	Obwohl nichts 100% sicher ist, können Sie davon ausgehen,
	dass die SUID- und SGID-Programme des Basissystems ausreichend
	sicher sind.  Allerdings werden ab und an in diesen Programmen
	Löcher gefunden.  1998 wurde in <code class="literal">Xlib</code> ein
	Loch gefunden, das <span class="application">xterm</span>, der
	normal mit SUID installiert wird, verwundbar machte.  Es ist besser
	auf der sicheren Seite zu sein, als sich später zu beklagen,
	darum wird ein kluger Systemadministrator den Zugriff auf
	SUID-Programme mit einer Gruppe, auf die nur Mitarbeiter zugreifen
	können, beschränken.  SUID-Programme, die niemand benutzt,
	sollten mit <code class="command">chmod 000</code> deaktiviert werden.  Zum
	Beispiel braucht ein Server ohne Bildschirm kein
	<span class="application">xterm</span> Programm.  SGID-Programme sind
	vergleichbar gefährlich.  Wenn ein Einbrecher Zugriff auf
	SGID-<code class="systemitem">kmem</code> Programm erhält, kann er
	vielleicht <code class="filename">/dev/kmem</code> und damit die
	verschlüsselte Passwortdatei lesen.  Dies kompromittiert
	unter Umständen jeden Account, der mit einem Passwort
	geschützt ist.  Alternativ kann ein Einbrecher, der in die
	Gruppe <code class="systemitem">kmem</code> eingebrochen ist, die
	Tastendrücke auf PTYs verfolgen.  Dies schließt
	auch PTYs mit ein, auf denen sich ein Benutzer mit sicheren
	Methoden anmeldet.  Ein Einbrecher, der Zugriff auf die
	<code class="systemitem">tty</code> Gruppe hat, kann auf fast jeden Terminal
	anderer Benutzer schreiben.  Wenn der Benutzer einen Terminal-Emulator
	benutzt, der über eine Tastatur-Simulation verfügt,
	könnte der Angreifer Daten generieren, die den Terminal
	veranlassen, ein Kommando unter diesem Benutzer laufen zu lassen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="secure-users"></a>15.3.3. Absichern von Accounts</h3></div></div></div><p>Accounts sind für gewöhnlich sehr schwierig
	abzusichern.  Während Sie drakonische Beschränkungen
	für Ihre Mitarbeiter einrichten und deren Passwörter
	als ungültig markieren können, werden Sie das
	vielleicht bei den normalen Accounts nicht durchsetzen.
	Wenn Sie über ausreichend Macht verfügen, gelingt es Ihnen
	vielleicht doch, ansonsten müssen Sie diese Accounts
	aufmerksam überwachen.  Wegen der zusätzlichen
	Administrationsarbeit und der nötigen technischen
	Unterstützung ist die Verwendung von
	<span class="application">SSH</span> und <span class="application">Kerberos</span>
	mit normalen Accounts erschwert, obwohl das natürlich
	sicherer als die Verwendung von verschlüsselten
	Passwörtern ist.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78170960"></a>15.3.4. Absichern der Passwort-Datei</h3></div></div></div><p>Der einzig sichere Weg ist, so viele Accounts wie möglich als
	ungültig zu markieren und <span class="application">SSH</span> oder
	<span class="application">Kerberos</span> zu benutzen, um auf sie
	zuzugreifen.  Obwohl die Datei <code class="filename">/etc/spwd.db</code>,
	die die verschlüsselten Passwörter enthält,
	nur von <code class="systemitem">root</code> gelesen werden kann, mag ein
	Angreifer lesenden Zugriff auf diese Datei erlangen, ohne die
	Fähigkeit sie auch zu beschreiben.</p><p>Ihre Überwachungsskripten sollten Änderungen
	an der Passwort-Datei melden (siehe <a class="link" href="securing-freebsd.html#security-integrity" title="15.3.6. Überprüfen der Integrität von Dateien">Überprüfen der
	Integrität von Dateien</a> weiter unten).</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78174800"></a>15.3.5. Absichern des Kernels, der Geräte und von
        Dateisystemen</h3></div></div></div><p>Wenn ein Angreifer <code class="systemitem">root</code>-Zugriff erlangt,
	kann er so ziemlich alles mit Ihrem System anstellen, doch sollten Sie
	es ihm nicht zu leicht machen.  Die meisten modernen Kernel haben
	zum Beispiel einen Gerätetreiber, der es erlaubt, Pakete
	abzuhören.  Unter FreeBSD wird das Gerät
	<code class="filename">bpf</code> genannt.  Für gewöhnlich
	wird ein Angreifer versuchen, dieses Gerät zu nutzen, um
	Pakete abzuhören.  Sie sollten ihm diese Gelegenheit nicht
	geben und auf den meisten Systemen ist das Gerät
	<code class="filename">bpf</code> nicht nötig.</p><a id="idp78185424" class="indexterm"></a><p>Auch wenn Sie <code class="filename">bpf</code> nicht verwenden,
	müssen Sie sich immer noch um <code class="filename">/dev/mem</code>
	und <code class="filename">/dev/kmem</code> sorgen.  Außerdem
	kann der Angreifer immer noch auf die rohen Geräte
	(<span class="foreignphrase"><em class="foreignphrase">raw devices</em></span>)
	schreiben.  Weiterhin gibt es ein Programm zum Nachladen von
	Modulen in den Kernel: <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kldload&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">kldload</span>(8)</span></a>.  Ein unternehmungslustiger
	Angreifer kann dies benutzen, um sein eigenes
	<code class="filename">bpf</code> oder ein anderes zum Abhören
	geeignetes Gerät in den laufenden Kernel einzubringen.  Um
	dieses Problem zu vermeiden, müssen Sie den Kernel auf
	einem höheren Sicherheitslevel laufen lassen, mindestens
	auf securelevel 1.</p><p>Das Securelevel des Kernels kann auf verschiedene Wege
        gesetzt werden.  Der einfachste Weg ist das erhöhen des
        Securelevel des laufenden Kernels durch ein
        <code class="command">sysctl</code> der <code class="varname">kern.securelevel</code>
        Kernel Variablen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.securelevel=1</code></strong></pre><p>Standardmässig bootet der FreeBSD Kernel mit einem
        Securelevel von -1.  Der Securelevel wird solange bei -1 bleiben,
        bis er entweder durch den Administrator oder von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>
        durch einen Eintrag im Startup Script verändert wird.  Der
        Securelevel kann während des Systemstarts durch das Setzen
        der Variable <code class="varname">kern_securelevel_enable</code> auf
        <code class="literal">YES</code> und der Wert der Variable
        <code class="varname">kern_securelevel</code> auf den gewünschten
        Securelevel in der <code class="filename">/etc/rc.conf</code>
        erhöht werden.</p><p>Der Standard Securelevel von einem FreeBSD-System direkt nach
        dem Start ist -1.  Dies wird <span class="quote">&#8222;<span class="quote">insecure mode</span>&#8220;</span> genannt,
        da zum Beispiel unverändeliche Dateiflags abgeschaltet werden
        könnten, von allen Geräten gelesen und auf alle geschrieben
        werden kann.</p><p>Sobald der Securelevel auf den Wert 1 oder höher gesetzt
        ist, werden die append-only und die unveränderlichen Dateien
        geschützt, die Flags können nicht abgeschaltet werden
        und der Zugriff auf raw Devices ist verboten.  Höhere Levels
        verbieten mehr Aktionen.  Für einen vollständige Liste
        aller Securelevels, lesen Sie bitte die <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=security&amp;sektion=7"><span class="citerefentry"><span class="refentrytitle">security</span>(7)</span></a>
        Manual Seite (oder die Manual Seite von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a> für
        ältere Releases als FreeBSD 7.0).</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Das Erhöhen des Securelevels auf 1 oder höher
	  kann einige Probleme mit X11 verursachen (Zugriff auf
	  <code class="filename">/dev/io</code> wird geblockt), ebenso die Installation
	  von FreeBSD aus den Quellen (der <code class="buildtarget">installworld</code>
	  Teil muss zeitweilig die append-only und die
	  unveränderlichen Flags einiger Dateien zurücksetzen),
	  und auch noch in einigen anderen Fällen.  Manchmal kann es,
	  wie bei X11, durch das sehr frühe Starten von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=xdm&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">xdm</span>(1)</span></a>
	  im Boot Prozess möglich sein, dies zu umgehen, wenn der
	  Securelevel noch niedrig genug ist.
	  Workarounds wie dieser sind nicht f¨r alle Securelevels
	  und für alle Einschränkungen, die sie schaffen,
	  möglich. Ein bisschen Vorausplanung ist eine gute
	  Idee.  Das Verständnis für die Beschränkungen,
	  die durch jedes Securelevel verursacht werden, ist wichtig, da sie
	  die einfache Benutzung des Systems verschlechtern.  Es vereinfacht
	  auch die Wahl einer Standardeinstellung und schützt vor
	  Überraschungen.</p></div><p>Wenn das Securelevel des Kernel auf einen Wert von 1 oder
        höher gesetzt ist, kann es sinnvoll sein das
        <code class="literal">schg</code> Flag auf kritische Startdateien,
        Verzeichnisse und Scripte (z.B. alles was läuft bis zu
        dem Punkt auf dem das Securelevel gesetzt ist) zu setzen.  Dies
        könnte etwas übertrieben sein, und auch das Upgrade
        des Systems ist sehr viel schwerer, wenn es auf einem hohen
        Securelevel läuft.  Ein strengerer Kompromiss ist es, das
        System auf einem höheren Securelevel laufen zu lassen, aber
        keine <code class="literal">schg</code> Flags für alle Systemdateien
        und Verzeichnisse zu setzen.  Eine andere Möglichkeit ist es,
        einfach die Verzeichnisse <code class="filename">/</code> und
        <code class="filename">/usr</code> read-only zu mounten.
        Es sei darauf hingewiesen, dass Sie nicht vor lauter Überlegen
        das Wichtigste, nämlich die Entdeckung eines Eindringens,
        vergessen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="security-integrity"></a>15.3.6. Überprüfen der Integrität von Dateien</h3></div></div></div><p>Sie können die Systemkonfiguration und die Dateien
	nur so weit schützen, wie es die Benutzbarkeit des
	Systems nicht einschränkt.  Wenn Sie zum Beispiel
	mit <code class="command">chflags</code> die Option <code class="literal">schg</code>
	auf die meisten Dateien in <code class="filename">/</code> und
	<code class="filename">/usr</code> setzen, kann das Ihre
	Arbeit mehr behindern
	als nützen.  Die Maßnahme schützt zwar die
	Dateien, schließt aber auch eine Möglichkeit,
	Veränderungen zu entdecken, aus.  Die letzte Schicht des
	Sicherheitsmodells &#8211; das Aufdecken von Einbrüchen &#8211;
	ist sicherlich die wichtigste.  Alle Sicherheitsmaßnahmen sind
	nichts wert, oder wiegen Sie in falscher Sicherheit, wenn Sie
	nicht in der Lage sind, einen möglichen Einbruch zu entdecken.
	Die Hälfte der Sicherheitsmaßnahmen hat die Aufgabe,
        einen Einbruch zu verlangsamen, um es zu ermöglichen, den
	Einbrecher auf frischer Tat zu ertappen.</p><p>Der beste Weg, einen Einbruch zu entdecken, ist es, nach
	veränderten, fehlenden oder unerwarteten Dateien zu suchen.
	Der wiederum beste Weg, nach veränderten Dateien zu suchen, ist
	es, die Suche von einem anderen (oft zentralen) besonders
	geschützten System durchzuführen.  Es ist wichtig, dass
	Ihre Sicherheitsüberprüfungen vor einem Angreifer
	verborgen bleiben und daher sind sie auf einem besonders
	geschützten System gut aufgehoben.  Um dies optimal auszunutzen,
	müssen Sie dem besonders geschützten System Zugriffsrechte
	auf die zu schützenden Systeme geben.  Sie können die
	Dateisysteme der zu schützenden Systeme schreibgeschützt
	für das besonders geschützte System exportieren, oder
	Sie können der besonders geschützten Maschine
	<span class="application">SSH</span> auf die anderen Maschinen erlauben,
	indem Sie <span class="application">SSH</span>-Schlüsselpaare
	installieren.  Mit Ausnahme des verursachten Netzwerkverkehrs
	ist die NFS-Methode die am wenigsten sichtbare.  Sie erlaubt es Ihnen,
	nahezu unentdeckt die Dateisysteme der Clients zu beobachten.  Wenn
	Ihr besonders geschütztes System mit den Clients über
	einen Switch verbunden ist, ist die NFS-Methode oft das Mittel der
	Wahl.  Wenn das besonders geschützte System allerdings
	mit einem Hub verbunden ist, oder der Zugriff über mehrere
	Router geschieht, ist die NFS-Methode aus der Netzwerksicht zu
	unsicher.  In einem solchen Fall ist <span class="application">SSH</span>
	besser geeignet, auch wenn es deutliche Spuren
	hinterlässt.</p><p>Wenn das besonders geschützte System lesenden Zugriff
        auf die Clients hat, müssen Sie Skripten schreiben, die die
	Überwachung durchführen.  Wenn Sie die NFS-Methode
	verwenden, können Sie dazu einfache Systemwerkzeuge wie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=find&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">find</span>(1)</span></a> und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=md5&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">md5</span>(1)</span></a> benutzen.  Am besten berechnen
	Sie einmal am Tag MD5-Prüfsummen der Dateien, Konfigurationsdateien
	in <code class="filename">/etc</code> und
	<code class="filename">/usr/local/etc</code>
	sollten öfter überprüft werden.  Wenn Unstimmigkeiten
	zwischen den auf der besonders geschützten Maschine gehaltenen
	MD5-Prüfsummen und den ermittelten Prüfsummen festgestellt
	werden, sollte Ihr System einen Systemadministrator benachrichtigen,
	der den Unstimmigkeiten dann nachgehen sollte.  Ein gutes Skript
	überprüft das System auch auf verdächtige
	SUID-Programme sowie gelöschte oder neue Dateien in
	<code class="filename">/</code> und
	<code class="filename">/usr</code>.</p><p>Wenn Sie <span class="application">SSH</span> anstelle von NFS
	benutzen, wird das Erstellen der Skripten schwieriger.  Sie müssen
	die Skripten und die Programme wie <code class="command">find</code> mit
	<code class="command">scp</code> auf den Client kopieren.  Damit machen
	Sie die Überprüfung für einen Angreifer sichtbar.
	Außerdem kann der SSH-Client auf dem
	Zielsystem schon kompromittiert sein.  Zusammenfassend kann der
	Einsatz von <span class="application">SSH</span> nötig sein,
	wenn Sie über ungesicherte Verbindungen arbeiten, aber
	der Umgang mit dieser Methode ist auch sehr viel schwieriger.</p><p>Ein gutes Sicherheitsskript wird auch Dateien von Benutzern,
	die den Zugriff auf ein System ermöglichen, wie
	<code class="filename">.rhosts</code>, <code class="filename">.shosts</code>,
	<code class="filename">.ssh/authorized_keys</code> usw., auf
	Veränderungen untersuchen, die über die Möglichkeiten
	einer Überprüfung mit <code class="literal">MD5</code>
	(die ja nur Veränderungen erkennen kann) hinausgehen.</p><p>Wenn Sie über große Partitionen verfügen, kann
	es zu lange dauern, jede Datei zu überprüfen.  In diesem
	Fall sollten Sie beim Einhängen des Dateisystems Optionen
	setzen, die das Ausführen von SUID-Programmen verbieten.
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a> stellt dazu <code class="literal">nosuid</code>
	zur Verfügung.  Sie sollten diese Dateien aber trotzdem
	mindestens einmal die Woche überprüfen, da das Ziel
	dieser Schicht das Aufdecken eines Einbruchs, auch wenn er nicht
	erfolgreich war, ist.</p><p>Die Prozessüberwachung (siehe <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=accton&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">accton</span>(8)</span></a>)
	des Betriebssystems steht ein günstiges Werkzeug zur
	Verfügung, dass sich bei der Analyse eines Einbruchs
	als nützlich erweisen kann.  Insbesondere können Sie
	damit herausfinden, wie der Einbrecher in das System eingedrungen ist,
	vorausgesetzt die Dateien der Prozessüberwachung sind
	noch alle intakt.</p><p>Schließlich sollten die Sicherheitsskripten die Logdateien
	analysieren.  Dies sollte so sicher wie möglich durchgeführt
	werden, nützlich ist das Schreiben von Logdateien auf
	entfernte Systeme mit <code class="command">syslog</code>.  Ein Einbrecher
	wird versuchen, seine Spuren zu verwischen.  Die Logdateien
	sind wichtig für den Systemadministrator, da er aus ihnen
	den Zeitpunkt und die Art des Einbruchs bestimmen kann.  Eine
	Möglichkeit, die Logdateien unverändert aufzuheben,
	ist es, die Systemkonsole auf einen seriellen Port zu legen
	und die Informationen dort von einer gesicherten Maschine
	auszulesen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78221136"></a>15.3.7. Paranoia</h3></div></div></div><p>Es schadet nicht, ein bisschen paranoid zu sein.
	Grundsätzlich darf ein Systemadministrator jede
	Sicherheitsmaßnahme treffen, die die Bedienbarkeit des
	Systems nicht einschränkt.  Er kann auch Maßnahmen
	treffen, die die Bedienbarkeit einschränken,
	wenn er diese vorher genau durchdacht hat.  Was noch wichtiger
	ist: Halten Sie sich nicht sklavisch an dieses Dokument, sondern
	führen Sie eigene Maßnahmen ein, um nicht einem
	künftigen Angreifer, der auch Zugriff auf dieses Dokument
	hat, alle Ihre Methoden zu verraten.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78222416"></a>15.3.8. Denial-of-Service Angriffe</h3></div></div></div><a id="idp78223056" class="indexterm"></a><p>Dieser Abschnitt behandelt Denial-of-Service Angriffe (DoS).
	Ein DoS-Angriff findet typischerweise auf der Paketebene statt.
	Während Sie nicht viel gegen moderne Angriffe mit falschen
	Paketen, die das Netzwerk sättigen, ausrichten können,
	können Sie sehr wohl den Schaden begrenzen, den solche
	Angriffe verursachen können und insbesondere einen kompletten
	Serverausfall verhindern, indem Sie beispielsweise folgende
	Vorkehrungen treffen:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Begrenzen von <code class="function">fork()</code> Aufrufen.</p></li><li class="listitem"><p>Begrenzen von Sprungbrett-Angriffen (ICMP response Angriffen,
	    <span class="application">ping</span> zu Broadcast-Adressen usw.).</p></li><li class="listitem"><p>Kernel-Cache für Routen.</p></li></ol></div><p>Ein häufiger DoS-Angriff gegen forkende Server versucht
	den Server dazu zu bringen, solange neue Prozesse zu starten,
	bis das System den ganzen Speicher und alle Dateideskriptoren
	verbraucht hat, was dann zu einem Ausfall des Servers führt.
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> besitzt einige Optionen, um diese Art von Angriffen
	zu begrenzen.  Beachten Sie bitte, dass es möglich ist, einen
	Ausfall einer Maschine zu verhindern, doch ist es generell nicht
	möglich, den Ausfall eines Dienstes bei dieser Art
	von Angriffen zu verhindern.  Lesen Sie sich bitte die Manualpages
	von <span class="application">inetd</span> gut durch und achten Sie speziell
	auf die Optionen <code class="option">-c</code>, <code class="option">-C</code> und
	<code class="option">-R</code>.  Angriffe mit gefälschten IP-Adressen
	umgehen <code class="option">-C</code>, so dass normalerweise eine
	Kombination der Optionen benutzt werden muss.  Manche Server,
	die nicht von <span class="application">inetd</span> gestartet werden,
	besitzen Optionen, um den Start über <code class="function">fork()</code>
	einzuschränken.</p><p><span class="application">Sendmail</span> besitzt die Option
	<code class="option">-OMaxDaemonChildren</code>, die besser als die
	eingebauten Optionen zur Begrenzung der Systemauslastung funktioniert.
	Sie sollten beim Start von <span class="application">sendmail</span>
	<code class="literal">MaxDaemonChildren</code> so hoch setzen, dass Sie
	die erwartete Auslastung gut abfangen können.  Allerdings
	sollten Sie den Wert nicht so hoch setzen, dass der
	Rechner über seine eigenen Füße fällt.
	Es ist auch klug, <span class="application">Sendmail</span> im
	Queue-Modus (<code class="option">-ODeliveryMode=queued</code>) laufen zu
	lassen.  Der Dæmon (<code class="command">sendmail -bd</code>) sollte
	getrennt von den Queue-Läufen (<code class="command">sendmail -q15m</code>)
	laufen.  Wenn Sie trotzdem eine sofortige Auslieferung der Post
	wünschen, können Sie die Queue in einem geringeren
	Intervall, etwa <code class="option">-q1m</code>, abarbeiten.  Geben Sie
	für <span class="emphasis"><em>dieses</em></span>
	<span class="application">Sendmail</span> aber einen vernünftigen
	Wert für <code class="literal">MaxDaemonChildren</code> an, um
	Fehler zu verhindern.</p><p><span class="application">Syslogd</span> kann direkt angegriffen
	werden.  Daher empfehlen wir Ihnen unbedingt die Option
	<code class="option">-s</code> zu benutzen.  Sollte das nicht möglich
	sein, benutzen Sie bitte <code class="option">-a</code>.</p><p>Vorsicht ist auch mit Diensten geboten, die automatisch
	eine Rückverbindung eröffnen, wie der
	reverse-identd der <span class="application">TCP-Wrapper</span>.
        Diese Funktion der <span class="application">TCP-Wrapper</span>
	sollten Sie normalerweise nicht benutzen.</p><p>Es empfiehlt sich sehr, interne Dienste vor externen Zugriffen
	durch eine Firewall an der Grenze Ihres Netzwerks zu schützen.
	Dahinter steckt mehr die Idee, das Netzwerk vor Überlastung
	durch Angriffe von außen zu schützen, als interne
	Dienste vor einem <code class="systemitem">root</code>-Zugriff aus dem Netz
	zu schützen.  Konfigurieren Sie immer eine Firewall, die
	alle Zugriffe blockiert, das heißt blockieren Sie
	<span class="emphasis"><em>alles</em></span> außer den Ports A, B, C, D
	und M-Z.  Damit können Sie Zugriffe auf alle niedrigen
	Ports blockieren und Zugriffe auf spezielle Dienste wie
	<span class="application">named</span>, wenn Sie den primären
	Namensdienst für eine Zone anbieten,
	<span class="application">ntalkd</span> oder
	<span class="application">sendmail</span> erlauben.  Wenn Sie die
	Firewall so konfigurieren, das sie in der Voreinstellung alle
	Zugriffe erlaubt, ist es sehr wahrscheinlich, dass Sie
	vergessen, eine Reihe von Diensten zu blockieren bzw. einen
	internen Dienst einführen und dann vergessen die Firewall
	zu aktualisieren.  Sie können immer die höheren
	Portnummern öffnen, ohne die niedrigen Portnummern,
	die nur von <code class="systemitem">root</code> benutzt werden dürfen,
	zu kompromittieren.  Beachten Sie bitte auch, dass es
	FreeBSD erlaubt, die Portnummern, die für dynamische
	Verbindungen zur Verfügung stehen, zu konfigurieren.
	Mit <code class="command">sysctl</code> lassen sich verschiedene
	Bereiche der <code class="varname">net.inet.ip.portrange</code> Variablen
	setzen (eine Liste erhalten Sie mit <code class="command">sysctl -a | fgrep
	portrange</code>).
	So können Sie zum Beispiel die Portnummern 4000 bis 5000
	für den normalen Bereich und die Nummern 49152 bis 65535
	für den hohen Bereich vorsehen.  Dies erleichtert Ihnen
	die Konfiguration der Firewall, da Sie nun Zugriffe auf Ports
	unterhalb von 4000, mit Ausnahme der Dienste, die von außen
	erreichbar sein sollen, blockieren können.</p><p>Eine andere Form eines DoS-Angriffs nutzt einen Server
	als Sprungbrett, der Server wird dabei so angegriffen, dass
	seine Antworten ihn selber, das lokale Netzwerk oder einen
	anderen Server überlasten.  Der am häufigsten verwendete
	Angriff dieser Art ist der <span class="emphasis"><em>ICMP ping broadcast
	Angriff</em></span>.  Der Angreifer fälscht dazu
	<span class="application">ping</span>-Pakete, die zu der Broadcast-Adresse
	Ihres LANs gesendet werden, indem er darin als Quelladresse
	die Adresse des Opfers einsetzt.  Wenn die Router an der Grenze
	Ihres Netzwerks <span class="application">ping</span>-Pakete auf
	Broadcast-Adressen nicht abwehren, wird Ihr LAN genügend
	Netzwerkverkehr generieren, um das Ziel des Angriffs zu
	überlasten.  Dies kann besonders effektiv sein, wenn der
	Angreifer diese Methode mit mehreren Dutzend Broadcast-Adressen
	über mehrere Netzwerke einsetzt.  Es wurden schon
	Broadcast-Angriffe mit über 120 Megabit pro Sekunde
	gemessen.  Ein zweiter Sprungbrett-Angriff wird gegen
	das Fehlerbehandlungssystem von ICMP eingesetzt.  Indem ein Angreifer
	Pakete konstruiert, die eine ICMP-Fehlermeldung hervorrufen, kann
	er das einkommende Netzwerk des Servers sättigen und diesen
	wiederum veranlassen sein ausgehendes Netzwerk mit ICMP-Antworten
	zu sättigen.  Diese Art des Angriffs kann den kompletten
	Speicher des Servers aufbrauchen und damit den Server stilllegen,
	insbesondere wenn der Server nicht in der Lage ist, die generierten
	ICMP-Antworten schnell genug abzuführen.  Verwenden Sie die
	<span class="application">sysctl</span>-Variable
	<code class="literal">net.inet.icmp.icmplim</code>, um die Auswirkungen
	solcher Angriffe zu begrenzen.  Die letzte
	weit verbreitete Form von Sprungbrett-Angriffen verwendet
	interne <span class="application">inetd</span>-Dienste wie den
	UDP <span class="application">echo</span>-Dienst.  Der Angreifer fälscht
	dazu einfach ein UDP-Paket, indem er als Quellport den
	<span class="application">echo</span>-Port von Server A
	und als Zielport den <span class="application">echo</span>-Port von
	Server B angibt, wobei beide
	Server in Ihrem LAN stehen.  Die beiden Server werden nun
        dieses Paket zwischen sich hin und her schicken.  Der Angreifer
	kann die beiden Server und das LAN einfach damit überlasten,
	dass er mehrere Pakete dieser Art generiert.  Ähnliche
	Probleme gibt es mit dem internen
	<span class="application">chargen</span>-Port, daher sollten Sie
	die internen <span class="application">inetd</span>-Testdienste
	abstellen.</p><p>Gefälschte IP-Pakete können dazu benutzt werden,
	den Kernel-Cache für Routen zu überlasten.  Schauen Sie
	sich bitte die  <code class="command">sysctl</code>-Parameter
	<code class="varname">net.inet.ip.rtexpire</code>, <code class="varname">rtminexpire</code>
	und <code class="varname">rtmaxcache</code> an.  Ein Angriff der gefälschte
	Pakete mit zufälligen Quelladressen einsetzt, bewirkt, dass
	der Kernel eine Route im Route-Cache anlegt, die Sie sich mit
	<code class="command">netstat -rna | fgrep W3</code> ansehen können.
	Diese Routen verfallen für gewöhnlich nach 1600 Sekunden.
	Wenn der Kernel feststellt, dass die Routingtabelle im Cache
	zu groß geworden ist, wird er dynamisch den Wert von
	<code class="varname">rtexpire</code> verringern.  Dieser Wert wird aber nie
	kleiner werden als <code class="varname">rtminexpire</code>.  Daraus
	ergeben sich zwei Probleme:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Der Kernel reagiert nicht schnell genug, wenn ein
	    Server mit einer niedrigen Grundlast plötzlich angegriffen
	    wird.</p></li><li class="listitem"><p><code class="varname">rtminexpire</code> ist nicht klein genug,
	    um einen anhaltenden Angriff zu überstehen.</p></li></ol></div><p>Wenn Ihre Server über eine T3 oder eine noch schnellere
	Leitung mit dem Internet verbunden sind, ist es klug, mit
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sysctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sysctl</span>(8)</span></a> die Werte für <code class="varname">rtexpire</code> und
	<code class="varname">rtminexpire</code> händisch zu setzen.  Setzen
	Sie bitte keinen der Werte auf Null, außer Sie wollen die
	Maschine zum Erliegen bringen.  Ein Wert von 2 Sekunden für
	beide Parameter sollte ausreichen, um die Routingtabelle vor
	einem Angriff zu schützen.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp78288208"></a>15.3.9. Anmerkungen zum Zugriff mit Kerberos und SSH</h3></div></div></div><a id="idp78288848" class="indexterm"></a><p>Es gibt ein paar Punkte, die Sie beachten sollten, wenn Sie
	<span class="application">Kerberos</span> oder <span class="application">SSH</span>
	einsetzen wollen.  <span class="application">Kerberos</span> 5 ist ein
	ausgezeichnetes Authentifizierungsprotokoll.  Leider gibt es
	Fehler in den für <span class="application">Kerberos</span>
	angepassten Versionen von <span class="application">telnet</span> und
	<span class="application">rlogin</span>, die sie ungeeignet für den
	Umgang mit binären Datenströmen machen.  Weiterhin
	verschlüsselt <span class="application">Kerberos</span> Ihre Sitzung
	nicht, wenn Sie nicht die <code class="option">-x</code> Option verwenden,
	mit <span class="application">SSH</span> wird dagegen alles
	verschlüsselt.</p><p>Ein Problem mit SSH sind Weiterleitungen von Verbindungen.
	Wenn Sie von einer sicheren Maschine, auf der sich Ihre
	Schlüssel  befinden, eine Verbindung zu einer
	ungesicherten Maschine aufmachen, wird für die Dauer der
	Sitzung ein Port für Weiterleitungen geöffnet.
	Ein Angreifer, der auf der unsicheren Maschine Zugang zu
	<code class="systemitem">root</code> hat, kann diesen Port
	benutzen, um Zugriff auf andere Maschinen zu
	erlangen, die mit Ihren Schlüsseln zugänglich
	sind.</p><p>Wir empfehlen Ihnen, für die Logins Ihrer Mitarbeiter immer
	<span class="application">SSH</span> zusammen mit
	<span class="application">Kerberos</span> einzusetzen.  Damit reduzieren
	Sie die Abhängigkeit von potentiell gefährdeten
	Schlüsseln und schützen gleichzeitig die Passwörter
	mit <span class="application">Kerberos</span>.
	<span class="application">SSH</span>-Schlüsselpaare sollten nur
	für automatisierte Aufgaben von einem besonders gesicherten
	Server eingesetzt werden (<span class="application">Kerberos</span>
	kann für diese Art von Aufgaben nicht eingesetzt werden).
	Weiterhin empfehlen wir Ihnen, das Weiterreichen von Schlüsseln
	in der <span class="application">SSH</span>-Konfiguration abzustellen bzw.
	die <code class="literal">from=IP/DOMAIN</code> Option in
	<code class="filename">authorized_keys</code> zu verwenden, die den
	Schlüssel nur von bestimmten Maschinen aus nutzbar macht.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security-intro.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="security.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="crypt.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. Einführung </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 15.4. DES, Blowfish, MD5, und Crypt</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>