<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>33.5. Bluetooth</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="advanced-networking.html" title="Kapitel 33. Weiterführende Netzwerkthemen" /><link rel="prev" href="network-usb-tethering.html" title="33.4. USB Tethering" /><link rel="next" href="network-bridging.html" title="33.6. LAN-Kopplung mit einer Bridge" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">33.5. Bluetooth</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-usb-tethering.html">Zurück</a> </td><th width="60%" align="center">Kapitel 33. Weiterführende Netzwerkthemen</th><td width="20%" align="right"> <a accesskey="n" href="network-bridging.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-bluetooth"></a>33.5. Bluetooth</h2></div><div><span class="authorgroup">Beigetragen von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pav</span> <span class="surname">Lucistnik</span></span>. </span></div></div></div><a id="idp92660304" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92661072"></a>33.5.1. Übersicht</h3></div></div></div><p>Bluetooth ermöglicht die Bildung von persönlichen
	Netzwerken über drahtlose Verbindungen bei einer maximalen
	Reichweite von 10 Metern und operiert im unlizensierten
	2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
	gebildet, wenn sich mobile Geräte, wie Mobiltelefone,
	Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz zu
	Wireless LAN ermöglicht Bluetooth auch höherwertige
	Dienste, wie FTP-ähnliche Dateiserver, Filepushing,
	Sprachübertragung, Emulation von seriellen Verbindungen
	und andere mehr.</p><p>Der Bluetooth-Stack von FreeBSD verwendet das
	Netgraph-Framework (<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netgraph&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">netgraph</span>(4)</span></a>).  Viele
	Bluetooth-USB-Adapter werden durch den <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a>-Treiber
	unterstützt.  Auf dem Chip BCM2033
	von Broadcom basierende	Bluetooth-Geräte werden von den
	Treibern <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ubtbcmfw</span>(4)</span></a> sowie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_ubt</span>(4)</span></a> unterstützt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_bt3c</span>(4)</span></a>-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Geräte werden von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sio&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">sio</span>(4)</span></a>, <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_h4&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_h4</span>(4)</span></a>
	sowie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcseriald&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcseriald</span>(8)</span></a>	unterstützt.  Dieses Kapitel
	beschreibt die Verwendung von USB-Bluetooth-Adaptern.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92672976"></a>33.5.2. Die Bluetooth-Unterstützung aktivieren</h3></div></div></div><p>Bluetooth-Unterstützung ist in der Regel als
	Kernelmodul verfügbar.  Damit ein Gerät funktioniert,
	muss der entsprechende Treiber im Kernel geladen werden:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kldload ng_ubt</code></strong></pre><p>Ist das Bluetooth-Gerät beim Systemstart angeschlossen,
        kann das entsprechende Modul auch von
        <code class="filename">/boot/loader.conf</code> geladen werden:</p><pre class="programlisting">ng_ubt_load="YES"</pre><p>Schließen Sie Ihren USB-Adapter an, sollte eine
	Meldung ähnlich der folgenden auf der Konsole (oder in
	syslog) erscheinen:</p><pre class="screen">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</pre><p>Zum Starten und Beenden des Bluetooth-Stacks verwenden Sie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=service&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">service</span>(8)</span></a>.  Es ist
	empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den
	Adapter entfernen.  Selbst wenn Sie dies nicht tun, kommt es
	(normalerweise) zu keinem fatalen Fehler.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich
	der folgenden:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service bluetooth start ubt0</code></strong>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92679120"></a>33.5.3. Das Host Controller Interface (HCI)</h3></div></div></div><a id="idp92679760" class="indexterm"></a><p>Das <span class="foreignphrase"><em class="foreignphrase">Host Controller Interface</em></span>
	(HCI) bietet eine Befehlsschnittstelle zum Basisbandcontroller
	und Linkmanager, sowie Zugriff auf den Hardwarestatus und die
	Kontrollregister.  Dadurch wird ein einheitlicher Zugriff auf
	die Fähigkeiten des Bluetooth-Basisbands möglich.  Die
	HCI-Layer des Rechners tauschen Daten und Befehle mit der
	HCI-Firmware der Bluetooth-Geräte aus.  Über den
	Host Controller Transport Layer-Treiber (also den physikalischen
	Bus) können beide HCI-Layer miteinander
	kommunizieren.</p><p>Eine einzelne Netgraph-Gerätedatei vom Typ
	<span class="emphasis"><em>hci</em></span> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die HCI-Gerätedatei ist
	normalerweise mit der Bluetooth-Gerätetreiberdatei
	(downstream) sowie der L2CAP-Gerätedatei (upstream)
	verbunden.  Alle HCI-Operationen müssen über die
	HCI-Gerätedatei und nicht über die Treiberdatei
	erfolgen.  Der Standardname für die HCI-Gerätedatei
	(die in <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_hci&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_hci</span>(4)</span></a> beschrieben wird) lautet
	<span class="quote">&#8222;<span class="quote">devicehci</span>&#8220;</span>.</p><p>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Geräten.  Diese
	Funktion wird als <span class="emphasis"><em>inquiry</em></span> bezeichnet.
	Inquiry sowie andere mit HCI in Verbindung stehende Funktionen
	werden von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hccontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hccontrol</span>(8)</span></a> zur Verfügung gestellt.  Das
	folgende Beispiel zeigt, wie man herausfindet, welche
	Bluetooth-Geräte sich in Reichweite befinden.  Eine solche
	Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass ein
	Gerät nur dann antwortet, wenn es sich im Modus
	<span class="emphasis"><em>discoverable</em></span> befindet.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci inquiry</code></strong>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</pre><p><code class="literal">BD_ADDR</code> stellt, ähnlich der
	MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines
	Bluetooth-Gerätes dar.  Diese Adresse ist für die
	Kommunikation mit dem Gerät nötig.  Es ist aber auch
	möglich, BD_ADDR einen Klartextnamen zuzuweisen.  Die
	Datei <code class="filename">/etc/bluetooth/hosts</code> enthält
	Informationen über die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Geräts in Erfahrung bringen kann:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</code></strong>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</pre><p>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird
	dieses Ihren Rechner unter dem Namen
	<span class="quote">&#8222;<span class="quote">your.host.name (ubt0)</span>&#8220;</span> finden.  Dieser Name kann
	aber jederzeit geändert werden.</p><p>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen (an
	denen nur zwei Bluetooth-Geräte beteiligt sind), aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von
	mehreren Bluetooth-Geräten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Gerätes anzeigen kann:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>hccontrol -n ubt0hci read_connection_list</code></strong>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</pre><p>Ein <span class="emphasis"><em>connection handle</em></span> ist für die
	Beendigung einer Basisbandverbindung nützlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci disconnect 41</code></strong>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</pre><p>Rufen Sie <code class="command">hccontrol help</code> auf, wenn Sie
	eine komplette Liste aller verfügbaren HCI-Befehle
	benötigen.  Die meisten dieser Befehle müssen nicht
	als <code class="systemitem">root</code> ausgeführt werden.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92702160"></a>33.5.4. Das Logical Link Control and Adaptation Protocol (L2CAP)</h3></div></div></div><a id="idp92702800" class="indexterm"></a><p>Das <span class="foreignphrase"><em class="foreignphrase">Logical Link Control and Adaptation
	Protocol</em></span> (L2CAP) bietet
	höherwertigen Protokollen verbindungsorientierte und
	verbindungslose Datendienste an.  Dazu gehören auch
	Protokollmultiplexing, Segmentierung und Reassemblierung.
	L2CAP erlaubt höherwertigen Protokollen und Programmen den
	Versand und Empfang von L2CAP-Datenpaketen mit einer Länge
	von bis zu 64 Kilobytes.</p><p>L2CAP arbeitet <span class="emphasis"><em>kanal</em></span>basiert.  Ein
	Kanal ist eine logische Verbindung innerhalb einer
	Basisbandverbindung.  Jeder Kanal ist dabei an ein einziges
	Protokoll gebunden.  Mehrere Geräte können an das
	gleiche Protokoll gebunden sein, es ist	aber nicht möglich,
	einen Kanal an mehrere Protokolle zu binden.  Jedes über
	einen Kanal ankommende L2CAP-Paket wird an das entsprechende
	höherwertige Protokoll weitergeleitet.  Mehrere Kanäle
	können sich die gleiche Basisbandverbindung teilen.</p><p>Eine einzelne Netgraph-Gerätedatei vom Typ
	<span class="emphasis"><em>l2cap</em></span> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die L2CAP-Gerätedatei ist
	normalerweise mit der Bluetooth-HCI-Gerätedatei
	(downstream) sowie der Bluetooth-Socket-Gerätedatei
	(upstream) verbunden.  Der Standardname für die
	L2CAP-Gerätedatei, die in <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4"><span class="citerefentry"><span class="refentrytitle">ng_l2cap</span>(4)</span></a> beschrieben
	wird, lautet <span class="quote">&#8222;<span class="quote">devicel2cap</span>&#8220;</span>.</p><p>Ein nützlicher Befehl zum Anpingen von anderen
	Geräten ist <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2ping&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2ping</span>(8)</span></a>.  Einige Bluetooth-Geräte
	senden allerdings nicht alle erhaltenen Daten zurück.  Die
	Ausgabe <code class="literal">0 bytes</code> ist also kein Fehler:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>l2ping -a 00:80:37:29:19:a4</code></strong>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</pre><p>Das Programm <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a> liefert Informationen
	über L2CAP-Dateien.  Das folgende Beispiel zeigt, wie man
	die Liste der logischen Verbindungen (Kanäle) sowie die
	Liste der Basisbandverbindungen abfragen kann:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_channel_list</code></strong>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<code class="prompt">%</code> <strong class="userinput"><code>l2control -a 00:02:72:00:d4:1a read_connection_list</code></strong>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</pre><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=btsockstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">btsockstat</span>(1)</span></a> ist ein weiteres Diagnoseprogramm.  Es
	funktioniert analog zu <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a>, arbeitet aber mit
	Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt die
	gleiche Liste der logischen Verbindungen wie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=l2control&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">l2control</span>(8)</span></a>
	im vorherigen Beispiel.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>btsockstat</code></strong>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92725072"></a>33.5.5. Das RFCOMM-Protokoll</h3></div></div></div><a id="idp92725712" class="indexterm"></a><p>Das RFCOMM-Protokoll emuliert serielle Verbindungen
	über das L2CAP-Protokoll.  Es basiert auf dem ETSI-Standard
	TS 07.10.  Bei RFCOMM handelt es sich um ein einfaches
	Transportprotokoll, das um Funktionen zur Emulation der
	9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen
	seriellen Ports ergänzt wurde.  RFCOMM erlaubt bis zu 60
	simultane Verbindungen (RFCOMM-Kanäle) zwischen zwei
	Bluetooth-Geräten.</p><p>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den
	Kommunikationsendpunkten), die über das
	Kommunikationssegment miteinander verbunden sind.  RFCOMM
	unterstützt Anwendungen, die auf serielle Ports angewiesen
	sind.  Das Kommunikationssegment entspricht der (direkten)
	Bluetooth-Verbindung zwischen den beiden Geräten.</p><p>RFCOMM kümmert sich um die direkte Verbindung von zwei
	Geräten, oder um die Verbindung zwischen einem Gerät
	und einem Modem (Netzwerkverbindung).  RFCOMM unterstützt
	auch andere Konfigurationen.  Ein Beispiel dafür sind
	Module, die drahtlose Bluetooth-Geräte mit einer
	verkabelten Schnittstelle verbinden können.</p><p>Unter FreeBSD wurde das RFCOMM-Protokoll im Bluetooth Socket-Layer
	implementiert.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92728144"></a>33.5.6. Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Geräten (<span class="foreignphrase"><em class="foreignphrase">Pairing</em></span>)
      </h3></div></div></div><a id="idp92729168" class="indexterm"></a><p>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothgerät mit
	jedem anderen Gerät verbinden.  Ein Bluetoothgerät
	(beispielsweise ein Mobiltelefon) kann jedoch für einen
	bestimmten Dienst (etwa eine Einwählverbindung) eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <span class="emphasis"><em>PIN-Codes</em></span>.  Ein PIN-Code ist ein
	maximal 16 Zeichen langer ASCII-String.  Damit eine Verbindung
	zustande kommt, muss auf beiden Geräten der gleiche
	PIN-Code verwendet werden.  Nachdem der Code eingegeben wurde,
	erzeugen beide Geräte einen <span class="emphasis"><em>link key</em></span>,
	der auf den Geräten gespeichert wird.  Beim nächsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<span class="foreignphrase"><em class="foreignphrase">Pairing</em></span>.  Geht der Link Key auf
	einem Gerät verloren, muss das Pairing wiederholt
	werden.</p><p>Der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a>-Daemon verarbeitet alle
	Bluetooth-Authentifzierungsanforderungen und wird über die
	Datei <code class="filename">/etc/bluetooth/hcsecd.conf</code>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration für ein Mobiltelefon, das den PIN-Code
	<span class="quote">&#8222;<span class="quote">1234</span>&#8220;</span> verwendet:</p><pre class="programlisting">device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</pre><p>Von der Länge abgesehen, unterliegen PIN-Codes keinen
	Einschränkungen.  Einige Geräte, beispielsweise
	Bluetooth-Headsets, haben einen festen PIN-Code eingebaut.  Die
	Option <code class="option">-d</code> sorgt dafür, dass der
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hcsecd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hcsecd</span>(8)</span></a>-Daemon im Vordergrund läuft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Gerät auf <span class="foreignphrase"><em class="foreignphrase">receive pairing</em></span>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Gerät.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der PIN-Code benötigt wird.  Geben Sie den
	gleichen PIN-Code ein, den Sie in
	<code class="filename">hcsecd.conf</code> festgelegt haben.  Ihr Computer
	und das entfernte Gerät sind nun miteinander verbunden.
	Alternativ können Sie das Pairing auch auf dem entfernten
	Gerät initiieren.</p><p><span class="application">hcsecd</span> kann durch das Einfügen
	der folgenden Zeile in <code class="filename">/etc/rc.conf</code>
	beim Systemstart automatisch aktiviert werden:</p><pre class="programlisting">hcsecd_enable="YES"</pre><p>Es folgt nun eine beispielhafte Ausgabe
	des <span class="application">hcsecd</span>-Daemons:</p><pre class="programlisting">hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92747344"></a>33.5.7. Das Service Discovery Protocol (SDP)</h3></div></div></div><a id="idp92747984" class="indexterm"></a><p>Das <span class="foreignphrase"><em class="foreignphrase">Service Discovery Protocol</em></span>
	(SDP) erlaubt es Clientanwendungen, von Serveranwendungen
	angebotene Dienste sowie deren Eigenschaften abzufragen.  Zu
	diesen Eigenschaften gehören die Art oder die Klasse der
	angebotenen Dienste sowie der Mechanismus oder das Protokoll,
	die zur Nutzung des Dienstes notwendig sind.</p><p>SDP ermöglicht Verbindungen zwischen einem SDP-Server
	und einem SDP-Client.  Der Server enthält eine Liste mit
	den Eigenschaften der vom Server angebotenen Dienste.  Jeder
	Eintrag beschreibt jeweils einen einzigen Serverdienst.  Ein
	Client kann diese Informationen durch eine SDP-Anforderung
	vom SDP-Server beziehen.  Wenn der Client oder eine Anwendung
	des Clients einen Dienst nutzen will, muss eine separate
	Verbindung mit dem Dienstanbieter aufgebaut werden.  SDP bietet
	einen Mechanismus zum Auffinden von Diensten und deren
	Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung
	dieser Dienste.</p><p>Normalerweise sucht ein SDP-Client nur nach Diensten, die
	bestimmte geforderte Eigenschaften erfüllen.  Es ist aber
	auch möglich, anhand der Dienstbeschreibungen eine
	allgemeine Suche nach den von einem Server angebotenen Diensten
	durchzuführen.  Diesen Vorgang bezeichnet man als
        <span class="foreignphrase"><em class="foreignphrase">Browsing</em></span>.</p><p>Der Bluetooth-SDP-Server <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a> und der
	Kommandozeilenclient <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a> sind bereits in der
	Standardinstallation von FreeBSD enthalten.  Das folgende Beispiel
	zeigt, wie eine SDP-Abfrage durchgeführt wird:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec browse</code></strong>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</pre><p>... und so weiter.  Beachten Sie, dass jeder Dienst eine
	Liste seiner Eigenschaften (etwa den RFCOMM-Kanal)
	zurückgibt.  Je nach dem, welche Dienste Sie
	benötigen, sollten Sie sich einige dieser Eigenschaften
	notieren.  Einige Bluetooth-Implementationen unterstützen
	kein <span class="foreignphrase"><em class="foreignphrase">Service Browsing</em></span> und geben
	daher eine leere Liste zurück.  Ist dies der Fall, ist es
	dennoch möglich, nach einem bestimmten Dienst zu suchen.
	Das folgende Beispiel demonstriert die Suche nach dem
	OBEX Object Push (OPUSH) Dienst:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></strong></pre><p>Unter FreeBSD ist es die Aufgabe des <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>-Servers,
	Bluetooth-Clients verschiedene Dienste anzubieten.  Sie
	können diesen Server durch das Einfügen der folgenden
	Zeile in die Datei <code class="filename">/etc/rc.conf</code>
	aktivieren:</p><pre class="programlisting">sdpd_enable="YES"</pre><p>Nun kann der <span class="application">sdpd</span>-Daemon durch
	folgene Eingabe gestartet werden:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service sdpd start</code></strong></pre><p>Der lokale Server, der den entfernten Clients
	Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	lokalen SDP-Daemon.  Ein Beispiel für eine solche
	Anwendung ist <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.  Einmal gestartet, wird der
	Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</p><p>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server
	registriert sind, lässt sich durch eine SDP-Abfrage
	über einen lokalen Kontrollkanal abfragen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sdpcontrol -l browse</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92761552"></a>33.5.8. Einwahlverbindungen (Dial-Up Networking (DUN)) oder
	Netzwerkverbindungen mit PPP (LAN)-Profilen einrichten</h3></div></div></div><p>Das
	<span class="foreignphrase"><em class="foreignphrase">Dial-Up Networking (DUN)</em></span>-Profil
	wird vor allem für Modems und Mobiltelefone verwendet.
	Dieses Profil ermöglicht folgende Szenarien:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computer als drahtloses Modem, um sich
	  über einen Einwahlprovider mit dem Internet zu verbinden
	  oder andere Einwahldienste zu benutzen.</p></li><li class="listitem"><p>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computers, um auf Datenabfragen zu
	  reagieren.</p></li></ul></div><p>Der Zugriff auf ein Netzwerk über das PPP (LAN)-Profil
	kann in folgenden Situationen verwendet werden:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Den LAN-Zugriff für ein einzelnes
	  Bluetooth-Gerät</p></li><li class="listitem"><p>Den LAN-Zugriff für mehrere
	  Bluetooth-Geräte</p></li><li class="listitem"><p>Eine PC-zu-PC-Verbindung (unter Verwendung
	  einer PPP-Verbindung über eine emulierte serielle
	  Verbindung)</p></li></ul></div><p>Beide Profile werden unter FreeBSD durch <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ppp&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">ppp</span>(8)</span></a> sowie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> implementiert - einem Wrapper, der
	RFCOMM Bluetooth-Verbindungen unter PPP nutzbar macht.  Bevor
	ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt
	in <code class="filename">/etc/ppp/ppp.conf</code> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.</p><p>Im folgenden Beispiel verwenden wir <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>, um
	eine RFCOMM-Verbindung zu einem entfernten Gerät mit der
	<code class="literal">BD_ADDR 00:80:37:29:19:a4</code> auf dem
	RFCOMM-Kanal <code class="literal">DUN</code> aufzubauen.  Die aktuelle
	RFCOMM-Kanalnummer erhalten Sie vom entfernten Gerät
	über SDP.  Es ist auch möglich, manuell einen
	RFCOMM-Kanal festzulegen.  In diesem Fall führt
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a> keine SDP-Abfrage durch.  Verwenden Sie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpcontrol</span>(8)</span></a>, um die RFCOMM-Kanäle des entfernten
	Geräts herauszufinden.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</code></strong></pre><p>Der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sdpd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sdpd</span>(8)</span></a>-Server muss laufen, damit ein Netzzugriff
	mit dem PPP (LAN)-Profil möglich ist.  Außerdem muss
	für den LAN-Client ein neuer Eintrag in
	<code class="filename">/etc/ppp/ppp.conf</code> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rfcomm_pppd</span>(8)</span></a>.  Danach starten Sie den RFCOMM PPP-Server
	über eine gültige RFCOMM-Kanalnummer.  Der
	RFCOMM PPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den
	lokalen SDP-Daemon.  Das folgende Beispiel zeigt Ihnen, wie man
	den RFCOMM PPP-Server startet.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_pppd -s -C 7 -l rfcomm-server</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92831824"></a>33.5.9. Das Profil OBEX-Push (OPUSH)</h3></div></div></div><a id="idp92832592" class="indexterm"></a><p>OBEX ist ein häufig verwendetes Protokoll für den
	Dateitransfer zwischen Mobilgeräten.  Sein Hauptzweck ist
	die Kommunikation über die Infrarotschnittstelle.  Es dient
	daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum
	Austausch von Visitenkarten oder Kalendereinträgen zwischen
	Mobiltelefonen und anderen Geräten mit PIM-Funktionen.</p><p>Server und Client von OBEX werden durch das Softwarepaket
	<span class="application">obexapp</span> bereitgestellt, das als Port
	<a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/obexapp/pkg-descr">comms/obexapp</a> verfügbar
	ist.</p><p>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt
	oder angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	ein Termin sein.  Der OBEX-Client fordert über SDP die
	Nummer des RFCOMM-Kanals vom entfernten Gerät an.  Dies
	kann auch durch die Verwendung des Servicenamens anstelle der
	RFCOMM-Kanalnummer erfolgen.  Folgende Dienste werden
	unterstützt:  IrMC, FTRN und OPUSH.  Es ist möglich,
	den RFCOMM-Kanal als Nummer anzugeben.  Es folgt nun ein
	Beispiel für eine OBEX-Sitzung, bei der ein
	Informationsobjekt vom Mobiltelefon angefordert und ein neues
	Objekt (hier eine Visitenkarte) an das Telefonbuch des
	Mobiltelefons geschickt wird:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>obexapp -a 00:80:37:29:19:a4 -C IrMC</code></strong>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</pre><p>Um OBEX-Push-Dienste anbieten zu können, muss der
	<span class="application">sdpd</span>-Server gestartet sein.  Ein
	Wurzelverzeichnis, in dem alle ankommenden Objekt gespeichert
	werden, muss zusätzlich angelegt werden.  In der
	Voreinstellung ist dies <code class="filename">/var/spool/obex</code>.
	Starten Sie den OBEX-Server mit einer gültigen Kanalnummer.
	Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem
	lokalen SDP-Daemon.  Um den OBEX-Server zu starten, geben Sie
	Folgendes ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>obexapp -s -C 10</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92838480"></a>33.5.10. Das Profil Serial-Port (SPP)</h3></div></div></div><p>Durch dieses Profil können Bluetooth-Geräte RS232-
	(oder damit kompatible) serielle Kabelverbindungen emulieren.
	Anwendungen sind dadurch in der Lage, über eine virtuelle
	serielle Verbindung Bluetooth als Ersatz für eine
	Kabelverbindung zu nutzen.</p><p>Das Profil Serial-Port wird durch <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a>
	verwirklicht.  Pseudo-tty wird hier als virtuelle serielle
	Verbindung verwendet.  Das folgende Beispiel zeigt, wie man sich
	mit einem entfernten Serial-Port-Dienst verbindet.  Beachten
	Sie, dass Sie den RFCOMM-Kanal nicht angeben müssen, da
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">rfcomm_sppd</span>(1)</span></a> diesen über SDP vom entfernten
	Gerät abfragen kann.  Wenn Sie dies nicht wollen,
	können Sie einen RFCOMM-Kanal auch manuell festlegen.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</code></strong>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</pre><p>Sobald die Verbindung hergestellt ist, kann pseudo-tty als
        serieller Port verwenden werden.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>cu -l ttyp6</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92848080"></a>33.5.11. Problembehandlung</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92848720"></a>33.5.11.1. Ein entferntes Gerät kann keine Verbindung
	  aufbauen</h4></div></div></div><p>Einige ältere Bluetooth-Geräte unterstützen
	  keinen Rollentausch.  Wenn FreeBSD eine neue Verbindung
	  akzeptiert, wird versucht, die Rolle zu tauschen, um zum
	  Master zu werden.  Geräte, die dies nicht
	  unterstützen, können keine Verbindung aufbauen.
	  Beachten Sie, dass der Rollentausch ausgeführt wird,
	  sobald eine neue Verbindung aufgebaut wird, daher ist es
	  nicht möglich, das entfernte Gerät zu fragen, ob es
	  den Rollentausch unterstützt.  Dieses Verhalten von FreeBSD
	  kann aber durch eine HCI-Option geändert werden:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hccontrol -n ubt0hci write_node_role_switch 0</code></strong></pre></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp92850768"></a>33.5.11.2. Wo finde ich genaue Informationen darüber, was
	  schiefgelaufen ist?</h4></div></div></div><p>Verwenden Sie <span class="application">hcidump</span>,
	  das Sie über den Port <a xmlns="" class="package" href="http://www.freebsd.org/cgi/url.cgi?ports/comms/hcidump/pkg-descr">comms/hcidump</a> installieren
	  können.  <span class="application">hcidump</span> hat
	  Ähnlichkeiten mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=tcpdump&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">tcpdump</span>(1)</span></a>.  Es dient zur Anzeige
	  der Bluetooth-Pakete in einem Terminal oder zur Speicherung
	  der Pakete in einer Datei (Dump).</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-usb-tethering.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="advanced-networking.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="network-bridging.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">33.4. USB Tethering </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 33.6. LAN-Kopplung mit einer Bridge</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>