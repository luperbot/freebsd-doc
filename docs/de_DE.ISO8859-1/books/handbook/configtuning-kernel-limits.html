<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>12.14. Einstellungen von Kernel Limits</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="config-tuning.html" title="Kapitel 12. Konfiguration und Tuning" /><link rel="prev" href="configtuning-disk.html" title="12.13. Tuning von Laufwerken" /><link rel="next" href="adding-swap-space.html" title="12.15. Hinzufügen von Swap-Bereichen" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.14. Einstellungen von Kernel Limits</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="configtuning-disk.html">Zurück</a> </td><th width="60%" align="center">Kapitel 12. Konfiguration und Tuning</th><td width="20%" align="right"> <a accesskey="n" href="adding-swap-space.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="configtuning-kernel-limits"></a>12.14. Einstellungen von Kernel Limits</h2></div></div></div><a id="idp76781264" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="file-process-limits"></a>12.14.1. Datei und Prozeß Limits</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="kern-maxfiles"></a>12.14.1.1. <code class="varname">kern.maxfiles</code></h4></div></div></div><a id="idp76788304" class="indexterm"></a><p>Abhängig von den Anforderungen Ihres Systems
	  kann <code class="varname">kern.maxfiles</code> erhöht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <span class="errorname">file: table is full</span>
	  wiederholt im Puffer für Systemmeldungen sehen.  Den
	  Inhalt des Puffers können Sie sich mit
	  <code class="command">dmesg</code> anzeigen lassen.</p><p>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <span class="quote">&#8222;<span class="quote">dicken</span>&#8220;</span>
	  Produktionsservern können leicht Tausende Dateideskriptoren
	  benötigt werden, abhängig von der Art und Anzahl der
	  gleichzeitig laufenden Dienste.</p><p>In älteren FreeBSD-Versionen wurde die Voreinstellung
	  von <code class="varname">kern.maxfile</code> aus der
	  Kernelkonfigurationsoption <code class="literal">maxusers</code>
	  bestimmt.  <code class="varname">kern.maxfiles</code> wächst
	  proportional mit dem Wert von <code class="literal">maxusers</code>.
	  Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es
	  sich diese Option entsprechend der maximalen Benutzerzahl
	  Ihres Systems einzustellen.  Obwohl auf einer
	  Produktionsmaschine vielleicht nicht 256 Benutzer
	  gleichzeitig angemeldet sind, können die benötigten
	  Ressourcen ähnlich denen eines großen Webservers
	  sein.</p><p>Die Variable <code class="varname">kern.maxusers</code> wird beim
	  Systemstart automatisch aus dem zur Verfügung stehenden
	  Hauptspeicher bestimmt.  Im laufenden Betrieb kann dieser
	  Wert aus der (nur lesbaren) sysctl-Variable
	  <code class="varname">kern.maxusers</code> ermittelt werden.  Falls
	  ein System für diese Variable einen anderen Wert benötigt,
	  kann der Wert über den Loader angepasst werden.
	  Häufig verwendete Werte sind dabei 64, 128, sowie 256.
	  Es ist empfehlenswert, die Anzahl der Dateideskriptoren
	  nicht auf einen Wert größer 256 zu setzen, es sei denn,
	  Sie benötigen wirklich eine riesige Anzahl von ihnen.
	  Viele der von <code class="varname">kern.maxusers</code> auf einen
	  Standardwert gesetzten Parameter können beim Systemstart
	  oder im laufenden Betrieb in
	  <code class="filename">/boot/loader.conf</code> (sehen Sie sich dazu
	  auch <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">loader.conf</span>(5)</span></a> sowie
	  <code class="filename">/boot/defaults/loader.conf</code> an) an Ihre
	  Bedürfnisse angepasst werden, so wie es bereits an anderer
	  Stelle dieses Dokuments beschrieben ist.</p><p>Ältere FreeBSD-Versionen setzen diesen Wert selbst,
	  wenn Sie in der Konfigurationsdatei den Wert <code class="literal">0</code>
	  <a href="#ftn.idp76797392" class="footnote" id="idp76797392"><sup class="footnote">[5]</sup></a>
	  angeben.  Wenn Sie den Wert selbst bestimmen wollen,
	  sollten Sie <code class="literal">maxusers</code> mindestens auf
	  <code class="literal">4</code> setzen.  Dies gilt insbesondere dann,
	  wenn Sie beabsichtigen, das X Window-System zu benutzen
	  oder Software zu kompilieren.  Der Grund dafür ist, dass
	  der wichtigste Wert, der durch <code class="literal">maxusers</code>
	  bestimmt wird, die maximale Anzahl an Prozessen ist, die auf
	  <code class="literal">20 + 16 * maxusers</code> gesetzt wird.  Wenn
	  Sie also <code class="literal">maxusers</code> auf 1 setzen, können
	  gleichzeitig nur 36 Prozesse laufen, von denen ungefähr
	  18 schon beim Booten des Systems gestartet werden.  Dazu
	  kommen nochmals etwa 15 Prozesse beim Start des
	  X Window-Systems.  Selbst eine einfache Aufgabe wie das
	  Lesen einer Manualpage benötigt neun Prozesse zum Filtern,
	  Dekomprimieren und Betrachten der Datei.  Für die meisten
	  Benutzer sollte es ausreichen, <code class="literal">maxusers</code>
	  auf 64 zu setzen, womit 1044 gleichzeitige Prozesse zur
	  Verfügung stehen.  Wenn Sie allerdings den
	  gefürchteten Fehler <span class="errortype">proc table full</span>
	  beim Start eines Programms oder auf einem Server mit einer
	  großen Benutzerzahl (wie
	  <code class="systemitem">ftp.FreeBSD.org</code>)
	  sehen, dann sollten Sie den Wert nochmals erhöhen und den
	  Kernel neu bauen.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Die Anzahl der Benutzer, die sich auf einem
	    Rechner anmelden kann, wird durch
	    <code class="literal">maxusers</code> <span class="emphasis"><em>nicht</em></span>
	    begrenzt.  Der Wert dieser Variablen legt neben der
	    möglichen Anzahl der Prozesse eines Benutzers weitere
	    sinnvolle Größen für bestimmte Systemtabellen fest.</p></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76804048"></a>12.14.1.2. <code class="varname">kern.ipc.somaxconn</code></h4></div></div></div><a id="idp76813136" class="indexterm"></a><p>Die Variable <code class="varname">kern.ipc.somaxconn</code>
	  beschränkt die Größe der Warteschlange
	  (<span class="foreignphrase"><em class="foreignphrase">Listen-Queue</em></span>) für
	  neue TCP-Verbindungen.  Der Vorgabewert von
	  <code class="literal">128</code> ist normalerweise zu klein, um neue
	  Verbindungen auf einem stark ausgelasteten Webserver
	  zuverlässig zu handhaben.  Auf solchen Servern sollte
	  der Wert auf <code class="literal">1024</code> oder höher gesetzt
	  werden.  Ein Dienst (z.B. <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendmail&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">sendmail</span>(8)</span></a>, oder
	  <span class="application">Apache</span>) kann die Größe
	  der Queue selbst einschränken.  Oft gibt es die
	  Möglichkeit, die Größe der Listen-Queue in
	  einer Konfigurationsdatei einzustellen.  Eine große
	  Listen-Queue übersteht vielleicht auch einen
	  Denial of Service Angriff (<abbr class="abbrev">DoS</abbr>).</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="nmbclusters"></a>12.14.2. Netzwerk Limits</h3></div></div></div><p>Die Kerneloption <code class="literal">NMBCLUSTERS</code> schreibt
	die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System
	besitzt.  Eine zu geringe Anzahl Mbufs auf einem Server mit
	viel Netzwerkverkehr verringert die Leistung von FreeBSD.  Jeder
	Mbuf-Cluster nimmt ungefähr 2 kB Speicher in Anspruch, so
	dass ein Wert von 1024 insgesamt 2 Megabyte Speicher für
	Netzwerkpuffer im System reserviert.  Wie viele Cluster
	benötigt werden, lässt sich durch eine einfache Berechnung
	herausfinden.  Wenn Sie einen Webserver besitzen, der maximal
	1000 gleichzeitige Verbindungen servieren soll und jede der
	Verbindungen je einen 16 kB großen Puffer zum Senden und
	Empfangen braucht, brauchen Sie ungefähr 32 MB Speicher
	für Netzwerkpuffer.  Als Daumenregel verdoppeln Sie diese
	Zahl, so dass sich für <code class="varname">NMBCLUSTERS</code> der Wert
	2x32 MB / 2 kB = 32768 ergibt.
	Für Maschinen mit viel Speicher sollten Werte zwischen
	4096 und 32768 genommen werden.  Sie können diesen Wert
	nicht willkürlich erhöhen, da dies bereits zu einem
	Absturz beim Systemstart führen kann.  Mit der Option
	<code class="option">-m</code> von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=netstat&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">netstat</span>(1)</span></a> können Sie den
	Gebrauch der Netzwerkpuffer kontrollieren.</p><p>Die Netzwerkpuffer können beim Systemstart mit der
	Loader-Variablen <code class="varname">kern.ipc.nmbclusters</code>
	eingestellt werden.  Nur auf älteren FreeBSD-Systemen
	müssen Sie die Kerneloption <code class="literal">NMBCLUSTERS</code>
	verwenden.</p><p>Die Anzahl der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendfile&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">sendfile</span>(2)</span></a> Puffer muss auf
	ausgelasteten Servern, die den Systemaufruf <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendfile&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">sendfile</span>(2)</span></a>
	oft verwenden, vielleicht erhöht werden.  Dazu können Sie die
	Kerneloption <code class="literal">NSFBUFS</code> verwenden oder die
	Anzahl der Puffer in <code class="filename">/boot/loader.conf</code>
	(siehe <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=loader&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">loader</span>(8)</span></a>) setzen.  Die Puffer sollten erhöht
	werden, wenn Sie Prozesse im Zustand <code class="literal">sfbufa</code>
	sehen.  Die schreibgeschützte sysctl-Variable
	<code class="varname">kern.ipc.nsfbufs</code> zeigt die Anzahl
	eingerichteten Puffer im Kernel.  Der Wert dieser Variablen
	wird normalerweise von <code class="varname">kern.maxusers</code>
	bestimmt.  Manchmal muss die Pufferanzahl jedoch manuell
	eingestellt werden.</p><div xmlns="" class="important"><h3 class="admontitle">Wichtig: </h3><p xmlns="http://www.w3.org/1999/xhtml">Auch wenn ein Socket nicht blockierend angelegt wurde,
	  kann der Aufruf von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=sendfile&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">sendfile</span>(2)</span></a> blockieren, um auf
	  freie <code class="literal">struct sf_buf</code> Puffer zu
	  warten.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76828880"></a>12.14.2.1. <code class="varname">net.inet.ip.portrange.*</code></h4></div></div></div><a id="idp76829776" class="indexterm"></a><p>Die sysctl-Variable
	  <code class="varname">net.inet.ip.portrange.*</code> legt die
	  Portnummern für TCP- und UDP-Sockets fest.  Es gibt drei
	  Bereiche: den niedrigen Bereich, den normalen Bereich und
	  den hohen Bereich.  Die meisten Netzprogramme benutzen den
	  normalen Bereich.  Dieser Bereich umfasst in der
	  Voreinstellung die Portnummern 500 bis 5000 und wird durch
	  die Variablen <code class="varname">net.inet.ip.portrange.first</code>
	  und <code class="varname">net.inet.ip.portrange.last</code>
	  festgelegt.  Die festgelegten Bereiche für Portnummern
	  werden von ausgehenden Verbindungen benutzt.  Unter
	  bestimmten Umständen, beispielsweise auf stark ausgelasteten
	  Proxy-Servern, sind alle Portnummern für ausgehende
	  Verbindungen belegt.  Bereiche
	  für Portnummern spielen auf Servern keine Rolle, die
	  hauptsächlich eingehende Verbindungen verarbeiten (wie ein
	  normaler Webserver) oder nur eine begrenzte Anzahl
	  ausgehender Verbindungen öffnen (beispielsweise ein
	  Mail-Relay).  Wenn Sie keine freien Portnummern mehr haben,
	  sollten Sie die Variable
	  <code class="varname">net.inet.ip.portrange.last</code> langsam
	  erhöhen.  Ein Wert von <code class="literal">10000</code>,
	  <code class="literal">20000</code> oder <code class="literal">30000</code> ist
	  angemessen.  Beachten Sie auch eine vorhandene Firewall,
	  wenn Sie die Bereiche für Portnummern ändern.  Einige
	  Firewalls sperren große Bereiche (normalerweise aus den
	  kleinen Portnummern) und erwarten, dass hohe Portnummern für
	  ausgehende Verbindungen verwendet werden.  Daher kann es
	  erforderlich sein, den Wert von
	  <code class="varname">net.inet.ip.portrange.first</code> zu
	  erhöhen.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76834128"></a>12.14.2.2. TCP Bandwidth Delay Product Begrenzung</h4></div></div></div><a id="idp76834768" class="indexterm"></a><p>Die TCP Bandwidth Delay Product Begrenzung gleicht
	  TCP/Vegas von NetBSD.  Die
	  Begrenzung wird aktiviert, indem Sie die sysctl-Variable
	  <code class="varname">net.inet.tcp.inflight.enable</code> auf den
	  Wert <code class="literal">1</code> setzen.  Das System wird dann
	  versuchen, für jede Verbindung, das Produkt aus der
	  Übertragungsrate und der Verzögerungszeit zu
	  bestimmen.  Dieses Produkt begrenzt die Datenmenge, die
	  für einen optimales Durchsatz zwischengespeichert
	  werden muss.</p><p>Diese Begrenzung ist nützlich, wenn Sie Daten
	  über Verbindungen mit einem hohen Produkt aus
	  Übertragungsrate und Verzögerungszeit wie Modems,
	  Gigabit-Ethernet oder schnellen WANs, zur Verfügung
	  stellen.  Insbesondere wirkt sich die Begrenzung aus, wenn
	  die Verbindung die TCP-Option
	  <span class="foreignphrase"><em class="foreignphrase">Window-scaling</em></span> verwendet oder
	  große Sende-Fenster
	  (<span class="foreignphrase"><em class="foreignphrase">send window</em></span>) benutzt.
	  Schalten Sie die Debug-Meldungen aus, wenn Sie die
	  Begrenzung aktiviert haben.  Dazu setzen Sie die Variable
	  <code class="varname">net.inet.tcp.inflight.debug</code> auf
	  <code class="literal">0</code>.  Auf Produktions-Systemen sollten Sie
	  zudem die Variable
	  <code class="varname">net.inet.tcp.inflight.min</code> mindestens auf
	  den Wert <code class="literal">6144</code> setzen.  Allerdings kann
	  ein zu hoher Wert, abhängig von der Verbindung, die
	  Begrenzungsfunktion unwirksam machen.  Die Begrenzung
	  reduziert die Datenmenge in den Queues von Routern und
	  Switches, sowie die Datenmenge in der Queue der lokalen
	  Netzwerkkarte.  Die Verzögerungszeit
	  (<span class="foreignphrase"><em class="foreignphrase">Round Trip Time</em></span>) für
	  interaktive Anwendungen sinkt, da weniger Pakete
	  zwischengespeichert werden.  Dies gilt besonders für
	  Verbindungen über langsame Modems.  Die Begrenzung
	  wirkt sich allerdings nur auf das Versenden von Daten aus
	  (Uploads, Server).  Auf den Empfang von Daten (Downloads)
	  hat die Begrenzung keine Auswirkungen.</p><p>Die Variable
	  <code class="varname">net.inet.tcp.inflight.stab</code> sollte
	  <span class="emphasis"><em>nicht</em></span> angepasst werden.  Der
	  Vorgabewert der Variablen beträgt <code class="literal">20</code>,
	  das heißt es werden maximal zwei Pakete zu dem Produkt
	  aus Übertragungsrate und Verzögerungszeit addiert.
	  Dies stabilisiert den Algorithmus und verbessert die
	  Reaktionszeit auf Veränderungen.  Bei langsamen
	  Verbindungen können sich aber die Laufzeiten der Pakete
	  erhöhen (ohne diesen Algorithmus wären sie allerdings noch
	  höher).  In solchen Fällen können Sie versuchen, den Wert
	  der Variablen auf <code class="literal">15</code>,
	  <code class="literal">10</code> oder <code class="literal">5</code>
	  herabzusetzten.  Gleichzeitig müssen Sie vielleicht auch
	  <code class="varname">net.inet.tcp.inflight.min</code> auf einen
	  kleineren Wert (beispielsweise <code class="literal">3500</code>)
	  setzen.  Ändern Sie diese Variablen nur ab, wenn Sie
	  keine anderen Möglichkeiten mehr haben.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76885456"></a>12.14.3. Virtueller Speicher (<span class="foreignphrase"><em class="foreignphrase">Virtual
	Memory</em></span>)</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp76890704"></a>12.14.3.1. <code class="varname">kern.maxvnodes</code></h4></div></div></div><p>Ein vnode ist die interne Darstellung einer Datei oder
	  eines Verzeichnisses.  Die Erhöhung der Anzahl der für das
	  Betriebssystem verfügbaren vnodes verringert also die
	  Schreib- und Lesezugriffe auf Ihre Festplatte.  vnodes
	  werden im Normalfall vom Betriebssystem automatisch vergeben
	  und müssen nicht von Ihnen angepasst werden.  In einigen
	  Fällen stellt der Zugriff auf eine Platte allerdings einen
	  Flaschenhals dar, daher sollten Sie in diesem Fall die
	  Anzahl der möglichen vnodes erhöhen, um dieses Problem zu
	  beheben.  Beachten Sie dabei aber die Größe des inaktiven
	  und freien Hauptspeichers.</p><p>Um die Anzahl der derzeit verwendeten vnodes zu sehen,
	  geben Sie Folgendes ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl vfs.numvnodes</code></strong>
vfs.numvnodes: 91349</pre><p>Die maximal mögliche Anzahl der vnodes erhalten
	   Sie durch die Eingabe von:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.maxvnodes</code></strong>
kern.maxvnodes: 100000</pre><p>Wenn sich die Anzahl der genutzten vnodes dem maximal
	  möglichen Wert nähert, sollten Sie den Wert
	  <code class="varname">kern.maxvnodes</code> zuerst um etwa 1.000
	  erhöhen.  Beobachten Sie danach die Anzahl der vom
	  System genutzten <code class="varname">vfs.numvnodes</code>.
	  Nähert sich der Wert wiederum dem definierten
	  Maximum, müssen Sie <code class="varname">kern.maxvnodes</code>
	  nochmals erhöhen.  Sie sollten nun eine Änderung
	  Ihres Speicherverbrauches (etwa über <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=top&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">top</span>(1)</span></a>)
	  registrieren können und über mehr aktiven
	  Speicher verfügen.</p></div></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp76797392" class="footnote"><p><a href="#idp76797392" class="para"><sup class="para">[5] </sup></a>Der verwendete Algorithmus setzt
	    <code class="literal">maxusers</code> auf die Speichergröße
	    des Systems.  Der minimale Wert beträgt dabei
	    <code class="literal">32</code>, das Maximum ist
	    <code class="literal">384</code>.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configtuning-disk.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="config-tuning.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="adding-swap-space.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">12.13. Tuning von Laufwerken </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 12.15. Hinzufügen von Swap-Bereichen</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>