<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>31.3. NFS &#8211; Network File System</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="network-servers.html" title="Kapitel 31. Netzwerkserver" /><link rel="prev" href="network-inetd.html" title="31.2. Der inetd &#8222;Super-Server&#8220;" /><link rel="next" href="network-nis.html" title="31.4. NIS/YP &#8211; Network Information Service" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.3. NFS &#8211; Network File System</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="network-inetd.html">Zurück</a> </td><th width="60%" align="center">Kapitel 31. Netzwerkserver</th><td width="20%" align="right"> <a accesskey="n" href="network-nis.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="network-nfs"></a>31.3. NFS &#8211; Network File System</h2></div><div><span class="authorgroup">Reorganisiert und erweitert von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Tom</span> <span class="surname">Rhodes</span></span>. </span></div><div><span class="authorgroup">Geschrieben von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Bill</span> <span class="surname">Swingle</span></span>. </span></div></div></div><a id="idp89263568" class="indexterm"></a><p>Eines der vielen von FreeBSD unterstützten Dateisysteme
      ist das Netzwerkdateisystem, das auch als <acronym class="acronym">NFS</acronym>
      bekannt ist.  <acronym class="acronym">NFS</acronym>
      ermöglicht es einem System, Dateien und Verzeichnisse
      über ein Netzwerk mit anderen zu teilen.  Über
      <acronym class="acronym">NFS</acronym> können
      Benutzer und Programme auf Daten entfernter Systeme zugreifen, und
      zwar genauso, wie wenn es sich um lokale Daten handeln würde.
    </p><p>Einige der wichtigsten Vorteile von <acronym class="acronym">NFS</acronym>
      sind:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Lokale Arbeitsstationen benötigen weniger
	  Plattenplatz, da gemeinsam benutzte Daten nur auf einem
	  einzigen Rechner vorhanden sind.  Alle anderen Stationen
	  greifen über das Netzwerk auf diese Daten zu.</p></li><li class="listitem"><p>Benutzer benötigen nur noch ein zentrales
	  Heimatverzeichnis auf einem <acronym class="acronym">NFS</acronym>-Server.
	  Diese Verzeichnisse sind über das Netzwerk auf allen
	  Stationen verfügbar.</p></li><li class="listitem"><p>Speichergeräte wie Disketten-, CD-ROM- oder
	  <span class="trademark">Zip</span>®-Laufwerke können über das Netzwerk von
	  anderen Arbeitstationen genutzt werden.  Dadurch sind für
	  das gesamte Netzwerk deutlich weniger Speichergeräte
	  nötig.</p></li></ul></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89278672"></a>31.3.1. Wie funktioniert <acronym class="acronym">NFS</acronym>?</h3></div></div></div><p><acronym class="acronym">NFS</acronym> besteht aus zwei Hauptteilen: Einem
        Server und einem oder mehreren Clients.  Der Client greift
	über das Netzwerk auf die Daten zu, die auf dem Server
	gespeichert sind.  Damit dies korrekt funktioniert, müssen
	einige Prozesse konfiguriert und gestartet werden:</p><p>Der Server benötigt folgende Daemonen:</p><a id="idp89280720" class="indexterm"></a><a id="idp89282000" class="indexterm"></a><a id="idp89283152" class="indexterm"></a><a id="idp89284048" class="indexterm"></a><a id="idp89284944" class="indexterm"></a><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /></colgroup><thead><tr><th>Daemon</th><th>Beschreibung</th></tr></thead><tbody><tr><td><span class="application">nfsd</span></td><td>Der <acronym class="acronym">NFS</acronym>-Daemon.  Er bearbeitet
	        Anfragen der <acronym class="acronym">NFS</acronym>-Clients.</td></tr><tr><td><span class="application">mountd</span></td><td>Der <acronym class="acronym">NFS</acronym>-Mount-Daemon.  Er
	        bearbeitet die Anfragen, die <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=nfsd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">nfsd</span>(8)</span></a> an ihn
		weitergibt.</td></tr><tr><td><span class="application">rpcbind</span></td><td> Der Portmapper-Daemon.  Durch ihn erkennen die
	        <acronym class="acronym">NFS</acronym>-Clients, welchen Port der
		<acronym class="acronym">NFS</acronym>-Server verwendet.</td></tr></tbody></table></div><p>Der Client kann ebenfalls einen Daemon aufrufen, und zwar
	den <span class="application">nfsiod</span>-Daemon.  Der
	<span class="application">nfsiod</span>-Daemon bearbeitet Anfragen vom
	<acronym class="acronym">NFS</acronym>-Server.  Er ist optional und verbessert
	die Leistung des Netzwerks.  Für eine normale und korrekte
	Arbeit ist er allerdings nicht erforderlich.  Mehr erfahren
	Sie in der Hilfeseite <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=nfsiod&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">nfsiod</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-configuring-nfs"></a>31.3.2. <acronym class="acronym">NFS</acronym> einrichten</h3></div></div></div><a id="idp89304016" class="indexterm"></a><p><acronym class="acronym">NFS</acronym> lässt sich leicht
        einrichten.  Die nötigen Prozesse werden durch einige
	Änderungen in <code class="filename">/etc/rc.conf</code> bei
	jedem Systemstart gestartet.</p><p>Stellen Sie sicher, dass auf dem
	<acronym class="acronym">NFS</acronym>-Server folgende Optionen in der Datei
	<code class="filename">/etc/rc.conf</code> gesetzt sind:</p><pre class="programlisting">rpcbind_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</pre><p><span class="application">mountd</span> läuft automatisch,
         wenn der <acronym class="acronym">NFS</acronym>-Server aktiviert ist.</p><p>Auf dem Client muss in <code class="filename">/etc/rc.conf</code>
        folgende Option gesetzt sein:</p><pre class="programlisting">nfs_client_enable="YES"</pre><p><code class="filename">/etc/exports</code> legt fest, welche
	Dateisysteme <acronym class="acronym">NFS</acronym> exportieren (manchmal auch
	als <span class="quote">&#8222;<span class="quote">teilen</span>&#8220;</span> bezeichnet) soll.  Jede Zeile in
	<code class="filename">/etc/exports</code> legt ein Dateisystem sowie
	die Arbeitsstationen, die darauf Zugriff haben, fest.
	Außerdem ist es möglich, Zugriffsoptionen
	festzulegen.  Es gibt viele verschiedene Optionen, allerdings
	werden hier nur einige von ihnen erwähnt.  Wenn Sie
	Informationen zu weiteren Optionen benötigen, lesen Sie
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exports&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">exports</span>(5)</span></a>.</p><p>Nun folgen einige Beispieleinträge für
        <code class="filename">/etc/exports</code>:</p><a id="idp89313360" class="indexterm"></a><p>Die folgenden Beispiele geben Ihnen Anhaltspunkte zum
        Exportieren von Dateisystemen, obwohl diese Einstellungen
	natürlich von Ihrer Arbeitsumgebung und Ihrer
	Netzwerkkonfiguration abhängen.  Das nächste
	Beispiel exportiert das Verzeichnis <code class="filename">/cdrom</code>
	für drei Rechner, die sich in derselben Domäne wie
	der Server befinden oder für die entsprechende
	Einträge in <code class="filename">/etc/hosts</code> existieren.
	Die Option <code class="option">-ro</code> kennzeichnet das
	exportierte Dateisystem als schreibgeschützt.  Durch dieses
	Flag ist das entfernte System nicht in der Lage, das exportierte
	Dateisystem zu verändern.</p><pre class="programlisting">/cdrom -ro host1 host2 host3</pre><p>Die nächste Zeile exportiert <code class="filename">/home</code>
        auf drei durch IP-Adressen bestimmte Rechner.  Diese Einstellung
	ist nützlich, wenn Sie über ein privates Netzwerk ohne
	<acronym class="acronym">DNS</acronym>-Server verfügen.  Optional
	könnten interne Rechnernamen auch in
	<code class="filename">/etc/hosts</code>	konfiguriert werden.
	Benötigen Sie hierzu weitere Informationen, lesen Sie bitte
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hosts&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hosts</span>(5)</span></a>.  Durch das Flag <code class="option">-alldirs</code> wird es
	möglich, auch Unterverzeichnisse als Mountpunkte
	festzulegen.  Dies bedeutet aber nicht, dass alle
	Unterverzeichnisse eingehängt werden, vielmehr wird es dem
	Client ermöglicht, nur diejenigen	Verzeichnisse
	einzuhängen, die auch benötigt werden.</p><pre class="programlisting">/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre><p>Die nächste Zeile exportiert <code class="filename">/a</code>,
        damit Clients von verschiedenen Domänen auf das Dateisystem
	zugreifen können.  Das <code class="option">-maproot=root</code>-Flag
	erlaubt es dem Benutzer <code class="systemitem">root</code> des entfernten
	Systems, als <code class="systemitem">root</code> auf das exportierte
	Dateisystem zu schreiben.  Wenn dieses Flag nicht gesetzt ist,
	kann selbst <code class="systemitem">root</code> nicht auf das exportierte
	Dateisystem schreiben.</p><pre class="programlisting">/a  -maproot=root  host.example.com box.example.org</pre><p>Damit ein Client auf ein exportiertes Dateisystem zugreifen
        kann, muss ihm dies explizit gestattet werden.  Stellen Sie also
	sicher, dass der Client in <code class="filename">/etc/exports</code>
	aufgeführt wird.</p><p>Jede Zeile in <code class="filename">/etc/exports</code> entspricht
	der Exportinformation für ein Dateisystem auf einen
	Rechner.  Ein entfernter Rechner kann für jedes Dateisystem
	nur einmal festgelegt werden, und kann auch nur einen
	Standardeintrag	haben.  Nehmen wir an, dass
	<code class="filename">/usr</code> ein einziges Dateisystem ist.  Dann
	wären folgende Zeilen ungültig:</p><pre class="programlisting">#Nicht erlaubt, wenn /usr ein einziges Dateisystem ist
/usr/src   client
/usr/ports client</pre><p>Das Dateisystem <code class="filename">/usr</code> wird hier zweimal
	auf den selben Rechner (<code class="systemitem">client</code>)
	exportiert.  Dies ist aber nicht zulässig.  Der korrekte
	Eintrag sieht daher so aus:</p><pre class="programlisting">/usr/src /usr/ports  client</pre><p>Die Eigenschaften eines auf einen anderen Rechner
	exportierten Dateisystems müssen alle in einer Zeile
	stehen.  Zeilen, in denen kein Rechner festgelegt wird, werden
	als einzelner Rechner behandelt.  Dies schränkt die
	Möglichkeiten zum Export von Dateisystemen ein, für
	die meisten Anwender ist dies aber kein Problem.</p><p>Eine gültige Exportliste, in der
        <code class="filename">/usr</code> und <code class="filename">/exports</code>
	lokale Dateisysteme sind, sieht so aus:</p><pre class="programlisting"># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports                  client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre><p>Der Daemon <span class="application">mountd</span> muss
	die Datei <code class="filename">/etc/exports</code> nach jeder
	Änderung neu einlesen, damit die Änderungen
	wirksam werden.  Dies kann durch das Senden des
	HUP-Signals an den <code class="command">mountd</code>-Prozess
	erfolgen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>kill -HUP `cat /var/run/mountd.pid`</code></strong></pre><p>Alternativ können Sie das
	<code class="command">mountd</code>-<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=rc&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">rc</span>(8)</span></a>-Skript auch mit dem
	passenden Parameter aufrufen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service mountd onereload</code></strong></pre><p>Lesen Sie bitte <a class="xref" href="configtuning-rcd.html" title="12.7. Das rc-System für Systemdienste">Abschnitt 12.7, &#8222;Das rc-System für Systemdienste&#8220;</a>
	des Handbuchs für Informationen zum Einsatz der
	rc-Skripte.</p><p>Eine weitere Möglichkeit, diese Änderungen zu
	übernehmen, wäre der Neustart des Systems.  Dies ist
	allerdings nicht nötig.  Wenn Sie die folgenden
	Befehle als <code class="systemitem">root</code> ausführen, sollte
	alles korrekt gestartet werden.</p><p>Auf dem <acronym class="acronym">NFS</acronym>-Server:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>rpcbind</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>nfsd -u -t -n 4</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mountd -r</code></strong></pre><p>Auf dem <acronym class="acronym">NFS</acronym>-Client:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>nfsiod -n 4</code></strong></pre><p>Nun sollte alles bereit sein, um ein entferntes Dateisystem
        einhängen zu können.  In unseren Beispielen nennen wir
	den Server <code class="systemitem">server</code>, den Client
	<code class="systemitem">client</code>.  Wenn Sie ein entferntes Dateisystem
	nur zeitweise einhängen wollen, oder nur Ihre Konfiguration
	testen möchten, führen Sie auf dem Client als
	<code class="systemitem">root</code> einen Befehl ähnlich dem
	folgenden aus:</p><a id="idp89350096" class="indexterm"></a><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount server:/home /mnt</code></strong></pre><p>Dadurch wird das Verzeichnis <code class="filename">/home</code> des
	Servers auf dem Client unter <code class="filename">/mnt</code>
	eingehängt.  Wenn alles korrekt konfiguriert wurde, sehen
	Sie auf dem Client im Verzeichnis <code class="filename">/mnt</code> alle
	Dateien des Servers.</p><p>Wenn Sie ein entferntes Dateisystem nach jedem Systemstart
	automatisch einhängen wollen, fügen Sie das
	Dateisystem in <code class="filename">/etc/fstab</code> ein.  Dazu ein
	Beispiel:</p><pre class="programlisting">server:/home	/mnt	nfs	rw	0	0</pre><p>Eine Beschreibung aller Optionen enthält
	die Hilfeseite <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=fstab&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">fstab</span>(5)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89356368"></a>31.3.3. Dateien sperren (<span class="foreignphrase"><em class="foreignphrase">Locking</em></span>)</h3></div></div></div><p>Einige Anwendungen (beispielsweise
	<span class="application">mutt</span>) erfordern die Sperrung von
	Dateien, damit sie korrekt arbeiten.  Verwenden Sie
	<acronym class="acronym">NFS</acronym>, so können Sie für die
	Sperrung von Dateien <span class="application">rpc.lockd</span>
	einsetzen.  Um diesen Daemon zu aktivieren, müssen Sie
	in <code class="filename">/etc/rc.conf</code> (sowohl auf Client- als
	auch auf Serverseite) folgende Zeilen aufnehmen (wobei
	vorausgesetzt wird, dasss <acronym class="acronym">NFS</acronym> auf beiden
	Systemen bereits konfiguriert ist):</p><pre class="programlisting">rpc_lockd_enable="YES"
rpc_statd_enable="YES"</pre><p>Danach starten Sie die Anwendung zur Verwaltung der
	Dateisperren durch folgenden Befehl:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service lockd start</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>/etc/rc.d/statd start</code></strong></pre><p>Benötigen Sie keine echten Dateisperren zwischen den
	<acronym class="acronym">NFS</acronym>-Clients und dem
	<acronym class="acronym">NFS</acronym>-Server, können Sie den
	<acronym class="acronym">NFS</acronym>-Client durch die Übergabe der
	Option <code class="option">-L</code> an <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_nfs</span>(8)</span></a> zu einer lokalen
	Sperrung von Dateien zwingen.  Lesen Sie dazu auch die
	Manualpage <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount_nfs</span>(8)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp89370064"></a>31.3.4. Praktische Anwendungen</h3></div></div></div><p><acronym class="acronym">NFS</acronym> ist in vielen Situationen
        nützlich.  Einige Anwendungsbereiche finden Sie in der
	folgenden Liste:</p><a id="idp89375568" class="indexterm"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Mehrere Maschinen können sich ein CD-ROM-Laufwerk
	    oder andere Medien teilen.  Dies ist billiger und
	    außerdem praktischer, um Programme auf mehreren
	    Rechnern zu installieren.</p></li><li class="listitem"><p>In größeren Netzwerken ist es praktisch,
	    einen zentralen <acronym class="acronym">NFS</acronym>-Server einzurichten,
	    auf dem die Heimatverzeichnisse der Benutzer gespeichert
	    werden.  Diese Heimatverzeichnisse werden über das
	    Netzwerk exportiert.  Dadurch haben die Benutzer immer das
	    gleiche Heimatverzeichnis zur Verfügung,
	    unabhängig davon, an welchem Arbeitsplatz sie sich
	    anmelden.</p></li><li class="listitem"><p>Verschiedene Rechner können auf ein gemeinsames
	    Verzeichnis <code class="filename">/usr/ports/distfiles</code>
	    zugreifen.  Wenn Sie nun einen Port auf mehreren Rechnern
	    installieren wollen, greifen Sie einfach auf dieses
	    Verzeichnis zu, ohne die Quelldateien auf jede Maschine
	    zu kopieren.</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-amd"></a>31.3.5. <span class="application">AMD</span></h3></div><div><span class="authorgroup">Beigetragen von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Wylie</span> <span class="surname">Stilwell</span></span>. </span></div><div><span class="authorgroup">Überarbeitet von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Chern</span> <span class="surname">Lee</span></span>. </span></div></div></div><a id="idp89384656" class="indexterm"></a><a id="idp89385168" class="indexterm"></a><p><a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">amd</span>(8)</span></a> (Automatic Mounter Daemon) hängt ein
	entferntes Dateisystem automatisch ein,
	wenn auf eine Datei oder ein Verzeichnis in diesem Dateisystem
	zugegriffen wird.  Dateisysteme, die über einen gewissen
	Zeitraum inaktiv sind, werden von <span class="application">amd</span>
	automatisch abgehängt.
	<span class="application">amd</span> ist eine einfache
	Alternative zum dauerhaften Einhängen von Dateisystemen
	in <code class="filename">/etc/fstab</code>.</p><p>In der Voreinstellung stellt <span class="application">amd</span>
	die Verzeichnisse <code class="filename">/host</code> und
	<code class="filename">/net</code> als NFS-Server bereit.  Wenn auf eine
	Datei in diesen Verzeichnissen zugegriffen wird, sucht
	<span class="application">amd</span> den entsprechenden Mountpunkt
	und hängt das Dateisystem automatisch ein.
	<code class="filename">/net</code> wird zum Einhängen von
	exportierten Dateisystemen von einer IP-Adresse verwendet,
	während <code class="filename">/host</code> zum Einhängen
	von exportierten Dateisystemen eines durch seinen Namen
	festgelegten Rechners dient.</p><p>Ein Zugriff auf eine Datei in
        <code class="filename">/host/foobar/usr</code> würde
	<span class="application">amd</span> veranlassen,
	das von <code class="systemitem">foobar</code> exportierte Dateisystem
	<code class="filename">/usr</code> einzuhängen.</p><div class="example"><a id="idp89408976"></a><div class="example-title">Beispiel 31.2. Ein exportiertes Dateisystem mit
	  <span class="application">amd</span> in den Verzeichnisbaum
	    einhängen</div><div class="example-contents"><p>Sie können sich die verfügbaren Mountpunkte
	  eines entfernten Rechners mit <code class="command">showmount</code>
	  ansehen.  Wollen Sie sich die Mountpunkte des Rechners
	  <code class="systemitem">foobar</code> ansehen, so verwenden Sie:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>showmount -e foobar</code></strong>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
<code class="prompt">%</code> <strong class="userinput"><code>cd /host/foobar/usr</code></strong></pre></div></div><br class="example-break" /><p>Wie Sie an diesem Beispiel erkennen können, zeigt
        <code class="command">showmount</code> <code class="filename">/usr</code>
	als exportiertes Dateisystem an.  Wenn man in das Verzeichnis
	<code class="filename">/host/foobar/usr</code> wechselt, versucht
	<span class="application">amd</span> den Rechnernamen
	<code class="systemitem">foobar</code>	aufzulösen	und den gewünschten
	Export in den Verzeichnisbaum einzuhängen.</p><p><span class="application">amd</span> kann durch das Einfügen
        der folgenden Zeile in <code class="filename">/etc/rc.conf</code>
	automatisch gestartet werden:</p><pre class="programlisting">amd_enable="YES"</pre><p>Mit der Option <code class="varname">amd_flags</code> kann
        <span class="application">amd</span> angepasst werden.
	Die Voreinstellung für <code class="varname">amd_flags</code> sieht
	so aus:</p><pre class="programlisting">amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</pre><p><code class="filename">/etc/amd.map</code> legt die Standardoptionen
        fest, mit denen exportierte Dateisysteme in den Verzeichnisbaum
	eingehängt werden.  <code class="filename">/etc/amd.conf</code>
	hingegen legt einige der erweiterten Optionen von
	<span class="application">amd</span> fest.</p><p>Weitere Informationen finden Sie in den Hilfeseiten
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">amd</span>(8)</span></a> und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=amd.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">amd.conf</span>(5)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="network-nfs-integration"></a>31.3.6. Integrationsprobleme mit anderen Systemen</h3></div><div><span class="authorgroup">Beigetragen von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">John</span> <span class="surname">Lind</span></span>. </span></div></div></div><p>Bestimmte ISA-Ethernetadapter haben Beschränkungen, die
        zu ernsthaften Netzwerkproblemen, insbesondere mit NFS
	führen können.  Es handelt sich dabei nicht um ein
	FreeBSD-spezifisches Problem, aber FreeBSD-Systeme sind davon
	ebenfalls betroffen.</p><p>Das Problem tritt fast ausschließlich dann auf, wenn
        (FreeBSD)-PC-Systeme mit Hochleistungsrechnern verbunden werden,
	wie Systemen von Silicon Graphics, Inc. oder
	Sun Microsystems, Inc.  Das Einhängen via NFS
	funktioniert problemlos, auch einige Dateioperationen
	können erfolgreich sein.  Plötzlich aber wird der
	Server nicht mehr auf den Client reagieren, obwohl Anfragen von
	anderen Rechnern weiterhin bearbeitet werden.  Dieses
	Problem betrifft stets den Client, egal ob es sich beim Client
	um das FreeBSD-System oder den Hochleistungsrechner handelt.
	Auf vielen Systemen gibt es keine Möglichkeit mehr, den
	Client ordnungsgemäß zu beenden.  Die einzige
	Lösung ist es oft, den Rechner neu zu starten, da dieses
	NFS-Problem nicht mehr behoben werden kann.</p><p>Die <span class="quote">&#8222;<span class="quote">korrekte</span>&#8220;</span> Lösung für dieses
        Problem ist es, sich eine schnellere Ethernetkarte für
	FreeBSD zu kaufen.  Allerdings gibt es auch eine einfache und
	meist zufriedenstellende Lösung, um dieses Problem zu
	umgehen.  Wenn es sich beim FreeBSD-System um den
	<span class="emphasis"><em>Server</em></span> handelt, verwenden Sie beim
	Einhängen in den Verzeichnisbaum auf der Clientseite
	zusätzlich die Option <code class="option">-w=1024</code> .  Wenn es
	sich beim FreeBSD-System um den <span class="emphasis"><em>Client</em></span>
	handelt, dann hängen Sie das NFS-Dateisystem mit der
	zusätzlichen Option <code class="option">-r=1024</code> ein.
	Diese Optionen können auf der Clientseite auch durch
	das vierte Feld der Einträge in
	<code class="filename">/etc/fstab</code>	festgelegt werden, damit die
	Dateisysteme automatisch eingehängt werden.  Um die
	Dateisysteme manuell einzuhängen, verwendet man bei
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a> zusätzlich die Option
	<code class="option">-o</code>.</p><p>Es gibt ein anderes Problem, das oft mit diesem verwechselt
        wird.  Dieses andere Problem tritt auf, wenn sich über NFS
	verbundene Server und Clients in verschiedenen Netzwerken
	befinden.  Wenn dies der Fall ist, stellen Sie
	<span class="emphasis"><em>sicher</em></span>, dass Ihre Router die
	nötigen <acronym class="acronym">UDP</acronym>-Informationen weiterleiten,
	oder Sie werden nirgends hingelangen, egal was Sie machen.</p><p>In den folgenden Beispielen ist <code class="systemitem">fastws</code> der
        Name des Hochleistungsrechners (bzw. dessen Schnittstelle),
	<code class="systemitem">freebox</code> hingegen ist der Name des
	FreeBSD-Systems, das über eine Netzkarte mit geringer
	Leistung verfügt.  <code class="filename">/sharedfs</code> ist das
	exportierte NFS -Dateisystem (lesen Sie dazu auch
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=exports&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">exports</span>(5)</span></a>).  Bei <code class="filename">/project</code> handelt es
	sich um den Mountpunkt, an dem das exportierte Dateisystem auf
	der Clientseite	eingehängt wird.  In allen Fällen
	können zusätzliche Optionen, wie z.B.
	<code class="option">hard</code>, <code class="option">soft</code> oder
	<code class="option">bg</code> wünschenswert sein.</p><p>FreeBSD als Client (eingetragen in
	<code class="filename">/etc/fstab</code> auf <code class="systemitem">freebox</code>):
      </p><pre class="programlisting">fastws:/sharedfs /project nfs rw,-r=1024 0 0</pre><p>Manuelles Einhängen auf
	<code class="systemitem">freebox</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t nfs -o -r=1024 fastws:/sharedfs /project</code></strong></pre><p>FreeBSD als Server (eingetragen in
	<code class="filename">/etc/fstab</code> auf <code class="systemitem">fastws</code>):
      </p><pre class="programlisting">freebox:/sharedfs /project nfs rw,-w=1024 0 0</pre><p>Manuelles Einhängen auf <code class="systemitem">fastws</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>mount -t nfs -o -w=1024 freebox:/sharedfs /project</code></strong></pre><p>Nahezu alle 16-bit Ethernetadapter erlauben Operationen
        ohne obengenannte Einschränkungen auf die Lese- oder
	Schreibgröße.</p><p>Für alle technisch Interessierten wird nun beschrieben,
        was passiert, wenn dieser Fehler auftritt, und warum er
	irreversibel ist.  NFS arbeitet üblicherweise mit einer
	<span class="quote">&#8222;<span class="quote">Blockgröße</span>&#8220;</span> von 8 kByte (obwohl
	es kleinere Fragmente zulassen würde).  Da die maximale
	Rahmengröße von Ethernet 1500 Bytes
	beträgt, wird der NFS-<span class="quote">&#8222;<span class="quote">Block</span>&#8220;</span> in einzelne
	Ethernetrahmen aufgeteilt, obwohl es sich nach wie vor um eine
	Einheit handelt, die auch als Einheit empfangen, verarbeitet
	und <span class="emphasis"><em>bestätigt</em></span> werden muss.  Der
	Hochleistungsrechner verschickt die Pakete, aus denen der
	NFS-Block besteht, so eng hintereinander, wie es der Standard
	erlaubt.  Auf der anderen Seite (auf der sich die langsamere
	Netzkarte befindet), überschreiben die späteren
	Pakete ihre Vorgänger, bevor diese vom System verarbeitet
	werden (Überlauf!).  Dies hat zur Folge, dass der NFS-Block
	nicht mehr rekonstruiert und bestätigt werden kann.  Als
	Folge davon glaubt der Hochleistungsrechner, dass der andere
	Rechner nicht erreichbar ist (Timeout!) und versucht die
	Sendung zu wiederholen.  Allerdings wird wiederum der komplette
	NFS-Block verschickt, so dass sich der ganze Vorgang wiederholt,
	und zwar immer wieder (oder bis zum Systemneustart).</p><p>Indem wir die Einheitengröße unter der maximalen
        Größe der Ethernetpakete halten, können wir
	sicherstellen, dass jedes vollständig erhaltene
	Ethernetpaket individuell angesprochen werden kann und vermeiden
	die Blockierung des Systems.</p><p>Überläufe können zwar nach wie vor auftreten,
        wenn ein Hochleistungsrechner Daten auf ein PC-System
	transferiert.  Durch die besseren (und schnelleren) Netzkarten
	treten solche Überläufe allerdings nicht mehr
	<span class="emphasis"><em>zwingend</em></span> auf, wenn
	NFS-<span class="quote">&#8222;<span class="quote">Einheiten</span>&#8220;</span> übertragen werden.  Tritt nun
	ein Überlauf auf, wird die betroffene Einheit erneut
	verschickt, und es besteht eine gute Chance, dass sie nun
	erhalten, verarbeitet und bestätigt werden kann.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="network-inetd.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="network-servers.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="network-nis.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">31.2. Der <span class="application">inetd</span>
      <span class="quote">&#8222;<span class="quote">Super-Server</span>&#8220;</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> 31.4. NIS/YP &#8211; Network Information Service</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>