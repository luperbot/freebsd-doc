<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde:$
     basiert auf: r44136
-->
<chapter xmlns="http://docbook.org/ns/docbook"
xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
xml:id="advanced-networking">

  <info><title>Weiterführende Netzwerkthemen</title>
    <authorgroup>
      <author>
        <personname>
          <firstname>Johann</firstname>
          <surname>Kois</surname>
        </personname>
        <contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>



  <sect1 xml:id="advanced-networking-synopsis">

    <title>Übersicht</title>

    <para>Dieses Kapitel beschreibt verschiedene
      weiterführende Netzwerkthemen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man USB Tethering einrichtet.</para>
      </listitem>

      <listitem>
	<para>&bluetooth;- sowie drahtlose, der Norm &ieee;&nbsp;802.11
	  entsprechende, Geräte mit &os; verwenden
	  können.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter &os; einrichten können.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man mithilfe von <acronym>PXE</acronym> über
          ein Netzwerk bootet.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem &os;-Rechner einrichten
	  können.</para>
      </listitem>

      <listitem>
	<para>CARP, das Common Address Redundancy Protocol, unter
	  &os; einsetzen können.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>

      <listitem>
	<para>Einen neuen &os;-Kernel konfigurieren und installieren
	  können (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man zusätzliche Softwarepakete von
	  Drittherstellern installiert (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info>
      <title>Gateways und Routen</title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Coranth</firstname>
            <surname>Gryphon</surname>
          </personname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen über ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      über das <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten später etwas genauer behandeln.
      Außerdem gibt es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC-Adressen).
    </para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> nächsten
	Abschnitt</link> behandeln), sowie die
	<systemitem>localhost</systemitem> Route an.</para>

      <indexterm>
	<primary>Loopback-Gerät</primary>
      </indexterm>

      <para>Das in der Routingtabelle für
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<filename>lo0</filename>, ist auch als loopback-Gerät
	(Prüfschleife) bekannt.  Das heißt, dass der ganze
	Datenverkehr für dieses Ziel intern (innerhalb des
	Gerätes) bleibt, anstatt ihn über ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der nächste auffällige Punkt sind die mit
	<systemitem class="etheraddress">0:e0:</systemitem> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  &os; identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <systemitem>test0</systemitem>)
	und fügt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert über die Ethernet-Schnittstelle
	<filename>ed0</filename>.  Außerdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) für diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gelöscht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den kürzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>&os; fügt außerdem Subnetzrouten für das
	lokale Subnetz hinzu (<systemitem class="ipaddress">10.20.30.255</systemitem> ist die Broadcast-Adresse
	für das Subnetz <systemitem class="ipaddress">10.20.30</systemitem>,
	<systemitem class="fqdomainname">example.com</systemitem> ist der zu
	diesem Subnetz gehörige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie können auch feststellen,
	dass keine zusätzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen für Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet &os; automatisch
	das Loopback-Gerät (<filename>lo0</filename>),
	anstatt den Datenverkehr über die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	dafür, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt über Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<filename>lo0</filename>-Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackgerät verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zusätzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben für solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Zielsubnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schließlich gibt es für Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze Übersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="4*"/>

	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das heißt sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route für den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise für lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 xml:id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <indexterm>
	<primary>Standardroute</primary>
	<see>Defaultroute</see>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle überprüft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Gehört dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist
	(<foreignphrase>Cloned route</foreignphrase>), dann versucht der
	lokale Rechner über diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte Möglichkeit: Die
	Standardroute (Defaultroute).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gewöhnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	Für Rechner im lokalen Netzwerk ist dieses Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	außen hat</emphasis> gesetzt (entweder über eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute für einen Rechner
	konfigurieren, der selbst als Gateway zur Außenwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel für Standardrouten an.  So
	sieht eine übliche Konfiguration aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	  </literallayout>
	</textobject>
      </mediaobject>

      <para>Die Rechner <systemitem>Local1</systemitem> und
	<systemitem>Local2</systemitem> befinden sich auf Ihrer Seite.
	<systemitem>Local1</systemitem> ist mit einem ISP über eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist über ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der über eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten für Ihre Maschinen lauten:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine häufig gestellte Frage lautet: <quote>Warum (oder
	wie) sollten wir <systemitem>T1-GW</systemitem> als Standard-Gateway
	für <systemitem>Local1</systemitem> setzen, statt den (direkt
	verbundenen) ISP-Server zu verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle für die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen für alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <systemitem>T1-GW</systemitem> erreichen
	können!  Es ist also unnötig, einen Zwischenschritt
	über den ISP-Server zu machen.</para>

      <para>Es ist üblich, die Adresse <systemitem class="ipaddress">X.X.X.1</systemitem> als Gateway-Adresse für
	ihr lokales Netzwerk zu verwenden.  Für unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<systemitem class="ipaddress">10.20.30</systemitem> ist und Ihr ISP
	<systemitem class="ipaddress">10.9.9</systemitem> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Sie können die Standardroute ganz einfach in der Datei
	<filename>/etc/rc.conf</filename> festlegen.  In unserem
	Beispiel wurde auf dem Rechner <systemitem>Local2</systemitem>
	folgende Zeile in <filename>/etc/rc.conf</filename>
	eingefügt:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann über &man.route.8; auch direkt
	gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Weitere Informationen zum Bearbeiten von
	Netzwerkroutingtabellen finden Sie in &man.route.8;.</para>
    </sect2>

    <sect2 xml:id="network-dual-homed-hosts">
      <title>Rechner mit zwei Heimatnetzen</title>
      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsmöglichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, zählt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verfügt der Rechner über zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste Möglichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden Fällen werden Routingtabellen erstellt,
	damit jedes Subnetz weiß, dass dieser Rechner als Gateway
	zum anderen Subnetz arbeitet (<foreignphrase>inbound
	route</foreignphrase>).  Diese Konfiguration (der
	Gateway-Rechner arbeitet als Router zwischen den Subnetzen) wird
	häufig verwendet, wenn es darum geht, Paketfilterung oder
	eine Firewall (in eine oder beide Richtungen) zu implementieren.
      </para>

      <para>Soll dieser Rechner Pakete zwischen den beiden
	Schnittstellen weiterleiten, müssen Sie diese Funktion
	manuell konfigurieren und aktivieren.  Lesen Sie den
	nächsten Abschnitt, wenn Sie weitere Informationen zu
	diesem Thema benötigen.</para>
    </sect2>

    <sect2 xml:id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	dafür, dass diese Funktion in &os; in der Voreinstellung
	deaktiviert ist.  Sie können diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende Änderung
	durchführen:</para>

      <programlisting>gateway_enable="YES"          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, können Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm>
        <primary>BGP</primary>
      </indexterm>
      <indexterm>
        <primary>RIP</primary>
      </indexterm>
      <indexterm>
        <primary>OSPF</primary>
      </indexterm>

      <para>Ihr neuer Router benötigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, können Sie statische Routen
	verwenden.  &os; verfügt über den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<package>net/zebra</package>
	unterstützt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verfügung.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info><title>Statische Routen einrichten</title>
	<authorgroup>
          <author>
            <personname>
              <firstname>Al</firstname>
              <surname>Hoang</surname>
            </personname>
            <contrib>Beigetragen von </contrib>
          </author>
	</authorgroup>
      </info>



      <sect3>
	<title>Manuelle Konfiguration</title>

	<para>Nehmen wir an, dass wir über folgendes Netzwerk
	  verfügen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/static-routes"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
            </literallayout>
          </textobject>
        </mediaobject>

	<para><systemitem>RouterA</systemitem>, ein &os;-Rechner, dient als
	  Router für den Zugriff auf das Internet.  Die
	  Standardroute ist auf <systemitem class="ipaddress">10.0.0.1</systemitem>
	  gesetzt, damit ein Zugriff auf das Internet möglich wird.
	  Wir nehmen nun an, dass <systemitem>RouterB</systemitem> bereits
	  konfiguriert ist und daher weiß, wie er andere Rechner
	  erreichen kann.  Dazu wird die Standardroute von
	  <systemitem>RouterB</systemitem> auf
	  <systemitem class="ipaddress">192.168.1.1</systemitem> gesetzt, da dieser
	  Rechner als Gateway fungiert.</para>

	<para>Sieht man sich die Routingtabelle für
	  <systemitem>RouterA</systemitem> an, erhält man folgende Ausgabe:
	</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Mit dieser Routingtabelle kann <systemitem>RouterA</systemitem>
	  unser internes Netz 2 nicht erreichen, da keine Route zum
	  Rechner <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  vorhanden ist.  Um dies zu korrigieren, kann die Route manuell
	  gesetzt werden.  Durch den folgenden Befehl wird das
	  interne Netz 2 in die Routingtabelle des Rechners
	  <systemitem>RouterA</systemitem> aufgenommen, indem
	  <systemitem class="ipaddress">192.168.1.2</systemitem> als nächster
	  Zwischenschritt verwenden wird:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ab sofort kann <systemitem>RouterA</systemitem> alle Rechner des
	  Netzwerks <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  erreichen.</para>
      </sect3>

      <sect3>
	<title>Routen dauerhaft einrichten</title>

	<para>Das obige Beispiel ist für die Konfiguration einer
	  statischen Route auf einem laufenden System geeignet.  Diese
	  Information geht jedoch verloren, wenn der &os;-Rechner neu
	  gestartet werden muss.  Um dies zu verhindern, wird diese
	  Route in <filename>/etc/rc.conf</filename> eingetragen:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>Die Variable <literal>static_routes</literal> enthält
	  eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	  Jeder String bezieht sich auf den Namen einer Route.  In
	  unserem Beispiel hat <literal>static_routes</literal>
	  <replaceable>internalnet2</replaceable> als einzigen String.
	  Zusätzlich verwendet man die Konfigurationsvariable
	  <literal>route_internalnet2</literal>,
	  in der alle sonstigen an &man.route.8; zu übergebenden
	  Parameter festgelegt werden.  In obigen Beispiel hätte
	  man folgenden Befehl verwendet:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Daher wird
	  <literal>"-net 192.168.2.0/24 192.168.1.2"</literal> als
	  Parameter der Variable <literal>route_</literal> angegeben.
	</para>

	<para>Wie bereits erwähnt, können bei
	  <literal>static_routes</literal> auch mehrere Strings
	  angegeben werden.  Dadurch lassen sich mehrere statische
	  Routen anlegen.  Durch folgende Zeilen werden auf einem
	  imaginären Rechner statische Routen zu den Netzwerken
	  <systemitem class="ipaddress">192.168.0.0/24</systemitem> sowie <systemitem class="ipaddress">192.168.1.0/24</systemitem> definiert:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="network-routing-propagation">
      <title>Verteilung von Routing-Informationen</title>
      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits darüber gesprochen, wie wir unsere
	Routen zur Außenwelt definieren, aber nicht darüber,
	wie die Außenwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden können, dass sämtlicher Verkehr für
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum für Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr für Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Außenwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (ähnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressräume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verfügt über eine Kopie von Haupttabellen, die den
	Verkehr für ein bestimmtes Netzwerk hierarchisch vom
	Backbone über eine Kette von Diensteanbietern bis hin zu
	Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Problembehebung</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der nützlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist außerdem sehr nützlich,
	wenn Sie einen entfernten Rechner nicht erreichen können
	(lesen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgeführt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schließlich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>Weitere Informationen finden Sie in
	&man.traceroute.8;.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Multicast-Routing</title>
      <indexterm>
	<primary>Multicast-Routing</primary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; unterstützt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen müssen
	nicht konfiguriert werden, sie laufen einfach.
	Multicast-Routing muss in der Kernelkonfiguration aktiviert
	werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Zusätzlich muss &man.mrouted.8;, der
	Multicast-Routing-Daemon, über die Datei
	<filename>/etc/mrouted.conf</filename> eingerichtet werden,
	um Tunnel und <acronym>DVMRP</acronym> zu aktivieren.  Weitere
	Informationen zu diesem Thema finden Sie in
	&man.mrouted.8;.</para>

      <note>
	<para>&man.mrouted.8;, der Multicast Routing Daemon,
	  verwendet das <acronym>DVMRP</acronym> Multicast Routing
	  Protocol, das inzwischen in den meisten Multicast-Installationen
	  durch &man.pim.4; ersetzt wurde.   &man.mrouted.8; sowie die
	  damit in Verbindung stehenden Werkzeuge &man.map-mbone.8; und
	  &man.mrinfo.8;können über die &os;-Ports-Sammlung
	  (genauer den Port <package>net/mrouted</package>) installiert werden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info><title>Drahtlose Netzwerke</title>
      <authorgroup>
        <author>
          <personname>
            <othername>Loader</othername>
          </personname>
        </author>

        <author>
          <personname>
            <firstname>Marc</firstname>
            <surname>Fonvieille</surname>
          </personname>
        </author>

        <author>
          <personname>
            <firstname>Murray</firstname>
            <surname>Stokely</surname>
          </personname>
        </author>
      </authorgroup>
    </info>



    <indexterm>
      <primary>Netzwerke, drahtlos</primary>
    </indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Grundlagen</title>

      <para>Die meisten drahtlosen Netzwerke basieren auf dem
	Standard &ieee;&nbsp;802.11.  Sie bestehen aus Stationen, die
	in der Regel im 2,4&nbsp;GHz- oder im 5&nbsp;GHz-Band
	miteinander kommunizieren.  Es ist aber auch
	möglich, dass regional andere Frequenzen,
	beispielsweise im 2,3&nbsp;GHz- oder 4,9&nbsp;GHz-Band,
	verwendet werden.</para>

      <para>802.11-Netzwerke können auf zwei verschiedene
	Arten aufgebaut sein:  Im
	<emphasis>Infrastruktur-Modus</emphasis> agiert eine
	Station als Master, mit dem sich alle anderen Stationen
	verbinden.  Die Summe aller Stationen wird als BSS
	(Basic Service Set), die Master-Station hingegen als
	Access Point (AP) bezeichnet.  In einem BSS läuft
	jedwede Kommunikation über den Access Point.  Die
	zweite Form drahtloser Netzwerke sind die sogenannten
	<emphasis>Ad-hoc-Netzwerke</emphasis> (auch als IBSS
	bezeichnet), in denen es keinen Access Point gibt und
	in denen die Stationen direkt miteinander
	kommunizieren.</para>

      <para>Die ersten 802.11-Netzwerke arbeiteten im
	2,4&nbsp;GHz-Band und nutzten dazu Protokolle der
	&ieee;-Standards 802.11 sowie 802.11b.  Diese Standards
	legen unter anderem Betriebsfrequenzen sowie Merkmale
	des MAC-Layers (wie Frames und Transmissionsraten) fest.
	Später kam der Standard 802.11a hinzu, der im
	5&nbsp;GHz-Band, im Gegensatz zu den ersten beiden
	Standards aber mit unterschiedlichen Signalmechanismen
	und höheren Transmissionsraten arbeitet.  Der
	neueste Standard 802.11g implementiert die Signal- und
	Transmissionsmechanismen von 802.11a im 2,4&nbsp;GHz-Band,
	ist dabei aber abwärtskompatibel zu
	802.11b-Netzwerken.</para>

      <para>Unabhängig von den zugrundeliegenden
	Transportmechanismen verfügen 802.11-Netzwerke
	über diverse Sicherheitsmechanismen.  Der
	ursprüngliche 802.11-Standard definierte lediglich
	ein einfaches Sicherheitsprotokoll namens WEP.  Dieses
	Protokoll verwendet einen fixen (gemeinsam verwendeten)
	Schlüssel sowie die RC4-Kryptografie-Chiffre,
	um Daten verschlüsselt über das drahtlose
	Netzwerk zu senden.  Alle Stationen des Netzwerks
	müssen sich auf den gleichen fixen Schlüssel
	einigen, um miteinander kommunizieren zu können.  Dieses
	Schema ist sehr leicht zu knacken und wird deshalb heute
	kaum mehr eingesetzt.  Aktuelle Sicherheitsmechanismen
	bauen auf dem Standard &ieee;&nbsp;802.11i auf, der neue
	kryptografische Schlüssel (Chiffren), ein neues
	Protokoll für die Anmeldung von Stationen an einem
	Access Point, sowie Mechanismen zum Austausch von
	Schlüsseln als Vorbereitung der Kommunikation zwischen
	verschiedenen Geräten festlegt.  Kryptografische
	Schlüssel werden regelmäßig getauscht.
	Außerdem gibt es Mechanismen, um Einbruchsversuche
	zu entdecken (und Gegenmaßnahmen ergreifen zu können).
	Ein weiteres häufig verwendetes Sicherheitsprotokoll ist
	WPA.  Dabei handelt es sich um einen Vorläufer von 802.11i,
	der von einem Industriekonsortium als Zwischenlösung bis
	zur endgültigen Verabschiedung von 802.11i entwickelt
	wurde.  WPA definiert eine Untergruppe der Anforderungen des
	802.11i-Standards und ist für den Einsatz in älterer
	Hardware vorgesehen.  WPA benötigt nur den (auf dem
	ursprünglichen WEP-Code basierenden) TKIP-Chiffre.  802.11i
	erlaubt zwar auch die Verwendung von TKIP, fordert aber
	zusätzlich eine stärkere Chiffre (AES-CCM)
	für die Datenverschlüsselung.  (AES war für
	WPA nicht vorgesehen, weil man es als zu rechenintensiv
	für den Einsatz in älteren Geräten ansah.)</para>

      <para>Neben den weiter oben erwähnten Standards ist auch
	der Standard 802.11e von großer Bedeutung.  Dieser
	definiert Protokolle zur Übertragung von
	Multimedia-Anwendungen wie das Streaming von Videodateien
	oder Voice-over-IP (VoIP) in einem 802.11-Netzwerk.  Analog
	zu 802.11i verfügt auch 802.11e über eine
	vorläufige Spezifikation namens WMM (ursprünglich
	WME), die von einem Industriekonsortium als Untergruppe
	von 802.11e spezifiziert wurde, um Multimedia-Anwendungen
	bereits vor der endgültigen Verabschiedung des
	802.11e-Standards implementieren zu können.  802.11e
	sowie WME/WMM  erlauben eine Prioritätenvergabe beim
	Datentransfer im einem drahtlosen Netzwerk.  Möglich
	wird dies durch den Einsatz von Quality of Service-Protokollen
	(QoS) und erweiterten Medienzugriffsprotokollen.  Werden
	diese Protokolle korrekt implementiert, erlauben sie daher
	hohe Datenübertragungsraten und einen priorisierten
	Datenfluss.</para>

      <para>&os; unterstützt die Standards
	802.11a, 802.11b, sowie 802.11g.  Ebenfalls unterstützt
	werden WPA sowie die Sicherheitsprotokolle gemäß
	802.11i (dies sowohl für 11a, 11b als auch 11g). QoS und
	Verkehrspriorisierung, die von den WME/WMM-Protokollen
	benötigt werden, werden ebenfalls (allerdings nicht
	für alle drahtlosen Geräte) unterstützt.</para>
    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Basiskonfiguration</title>

      <sect3>
	<title>Kernelkonfiguration</title>

	<para>Um ein drahtloses Netzwerk zu nutzen, benötigen
	  Sie eine drahtlose Netzwerkkarte und einen Kernel, der
	  drahtlose Netzwerke unterstützt.  Der &os;-Kernel
	  unterstützt den Einsatz von Kernelmodulen.  Daher
	  müssen Sie nur die Unterstützung für die
	  von Ihnen verwendeten Geräte aktivieren.</para>

	<para>Als Erstes benötigen Sie ein drahtloses Gerät.
	  Die meisten drahtlosen Geräte verwenden Bauteile von
	  Atheros und werden deshalb vom &man.ath.4;-Treiber
	  unterstützt.  Um diesen Treiber zu verwenden,
	  nehmen Sie die folgende Zeile in die Datei
	  <filename>/boot/loader.conf</filename> auf:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Der Atheros-Treiber besteht aus drei Teilen:
	  dem Treiber selbst (&man.ath.4;), dem
	  Hardware-Support-Layer für die
	  chip-spezifischen Funktionen (&man.ath.hal.4;)
	  sowie einem Algorithmus zur Auswahl der korrekten
	  Frame-Übertragungsrate (ath_rate_sample).
	  Wenn Sie die Unterstützung für diesen
	  Treiber als Kernelmodul laden, kümmert sich
	  dieses automatisch um diese Aufgaben.  Verwenden
	  Sie ein Nicht-Atheros-Gerät, so müssen
	  Sie hingegen das für dieses Gerät geeignete
	  Modul laden, beispielsweise</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<para>für Geräte, die auf Bauteilen von
	  Intersil Prism basieren und daher den Treiber
	  &man.wi.4; voraussetzen.</para>

	<note>
	  <para>In den folgenden Abschnitten wird der
	    &man.ath.4;-Treiber verwendet.  Verwenden Sie ein
	    anderes Gerät, müssen Sie diesen Wert
	    daher an Ihre Konfiguration anpassen.  Eine Liste aller
	    verfügbaren Treiber und unterstützten
	    drahtlosen Geräte finden sich in den &os;
	    Hardware Notes.  Diese sind für verschiedene
	    Releases und Architekturen auf der Seite <link xlink:href="http://www.FreeBSD.org/releases/index.html">
	    Release Information</link> der &os; Homepage.  Gibt es
	    keinen nativen &os;-Treiber für Ihr drahtloses
	    Gerät, können Sie möglicherweise mit
	    <link linkend="config-network-ndis">NDIS</link> einen
	    &windows;-Treiber verwenden.</para>
	</note>

	<para>Zusätzlich
	  benötigen Sie noch Module zur Verschlüsselung
	  ihres drahtlosen Netzwerks.  Diese werden normalerweise
	  dynamisch vom &man.wlan.4;-Modul geladen.  Im folgenden
	  Beispiel erfolgt allerdings eine manuelle Konfiguration.
	  Folgende Module sind verfügbar:  &man.wlan.wep.4;,
	  &man.wlan.ccmp.4; sowie &man.wlan.tkip.4;.  Sowohl
	  &man.wlan.ccmp.4; als auch &man.wlan.tkip.4; werden nur
	  benötigt, wenn Sie WPA und/oder die Sicherheitsprotokolle
	  von 802.11i verwenden wollen.  Wollen Sie Ihr Netzwerk
	  hingegen ohne Verschlüsselung betreiben,
	  benötigen Sie nicht einmal
	  die &man.wlan.wep.4;-Unterstützung.  Um alle drei
	  Module beim Systemstart zu laden, fügen Sie folgende
	  Zeilen in die Datei <filename>/boot/loader.conf</filename>
	  ein:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Um diese neuen Einträge in der Datei
	  <filename>/boot/loader.conf</filename> zu aktivieren, müssen
	  Sie Ihr &os;-System neu starten.  Alternativ können Sie
	  die Kernelmodule aber auch manuell mit &man.kldload.8; laden.</para>

	<note>
	  <para>Wollen Sie keine Kernelmodule verwenden, können
	    Sie die benötigten Treiber auch in Ihren Kernel
	    kompilieren.  Dazu nehmen Sie folgende Zeilen in Ihre
	    Kernelkonfigurationsdatei auf:</para>

	  <programlisting>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</programlisting>

	  <para>Danach bauen Sie den neuen Kernel und starten Ihr
	    &os;-System neu.</para>
	</note>

	<para>Während des Systemstarts sollten nun einige
	  Informationen ähnlich den folgenden über das von
	  Ihnen verwendete drahtlose Gerät ausgegeben
	  werden:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastruktur-Modus</title>

      <para>Drahtlose Netzwerke werden in der Regel im
	Infrastruktur-Modus (auch BSS-Modus genannt) betrieben.
	Dazu werden mehrere drahtlose Access Points zu einem
	gemeinsamen drahtlosen Netzwerk verbunden.  Jedes dieser
	drahtlosen Netzwerke hat einen eigenen Namen, der als
	<emphasis>SSID</emphasis> bezeichnet wird.  Alle Clients
	eines drahtlosen Netzwerks verbinden sich in diesem Modus
	mit einem Access Point.</para>

      <sect3>
	<title>&os;-Clients</title>

	<sect4>
	  <title>Einen Access Point finden</title>

	  <para>Um nach drahtlosen Netzwerken zu suchen verwenden Sie
	    <command>ifconfig</command>.  Dieser Scanvorgang kann einige
	    Zeit in Anspruch nehmen, da dazu jede verfügbare
	    Frequenz auf verfügbare Access Points hin
	    überprüft werden muss.  Um die Suche zu starten,
	    müssen Sie als Super-User angemeldet sein:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>Ihre Netzwerkkarte muss in den Status
	      <option>up</option> versetzt werden, bevor Sie den ersten
	      Scanvorgang starten können.  Für spätere
	      Scans ist dies aber nicht mehr erforderlich.</para>
	  </note>

	  <para>Als Ergebnis erhalten Sie eine Liste mit allen
	    gefundenen BSS/IBSS-Netzwerken.  Zusätzlich zur
	    <literal>SSID</literal> (dem Namen des Netzwerks) wird
	    auch die <literal>BSSID</literal> ausgegeben.  Dabei
	    handelt es sich um MAC-Adresse des Access Points.  Das
	    Feld <literal>CAPS</literal> gibt den Typ des Netzwerks
	    sowie die Fähigkeiten der Stationen innerhalb des
	    Netzwerks an:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>E</literal></term>

	      <listitem>
		<para>Extended Service Set (ESS).  Zeigt an, dass die
		  Station Teil eines Infrastruktur-Netzwerks ist (und
		  nicht eines IBSS/Ad-hoc-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>I</literal></term>

	      <listitem>
		<para>IBSS/Ad-hoc-Netzwerk.  Die Station ist Teil eines
		  Ad-hoc-Netzwerks (und nicht eines
		  ESS-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>P</literal></term>

	      <listitem>
		<para>Privacy.  Alle Datenframes, die innerhalb des
		  BSS ausgetauscht werden, sind verschlüsselt.
		  Dieses BSS verwendet dazu kryptografische Verfahren
		  wie WEP, TKIP oder AES-CCMP.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>S</literal></term>

	      <listitem>
		<para>Short Preamble.  Das Netzwerk verwendet eine
		  kurze Präambel (definiert in 802.11b High
		  Rate/DSSS PHY). Eine kurze Präambel verwendet
		  ein 56&nbsp;Bit langes Sync-Feld (im Gegensatz
		  zu einer langen Präambel, die ein
		  128&nbsp;Bit langes Sync-Feld verwendet).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>s</literal></term>

	      <listitem>
		<para>Short slot time.  Das 802.11g-Netzwerk verwendet
		  eine kurze Slotzeit, da es in diesem Netzwerk keine
		  veralteten (802.11b) Geräte gibt.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Um eine Liste der bekannten Netzwerke auszugeben,
	    verwenden Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 list scan</userinput></screen>

	  <para>Diese Liste kann entweder automatisch durch das
	    drahtlose Gerät oder manuell durch eine
	    <option>scan</option>-Aufforderung aktualisiert werden.
	    Veraltete Informationen werden dabei automatisch
	    entfernt.</para>
	</sect4>

	<sect4>
	  <title>Basiseinstellungen</title>

	  <para>Dieser Abschnitt beschreibt, wie Sie ein einfaches
	    drahtloses Netzwerk ohne Verschlüsselung unter &os;
	    einrichten.  Nachdem Sie sich mit den Informationen dieses
	    Abschnitts vertraut gemacht haben, sollten Sie Ihr
	    drahtloses Netzwerk mit <link linkend="network-wireless-wpa">WPA</link>
	    verschlüsseln.</para>

	  <para>Das Einrichten eines drahtlosen Netzwerks erfolgt
	    in drei Schritten:  Der Auswahl eines Access Points, der
	    Anmeldung Ihrer Station sowie der Konfiguration Ihrer
	    IP-Adresse.</para>

	  <sect5>
	    <title>Einen Access Point auswählen</title>

	    <para>Im Normalfall wird sich Ihre Station automatisch mit
	      einem der zur Verfügung stehenden Access Points
	      verbinden.  Sie müssen dazu lediglich Ihr
	      drahtloses Gerät aktivieren.  Alternativ können
	      Sie auch einen Eintrag ähnlich dem folgenden in
	      <filename>/etc/rc.conf</filename> aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Wollen Sie sich hingegen mit einem bestimmten
	      Access Point verbinden, müssen Sie dessen
	      SSID angeben:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Gibt es in Ihrem Netzwerk mehrere Access Points
	      mit der gleichen SSID (was der Einfachheit wegen
	      häufig der Fall ist), können Sie sich dennoch
	      mit einem bestimmten Access Point verbinden.  Dazu
	      müssen Sie lediglich die BSSID des Access Points
	      angeben (die Angabe der SSID ist in diesem Fall nicht
	      erforderlich):</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>Es gibt noch weitere Möglichkeiten, den Zugriff
	      auf bestimmte Access Point zu beschränken,
	      beispielsweise durch die Begrenzung der Frequenzen, auf
	      denen eine Station nach einem Access Point sucht.  Sinnvoll
	      ist ein solches Vorgehen beispielsweise, wenn Ihr
	      drahtloses Gerät in verschiedenen Frequenzbereichen
	      arbeiten kann, da in diesem Fall das Prüfen aller
	      Frequenzen sehr zeitintensiv ist.  Um nur innerhalb eines
	      bestimmten Frequenzbereichs nach einem Access Point zu
	      suchen, verwenden Sie die Option <option>mode</option>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Dadurch sucht Ihr drahtloses Gerät nur im
	      2,4&nbsp;GHz-Band (802.11g), aber nicht innerhalb des
	      5&nbsp;GHz-Bandes nach einem Access Point.  Mit der
	      Option <option>channel</option> können Sie eine
	      bestimmte Frequenz vorgeben, auf der gesucht werden
	      soll.   Die Option <option>chanlist</option> erlaubt
	      die Angabe mehrerer erlaubter Frequenzen.  Eine
	      umfassende Beschreibung dieser Optionen finden Sie in
	      der Manualpage &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5>
	    <title>Authentifizierung</title>

	    <para>Wenn Sie einen Access Point gefunden haben, muss
	      sich Ihrem Station am Access Point anmelden, bevor
	      Sie Daten übertragen kann.  Dazu gibt es
	      verschiedene Möglichkeiten.  Am häufigsten
	      wird nach wie vor die sogenannte <emphasis>offene
	      Authentifizierung</emphasis> verwendet.  Dabei wird
	      es jeder Station erlaubt, sich mit einem Netzwerk
	      zu verbinden und Daten zu übertragen.  Aus
	      Sicherheitsgründen sollte diese Methode allerdings
	      nur zu Testzwecken bei der erstmaligen Einrichtung
	      eines drahtlosen Netzwerks verwendet werden.  Andere
	      Authentifizierungsmechanismen erfordern den Austausch
	      kryptografischer Informationen, bevor Sie die
	      Übertragung von Daten erlauben.  Dazu gehören
	      der Austausch fixer (vorher vereinbarter) Schlüssel
	      oder Kennwörter sowie der Einsatz komplexerer
	      Verfahren mit Backend-Diensten wie RADIUS.  Die meisten
	      Netzwerke nutzen allerdings nach wie vor die offene
	      Authentifizierung, da dies die Voreinstellung ist.  Am
	      zweithäufigsten kommt das weiter unten beschriebene
	      <link linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      (das auch als <foreignphrase>WPA Personal</foreignphrase>
	      bezeichnet wird) zum Einsatz.</para>

	    <note>
	      <para>Verwenden Sie eine
		&apple; &airport; Extreme-Basisstation als Access Point,
		benötigen Sie wahrscheinlich sowohl die
		Shared-Key-Authentifizierung als auch einen
		WEP-Schlüssel.  Die entsprechende Konfiguration
		erfolgt entweder in der Datei
		<filename>/etc/rc.conf</filename> oder über das
		Programm &man.wpa.supplicant.8;.  Verwenden Sie nur
		eine einzige &airport;-Basisstation, benötigen
		Sie einen Eintrag ähnlich dem folgenden:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>


	      <para>Normalerweise sollten Sie
		Shared-Key-Authentifizierung aber nicht verwenden,
		da diese die Sicherheit des WEP-Schlüssel noch
		weiter verringert.  Müssen Sie WEP einsetzen
		(beispielsweise weil Sie zu veralteten Geräten
		kompatibel bleiben müssen),  sollten Sie WEP
		nur zusammen mit der offenen Authentifizierung
		(<literal>open</literal> authentication) verwenden.
		WEP wird im <xref linkend="network-wireless-wep"/> näher
		beschrieben.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Eine IP-Adresse über DHCP beziehen</title>

	    <para>Nachdem Sie einen Access Point gefunden und sich
	      authentifiziert haben, benötigen Sie noch eine
	      IP-Adresse, die Sie in der Regel über DHCP
	      zugewiesen bekommen.  Dazu müssen Sie lediglich
	      die Option <literal>DHCP</literal> in Ihre
	      in der Datei <filename>/etc/rc.conf</filename>
	      vorhandene Konfiguration Ihres drahtlosen Geräts
	      aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      starten:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput></screen>

	    <para>Nachdem Sie das Gerät aktiviert haben,
	      können Sie mit <command>ifconfig</command> den
	      Status des Geräts <filename>ath0</filename>
	      abfragen:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>


	    <para><literal>status: associated</literal> besagt, dass
	      sich Ihr Gerät mit dem drahtlosen Netzwerk verbunden
	      hat (konkret mit dem Netzwerk <literal>dlinkap</literal>).
	      <literal>bssid 00:13:46:49:41:76</literal> gibt die
	      MAC-Adresse Ihres Access Points aus und die Zeile mit
	      <literal>authmode OPEN</literal> informiert Sie darüber,
	      dass Ihre Kommunikation nicht verschlüsselt wird.</para>
	  </sect5>

	  <sect5>
	    <title>Statische IP-Adressen</title>

	    <para>Alternativ zu dynamischen IP-Adressen
	      können Sie auch eine statische IP-Adresse verwenden.
	      Dazu ersetzen Sie in Ihrer Konfiguration
	      <literal>DHCP</literal> durch die zu verwendende
	      IP-Adresse.  Beachten Sie dabei, dass Sie die anderen
	      Konfigurationsparameter nicht versehentlich
	      verändern:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>your_ssid_here</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title>WPA</title>

	  <para>Bei WPA (Wi-Fi Protected Access) handelt es sich um ein
	    Sicherheitsprotokoll, das in 802.11-Netzwerken verwendet
	    wird, um die Nachteile von <link linkend="network-wireless-wep">WEP</link> (fehlende
	    Authentifizierung und schwache Verschlüsselung)
	    zu vermeiden.  WPA stellt das aktuelle
	    802.1X-Authentifizierungsprotokoll dar und verwendet
	    eine von mehreren Chiffren, um die Datensicherheit
	    zu gewährleisten.  Die einzige Chiffre, die von
	    WPA verlangt wird, ist TKIP (<foreignphrase>Temporary
	    Key Integrity Protocol</foreignphrase>), eine Chiffre,
	    die die von WEP verwendete RC4-Chiffre um Funktionen
	    zur Prüfung der Datenintegrität und zur
	    Erkennung und Bekämpfung von Einbruchsversuchen
	    erweitert.
	    TKIP ist durch Softwaremodifikationen auch unter
	    veralteter Hardware lauffähig.  Im Vergleich zu
	    WEP ist WPA zwar sehr viel sicherer, es ist aber dennoch
	    nicht völlig immun gegen Angriffe.  WPA definiert
	    mit AES-CCMP noch eine weitere Chiffre als Alternative
	    zu TKIP.  AES-CCMP (das häufig als WPA2 oder RSN
	    bezeichnet wird) sollte, wenn möglich, eingesetzt
	    werden.</para>

	  <para>WPA definiert Authentifizierungs- und
	    Verschlüsselungsprotokolle.  Die Authentifizierung
	    erfolgt in der Regel über eine der folgenden
	    Techniken:  802.1X gemeinsam mit einem
	    Backend-Authentifizierungsdienst wie RADIUS, oder durch
	    einen Minimal-Handshake zwischen der Station und dem
	    Access Point mit einem vorher vereinbarten gemeinsamen
	    Schlüssel.  Die erste Technik wird als
	    <foreignphrase>WPA Enterprise</foreignphrase>, die zweite
	    hingegen als <foreignphrase>WPA Personal</foreignphrase>
	    bezeichnet.  Da sich der Aufwand für das Aufsetzen
	    eines RADIUS-Backend-Servers für die meisten
	    drahtlosen Netzwerke nicht lohnt, wird WPA in der Regel
	    als WPA-PSK (WPA, Pre-Shared-Key) konfiguriert.</para>

	  <para>Die Kontrolle der drahtlosen Verbindung sowie die
	    vorangehende Authentifizierung (über Schlüssel
	    oder durch die Kommunikation mit einem Server) erfolgt
	    über das Programm &man.wpa.supplicant.8;, das
	    über die Datei
	    <filename>/etc/wpa_supplicant.conf</filename>
	    eingerichtet wird.  Ausführliche Informationen
	    zur Konfiguration des Programms finden sich in der
	    Manualpage &man.wpa.supplicant.conf.5;.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title>WPA-PSK</title>

	    <para>WPA-PSK oder WPA-Personal basiert auf einem
	      gemeinsamen (vorher vereinbarten) Schlüssel (PSK),
	      der aus einem Passwort generiert und danach als
	      Master-Key des drahtlosen Netzwerks verwendet wird.
	      Jeder Benutzer des drahtlosen Netzwerks verwendet daher
	      <emphasis>den gleichen</emphasis> Schlüssel.  WPA-PSK
	      sollte nur in kleinen Netzwerken eingesetzt werden, in
	      denen die Konfiguration eines Authentifizierungsservers
	      nicht möglich oder erwünscht ist.</para>

	    <warning>
	      <para>Achten Sie darauf, dass Sie immer starke
		Passwörter verwenden, die ausreichend lang sind und,
		wenn möglich, auch Sonderzeichen enthalten, damit
		diese nicht leicht erraten und/oder umgangen werden
		können.</para>
	    </warning>

	    <para>Der erste Schritt zum Einsatz von WPA-PSK ist die
	      Konfiguration der SSID und des gemeinsamen Schlüssels
	      Ihres Netzwerks in der Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Danach geben Sie in <filename>/etc/rc.conf</filename>
	      an, dass WPA zur Verschlüsselung eingesetzt werden
	      soll und dass die IP-Adresse über DHCP bezogen
	      wird:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr Netzgerät aktivieren:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ können Sie die Konfiguration von
	      <link linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      auch manuell durchführen, wobei Sie wiederum die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      verwenden:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>Im zweiten Schritt starten Sie nun
	      <command>dhclient</command>, um eine IP-Adresse vom
	      DHCP-Server zu beziehen:</para>

	    <screen>&prompt.root; <userinput>dhclient wlan0</userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>Enthält Ihre <filename>/etc/rc.conf</filename>
		bereits die Zeile <literal>ifconfig_wlan0="DHCP"</literal>,
		müssen Sie <command>dhclient</command> nicht mehr
		manuell aufrufen, da <command>dhclient</command> in
		diesem Fall automatisch gestartet wird, nachdem
		<command>wpa_supplicant</command> die Schlüssel
		übergibt.</para>
	    </note>

	    <para>Sollte der Einsatz von DHCP nicht möglich sein,
	      können Sie auch eine statische IP-Adresse
	      angeben, nachdem <command>wpa_supplicant</command> Ihre
	      Station authentifiziert hat:</para>

            <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.100</replaceable> netmask <replaceable>255.255.255.0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Verwenden Sie DHCP nicht, müssen Sie
	      zusätzlich noch das Standard-Gateway sowie
	      den/die Nameserver manuell festlegen:</para>

            <screen>&prompt.root; <userinput>route add default <replaceable>your_default_router</replaceable></userinput>
              &prompt.root; <userinput>echo "nameserver <replaceable>your_DNS_server</replaceable>" &gt;&gt; /etc/resolv.conf</userinput>
            </screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title>WPA und EAP-TLS</title>

	    <para>Die zweite Möglichkeit, WPA einzusetzen, ist
	      die Verwendung eines
	      802.1X-Backend-Authentifizierungsservers.  Diese
	      Variante wird als WPA-Enterprise bezeichnet, um sie
	      vom weniger sicheren WPA-Personal abzugrenzen, das
	      auf dem Austausch gemeinsamer (und vorher vereinbarter
	      Schlüssel) basiert.  Die bei WPA-Enterprise
	      verwendete Authentifizierung basiert auf EAP
	      (<foreignphrase>Extensible Authentication
	      Protocol</foreignphrase>).</para>

	    <para>EAP selbst bietet keine Verschlüsselung,
	      sondern operiert in einem verschlüsselten
	      Tunnel.  Es gibt verschiedene, auf EAP basierende
	      Authentifizierungsmethoden, darunter EAP-TLS,
	      EAP-TTLS sowie EAP-PEAP.</para>

	    <para>Bei EAP-TLS (<foreignphrase>EAP with Transport Layers
	      Security</foreignphrase>) handelt es sich um sehr gut
	      unterstütztes Authentifizierungsprotokoll, da es
	      sich dabei um die erste EAP-Methode handelt, die von
	      der <link xlink:href="http://www.wi-fi.org/">Wi-Fi
	      Alliance</link> zertifiziert wurde.  EAP-TLS
	      erfordert drei Zertifikate:  Das (auf allen Rechnern
	      installierte) CA-Zertifikat, das Server-Zertifikat
	      Ihres Authentifizierungsservers, sowie ein
	      Client-Zertifikat für jeden drahtlosen Client.
	      Sowohl der Authentifizierungsservers als auch die
	      drahtlosen Clients authentifizieren sich gegenseitig
	      durch ihre Zertifikate, wobei sie überprüfen,
	      ob diese Zertifikate auch von der
	      Zertifizierungs-Authorität (CA) des jeweiligen
	      Unternehmens signiert wurden.</para>

	    <para>Die Konfiguration erfolgt (analog zu WPA-PSK)
	      über die Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Der Name des Netzwerks (die SSID).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Das RSN/WPA2-Protokoll (&ieee; 802.11i) wird
		  verwendet.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>Die <literal>key_mgmt</literal>-Zeile bezieht
		  sich auf das verwendete Key-Management-Protokoll.
		  In diesem Beispiel wird WPA gemeinsam mit der
		  EAP-Authentifizierung verwendet
		  (<literal>WPA-EAP</literal>).</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den von EAP verwendeten Identifizierungsstring.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an.  Dieses Datei wird benötigt,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>Die <literal>client_cert</literal>-Zeile gibt den
		  Pfad zum Client-Zertifikat an.  Jeder Client hat ein
		  eigenes, innerhalb des Netzwerks eindeutiges,
		  Zertifikat.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>Das Feld <literal>private_key</literal> gibt den
		  Pfad zum privaten Schlüssel des
		  Client-Zertifikat an.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>Das Feld <literal>private_key_passwd</literal>
		  enthält die Passphrase für den privaten
		  Schlüssel.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ können Sie Ihr drahtloses Gerät
	      wiederum manuell über
	      <command>wpa_supplicant</command> und
	      <command>ifconfig</command> aktivieren.</para>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title>WPA und EAP-TTLS</title>

	    <para>Bei EAP-TLS müssen sowohl der
	      Authentifizierungsserver als auch die Clients jeweils
	      ein eigenes Zertifikat aufweisen.  Setzen Sie hingegen
	      EAP-TTLS (<foreignphrase>EAP-Tunneled
	      Transport Layer Security</foreignphrase>) ein, ist das
	      Client-Zertifikat optional.  EAP-TTLS geht dabei
	      ähnlich vor wie verschlüsselte Webseiten,
	      bei denen der Webserver einen sicheren SSL-Tunnel
	      erzeugen kann, ohne dass der Besucher dabei über
	      ein clientseitiges Zertifikat verfügen muss.
	      EAP-TTLS verwendet einen verschlüsselten
	      TLS-Tunnel zum sicheren Transport der
	      Authentifizierungsdaten.</para>

	    <para>Die Konfiguration von EAP-TTLS erfolgt in der
	      Datei <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die
		  EAP-Authentifizierung innerhalb des
		  verschlüsselten TlS-Tunnels.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>Das <literal>password</literal>-Feld enthält
		  die Passphrase für die
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum CA-Zertifikat an, das benötigt wird,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>Die innerhalb des verschlüsselten TLS-Tunnels
		  verwendete Authentifizierungsmethode.  In unserem
		  Beispiel handelt es sich dabei um EAP und MD5.  Diese
		  Phase der <quote>inneren Authentifizierung</quote> wird
		  oft als <quote>phase2</quote> bezeichnet.</para>
	      </callout>
	    </calloutlist>

	    <para>Folgende Zeilen müssen zusätzlich in die Datei
	      <filename>/etc/rc.conf</filename> aufgenommen werden:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie Ihr drahtloses Gerät
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title>WPA und EAP-PEAP</title>

	    <para>PEAP (<foreignphrase>Protected EAP</foreignphrase>)
	      wurde als Alternative zu EAP-TTLS entwickelt.  Es gibt
	      zwei verschiedene PEAP-Methoden, wobei es sich bei
	      PEAPv0/EAP-MSCHAPv2 um die häufiger verwendete
	      Methode handelt.  In den folgenden Ausführungen
	      wird der Begriff PEAP synonym für diese
	      EAP-Methode verwendet.  PEAP ist nach EAP-TLS der
	      am häufigsten verwendete und am besten
	      unterstützte EAP-Standard.</para>

	    <para>PEAP arbeitet ähnlich wie EAP-TTLS:  Es
	      verwendet ein serverseitiges Zertifikat, um
	      einen verschlüsselten TLS-Tunnel zu erzeugen,
	      über den die sichere Authentifizierung zwischen
	      den Clients und dem Authentifizierungsserver erfolgt.
	      In Sachen Sicherheit unterscheiden sich EAP-TTLS und
	      PEAP allerdings:  PEAP überträgt den
	      Benutzernamen im Klartext und verschlüsselt nur
	      das Passwort, während EAP-TTLS sowohl den
	      Benutzernamen als auch das Passwort über den
	      TLS-Tunnel überträgt.</para>

	    <para>Um EAP-PEAP einzurichten, müssen Sie die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      anpassen:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Die für die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die innerhalb
		  des verschlüsselten TLS-Tunnels erfolgende
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>Das Feld <literal>password</literal> enthält
		  die Passphrase für die EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an, das zur Verifizierung des
		  Server-Zertifikats benötigt wird.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Dieses Feld enthält die Parameter für
		  die erste Phase der Authentifizierung (also den
		  TLS-Tunnel).  Je nach dem, welchen
		  Authentifizierungsserver Sie verwenden, müssen
		  Sie hier einen unterschiedlichen Wert angeben.
		  In den meisten Fällen wird dieses Feld den
		  Wert <quote>client EAP encryption</quote> aufweisen,
		  der durch die Angabe von
		  <literal>peaplabel=0</literal> gesetzt wird.  Weitere
		  Informationen zur Konfiguration von PEAP finden Sie
		  in der Manualpage &man.wpa.supplicant.conf.5;.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Das innerhalb des verschlüsselten TLS-Tunnels
		  verwendete Authentifizierungsprotokoll.  In unserem
		  Beispiel handelt es sich dabei um
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>Zuletzt müssen Sie die Netzwerkkarte noch
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title>WEP</title>

	  <para>WEP (Wired Equivalent Privacy) ist Teil des
	    ursprünglichen 802.11-Standards.  Es enthält
	    keinen Authentifzierungsmechanismus und verfügt
	    lediglich über eine schwache Zugriffskontrolle,
	    die sehr leicht umgangen werden kann.</para>

	  <para>WEP kann über <command>ifconfig</command>
	    aktiviert werden:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
            ssid <replaceable>my_net</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable></userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para> Mit <literal>weptxkey</literal> geben Sie an,
		welcher WEP-Schlüssel für für die
		Datenübertragung verwendet wird (in unserem
		Beispiel ist dies der dritte Schlüssel).  Der
		gleiche Schlüssel muss auch am Access Point
		eingestellt sein.  Kennen Sie den vom Access Point
		verwendeten Schlüssel nciht, sollten Sie zuerst
		den Wert <literal>1</literal> (d.h. den ersten
		Schlüssel) für diese Variable verwenden.</para>
	    </listitem>

	    <listitem>
	      <para>Mit <literal>wepkey</literal> legen Sie den zu
		verwendenden WEP-Schlüssel in der Form
		<replaceable>Nummer:Schlüssel</replaceable> fest.
		Ist der Schlüssel "Nummer" nicht vorhanden, wird
		automatisch Schlüssel <literal>1</literal>
		verwendet.  Die Angabe von "Nummer" ist zwingend
		nötig, wenn Sie einen anderen als den ersten
		Schlüssel verwenden wollen.</para>

	      <note>
		<para>In Ihrer Konfiguration müssen Sie
		  <literal>0x3456789012</literal> durch den an
		  Ihrem Access Point konfigurierten Schlüssel
		  ersetzen.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Weitere Informationen finden Sie in der Manualpage
	    &man.ifconfig.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    eignet sich ebenfalls dazu, WEP für Ihr drahtloses
	    Gerät zu aktivieren.  Obige Konfiguration lässt
	    sich dabei durch die Aufnahme der folgenden Zeilen in die
	    Datei <filename>/etc/wpa_supplicant.conf</filename>
	    realisieren:</para>

	  <programlisting>network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Danach müssen Sie das Programm noch aufrufen:</para>

          <screen>&prompt.root; <userinput>wpa_supplicant -i <replaceable>wlan0</replaceable> -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc-Modus</title>

      <para>Der IBSS-Modus (auch als Ad-hoc-Modus bezeichnet), ist
	für Punkt-zu-Punkt-Verbindungen vorgesehen.  Um
	beispielsweise eine Ad-hoc-Verbindung zwischen den Rechnern
	<systemitem>A</systemitem> und <systemitem>B</systemitem> aufzubauen,
	benötigen Sie lediglich zwei IP-Adressen und eine
	SSID.</para>

      <para>Auf dem Rechner <systemitem>A</systemitem> geben Sie Folgendes
	ein:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Der <literal>adhoc</literal>-Parameter gibt an, dass die
	Schnittstelle im IBSS-Modus läuft.</para>

      <para>Rechner <systemitem>B</systemitem> sollte nun in der Lage sein,
	Rechner <systemitem>A</systemitem> zu finden:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>Der Wert <literal>I</literal> (Spalte CAPS) gibt an,
	dass sich Rechner <systemitem>A</systemitem> im Ad-hoc-Modus befindet.
	Nun müssen Sie nur noch Rechner <systemitem>B</systemitem> eine
	unterschiedliche IP-Adresse zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Damit sind die Rechner <systemitem>A</systemitem> und
	<systemitem>B</systemitem> bereit und können untereinander
	Daten austauschen.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; Host Access Points</title>

      <para>&os; kann als Access Point (AP) agieren. Dies verhindert,
        dass man sich einen Hardware AP kaufen oder ein ad-hoc
        Netzwerk laufen lassen muss.  Dies kann sinnvoll sein,
        falls Ihre &os;-Computer als Gateway zu einem anderen
        Netzwerk (z.B. Internet) fungiert.</para>

      <sect3 xml:id="network-wireless-ap-basic">
        <title>Grundeinstellungen</title>

        <para>Bevor Sie ihren &os;-Computer als einen AP konfigurieren,
          muss der Kernel mit dem für ihre Wireless-Karte
          entsprechenden Treibern konfiguriert werden.  Sie
          müssen ebenfalls die Sicherheitsprotokolle, die Sie
          nutzen wollen, dem Kernel hinzufügen.  Für
          weitere Informationen siehe:
          <xref linkend="network-wireless-basic"/>.</para>

        <note>
          <para>Die Verwendung der NDIS und &windows; Treiber erlauben
            zur Zeit keinen AP-Modus. Nur die nativen
            &os;-Wireless-Treiber unterstützen den AP Modus.</para>
        </note>

        <para>Nachdem die Unterstützung für ihr drahtloses
          Netzwerk geladen ist, können Sie überprüfen, ob
          Ihr Wireless-Gerät den hostbasierenden Access-Point Modus
          (auch bekannt als hostap Modus) unterstützt:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>Diese Ausgabe zeigt die Möglichkeiten der Karte. Das
	  Wort <literal>HOSTAP</literal> bestätigt, dass diese
	  Wireless-Karte als Access Point agieren kann.  Die
	  verschiedenen unterstützten Algorithmen
	  (z.B. WEP, TKIP, AES usw.) werden ebenfalls angezeigt.
	  Diese Informationen sind wichtig, wenn Sie wissen wollen,
	  welche Sicherheitsprotokolle auf diesem Access Point
	  verwendbar sind.</para>

	<para>Das Wireless-Gerät kann nur während der Erzeugung
	  des Pseudo-Geräts in den hostap-Modus gesetzt werden.
	  Zuvor erstellte Pseudo-Geräte müssen also vorher
	  zerstört werden:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> destroy</userinput></screen>

	<para>Danach muss das Gerät erneut erstellt werden, bevor
	  die restlichen Netzwerkparameter konfiguriert werden
	  können:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel 1</userinput></screen>

	<para>Benutzen Sie danach erneut den Befehl
	  <command>ifconfig</command>, um den Status der
	  <filename>wlan0</filename>-Schnittstelle abzufragen:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Die <literal>hostap</literal>-Parameter geben die
	  Schnittstelle an, die im hostbasierenden Access Point Modus
	  läuft.</para>

	<para>Die Konfiguration der Schnittstelle kann durch
	  Hinzufügen der folgenden Zeilen in die Datei
	  <filename>/etc/rc.conf</filename> automatisch während
	  des Bootvorganges erfolgen:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
        <title>Hostbasierender Access Point ohne Authentifizierung
	  oder Verschlüsselung</title>

	<para>Obwohl es nicht empfohlen wird, einen AP ohne jegliche
	  Authentifizierung oder Verschlüsselung laufen zu lassen,
	  ist es eine einfache Art zu testen, ob der AP funktioniert.
	  Diese Konfiguration ist auch wichtig für die Fehlersuche
	  bei Client-Problemen.</para>

	<para>Nachdem Sie den AP, wie oben beschrieben, konfiguriert
	  haben, ist es möglich von einem anderen drahtlosen
	  Computer eine Suche nach dem AP zu starten:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>Der Client-Rechner fand den Access Point und kann mit ihm
	  verbunden werden:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title>WPA-basierender Host-Access Point</title>

	<para>Dieser Abschnitt beschäftigt sich mit dem Konfigurieren
	  eines &os;-Access-Points mit dem WPA-Sicherheitsprotokoll.
	  Weitere Einzelheiten zu WPA und der Konfiguration von Clients mit
	  WPA finden Sie im
	  <xref linkend="network-wireless-wpa"/>.</para>

	<para>Der <application>hostapd</application>-Dienst wird genutzt,
	  um die Client-Authentifizierung und das Schlüsselmanagement
	  auf dem Access Point mit aktiviertem WPA zu nutzen.</para>

	<para>In den folgenden Abschnitten werden allen Konfigurationen
	  auf dem &os;-Computer ausgeführt, der als AP agiert.
	  Nachdem der AP korrekt arbeitet, sollte
	  <application>hostapd</application> automatisch beim Booten
	  durch folgende Zeile in der <filename>/etc/rc.conf</filename>
	  aktiviert werden:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Bevor Sie versuchen <application>hostapd</application>
	  zu konfigurieren, stellen Sie sicher, dass die
	  Grundeinstellungen, wie in
	  <xref linkend="network-wireless-ap-basic"/> beschrieben,
	  ausgeführt wurden.</para>

	<sect4>
	  <title>WPA-PSK</title>

	  <para>WPA-PSK ist für kleine Netzwerke gedacht, in denen die
	    Verwendung eines Authentifizierungs-Backend-Server nicht
	    möglich oder erwünscht ist.</para>

	  <para>Die Konfiguration wird in
	    <filename>/etc/hostapd.conf</filename>
	    durchgeführt:</para>

	  <programlisting>interface=wlan0 <co xml:id="co-ap-wpapsk-iface"/>
debug=1 <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap <co xml:id="co-ap-wpapsk-ssid"/>
wpa=1 <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP TKIP <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Dieses Feld zeigt die Wireless-Schnittstelle an, die
	        für den Access Point verwendet wird an.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Dieses Feld legt den debuglevel von
	        <application>hostapd</application> während der
	        Ausführung fest.  Ein Wert von <literal>1</literal>
	        ist der kleinste zulässige Wert.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>Das <literal>ctrl_interface</literal>-Feld gibt
	        den Pfadnamen des Verzeichnisses an, der von
	        <application>hostapd</application> dazu genutzt wird,
	        um die domain socket Dateien zu speichern, die für
	        die Kommunikation mit externen Programmen,
	        wie z.B. &man.hostapd.cli.8;, benutzt werden.
	        Hier wurden die Standardwerte benutzt.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>Die Zeile <literal>ctrl_interface_group</literal>
	        legt fest, welche Gruppe (hier ist es die
	        <systemitem class="groupname">wheel</systemitem>-Gruppe) die Erlaubnis hat,
	        die Schnittstellendateien zu kontrollieren.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>Dieses Feld setzt den Netzwerknamen.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>Das <literal>wpa</literal>-Feld aktiviert WPA und
	        gibt an welches WPA-Authentifizierungprotokoll
	        benötigt wird.  Ein Wert von <literal>1</literal>
	        konfiguriert den AP mit WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>Das <literal>wpa_passphrase</literal>-Feld
	        beinhaltet das ASCII-Passwort für die
	        WPA-Authentifikation.</para>

	      <warning>

	        <para>Verwenden Sie immer sichere Passwörter,
	          die ausreichend lang sind und aus vielen
	          unterschiedlichen Zeichen bestehen, damit sie nicht
	          erraten werden oder umgangen werden können.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">

	      <para>Die <literal>wpa_key_mgmt</literal> Zeile bestimmt
	        das Schlüsselmanagement-Protokoll, das benutzt wird.
	        In unserem Fall ist es WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>Das <literal>wpa_pairwise</literal> Feld zeigt die
	        zulässigen Verschlüsselungs-Algorithmen
	        des Access Points.  Hier werden beide, TKIP (WPA) und
	        CCMP (WPA2), akzeptiert.  CCMP-Verschlüsselung ist
	        eine Alternative zu TKIP und sollte wenn möglich
	        eingesetzt werden.  TKIP sollte nur da eingesetzt werden,
	        wo kein CCMP möglich ist.</para>
	    </callout>
	  </calloutlist>

	  <para>Als nächstes wird der
	    <application>hostapd</application> gestartet:</para>

	  <screen>&prompt.root; <userinput>service hostapd forcestart</userinput></screen>

          <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
      ether 00:11:95:c3:0d:ac
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

	  <para>Der Access Point läuft nun, die Clients können mit ihm
	    verbunden werden.  Weitere Informationen finden Sie im
	    <xref linkend="network-wireless-wpa"/>.  Es ist möglich zu
	    sehen, welche Stationen mit dem AP verbunden sind.  Dazu
	    geben Sie den Befehl <command>ifconfig wlan0 list
	      sta</command> ein.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>WEP hostbasierender Access Point</title>

	  <para>Es ist nicht empfehlenswert, einen Access Point mit
	    WEP zu konfigurieren, da es keine
	    Authentifikationsmechanismen gibt und WEP leicht zu
	    knacken ist.  Einige ältere WLAN-Karten unterstützen nur
	    WEP als Sicherheitsprotokoll.  Für solche Karten ist es
	    notwendig den AP ohne Authentifikation, Verschlüsselung
	    oder mit dem WEP-Protokoll zu konfigurieren.</para>

	  <para>Das Wireless-Gerät kann nun in den hostap-Modus
	    versetzt werden und mit der korrekten SSID und IP-Adresse
	    konfiguriert werden:</para>

          <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
  ssid <replaceable>freebsdap</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable> mode 11g</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para>Der <literal>weptxkey</literal> gibt an,
	        welcher WEP-Schlüssel bei der Übertragung
	        benutzt wird.  Hier nutzen wir den 3. Schlüssel
	        (die Nummerierung der Schlüssel beginnt bei
	        <literal>1</literal>).  Dieses Parameter muss angegeben
	        sein, damit die Daten wirklich verschlüsselt
	        werden.</para>
	    </listitem>

	    <listitem>
	      <para>Der <literal>wepkey</literal> gibt den
	        gewählten WEP-Schlüssel an.  Er sollte im
	        folgenden Format <replaceable>index:key</replaceable>
	        vorliegen.  Wenn kein Index vorhanden ist, wird der
	        Schlüssel <literal>1</literal> benutzt.  Das bedeutet
	        wir brauchen einen Index, falls wir einen anderen
	        Schlüssel als den ersten nutzen wollen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Benutzen Sie den Befehl <command>ifconfig</command>
	    noch einmal um den Status der
	    <filename>wlan0</filename>-Schnittstelle zu sehen:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	  <para>Es ist möglich, von einem anderen drahtlosen
	    Computer eine Suche nach dem AP zu starten:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	  <para>Der Client-Rechner fand den Access Point und kann
	    mit den korrekten Parametern (Schlüssel usw.)
	    mit ihm verbunden werden.  Weitere Informationen gibt es in
	    folgendem <xref linkend="network-wireless-wep"/></para>
      </sect3>
    </sect2>

    <sect2>
      <title>Benutzung von drahtgebundenen und drahtlosen
	Verbindungen</title>

      <para>Eine Verbindung per Kabel bietet eine bessere Leistung
        und eine höhere Zuverlässigkeit, während die
        Wireless-Verbindung eine höhere Flexibilität
        und Mobilität bietet.  Benutzer von Laptops wollen
        normalerweise beides nutzen und zwischen beiden hin und her
        schalten.</para>

      <para>Unter &os; ist es möglich zwei oder mehr
        Netzwerkschnittstellen in einem <quote>failover</quote>-Mode zu
        kombinieren, so dass automatisch die beste verfügbare Verbindung
        aus der Gruppe ausgewählt wird, sobald der Linkstatus
        wechselt.</para>

      <para>Wir behandeln Link-Aggregation und Failover in dem Kapitel
        <xref linkend="network-aggregation"/>.  Dort gibt es auch ein
        Beispiel (<xref linkend="networking-lagg-wired-and-wireless"/>)
        für die Verwendung von sowohl kabelgebundenen wie
        auch drahtlosen Verbindungen.</para>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <para>Die folgenden Auflistung zeigt, wie Sie einige
	häufig auftretende Probleme bei der Einrichtung
	Ihres drahtlosen Netzwerks beheben können.</para>

      <itemizedlist>
	<listitem>
	  <para>Wird Ihr Access Point bei der Suche nicht gefunden,
	    sollten Sie überprüfen, ob Sie bei Konfiguration
	    Ihres drahtlosen Geräts die Anzahl der Kanäle
	    beschränkt haben.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie sich nicht mit Ihrem Access Point verbinden
	    können, sollten Sie überprüfen, ob die
	    Konfiguration Ihrer Station auch der des Access Points
	    entspricht.  Achten Sie dabei speziell auf die
	    Authentifzierungsmethode und die Sicherheitsprotokolle.
	    Halten Sie Ihre Konfiguration so einfach wie möglich.
	    Verwenden Sie ein Sicherheitsprotokoll wie WPA oder WEP,
	    sollten Sie testweise Ihren Access Point auf
	    <emphasis>offene Authentifizierung</emphasis> und
	    <emphasis>keine Sicherheit</emphasis> einstellen.
	    Danach versuchen Sie sich erneut mit Ihren Access Point
	    zu verbinden.</para>
	</listitem>

	<listitem>
	  <para>Nachdem Sie sich mit dem Access Point verbinden
	    können, prüfen Sie die Sicherheitseinstellungen,
	    beginnend mit einfachen Werkzeugen wie &man.ping.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    kann Ihnen bei der Fehlersuche helfen.  Dazu starten
	    Sie es manuell mit der Option <option>-dd</option> und
	    durchsuchen anschließend die Protokollinformationen
	    nach eventuellen Fehlermeldungen.</para>
	</listitem>

	<listitem>
	  <para>Zusätzlich gibt es auch zahlreiche
	    Low-Level-Debugging-Werkzeuge.  Die Ausgabe von
	    Debugging-Informationen des 802.11 Protocol Support Layers
	    lassen sich mit dem Programm <command>wlandebug</command>
	    (das sich unter
	    <filename>/usr/src/tools/tools/net80211</filename>
	    befindet) aktivieren.  Um beispielsweise während
	    der Suche nach Access Points und des Aufbaus von
	    802.11-Verbindungen
	    (<foreignphrase>Handshake</foreignphrase>) auftretende
	    Systemmeldungen auf die Konsole auszugeben, verwenden
	    Sie den folgenden Befehl:</para>

          <screen>&prompt.root; <userinput>wlandebug -i <replaceable>ath0</replaceable> +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>Der 802.11-Layer liefert umfangreiche Statistiken,
	    die Sie mit dem Werkzeug <command>wlanstats</command>
	    abrufen können.  Diese Statistiken sollten alle
	    Fehler identifizieren, die im 802.11-Layer auftreten.
	    Beachten Sie aber, dass einige Fehler bereits im
	    darunterliegenden Gerätetreiber auftreten und
	    daher in diesen Statistiken nicht enthalten sind.  Wie
	    Sie Probleme des Gerätetreibers identifizieren,
	    entnehmen Sie bitte der Dokumentation Ihres
	    Gerätetreibers.</para>
	</listitem>
      </itemizedlist>

      <para>Können Sie Ihr Problem durch diese
	Maßnahmen nicht lösen, sollten Sie einen
	Problembericht (PR) erstellen und die Ausgabe der weiter
	oben genannten Werkzeuge in den Bericht aufnehmen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-usb-tethering">
    <info><title>USB Tethering</title></info>

    <indexterm>
      <primary>tether</primary>
    </indexterm>

    <para>Viele Mobiltelefone bieten die Möglichkeit, ihre
      Datenverbindung über USB (oft "Tethering" genannt) zu
      teilen.  Diese Funktion verwendet das
      <acronym>RNDIS</acronym> oder
      <acronym>CDC</acronym>-Protokoll.</para>

    <para>Bevor Sie ein Gerät anschließen, laden Sie den
      entsprechenden Treiber in den Kernel:</para>

    <screen>&prompt.root; <userinput>kldload if_urndis
&prompt.root; kldload cdce</userinput></screen>

    <para>Sobald das Gerät angeschlossen ist, steht es Ihnen
      unter <literal>ue</literal><replaceable>0</replaceable>
      wie ein normales Netzwerkgerät zur Verfügung.
      Stellen Sie sicher, dass die Option
      <quote>USB Tethering</quote> auf dem Gerät
      aktiviert ist.</para>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info>
      <title>Bluetooth</title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Pav</firstname>
            <surname>Lucistnik</surname>
          </personname>
          <contrib>Beigetragen von </contrib>
          <email>pav@FreeBSD.org</email>
        </author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Bluetooth</primary>
    </indexterm>

    <sect2>
      <title>Übersicht</title>

      <para>Bluetooth ermöglicht die Bildung von persönlichen
	Netzwerken über drahtlose Verbindungen bei einer maximalen
	Reichweite von 10 Metern und operiert im unlizensierten
	2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
	gebildet, wenn sich mobile Geräte, wie Mobiltelefone,
	Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz zu
	Wireless LAN ermöglicht Bluetooth auch höherwertige
	Dienste, wie FTP-ähnliche Dateiserver, Filepushing,
	Sprachübertragung, Emulation von seriellen Verbindungen
	und andere mehr.</para>

      <para>Der Bluetooth-Stack von &os; verwendet das
	Netgraph-Framework (&man.netgraph.4;).  Viele
	Bluetooth-USB-Adapter werden durch den &man.ng.ubt.4;-Treiber
	unterstützt.  Auf dem Chip BCM2033
	von Broadcom basierende	Bluetooth-Geräte werden von den
	Treibern &man.ubtbcmfw.4; sowie &man.ng.ubt.4; unterstützt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	&man.ng.bt3c.4;-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Geräte werden von &man.sio.4;, &man.ng.h4.4;
	sowie &man.hcseriald.8;	unterstützt.  Dieses Kapitel
	beschreibt die Verwendung von USB-Bluetooth-Adaptern.</para>
    </sect2>

    <sect2>
      <title>Die Bluetooth-Unterstützung aktivieren</title>

      <para>Bluetooth-Unterstützung ist in der Regel als
	Kernelmodul verfügbar.  Damit ein Gerät funktioniert,
	muss der entsprechende Treiber im Kernel geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ist das Bluetooth-Gerät beim Systemstart angeschlossen,
        kann das entsprechende Modul auch von
        <filename>/boot/loader.conf</filename> geladen werden:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Schließen Sie Ihren USB-Adapter an, sollte eine
	Meldung ähnlich der folgenden auf der Konsole (oder in
	syslog) erscheinen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Zum Starten und Beenden des Bluetooth-Stacks verwenden Sie
	&man.service.8;.  Es ist
	empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den
	Adapter entfernen.  Selbst wenn Sie dies nicht tun, kommt es
	(normalerweise) zu keinem fatalen Fehler.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich
	der folgenden:</para>

      <screen>&prompt.root; <userinput>service bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <sect2>
      <title>Das Host Controller Interface (HCI)</title>

      <indexterm>
        <primary>HCI</primary>
      </indexterm>

      <para>Das <foreignphrase>Host Controller Interface</foreignphrase>
	(HCI) bietet eine Befehlsschnittstelle zum Basisbandcontroller
	und Linkmanager, sowie Zugriff auf den Hardwarestatus und die
	Kontrollregister.  Dadurch wird ein einheitlicher Zugriff auf
	die Fähigkeiten des Bluetooth-Basisbands möglich.  Die
	HCI-Layer des Rechners tauschen Daten und Befehle mit der
	HCI-Firmware der Bluetooth-Geräte aus.  Über den
	Host Controller Transport Layer-Treiber (also den physikalischen
	Bus) können beide HCI-Layer miteinander
	kommunizieren.</para>

      <para>Eine einzelne Netgraph-Gerätedatei vom Typ
	<emphasis>hci</emphasis> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die HCI-Gerätedatei ist
	normalerweise mit der Bluetooth-Gerätetreiberdatei
	(downstream) sowie der L2CAP-Gerätedatei (upstream)
	verbunden.  Alle HCI-Operationen müssen über die
	HCI-Gerätedatei und nicht über die Treiberdatei
	erfolgen.  Der Standardname für die HCI-Gerätedatei
	(die in &man.ng.hci.4; beschrieben wird) lautet
	<quote>devicehci</quote>.</para>

      <para>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Geräten.  Diese
	Funktion wird als <emphasis>inquiry</emphasis> bezeichnet.
	Inquiry sowie andere mit HCI in Verbindung stehende Funktionen
	werden von &man.hccontrol.8; zur Verfügung gestellt.  Das
	folgende Beispiel zeigt, wie man herausfindet, welche
	Bluetooth-Geräte sich in Reichweite befinden.  Eine solche
	Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass ein
	Gerät nur dann antwortet, wenn es sich im Modus
	<emphasis>discoverable</emphasis> befindet.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> stellt, ähnlich der
	MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines
	Bluetooth-Gerätes dar.  Diese Adresse ist für die
	Kommunikation mit dem Gerät nötig.  Es ist aber auch
	möglich, BD_ADDR einen Klartextnamen zuzuweisen.  Die
	Datei <filename>/etc/bluetooth/hosts</filename> enthält
	Informationen über die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Geräts in Erfahrung bringen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird
	dieses Ihren Rechner unter dem Namen
	<quote>your.host.name (ubt0)</quote> finden.  Dieser Name kann
	aber jederzeit geändert werden.</para>

      <para>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen (an
	denen nur zwei Bluetooth-Geräte beteiligt sind), aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von
	mehreren Bluetooth-Geräten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Gerätes anzeigen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Ein <emphasis>connection handle</emphasis> ist für die
	Beendigung einer Basisbandverbindung nützlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Rufen Sie <command>hccontrol help</command> auf, wenn Sie
	eine komplette Liste aller verfügbaren HCI-Befehle
	benötigen.  Die meisten dieser Befehle müssen nicht
	als <systemitem class="username">root</systemitem> ausgeführt werden.</para>
    </sect2>

    <sect2>
      <title>Das Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <indexterm>
        <primary>L2CAP</primary>
      </indexterm>

      <para>Das <foreignphrase>Logical Link Control and Adaptation
	Protocol</foreignphrase> (L2CAP) bietet
	höherwertigen Protokollen verbindungsorientierte und
	verbindungslose Datendienste an.  Dazu gehören auch
	Protokollmultiplexing, Segmentierung und Reassemblierung.
	L2CAP erlaubt höherwertigen Protokollen und Programmen den
	Versand und Empfang von L2CAP-Datenpaketen mit einer Länge
	von bis zu 64 Kilobytes.</para>

      <para>L2CAP arbeitet <emphasis>kanal</emphasis>basiert.  Ein
	Kanal ist eine logische Verbindung innerhalb einer
	Basisbandverbindung.  Jeder Kanal ist dabei an ein einziges
	Protokoll gebunden.  Mehrere Geräte können an das
	gleiche Protokoll gebunden sein, es ist	aber nicht möglich,
	einen Kanal an mehrere Protokolle zu binden.  Jedes über
	einen Kanal ankommende L2CAP-Paket wird an das entsprechende
	höherwertige Protokoll weitergeleitet.  Mehrere Kanäle
	können sich die gleiche Basisbandverbindung teilen.</para>

      <para>Eine einzelne Netgraph-Gerätedatei vom Typ
	<emphasis>l2cap</emphasis> wird für ein einzelnes
	Bluetooth-Gerät erzeugt.  Die L2CAP-Gerätedatei ist
	normalerweise mit der Bluetooth-HCI-Gerätedatei
	(downstream) sowie der Bluetooth-Socket-Gerätedatei
	(upstream) verbunden.  Der Standardname für die
	L2CAP-Gerätedatei, die in &man.ng.l2cap.4; beschrieben
	wird, lautet <quote>devicel2cap</quote>.</para>

      <para>Ein nützlicher Befehl zum Anpingen von anderen
	Geräten ist &man.l2ping.8;.  Einige Bluetooth-Geräte
	senden allerdings nicht alle erhaltenen Daten zurück.  Die
	Ausgabe <literal>0 bytes</literal> ist also kein Fehler:</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Das Programm &man.l2control.8; liefert Informationen
	über L2CAP-Dateien.  Das folgende Beispiel zeigt, wie man
	die Liste der logischen Verbindungen (Kanäle) sowie die
	Liste der Basisbandverbindungen abfragen kann:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>&man.btsockstat.1; ist ein weiteres Diagnoseprogramm.  Es
	funktioniert analog zu &man.netstat.1;, arbeitet aber mit
	Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt die
	gleiche Liste der logischen Verbindungen wie &man.l2control.8;
	im vorherigen Beispiel.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <sect2>
      <title>Das RFCOMM-Protokoll</title>

      <indexterm>
        <primary>RFCOMM</primary>
      </indexterm>

      <para>Das RFCOMM-Protokoll emuliert serielle Verbindungen
	über das L2CAP-Protokoll.  Es basiert auf dem ETSI-Standard
	TS 07.10.  Bei RFCOMM handelt es sich um ein einfaches
	Transportprotokoll, das um Funktionen zur Emulation der
	9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen
	seriellen Ports ergänzt wurde.  RFCOMM erlaubt bis zu 60
	simultane Verbindungen (RFCOMM-Kanäle) zwischen zwei
	Bluetooth-Geräten.</para>

      <para>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den
	Kommunikationsendpunkten), die über das
	Kommunikationssegment miteinander verbunden sind.  RFCOMM
	unterstützt Anwendungen, die auf serielle Ports angewiesen
	sind.  Das Kommunikationssegment entspricht der (direkten)
	Bluetooth-Verbindung zwischen den beiden Geräten.</para>

      <para>RFCOMM kümmert sich um die direkte Verbindung von zwei
	Geräten, oder um die Verbindung zwischen einem Gerät
	und einem Modem (Netzwerkverbindung).  RFCOMM unterstützt
	auch andere Konfigurationen.  Ein Beispiel dafür sind
	Module, die drahtlose Bluetooth-Geräte mit einer
	verkabelten Schnittstelle verbinden können.</para>

      <para>Unter &os; wurde das RFCOMM-Protokoll im Bluetooth Socket-Layer
	implementiert.</para>
    </sect2>

    <sect2>
      <title>Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Geräten (<foreignphrase>Pairing</foreignphrase>)
      </title>

      <indexterm>
        <primary>Pairing</primary>
      </indexterm>

      <para>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothgerät mit
	jedem anderen Gerät verbinden.  Ein Bluetoothgerät
	(beispielsweise ein Mobiltelefon) kann jedoch für einen
	bestimmten Dienst (etwa eine Einwählverbindung) eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <emphasis>PIN-Codes</emphasis>.  Ein PIN-Code ist ein
	maximal 16 Zeichen langer ASCII-String.  Damit eine Verbindung
	zustande kommt, muss auf beiden Geräten der gleiche
	PIN-Code verwendet werden.  Nachdem der Code eingegeben wurde,
	erzeugen beide Geräte einen <emphasis>link key</emphasis>,
	der auf den Geräten gespeichert wird.  Beim nächsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<foreignphrase>Pairing</foreignphrase>.  Geht der Link Key auf
	einem Gerät verloren, muss das Pairing wiederholt
	werden.</para>

      <para>Der &man.hcsecd.8;-Daemon verarbeitet alle
	Bluetooth-Authentifzierungsanforderungen und wird über die
	Datei <filename>/etc/bluetooth/hcsecd.conf</filename>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration für ein Mobiltelefon, das den PIN-Code
	<quote>1234</quote> verwendet:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Von der Länge abgesehen, unterliegen PIN-Codes keinen
	Einschränkungen.  Einige Geräte, beispielsweise
	Bluetooth-Headsets, haben einen festen PIN-Code eingebaut.  Die
	Option <option>-d</option> sorgt dafür, dass der
	&man.hcsecd.8;-Daemon im Vordergrund läuft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Gerät auf <foreignphrase>receive pairing</foreignphrase>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Gerät.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der PIN-Code benötigt wird.  Geben Sie den
	gleichen PIN-Code ein, den Sie in
	<filename>hcsecd.conf</filename> festgelegt haben.  Ihr Computer
	und das entfernte Gerät sind nun miteinander verbunden.
	Alternativ können Sie das Pairing auch auf dem entfernten
	Gerät initiieren.</para>

      <para><application>hcsecd</application> kann durch das Einfügen
	der folgenden Zeile in <filename>/etc/rc.conf</filename>
	beim Systemstart automatisch aktiviert werden:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Es folgt nun eine beispielhafte Ausgabe
	des <application>hcsecd</application>-Daemons:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <sect2>
      <title>Das Service Discovery Protocol (SDP)</title>

      <indexterm>
        <primary>SDP</primary>
      </indexterm>

      <para>Das <foreignphrase>Service Discovery Protocol</foreignphrase>
	(SDP) erlaubt es Clientanwendungen, von Serveranwendungen
	angebotene Dienste sowie deren Eigenschaften abzufragen.  Zu
	diesen Eigenschaften gehören die Art oder die Klasse der
	angebotenen Dienste sowie der Mechanismus oder das Protokoll,
	die zur Nutzung des Dienstes notwendig sind.</para>

      <para>SDP ermöglicht Verbindungen zwischen einem SDP-Server
	und einem SDP-Client.  Der Server enthält eine Liste mit
	den Eigenschaften der vom Server angebotenen Dienste.  Jeder
	Eintrag beschreibt jeweils einen einzigen Serverdienst.  Ein
	Client kann diese Informationen durch eine SDP-Anforderung
	vom SDP-Server beziehen.  Wenn der Client oder eine Anwendung
	des Clients einen Dienst nutzen will, muss eine separate
	Verbindung mit dem Dienstanbieter aufgebaut werden.  SDP bietet
	einen Mechanismus zum Auffinden von Diensten und deren
	Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung
	dieser Dienste.</para>

      <para>Normalerweise sucht ein SDP-Client nur nach Diensten, die
	bestimmte geforderte Eigenschaften erfüllen.  Es ist aber
	auch möglich, anhand der Dienstbeschreibungen eine
	allgemeine Suche nach den von einem Server angebotenen Diensten
	durchzuführen.  Diesen Vorgang bezeichnet man als
        <foreignphrase>Browsing</foreignphrase>.</para>

      <para>Der Bluetooth-SDP-Server &man.sdpd.8; und der
	Kommandozeilenclient &man.sdpcontrol.8; sind bereits in der
	Standardinstallation von &os; enthalten.  Das folgende Beispiel
	zeigt, wie eine SDP-Abfrage durchgeführt wird:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... und so weiter.  Beachten Sie, dass jeder Dienst eine
	Liste seiner Eigenschaften (etwa den RFCOMM-Kanal)
	zurückgibt.  Je nach dem, welche Dienste Sie
	benötigen, sollten Sie sich einige dieser Eigenschaften
	notieren.  Einige Bluetooth-Implementationen unterstützen
	kein <foreignphrase>Service Browsing</foreignphrase> und geben
	daher eine leere Liste zurück.  Ist dies der Fall, ist es
	dennoch möglich, nach einem bestimmten Dienst zu suchen.
	Das folgende Beispiel demonstriert die Suche nach dem
	OBEX Object Push (OPUSH) Dienst:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Unter &os; ist es die Aufgabe des &man.sdpd.8;-Servers,
	Bluetooth-Clients verschiedene Dienste anzubieten.  Sie
	können diesen Server durch das Einfügen der folgenden
	Zeile in die Datei <filename>/etc/rc.conf</filename>
	aktivieren:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Nun kann der <application>sdpd</application>-Daemon durch
	folgene Eingabe gestartet werden:</para>

      <screen>&prompt.root; <userinput>service sdpd start</userinput></screen>

      <para>Der lokale Server, der den entfernten Clients
	Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	lokalen SDP-Daemon.  Ein Beispiel für eine solche
	Anwendung ist &man.rfcomm.pppd.8;.  Einmal gestartet, wird der
	Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</para>

      <para>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server
	registriert sind, lässt sich durch eine SDP-Abfrage
	über einen lokalen Kontrollkanal abfragen:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>Einwahlverbindungen (Dial-Up Networking (DUN)) oder
	Netzwerkverbindungen mit PPP (LAN)-Profilen einrichten</title>

      <para>Das
	<foreignphrase>Dial-Up Networking (DUN)</foreignphrase>-Profil
	wird vor allem für Modems und Mobiltelefone verwendet.
	Dieses Profil ermöglicht folgende Szenarien:</para>

      <itemizedlist>
        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computer als drahtloses Modem, um sich
	  über einen Einwahlprovider mit dem Internet zu verbinden
	  oder andere Einwahldienste zu benutzen.</para>
	</listitem>

        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computers, um auf Datenabfragen zu
	  reagieren.</para>
	</listitem>
      </itemizedlist>

      <para>Der Zugriff auf ein Netzwerk über das PPP (LAN)-Profil
	kann in folgenden Situationen verwendet werden:</para>

      <itemizedlist>
        <listitem><para>Den LAN-Zugriff für ein einzelnes
	  Bluetooth-Gerät</para>
	</listitem>

        <listitem><para>Den LAN-Zugriff für mehrere
	  Bluetooth-Geräte</para>
	</listitem>

        <listitem><para>Eine PC-zu-PC-Verbindung (unter Verwendung
	  einer PPP-Verbindung über eine emulierte serielle
	  Verbindung)</para>
	</listitem>
      </itemizedlist>

      <para>Beide Profile werden unter &os; durch &man.ppp.8; sowie
	&man.rfcomm.pppd.8; implementiert - einem Wrapper, der
	RFCOMM Bluetooth-Verbindungen unter PPP nutzbar macht.  Bevor
	ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt
	in <filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.</para>

      <para>Im folgenden Beispiel verwenden wir &man.rfcomm.pppd.8;, um
	eine RFCOMM-Verbindung zu einem entfernten Gerät mit der
	<literal>BD_ADDR 00:80:37:29:19:a4</literal> auf dem
	RFCOMM-Kanal <literal>DUN</literal> aufzubauen.  Die aktuelle
	RFCOMM-Kanalnummer erhalten Sie vom entfernten Gerät
	über SDP.  Es ist auch möglich, manuell einen
	RFCOMM-Kanal festzulegen.  In diesem Fall führt
	&man.rfcomm.pppd.8; keine SDP-Abfrage durch.  Verwenden Sie
	&man.sdpcontrol.8;, um die RFCOMM-Kanäle des entfernten
	Geräts herauszufinden.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Der &man.sdpd.8;-Server muss laufen, damit ein Netzzugriff
	mit dem PPP (LAN)-Profil möglich ist.  Außerdem muss
	für den LAN-Client ein neuer Eintrag in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.  Danach starten Sie den RFCOMM PPP-Server
	über eine gültige RFCOMM-Kanalnummer.  Der
	RFCOMM PPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den
	lokalen SDP-Daemon.  Das folgende Beispiel zeigt Ihnen, wie man
	den RFCOMM PPP-Server startet.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil OBEX-Push (OPUSH)</title>

      <indexterm>
        <primary>OBEX</primary>
      </indexterm>

      <para>OBEX ist ein häufig verwendetes Protokoll für den
	Dateitransfer zwischen Mobilgeräten.  Sein Hauptzweck ist
	die Kommunikation über die Infrarotschnittstelle.  Es dient
	daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum
	Austausch von Visitenkarten oder Kalendereinträgen zwischen
	Mobiltelefonen und anderen Geräten mit PIM-Funktionen.</para>

      <para>Server und Client von OBEX werden durch das Softwarepaket
	<application>obexapp</application> bereitgestellt, das als Port
	<package>comms/obexapp</package> verfügbar
	ist.</para>

      <para>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt
	oder angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	ein Termin sein.  Der OBEX-Client fordert über SDP die
	Nummer des RFCOMM-Kanals vom entfernten Gerät an.  Dies
	kann auch durch die Verwendung des Servicenamens anstelle der
	RFCOMM-Kanalnummer erfolgen.  Folgende Dienste werden
	unterstützt:  IrMC, FTRN und OPUSH.  Es ist möglich,
	den RFCOMM-Kanal als Nummer anzugeben.  Es folgt nun ein
	Beispiel für eine OBEX-Sitzung, bei der ein
	Informationsobjekt vom Mobiltelefon angefordert und ein neues
	Objekt (hier eine Visitenkarte) an das Telefonbuch des
	Mobiltelefons geschickt wird:</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Um OBEX-Push-Dienste anbieten zu können, muss der
	<application>sdpd</application>-Server gestartet sein.  Ein
	Wurzelverzeichnis, in dem alle ankommenden Objekt gespeichert
	werden, muss zusätzlich angelegt werden.  In der
	Voreinstellung ist dies <filename>/var/spool/obex</filename>.
	Starten Sie den OBEX-Server mit einer gültigen Kanalnummer.
	Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem
	lokalen SDP-Daemon.  Um den OBEX-Server zu starten, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil Serial-Port (SPP)</title>

      <para>Durch dieses Profil können Bluetooth-Geräte RS232-
	(oder damit kompatible) serielle Kabelverbindungen emulieren.
	Anwendungen sind dadurch in der Lage, über eine virtuelle
	serielle Verbindung Bluetooth als Ersatz für eine
	Kabelverbindung zu nutzen.</para>

      <para>Das Profil Serial-Port wird durch &man.rfcomm.sppd.1;
	verwirklicht.  Pseudo-tty wird hier als virtuelle serielle
	Verbindung verwendet.  Das folgende Beispiel zeigt, wie man sich
	mit einem entfernten Serial-Port-Dienst verbindet.  Beachten
	Sie, dass Sie den RFCOMM-Kanal nicht angeben müssen, da
	&man.rfcomm.sppd.1; diesen über SDP vom entfernten
	Gerät abfragen kann.  Wenn Sie dies nicht wollen,
	können Sie einen RFCOMM-Kanal auch manuell festlegen.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Sobald die Verbindung hergestellt ist, kann pseudo-tty als
        serieller Port verwenden werden.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <sect3>
        <title>Ein entferntes Gerät kann keine Verbindung
	  aufbauen</title>

	<para>Einige ältere Bluetooth-Geräte unterstützen
	  keinen Rollentausch.  Wenn &os; eine neue Verbindung
	  akzeptiert, wird versucht, die Rolle zu tauschen, um zum
	  Master zu werden.  Geräte, die dies nicht
	  unterstützen, können keine Verbindung aufbauen.
	  Beachten Sie, dass der Rollentausch ausgeführt wird,
	  sobald eine neue Verbindung aufgebaut wird, daher ist es
	  nicht möglich, das entfernte Gerät zu fragen, ob es
	  den Rollentausch unterstützt.  Dieses Verhalten von &os;
	  kann aber durch eine HCI-Option geändert werden:</para>

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
        <title>Wo finde ich genaue Informationen darüber, was
	  schiefgelaufen ist?</title>

	<para>Verwenden Sie <application>hcidump</application>,
	  das Sie über den Port <package>comms/hcidump</package> installieren
	  können.  <application>hcidump</application> hat
	  Ähnlichkeiten mit &man.tcpdump.1;.  Es dient zur Anzeige
	  der Bluetooth-Pakete in einem Terminal oder zur Speicherung
	  der Pakete in einer Datei (Dump).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info><title>LAN-Kopplung mit einer Bridge</title>
      <authorgroup>
        <author>
          <personname>
            <firstname>Andrew</firstname>
            <surname>Thompson</surname>
          </personname>
          <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>
    </info>



    <sect2>
      <title>Einführung</title>

      <indexterm>
        <primary>Subnetz</primary>
      </indexterm>
      <indexterm>
        <primary>Bridge</primary>
      </indexterm>

      <para>Manchmal ist es nützlich, ein physikalisches Netzwerk
	(wie ein Ethernetsegment) in zwei separate Netzwerke
	aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die über
	einen Router miteinander verbunden sind.  Ein Gerät, das
	zwei Netze auf diese Weise verbindet, wird als
	<emphasis>Bridge</emphasis> bezeichnet.  Jedes &os;-System
	mit zwei Netzwerkkarten kann als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen
	(Ethernet Adressen) der Geräte in ihren
	Netzwerksegmenten lernt.  Der Verkehr wird nur dann zwischen
	zwei Segmenten weitergeleitet, wenn sich Sender und
	Empfänger in verschiedenen Netzwerksegmenten
	befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis>
	angebracht ist</title>

      <para>Es gibt zahlreiche Situationen, in denen der Einsatz
	einer Bridge sinnvoll ist:</para>

      <sect3>
	<title>Verbinden von Netzwerken</title>

	<para>Die Hauptaufgabe einer Bridge ist die Verbindung von zwei
	  oder mehreren Netzwerksegmenten zu einem gemeinsamen Netzwerk.
	  Es ist oft sinnvoller, eine hostbasierte Bridge anstelle
	  normaler Netzwerkkomponenten (wie Kabelverbindungen),
	  Firewalls oder Pseudonetzwerken über die
	  Schnittstelle einer virtuellen Maschine einzusetzen.
	  Eine Bridge kann außerdem ein drahtloses Gerät mit
	  einem Kabelnetzwerk verbinden.  Diese Fähigkeit der
	  Bridge wird als <foreignphrase>HostAP-Modus</foreignphrase>
	  bezeichnet.  Die Bridge agiert in diesem Fall als
	  Access Point für das drahtlose Gerät.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

        <indexterm>
          <primary>Firewall</primary>
        </indexterm>
        <indexterm>
          <primary>NAT</primary>
        </indexterm>

	<para>Häufig kommt es vor, dass Firewallfunktionen
	  benötigt werden, ohne dass Routing oder
	  <foreignphrase>Network Adress Translation</foreignphrase>
	  (NAT) verwendet werden soll.</para>

	<para>Ein Beispiel dafür wäre ein kleines Unternehmen,
	  das über DSL oder ISDN an seinen ISP angebunden ist.  Es
	  verfügt über 13 weltweit erreichbare IP-Adressen,
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation
	  ist der Einsatz von Subnetzen sowie einer routerbasierten
	  Firewall schwierig.</para>

        <indexterm>
          <primary>Router</primary>
        </indexterm>
        <indexterm>
          <primary>DSL</primary>
        </indexterm>
        <indexterm>
          <primary>ISDN</primary>
        </indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  dass Sie sich um IP-Adressen kümmern müssen.</para>
      </sect3>

      <sect3>
	<title>Netzwerküberwachung</title>

	<para>Eine Bridge kann zwei Netzwerksegmente miteinander
	  verbinden und danach alle Ethernet-Rahmen überprüfen,
	  die zwischen den beiden Netzwerksegmenten ausgetauscht werden.
	  Dazu verwendet man entweder &man.bpf.4;/&man.tcpdump.1; auf
	  dem Netzgerät der Bridge oder schickt Kopien aller
	  Rahmen an ein zusätzliches Netzgerät (den sogenannten
	  <foreignphrase>Span Port</foreignphrase>).</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-VPN</title>

	<para>Zwei Ethernetnetzwerke können über einen IP-Link
	  miteinander verbunden werden, indem Sie die beiden Netzwerke
	  über einen EtherIP-Tunnel koppeln oder eine
	  &man.tap.4;-basierte Lösung wie OpenVPN einsetzen.</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-Redundanz</title>

	<para>Die Systeme eines Netzwerks können redundant
	  miteinander verbunden sein.  In diesem Fall verwenden Sie das
	  <foreignphrase>Spanning Tree Protocol</foreignphrase>, um
	  redundante Pfade zu blockieren.  Damit ein Ethernetnetzwerk
	  korrekt arbeitet, darf immer nur ein aktiver Pfad zwischen
	  zwei Geräten des Netzwerks existieren.  Aufgabe des
	  Spanning Tree Protocols ist es daher, Schleifen zu entdecken
	  und redundante Links in den Status
	  <emphasis>blockiert</emphasis> zu versetzen.  Fällt ein
	  aktiver Link aus, so berechnet das Protokoll einen neuen
	  Pfad.  Dazu wird ein blockierter Pfad in den Status
	  <emphasis>aktiv</emphasis> versetzt, damit alle Systeme des
	  Netzwerks wieder miteinander kommunizieren können.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>Dieser Abschnitt beschreibt nur die
	&man.if.bridge.4;-Bridge-Implementierung.  Ein
	Netgraph-Bridge-Treiber ist ebenfalls verfügbar, wird
	hier aber nicht behandelt.  Lesen Sie die Manualpage
	&man.ng.bridge.4;, wenn Sie diesen Treiber einsetzen
	wollen.</para>

      <para>Bei diesem Treiber handelt es sich um ein
	Kernelmodul, das von &man.ifconfig.8; automatisch geladen
	wird, wenn ein Bridge-Interface erzeugt wird.  Alternativ ist
	es aber auch möglich, die Unterstützung für
	den Treiber in Ihren Kernel zu kompilieren.  Dazu fügen
	Sie die Zeile <literal>device if_bridge</literal> in Ihre
	Kernelkonfigurationsdatei ein und bauen danach den Kernel
	neu.</para>

      <para>Paketfilter können mit allen Firewallpaketen verwendet
	werden, die das &man.pfil.9;-Framework benutzen.  Die Firewall
	kann dabei entweder als Kernelmodul geladen oder in den Kernel
	kompiliert werden.</para>

      <para>Eine Bridge kann auch als <foreignphrase>Traffic
	Shaper</foreignphrase> verwendet werden, wenn Sie
	&man.altq.4; oder &man.dummynet.4; einsetzen.</para>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>Eine Bridge wird durch das Klonen von Schnittstellen
	erzeugt.  Um eine Bridge zu erzeugen, verwenden Sie den Befehl
	&man.ifconfig.8;.  Ist der Bridge-Treiber nicht in Ihren Kernel
	kompiliert, wird er automatisch geladen.</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Im obigen Beispiel wird die Bridge erzeugt und erhält
	automatisch eine zufällig generierte Ethernet-Adresse
	zugewiesen.  Die Parameter <literal>maxaddr</literal> sowie
	<literal>timeout</literal> legen fest, wie viele MAC-Adressen
	die Bridge in ihrer Forward-Tabelle halten kann beziehungsweise
	wie viele Sekunden jeder Eintrag erhalten bleiben soll, nachdem
	er zuletzt verwendet wurde.  Die restlichen Parameter sind
	für die Konfiguration von Spanning&nbsp;Tree notwendig.</para>

      <para>Im nächsten Schritt werden die Schnittstellen, die
	die Bridge verbinden soll, zugewiesen.  Damit die Bridge
	Datenpakete weiterleiten kann, müssen sowohl die Bridge
	als auch die Schnittstellen (der zu verbindenden
	Netzwerksegmente) aktiviert sein:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>Danach ist die Bridge in der Lage, Ethernet-Rahmen zwischen
	den Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> weiterzuleiten.  Um diese
	Konfiguration beim Systemstart automatisch zu aktivieren,
	müssen Sie folgende Einträge in die Datei
	<filename>/etc/rc.conf</filename> aufnehmen:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Benötigen Sie für die Bridge eine IP-Adresse,
	müssen Sie diese der Schnittstelle der Bridge zuweisen
	(und nicht einer der Schnittstellen der gekoppelten
	Netzwerksegmente).  Dabei können Sie die IP-Adresse
	sowohl statisch als auch dynamisch über DHCP
	zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>Sie können der Bridge-Schnittstelle auch eine
	IPv6-Adresse zuweisen.</para>
    </sect2>

    <sect2>
      <title>Firewalls</title>
      <indexterm>
        <primary>firewall</primary>
      </indexterm>

      <para>Nachdem ein Paketfilter aktiviert wurde, können
	Datenpakete, die von den Schnittstellen der gekoppelten
	Netzwerksegmente gesendet und empfangen werden, über
	die Bridge weitergeleitet oder nach bestimmten Regeln
	gefiltert oder auch komplett geblockt werden.  Ist die
	Richtung des Paketflusses wichtig, ist es am besten, eine
	Firewall auf den Schnittstellen der einzelnen
	Netzwerksegmente einzurichten und nicht auf der Bridge
	selbst.</para>

      <para>Eine Bridge verfügt über verschiedene Optionen,
	über die Sie die Weiterleitung von Nicht-IP- und
	ARP-Paketen sowie den Einsatz von Layer&nbsp;2-Firewalls
	(mit IPFW) steuern können.  Lesen Sie die Manualpage
	&man.if.bridge.4;, wenn Sie diese Funktionen
	benötigen.</para>
    </sect2>

    <sect2>
      <title>Spanning&nbsp;Tree</title>

      <para>Der Bridge-Treiber implementiert das <foreignphrase>Rapid
	Spanning Tree Protocol</foreignphrase> (RSTP oder 802.1w), das
	abwärtskompatibel zum veralteten <foreignphrase>Spanning
	Tree Protocol</foreignphrase> (STP) ist.  Spanning&nbsp;Tree
	dient dazu, Schleifen in einer Netzwerktopologie zu entdecken
	und zu entfernen.  RSTP arbeitet dabei schneller als das
	veraltete STP.  RSTP tauscht Informationen mit
	benachbarten Switchen aus, um Pakete korrekt weiterzuleiten
	und eine Schleifenbildung zu verhindern.</para>

      <para>&os; unterstützt die Betriebsmode RSTP sowie STP,
	von denen RSTP als Standardmodus voreingestellt ist.</para>

      <para>Spanning&nbsp;Tree kann auf den Schnittstellen der
	durch die Bridge verbundenen Netzwerksegmente über die
	Option <literal>stp</literal> aktiviert werden.  Für eine
	Bridge, die die Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> verbindet, aktivieren Sie STP wie
	folgt:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Diese Bridge hat die Spanning-Tree-ID
	<literal>00:01:02:4b:d4:50</literal> und die Priorität
	<literal>32768</literal>.  Da diese ID mit der
	<literal>Root-ID</literal> identisch ist, handelt es sich um die
	Root-Bridge dieses Netzwerks.</para>

      <para>Auf einer anderen Bridge des Netzwerks ist Spanning&nbsp;Tree
	ebenfalls aktiviert:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Die Zeile <literal>root id 00:01:02:4b:d4:50 priority 32768
	ifcost 400000 port 4</literal> zeigt an, dass die Root-Bridge wie
	im obigen Beispiel die ID <literal>00:01:02:4b:d4:50</literal>
	hat.  Die Pfadkosten hin zur Root-Bridge betragen
	<literal>400000</literal>, wobei der Pfad zur Root-Bridge
	über <literal>Port&nbsp;4</literal> geht (der wiederum
	der Schnittstelle <filename>fxp0</filename>
	entspricht).</para>
    </sect2>

    <sect2>
      <title>Fortgeschrittene Funktionen</title>

      <sect3>
	<title>Den Datenfluss rekonstruieren</title>

	<para>Die Bridge unterstützt den Monitormodus.  Dabei
	  werden alle Pakete verworfen, nachdem sie von &man.bpf.4;
	  verarbeitet wurden.  In diesem Modus erfolgt keine weitere
	  Bearbeitung und auch keine Weiterleitung von Datenpaketen.
	  Es ist daher möglich, die Eingabe von zwei oder mehr
	  Netzwerkschnittstellen in einen einzigen gemeinsamen
	  &man.bpf.4;-Stream zu vereinen.  Ein solcher Datenstrom
	  ist beispielsweise nützlich, um den Datenverkehr für
	  ""network taps"" zu rekonstruieren, die ihre RX/TX-Signale
	  über verschiedene Schnittstellen senden.</para>

	<para>Um die Eingabe von vier Netzwerkschnittstellen in einzigen
	  gemeinsamen Datenstrom zu vereinen, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
      </sect3>

      <sect3>
	<title>Span Ports</title>

	<para>Eine Kopie jedes Ethernet-Rahmens, der an der Bridge
	  ankommt, wird über einen festgelegten
	  <foreignphrase>Span&nbsp;Port</foreignphrase> verschickt.
	  Auf einer Bridge können
	  beliebig viele Span&nbsp;Ports festgelegt werden.  Wird
	  eine Schnittstelle als Span&nbsp;Port konfiguriert, kann
	  sie nicht mehr als normaler Bridge-Port verwendet werden.
	  Eine derartige Konfiguration ist beispielsweise sinnvoll,
	  um den Datenverkehr, der in einem Netzwerk über die
	  Bridge läuft, auf einen Rechner zu übertragen,
	  der mit einem Span&nbsp;Port der Bridge verbunden
	  ist.</para>

	<para>Um eine Kopie aller Ethernet-Rahmen über die
	  Schnittstelle <filename>fxp4</filename> zu verschicken,
	  geben Sie Folgendes ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
      </sect3>

      <sect3>
	<title>Private Schnittstellen</title>

	<para>Eine private Schnittstelle leitet keine Daten an einen
	  Port weiter, bei dem es sich ebenfalls um eine private
	  Schnittstelle handelt.  Der Datenverkehr wird dabei komplett
	  blockiert, auch Ethernet-Rahmen und ARP-Pakete werden nicht
	  weitergeleitet.  Wollen Sie hingegen nur spezifische
	  Datenpakete blockieren, sollten Sie eine Firewall
	  einsetzen.</para>
      </sect3>

      <sect3>
	<title>Schnittstellen als <foreignphrase>sticky</foreignphrase>
	  kennzeichnen</title>

	<para>Wenn die Schnittstelle eines über eine Bridge
	  verbundenen Netzwerksegments als
	  <foreignphrase>sticky</foreignphrase> gekennzeichnet wird,
	  werden alle dynamisch gelernten Adressen als statische Adressen
	  behandelt, sobald sie in den Forward-Cache der Bridge
	  aufgenommen wurden.  Sticky-Einträge werden niemals aus
	  dem Cache entfernt oder ersetzt.  Selbst dann nicht, wenn die
	  Adresse von einer anderen Schnittstelle verwendet wird.  Sie
	  können dadurch die Vorteile statischer Adresseinträge
	  nutzen, ohne die Forward-Tabelle vor dem Einsatz der Bridge
	  mit statischen Einträgen füllen zu müssen.
	  Clients, die sich in einem bestimmten von der Bridge
	  verwalteten Segmente befinden, können dabei nicht in ein
	  anderes Segment wechseln.</para>

	<para>Ein weiteres Beispiel für den Einsatz von
	  Sticky-Adressen wäre die Kombination einer Bridge mit
	  mehreren VLANs, um einen Router zu konfigurieren, der in
	  in der Lage ist, einzelne Kundennetzwerke voneinander zu
	  trennen, ohne IP-Adressbereiche zu verschwenden.  Für das
	  folgende Beispiel nehmen wir an, dass sich der Client
	  <systemitem class="fqdomainname">CustomerA</systemitem> im VLAN
	  <literal>vlan100</literal> und der Client
	  <systemitem class="fqdomainname">CustomerB</systemitem> im VLAN
	  <literal>vlan101</literal> befinden.  Die Bridge hat die
	  IP-Adresse <systemitem class="ipaddress">192.168.0.1</systemitem> und ist
	  als Internet-Router konfiguriert.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>Beide Clients sehen <systemitem class="ipaddress">192.168.0.1</systemitem> als Ihr Default-Gateway.
	  Da der Brücken-Cache <emphasis>sticky</emphasis> ist,
	  sind Sie nicht dazu in der Lage, die MAC-Adresse des
	  anderen Kunden zu spoofen und dessen Datenverkehr
	  abzufangen.</para>

	<para>Sie können die Kommunikation zwischen den VLANs
	  vollständig unterbinden, wenn Sie private Schnittstellen
	  (oder eine Firewall) einsetzen:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>Die Kunden sind nun komplett voneinander isoliert und
	  der komplette <systemitem class="netmask">/24</systemitem>-Adressbereich
	  kann zugewiesen werden, ohne dass Sie Subnetze einsetzen
	  müssen.</para>
      </sect3>

      <sect3>
	<title>Adressen-Limitierung</title>

	<para>Die maximale mögliche Anzahl an eindeutigen
	  MAC-Adressen hinter einer Schnittstelle kann festgelegt werden.
	  Sobald das Limit erreicht ist, werden Pakete mit einer
	  unbekannten Quell-Adresse solange verworfen, bis ein
	  existierender Eintrag gelöscht wird oder
	  abläuft.</para>

	<para>Das folgende Beispiel setzt die maximale Anzahl von
	  Netzgeräten für
	  <systemitem class="fqdomainname">CustomerA</systemitem> für
	  das VLAN <literal>vlan100</literal> auf 10.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
      </sect3>

      <sect3>
	<title>SNMP-Monitoring</title>

	<para>Die Schnittstelle der Bridge sowie die STP-Parameter
	  können durch den bereits im Basissystem enthaltenen
	  SNMP-Daemon überwacht werden.  Die exportierten
	  Bridge-MIBs entsprechen den IETF-Standards, daher können
	  Sie einen beliebigen SNMP-Client oder ein beliebiges
	  Monitoring-Werkzeug einsetzen, um die benötigten Daten
	  zu erhalten.</para>

	<para>Auf dem Rechner, auf dem die Bridge konfiguriert ist,
	  aktivieren Sie die Zeile
	  <literal>begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"</literal>
	  in der Datei <filename>/etc/snmp.config</filename> und starten
	  danach den <application>bsnmpd</application>-Daemon.
	  Eventuell benötigen Sie noch weitere
	  Konfigurationsparameter wie Community-Namen und
	  Zugriffslisten.  Die Konfiguration dieser Parameter wird
	  in den Manualpages &man.bsnmpd.1; sowie &man.snmp.bridge.3;
	  beschrieben.</para>

	<para>Die folgenden Beispiele verwenden das Softwarepaket
	  <application>Net-SNMP</application> (<package>net-mgmt/net-snmp</package>), um die Bridge
	  abzufragen.  Alternativ können Sie dafür auch den
	  Port <package>net-mgmt/bsnmptools</package>
	  einsetzen.  Auf dem SNMP-Client fügen Sie danach die
	  folgenden Zeilen in die Datei
	  <filename>$HOME/.snmp/snmp.conf</filename> ein, um die
	  MIB-Definitionen der Bridge in
	  <application>Net-SNMP</application> zu importieren:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>Um eine einzelne Bridge über den IETF BRIDGE-MIB
	  (RFC4188) zu überwachen, geben Sie Folgendes ein:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>Der Wert der Variable
	  <literal>dot1dStpTopChanges.0</literal> ist hier 2, die
	  STP-Topologie der Bridge wurde also bereits zweimal
	  geändert.  Unter einer Änderung versteht man dabei
	  die Anpassung eines oder mehrerer Links und die Kalkulation
	  eines neuen Baums.  Der Wert der Variable
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal> gibt an,
	  wann dies zuletzt geschah.</para>

	<para>Um mehrere Bridge-Schnittstellen zu überwachen,
	  können Sie den privaten BEGEMOT-BRIDGE-MIB
	  einsetzen:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>Um die über den
	  <literal>mib-2.dot1dBridge</literal>-Subtree überwachte
	  Bridge-Schnittstelle zu ändern, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info><title>Link-Aggregation und Failover</title>
      <authorgroup>
        <author>
          <personname>
            <firstname>Andrew</firstname>
            <surname>Thompson</surname>
          </personname>
          <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <personname>
            <firstname>Benedict</firstname>
            <surname>Reuschling</surname>
          </personname>
          <contrib>Übersetzt von </contrib>
        </author>

        <author>
          <personname>
            <firstname>Sharon</firstname>
            <surname>Bahagi</surname>
          </personname>
        </author>
      </authorgroup>
    </info>


    <indexterm>
      <primary>lagg</primary>
    </indexterm>
    <indexterm>
      <primary>failover</primary>
    </indexterm>
    <indexterm>
      <primary>fec</primary>
    </indexterm>
    <indexterm>
      <primary>lacp</primary>
    </indexterm>
    <indexterm>
      <primary>loadbalance</primary>
    </indexterm>
    <indexterm>
      <primary>roundrobin</primary>
    </indexterm>

      <para>Die von &os; unterstützte &man.lagg.4;-Schnittstelle
	erlaubt die Gruppierung von mehreren Netzwerkadaptern als eine
	virtuelle Schnittstelle mit dem Ziel, Ausfallsicherheit
	(Failover) und Link Aggregation bereitzustellen.  Bei Failover
	kann der Verkehr auch dann weiter fließen, wenn nur eine
	Schnittstelle verfügbar ist.  Link Aggregation funktioniert am
	besten mit Switches, welche <acronym>LACP</acronym>
	unterstützen, da dieses Protokoll den Datenverkehr
	bidirektional verteilt, während es auch auf den Ausfall
	einzelner Verbindungen reagiert.</para>

      <para>Die von der lagg-Schnittstelle unterstützten Protokolle
	bestimmten, welche Ports für den ausgehenden Datenverkehr
	benutzt werden, und ob ein bestimmter Port eingehenden
	Datenverkehr akzeptiert.  Die folgenden Protokolle werden von
	&man.lagg.4; unterstützt:</para>

      <variablelist>
        <varlistentry>
          <term>failover (Ausfallsicherheit)</term>
	  <listitem>
	    <para>Dieser Modus sendet und empfängt Datenverkehr nur
	      auf dem Masterport.  Sollte der Masterport nicht zur
	      Verfügung stehen, wird der nächste aktive Port
	      verwendet.  Der zuerst hinzugefügte Adapter der
	      virtuellen Schnittstelle wird zum Masterport, jeder
	      weitere Adapter dient als Gerät zur Ausfallsicherheit.
	      Wenn ein Failover auf einem Nicht-Master Port
	      stattfindet, wird der ursprüngliche Port wieder zum
	      Master-Port, sobald er wieder verfügbar ist.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>fec / loadbalance (Lastverteilung)</term>
	  <listitem>
	    <para>&cisco; Fast &etherchannel; (<acronym>FEC</acronym>)
	      findet sich auf älteren &cisco; Switches.  Es bietet
	      eine statische Konfiguration und handelt weder
	      Aggregation mit der Gegenstelle aus, noch werden Frames
	      zur Überwachung der Verbindung ausgetauscht.  Wenn der
	      Switch <acronym>LACP</acronym> unterstützt, sollte diese
	      Option auch verwendet werden.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lacp</term>
	  <listitem>
	    <para>Das &ieee; 802.3ad Link-Aggregation Control
	      Protokoll (<acronym>LACP</acronym>).  Mit
	      <acronym>LACP</acronym> wird eine Menge von
	      aggregierbaren Verbindungen mit der Gegenstelle in einer
	      oder mehreren Link Aggregated Groups
	      (<acronym>LAG</acronym>) ausgehandelt.  Jede
	      <acronym>LAG</acronym> besteht aus Ports der gleichen
	      Geschwindigkeit, eingestellt auf Voll-Duplex-Betrieb.
	      Der Verkehr wird über die Ports in der
	      <acronym>LAG</acronym> mit der größten
	      Gesamtgeschwindigkeit balanciert.  Typischerweise gibt
	      es nur eine <acronym>LAG</acronym>, die alle Ports
	      enthält.  Im Falle von Änderungen in der physischen
	      Anbindung wird <acronym>LACP</acronym> schnell zu einer
	      neuen Konfiguration konvergieren.</para>

            <para><acronym>LACP</acronym> balanciert ausgehenden
              Verkehr über die aktiven Ports basierend auf der
              gehashten Protokollheaderinformation und akzeptiert
              eingehenden Verkehr auf jedem aktiven Port.  Der Hash
              beinhaltet die Ethernet-Quell- und Zieladresse, und,
              soweit verfügbar, den <acronym>VLAN</acronym>-Tag,
              sowie die <acronym>IPv4</acronym> oder
              <acronym>IPv6</acronym> Quell- und Zieladresse.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>roundrobin</term>
	  <listitem>
	    <para>Dieser Modus verteilt ausgehenden Verkehr mittels
	      einer Round-Robin-Zuteilung über alle aktiven Ports und
	      akzeptiert eingehenden Verkehr auf jedem aktiven Port.
	      Da dieser Modus die Reihenfolge von Ethernet-Frames
	      verletzt, sollte er mit Vorsicht eingesetzt
	      werden.</para>
          </listitem>
        </varlistentry>
      </variablelist>

    <sect2>
      <title>Beispiele</title>

      <para>Dieser Abschnitt zeigt, wie man einen &cisco; Switch und
	ein &os;-System für <acronym>LACP</acronym> Load Balancing
	konfiguriert.  Weiterhin wird gezeigt, wie man zwei
	Ethernet-Schnittstellen, sowie eine Ethernet- und eine
	Drahtlos-Schnittstelle für den Failover-Modus konfigurieren
	kann.</para>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title><acronym>LACP</acronym> Aggregation mit einem Switch
	  von &cisco;</title>

	<para>Dieses Beispiel verbindet zwei &man.fxp.4;
	  Ethernet-Schnittstellen einer &os;-Maschine zu den ersten
	  zwei Ethernet-Ports auf einem &cisco; Switch als eine
	  einzelne, lastverteilte und ausfallsichere Verbindung.
	  Weitere Adapter können hinzugefügt werden, um den Durchsatz
	  zu erhöhen und die Ausfallsicherheit zu steigern.  Ersetzen
	  Sie die Namen der &cisco;-Ports, Ethernet-Geräte,
	  channel-group Nummern und <acronym>IP</acronym>-Adressen im
	  Beispiel durch Namen, die mit Ihrer lokalen Konfiguration
	  übereinstimmen.</para>


        <para>Da die Reihenfolge der Frames bei Ethernet zwingend
          eingehalten werden muss, fließt auch jeglicher Verkehr
          zwischen zwei Stationen über den gleichen physischen
          Kanal, was die maximale Geschwindigkeit der Verbindung auf
          die eines einzelnen Adapters beschränkt.
          Der Übertragungsalgorithmus versucht, so viele
          Informationen wie möglich zu verwenden, um die
          verschiedenen Verkehrsflüsse zu unterscheiden und
	  balanciert diese über die verfügbaren Adapter.</para>

	<para>Fügen Sie auf dem &cisco;-Switch die Adapter
	  <replaceable>FastEthernet0/1</replaceable> und
	  <replaceable>FastEthernet0/2</replaceable> zu der
	  channel-group <replaceable>1</replaceable> hinzu:</para>

	<screen><userinput>interface
<replaceable>FastEthernet0/1</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput>
!
<userinput>interface <replaceable>FastEthernet0/2</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput></screen>

	<para>Auf der Maschine mit &os; erstellen Sie die
	  &man.lagg.4;-Schnittstelle unter Verwendung von
	  <replaceable>fxp0</replaceable> und
	  <replaceable>fxp1</replaceable> und starten Sie
	  Schnittstelle mit der <acronym>IP</acronym>-Adresse
	  <replaceable>10.0.0.3/24</replaceable>:</para>

        <screen>&prompt.root; <userinput>ifconfig
<replaceable>fxp0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <replaceable>fxp1</replaceable>
up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create </userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto lacp laggport
<replaceable>fxp0</replaceable> laggport
<replaceable>fxp1</replaceable>
<replaceable>10.0.0.3/24</replaceable></userinput></screen>

	<para>Als nächstes, überprüfen Sie den Status der virtuellen
	  Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal></userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>Ports, die als <emphasis>ACTIVE</emphasis> markiert
	  sind, sind Teil der aktiven Aggregations-Gruppe, die mit dem
	  Switch ausgehandelt wurde und der Verkehr wird über diese
	  übertragen und empfangen.  Benutzen Sie <option>-v</option>
	  im obigen Kommando, um sich die
	  <acronym>LAG</acronym>-Bezeichner anzeigen zu lassen.</para>

	<para>Um den Status der Ports auf dem &cisco; Switch
	  anzuzeigen:</para>

        <screen>switch# <userinput>show lacp neighbor</userinput>
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Benutzen Sie das Kommando <userinput>show lacp neighbor
	  detail</userinput>, um weitere Informationen zu erhalten.</para>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie auf Ihrem &os;-System folgende
	  Einträge in <filename>/etc/rc.conf</filename> hinzu:</para>

        <programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>
ifconfig_<literal>lagg0</literal>="laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.3/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-failover">
	<title>Ausfallsicherer Modus</title>

	<para>Der ausfallsichere Modus kann verwendet werden, um zu
	  einer zweiten Schnittstelle zu wechseln, sollte die
	  Verbindung mit der Master-Schnittstelle ausfallen.  Um den
	  ausfallsicheren Modus zu konfigurieren, stellen Sie sicher,
	  dass die zugrunde liegenden physikalischen Schnittstellen
	  aktiv sind.  Erstellen Sie dann die
	  &man.lagg.4;-Schnittstelle.  In diesem Beispiel ist
	  <replaceable>fxp0</replaceable> die Master-Schnittstelle,
	  <replaceable>fxp1</replaceable> die sekundäre Schnittstelle,
	  und der virtuellen Schnittstelle wird die
	  <acronym>IP</acronym>-Adresse
	  <replaceable>10.0.0.15/24</replaceable> zugewiesen:</para>

        <screen>&prompt.root; <userinput>ifconfig
<replaceable>fxp0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <replaceable>fxp1</replaceable>
up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport
<replaceable>fxp0</replaceable> laggport
<replaceable>fxp1</replaceable>
<replaceable>10.0.0.15/24</replaceable></userinput></screen>

	<para>Die virtuelle Schnittstelle sollte in etwa so
	  aussehen:</para>

        <screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Der Verkehr wird auf <replaceable>fxp0</replaceable>
	  übertragen und empfangen.  Wenn die Verbindung auf
	  <replaceable>fxp0</replaceable> abbricht, so wird
	  <replaceable>fxp1</replaceable> die Verbindung übernehmen.
	  Sobald die Verbindung auf der Master-Schnittstelle
	  wiederhergestellt ist, wird diese auch wieder als aktive
	  Schnittstelle genutzt.</para>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie folgende Einträge in
	  <filename>/etc/rc.conf</filename> hinzu:</para>

        <programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>
ifconfig_<literal>lagg0</literal>="laggproto failover laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.15/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
        <title>Failover Modus zwischen Ethernet- und
          Wireless-Schnittstellen</title>

	<para>Für Laptop-Benutzer ist es normalerweise wünschenswert,
	  wireless als sekundäre Schnittstelle einzurichten, die
	  verwendet wird, wenn die Ethernet-Verbindung nicht verfügbar
	  ist.  Mit &man.lagg.4; ist es möglich, ein Failover zu
	  konfigurieren, welches die Ethernet-Verbindung aus
	  Performance- und Sicherheitsgründen bevorzugt, während es
	  gleichzeitig möglich bleibt, Daten über die drahtlose
	  Verbindung zu übertragen.</para>

	<para>Dies wird durch das Überschreiben der physikalischen
	  <acronym>MAC</acronym>-Adresse der drahtlosen Schnittstelle,
	  durch die der Ethernet-Schnittstelle erreicht.</para>

	<para>In dieser Konfiguration behandeln wir die
	  Ethernet-Schnittstelle <replaceable>bge0</replaceable> als
	  die Master und die drahtlose Schnittstelle
	  <replaceable>wlan0</replaceable> als die
	  Failover-Schnittstelle.  Die
	  <replaceable>wlan0</replaceable> wurde von der
	  <replaceable>iwn0</replaceable> mit der
	  <acronym>MAC</acronym>-Adresse der Ethernet-Schnittstelle
	  eingerichtet.  Im ersten Schritt ermitteln wir die
	  <acronym>MAC</acronym>-Adresse der
	  Ethernet-Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>bge0</replaceable></userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
 options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
 ether 00:21:70:da:ae:37
 inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
 nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
 media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
 status: active</screen>

	<para>Ersetzen Sie <replaceable>bge0</replaceable> durch den
	  Namen der Ethernet-Schnittstelle Ihres Systems.  Die
	  <literal>ether</literal>-Zeile wird die
	  <acronym>MAC</acronym>-Adresse der angegebenen Schnittstelle
	  enthalten.  Ändern Sie nun die
	  <acronym>MAC</acronym>-Adresse der zugrunde liegenden
	  Wireless-Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig
<replaceable>iwn0</replaceable> ether
<replaceable>00:21:70:da:ae:37</replaceable></userinput></screen>

	<para>Starten Sie den Wireless-Schnittstelle, aber ohne
	  IP-Adresse:</para>

        <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev
<replaceable>iwn0</replaceable> ssid
<replaceable>my_router</replaceable> up</userinput></screen>

	<para>Stellen Sie sicher, dass die
	  <replaceable>bge0</replaceable>-Schnittstelle aktiv ist.
	  Erstellen Sie dann die &man.lagg.4;-Schnittstelle mit
	  <replaceable>bge0</replaceable> als Master mit Failover auf
	  <replaceable>wlan0</replaceable>:</para>

        <screen>&prompt.root; <userinput>ifconfig
<replaceable>bge0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport
<replaceable>bge0</replaceable> laggport wlan0</userinput></screen>

	<para>Die virtuelle Schnittstelle sollte in etwa so
	  aussehen:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie folgende Einträge in
	  <filename>/etc/rc.conf</filename> hinzu:</para>

        <programlisting>ifconfig_<replaceable>bge0</replaceable>="up"
ifconfig_<replaceable>iwn0</replaceable>="<replaceable>ether
00:21:70:da:ae:37</replaceable>"
wlans_<replaceable>iwn0</replaceable>="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto failover laggport
<replaceable>bge0</replaceable> laggport wlan0
DHCP"</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info>
      <title>Plattenloser Betrieb mit <acronym>PXE</acronym></title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Jean-Fran&ccedil;ois</firstname>
            <surname>Dock&egrave;s</surname>
          </personname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <personname>
            <firstname>Alex</firstname>
            <surname>Dupre</surname>
          </personname>
          <contrib>Reorganisiert und erweitert von </contrib>
        </author>
      </authorgroup>
    </info>



    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>Das &intel; Preboot eXecution Environment
      (<acronym>PXE</acronym>) erlaubt es dem Betriebssystem über das
      Netzwerk zu starten.  Zum Beispiel kann ein &os;-System, ohne
      lokale Festplatte, über das Netzwerk gestartet und betrieben
      werden.  Die Dateisysteme werden dabei über einen
      <acronym>NFS</acronym>-Server eingehangen.
      <acronym>PXE</acronym>-Unterstützung steht in der Regel im
      <acronym>BIOS</acronym> zur Verfügung.  Um
      <acronym>PXE</acronym> beim Systemstart zu verwenden, müssen Sie
      im <acronym>BIOS</acronym> des Rechners die Option <literal>Über
	das Netzwerk starten</literal> aktivieren.  Alternativ können
      Sie während der PC-Initialisierung auch eine Funktionstaste
      drücken.</para>

    <para>Um die notwendigen Dateien für ein Betriebssystem für den
      Start über das Netzwerk bereitzustellen, benötigt ein
      <acronym>PXE</acronym>-Setup einen richtig konfigurierten
      <acronym>DHCP</acronym>-, <acronym>TFTP</acronym>- und
      <acronym>NFS</acronym>-Server, wobei:</para>

      <itemizedlist>
	<listitem>
	  <para>Die initialen Parameter, wie
	    <acronym>IP</acronym>-Adresse, Dateiname und Speicherort
	    der ausführbaren Bootdateien, Servername sowie Root-Pfad
	    vom <acronym>DHCP</acronym>-Server bezogen werden.</para>
        </listitem>

	<listitem>
          <para>Der Loader für das Betriebssystem über
            <acronym>TFTP</acronym> gestartet wird.</para>
	</listitem>

        <listitem>
          <para>Die Dateisysteme über
            <acronym>NFS</acronym> geladen werden.</para>
        </listitem>
      </itemizedlist>

      <para>Sobald das Gastsystem startet, erhält es vom
	<acronym>DHCP</acronym>-Server Informationen, wo der initiale
	Bootloader per <acronym>TFTP</acronym> zu bekommen ist.
	Nachdem das Gastsystem diese Informationen erhalten hat, lädt
	es den Bootloader über <acronym>TFTP</acronym> herunter und
	führt diesen anschließend aus.  In &os; ist
	<filename>/boot/pxeboot</filename> der Bootloader.  Nachdem
	<filename>/boot/pxeboot</filename> ausgeführt und der
	&os;-Kernel geladen wurde, wird mit dem Rest der
	&os;-Bootsequenz, wie in <xref linkend="boot"/> beschrieben,
	fortgefahren.</para>

      <para>Dieser Abschnitt beschreibt, wie Sie diese Dienste auf
	einem &os;-System so konfigurieren, sodass andere Systeme &os;
	über <acronym>PXE</acronym> starten können.  Weitere
	Informationen finden Sie in &man.diskless.8;.</para>

      <caution>
	<para>Wie beschrieben, ist das System, welches diese Dienste
	  bereitstellt, unsicher.  Daher sollte es in einem
	  geschützten Bereich des Netzwerks aufgestellt und von
	  anderen Hosts als nicht vertrauenswürdig eingestuft
	  werden.</para>
      </caution>

    <sect2 xml:id="network-pxe-nfs">
      <info>
      <title>Konfiguration der
          <acronym>PXE</acronym>-Umgebung</title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Craig</firstname>
            <surname>Rodrigues</surname>
          </personname>
          <affiliation>
            <address>rodrigc@FreeBSD.org</address>
          </affiliation>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
      </info>

      <para>Die in diesem Abschnitt dargestellten Schritte
	konfigurieren die in &os; enthaltenen <acronym>NFS</acronym>-
	und <acronym>TFTP</acronym>-Server.  Der folgende Abschnitt
	beschreibt die Installation und Konfiguration des
	<acronym>DHCP</acronym>-Servers.  In diesem Beispiel verwenden
	wir <filename>/b/tftpboot/FreeBSD/install</filename>, welches
	die Dateien für <acronym>PXE</acronym>-Benutzer enthält.  Es
	ist wichtig, dass dieses Verzeichnis existiert und das der
	gleiche Verzeichnisname ebenfalls in
	<filename>/etc/inetd.conf</filename> und
	<filename>/usr/local/etc/dhcpd.conf</filename> gesetzt
	wird.</para>

      <procedure>
        <step>
          <para>Erstellen Sie das Root-Verzeichnis, welches eine
	    &os;-Installation enthält und über NFS eingehangen
            werden kann.</para>

          <screen>&prompt.root; <userinput>export NFSROOTDIR=/b/tftpboot/FreeBSD/install</userinput>
&prompt.root; <userinput>mkdir -p ${NFSROOTDIR}</userinput></screen>
        </step>

        <step>
	  <para>Aktivieren Sie den NFS-Server, indem Sie folgende
	    Zeile in <filename>/etc/rc.conf</filename>
	    hinzufügen:</para>

          <programlisting>nfs_server_enable="YES"</programlisting>

	  <para>Exportieren Sie das Root-Verzeichnis über NFS, indem
	    Sie folgende Zeile in <filename>/etc/exports</filename>
	    hinzufügen:</para>

          <programlisting>/b -ro -alldirs</programlisting>
        </step>

        <step>
          <para>Starten Sie den <acronym>NFS</acronym>-Server:</para>

          <screen>&prompt.root; <userinput>service nfsd start</userinput></screen>
        </step>

        <step>
	  <para>Aktivieren Sie &man.inetd.8;, indem Sie folgende Zeile
	    in <filename>/etc/rc.conf</filename> hinzufügen:</para>

          <programlisting>inetd_enable="YES"</programlisting>
        </step>

        <step>
	  <para>Kommentieren Sie die folgende Zeile in
	    <filename>/etc/inetd.conf</filename> aus, indem Sie
	    sicherstellen, dass die Zeile nicht mit einem
	    <literal>#</literal>-Zeichen beginnt:</para>

          <programlisting>tftp dgram udp wait root /usr/libexec/tftp tftp -l -s /b/tftpboot</programlisting>

            <note>
	      <para>Einige <acronym>PXE</acronym>-Versionen benötigen
		die <acronym>TCP</acronym>-Version von
		<acronym>TFTP</acronym>.  In diesem Fall können Sie
		die zweite <literal>tftp</literal>-Zeile, welche
		<literal>stream tcp</literal> enthält,
		auskommentieren.</para>
            </note>
        </step>

        <step>
          <para>Starten Sie &man.inetd.8;:</para>

          <screen>&prompt.root; <userinput>service inetd start</userinput></screen>
        </step>

        <step>
	  <para>Erstellen Sie einen neues Basissystem und einen
	    &os;-Kernel (detaillierte Anweisungen hierzu finden Sie
	    unter <xref linkend="makeworld"/>):</para>

          <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>
        </step>

        <step>
          <para>Installieren sie &os; in das Verzeichnis, welches
            über <acronym>NFS</acronym> eingehangen ist:</para>

          <screen>
&prompt.root; <userinput>make installworld DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make installkernel DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make distribution DESTDIR=${NFSROOTDIR}</userinput>
          </screen>
        </step>

        <step>
	  <para>Testen Sie den <acronym>TFTP</acronym>-Server und
	    vergewissern Sie sich, dass Sie den Bootloader
	    herunterladen können, der über <acronym>PXE</acronym>
	    bereitgestellt wird:</para>

          <screen>
&prompt.root; <userinput>tftp localhost</userinput>
tftp> <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds
          </screen>
        </step>

        <step>
	  <para>Bearbeiten Sie
	    <filename>${NFSROOTDIR}/etc/fstab</filename> und
	    erstellen Sie einen Eintrag, um das Root-Dateisystem
	    über <acronym>NFS</acronym> einzuhängen:</para>

          <programlisting>
# Device                                      Mountpoint    FSType    Options   Dump  Pass
<replaceable>myhost.example.com</replaceable>:/b/tftpboot/FreeBSD/install    /         nfs       ro        0     0
          </programlisting>

	  <para>Ersetzen Sie
	    <replaceable>myhost.example.com</replaceable> durch den
	    Hostnamen oder die <acronym>IP</acronym>-Adresse Ihres
	    <acronym>NFS</acronym>-Servers.  In diesem Beispiel wird
	    das Root-Dateisystem schreibgeschützt eingehangen, um
	    ein potenzielles Löschen des Inhalts durch die
	    <acronym>NFS</acronym>-Clients zu verhindern.</para>
        </step>

        <step>
	  <para>Setzen Sie das root-Passwort in der
            <acronym>PXE</acronym>-Umgebung für Client-Maschinen, die
            über <acronym>PXE</acronym> starten:</para>

          <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR} </userinput>
&prompt.root; <userinput>passwd</userinput></screen>
        </step>

        <step>
          <para>Falls erforderlich, aktivieren Sie &man.ssh.1;
            root-Logins für Client-Maschinen, die über
            <acronym>PXE</acronym> starten, indem Sie die
            Option <literal>PermitRootLogin</literal> in
	    <filename>${NFSROOTDIR}/etc/ssh/sshd_config</filename>
	    aktivieren. Dies ist in &man.sshd.config.5;
	    dokumentiert.</para>
        </step>

        <step>
	  <para>Führen Sie alle weiteren Anpassungen der
	    <acronym>PXE</acronym>-Umgebung in ${NFSROOTDIR} durch,
	    wie zum Beispiel die Installation weiterer Pakete, oder
	    dass Bearbeiten der Passwortdatei mit &man.vipw.8;.</para>
        </step>
      </procedure>

      <para>Booten Sie von einem <acronym>NFS</acronym>-Root-Volume,
	so erkennt <filename>/etc/rc</filename> dies und startet
	daraufhin das <filename>/etc/rc.initdiskless</filename>
	Skript.  Lesen Sie die Kommentare in diesem Skript um zu
	verstehen, was dort vor sich geht.  Weil das
	<acronym>NFS</acronym>-Root-Verzeichnis schreibgeschützt ist,
	wir aber Schreibzugriff für <filename>/etc</filename> und
	<filename>/var</filename> benötigen, müssen wir diese
	Verzeichnisse über Speicher-Dateisysteme (memory backed file
	system) einbinden.</para>

      <screen>
&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>mkdir -p conf/base</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/etc.cpio.gz --format cpio
--gzip etc</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/var.cpio.gz --format cpio
--gzip var</userinput></screen>
    </sect2>

    <sect2 xml:id="network-pxe-setting-up-dhcp">
	<title>Konfiguration des
          <acronym>DHCP</acronym>-Servers</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

        <para>Der <acronym>DHCP</acronym>-Server muss nicht auf der
          selben Maschine laufen wie der <acronym>TFTP</acronym>- und
          <acronym>NFS</acronym>-Server, aber er muss
          über das Netzwerk erreichbar sein.</para>

        <para><acronym>DHCP</acronym> ist nicht Bestandteil des &os;
          Basissystems, kann jedoch über den Port
          <package>net/isc-dhcp42-server</package> oder als Paket
          nachinstalliert werden.</para>

	<para>Einmal installiert, bearbeiten Sie seine
	  Konfigurationsdatei,
	  <filename>/usr/local/etc/dhcpd.conf</filename>.
	  Konfigurieren Sie die <literal>next-server</literal>,
	  <literal>filename</literal> und <literal>root-path</literal>
	  Einstellungen, wie in diesem Beispiel zu sehen ist:</para>

        <programlisting>subnet 192.168.0.0 netmask 255.255.255.0 {
range 192.168.0.2 192.168.0.3;
option subnet-mask 255.255.255.0;
option routers 192.168.0.1;
option broadcast-address 192.168.0.255;
option domain-name-servers 192.168.35.35, 192.168.35.36;
option domain-name "example.com";

# IP address of TFTP server
next-server <replaceable>192.168.0.1</replaceable>;

# path of boot loader obtained via tftp
filename "<replaceable>FreeBSD/install/boot/pxeboot</replaceable>";

# pxeboot boot loader will try to NFS mount this directory for root FS
option root-path "<replaceable>192.168.0.1:/b/tftpboot/FreeBSD/install/</replaceable>";
}</programlisting>

<!--
This option still needed?
host corbieres {
	  <para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    <literal>host</literal>-Deklaration Folgendes
	    hinzufügen: <literal>option host-name
	    margaux</literal></para>
            -->

	  <para>Die Anweisung
            <literal>next-server</literal> wird benutzt, um die
            <acronym>IP</acronym>-Adresse des
            <acronym>TFTP</acronym>-Servers anzugeben.</para>

	  <para>Die Anweisung
            <literal>filename</literal> definiert den Pfad zu
            <filename>/boot/pxeboot</filename>.  Da hier der relative
            Dateiname verwendet wird, bedeutet das, dass
            <filename>/b/tftpboot</filename> nicht im Pfad enthalten
            ist.</para>

          <para>Die Option <literal>root-path</literal> bestimmt den
            Pfad zum <acronym>NFS</acronym> root-Dateisystem.</para>

	  <para>Sobald die Änderungen gespeichert werden, aktivieren
	    Sie <acronym>NFS</acronym> beim Systemstart, indem Sie die
	    folgende Zeile in <filename>/etc/rc.conf</filename>
	    hinzufügen:</para>

          <programlisting>dhcpd_enable="YES"</programlisting>

	  <para>Starten Sie anschließend den
	    <acronym>DHCP</acronym>-Dienst:</para>

          <screen>&prompt.root; <userinput>service isc-dhcpd
start</userinput></screen>
      </sect2>

<!--
I don't know why this is still here. Comment it out for now.
      <sect2>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (für einen Client) für
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>Etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>benötigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect2>

      <sect2>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <link xlink:href="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</link> enthält
	  <link xlink:href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausführliche Informationen</link>, die zwar vor allem
          für Linux gedacht sind, aber dennoch nützliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>Etherboot</application> auf
          einem &os;-System einsetzen können.</para>

        <para>Als Erstes müssen Sie
          <package>net/etherboot</package> als Paket
          oder als Port installieren.</para>

	<para>Sie können <application>Etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>Etherboot</application> bearbeiten.</para>

        <para>Für unsere Installation verwenden wir eine
          Startdiskette.  Für Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>Etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>Etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>Etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/devicetype.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> hängt vom Typ
          der Ethernetkarte ab, über die der plattenlose Rechner
          verfügt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert für
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect2>
-->
<!--
Are these sections still needed?
      <sect2>
        <title>Vorbereitung des Root-Dateisystems</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

        <para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
          Erzeugung eines neuen Kernels zwar nicht unbedingt
          notwendig, es wird allerdings dennoch empfohlen.  Die
          Aktivierung dieser Optionen bewirkt, dass die Anzahl der
          möglichen <acronym>DHCP</acronym>-Anfragen während des
          Kernelstarts erhöht wird.  Ein kleiner Nachteil sind
          eventuell auftretende Inkonsistenzen zwischen den neuen
          Werten und den von &man.pxeboot.8; erhaltenen Werten.
          Der große Vorteil dieser Variante ist es, das dabei der
          Rechnername gesetzt wird, den Sie ansonsten durch eine
          andere Methode, beispielsweise in einer clientspezifischen
          <filename>/etc/rc.conf</filename> festlegen müssten.</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

        <para>Außerdem können Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch die Datei <filename>NOTES</filename> an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie ermöglichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch möglich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig"/>) und kopieren Sie ihn an den
          in <filename>/usr/local/etc/dhcpd.conf</filename> festgelegten
          Ort.</para>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie müssen für den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>/usr/local/etc/dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.</para>

        <para><command>make world</command> zum Füllen des
	    Dateisystems einsetzen</para>

	  <para>Diese schnelle Methode installiert ein komplettes
	    <quote>jungfräuliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    müssen Sie lediglich das folgende Skript
	    ausführen:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach müssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren Wünschen
	    anpassen.</para>
	</sect2>

      <sect2>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls nötig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.</para>

	  <para>Der Kernel unterstützt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingehängt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, fügen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect2>

      <sect2>
        <title>Verschiedenes</title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgeschützt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner
            <application>&xorg;</application> sowie ein
            schreibgeschütztes <filename>/usr</filename> läuft, müssen
            Sie die Konfigurationsdatei von
            <application>XDM</application> anpassen, da Fehlermeldungen
            in der Voreinstellung auf <filename>/usr</filename>
            geschrieben werden.</para>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    &os;-Rechner liegt, muss das Dateisystem zuerst unter
	    &os; erzeugt werden.  Anschließend wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gewünschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Gerätedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Geräten auf beiden Systemen hervorgerufen werden.
	    Eine Problemlösung besteht darin, das root-Verzeichnis
	    auf einem &os;-Rechner einzuhängen und die
	    Gerätedateien dort mit &man.devfs.5; zu erzeugen.</para>
    </sect2>
-->
    <sect2>
      <title>Fehlersuche bei <acronym>PXE</acronym> Problemen</title>

      <para>Sobald alle Dienste konfiguriert und gestartet wurden,
        sollten <acronym>PXE</acronym>-Clients in der Lage sein,
        &os; automatisch über das Netzwerk zu starten.  Wenn ein
        bestimmter Client beim hochfahren keine Verbindung herstellen
        kann, sehen Sie im <acronym>BIOS</acronym> nach, ob die
        Option für den Start über das Netzwerk konfiguriert
        ist.</para>

      <para>Dieser Abschnitt gibt einige Tipps zu Fehlerbehebung und
        zeigt, wie Sie Konfigurationsprobleme eingrezen können für
        den Fall, dass <acronym>PXE</acronym>-Clients nicht in der
        Lage sind über das Netzwerk zu starten.</para>

      <procedure>
        <step>
	  <para>Benutzen Sie den <filename
	      role="package">net/wireshark</filename> Port um
            Fehler im Netzwerkverkehr während des Bootvorgangs
            von <acronym>PXE</acronym> zu finden.  Der
            Bootvorgang wird im folgenden Diagramm schematisch
            dargestellt.</para>

          <figure>
            <title><acronym>PXE</acronym>-Bootvorgang mit
              <acronym>NFS</acronym> Root Mount</title>

            <mediaobject>
              <imageobjectco>
                <areaspec units="calspair">
                  <area
                    xml:id="co-pxenfs1" coords="2873,8133 3313,7266"/>
                  <area
                    xml:id="co-pxenfs2" coords="3519,6333 3885,5500"/>
                  <area
                    xml:id="co-pxenfs3" coords="4780,5866 5102,5200"/>
                  <area
                    xml:id="co-pxenfs4" coords="4794,4333 5102,3600"/>
                  <area
                    xml:id="co-pxenfs5" coords="3108,2666 3519,1800"/>
                </areaspec>
                <imageobject>
                  <imagedata fileref="advanced-networking/pxe-nfs"/>
                </imageobject>
                <calloutlist>
                  <callout arearefs="co-pxenfs1">
                    <para>Client sendet eine
                      <literal>DHCPDISCOVER</literal>
                      Nachricht.</para>
                  </callout>
                  <callout arearefs="co-pxenfs2">
                    <para>Der <acronym>DHCP</acronym>-Server antwortet
                      mit einer <acronym>IP</acronym>-Adresse, sowie
                      den Werten für <literal>next-server</literal>,
                      <literal>filename</literal> und
                      <literal>root-path</literal>.</para>
                  </callout>
                  <callout arearefs="co-pxenfs3">
                    <para>Der Client sendet eine
                      <acronym>TFTP</acronym>-Anfrage an
                      <literal>next-server</literal>, mit der Bitte
                      <literal>filename</literal> zu empfangen.</para>
                  </callout>
                  <callout arearefs="co-pxenfs4">
                    <para>Der <acronym>TFTP</acronym>-Server antwortet
                      und sendet <literal>filename</literal>
                      zum Client.</para>
                  </callout>
                  <callout arearefs="co-pxenfs5">
                    <para>Der Client führt
                      <literal>filename</literal>, sprich
                      &man.pxeboot.8; aus, was wiederum den
                      Kernel lädt.  Wenn der Kernel ausgeführt wird,
                      wird das Root-Dateisystem, welches in
                      <literal>root-path</literal> spezifiziert ist,
                      über <acronym>NFS</acronym> eingebunden.</para>
                  </callout>
                </calloutlist>
              </imageobjectco>
            </mediaobject>
          </figure>
        </step>

        <step>
          <para>Schauen Sie in <filename>/var/log/xferlog</filename>
            auf Ihrem <acronym>TFTP</acronym>-Server und vergewissern
            Sie sich, dass die <filename>pxeboot</filename>-Datei von
            der richtigen Adresse heruntergeladen wurde.  Um die
            obige Konfiguration von
            <filename>/usr/local/etc/dhcpd.conf</filename>
	    zu testen, geben Sie folgendes ein:</para>

          <screen>&prompt.root; <userinput>tftp 192.168.0.1</userinput>
tftp> <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>

	 <para>Weitere Informationen finden Sie in &man.tftpd.8; und
	   &man.tftp.1;.  Die <literal>BUGS</literal>-Sektionen dieser
	   Seiten dokumentieren einige Einschränkungen von
	   <acronym>TFTP</acronym>.</para>
        </step>

        <step>
	  <para>Achten Sie darauf, dass Sie das Root-Dateisystem über
	    <acronym>NFS</acronym> einhängen können. Auch hier können
            Sie Ihre Einstellungen aus
            <filename>/usr/local/etc/dhcpd.conf</filename>
	    wie folgt testen:</para>

          <screen>&prompt.root; <userinput>mount -t nfs 192.168.0.1:/b
/tftpboot/FreeBSD/install /mnt</userinput></screen>
        </step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="network-isdn">
    <title>ISDN &ndash; dienstintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle für Informationen zu ISDN ist die
      <link xlink:href="http://www.alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</link> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, könnte der Abschnitt
          über ISDN-Karten für Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN hauptsächlich dazu verwenden wollen, um
          sich über einen Anbieter ins Internet einzuwählen,
          sollten Sie den Abschnitt über Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          über eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          über Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gewünschten Lösung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 xml:id="network-isdn-cards">
      <info><title>ISDN-Karten</title>
        <authorgroup>
          <author>
            <personname>
              <firstname>Hellmuth</firstname>
              <surname>Michaelis</surname>
            </personname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </info>



      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Das ISDN-Subsystem von &os; unterstützt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur für passive
        Karten.  Zusätzlich werden aber auch einige
        aktive Karten unterstützt, bei denen die Firmware auch
        andere Signalprotokolle unterstützt;  dies schließt
        auch die erste ISDN-Karte mit
        Primärmultiplex-Unterstützung mit ein.</para>

      <para><application>isdn4bsd</application> ermöglicht es
	Ihnen, sich unter Nutzung von
	<emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
	(via <literal>isppp</literal>, einem modifizierten
	sppp-Treiber), oder Sie benutzen User-&man.ppp.8;.  Wenn Sie
	User-&man.ppp.8; verwenden, können Sie zwei oder mehrere
	ISDN-B-Kanäle bündeln.  Im Paket enthalten ist auch
	ein Programm mit Anrufbeantworterfunktion sowie verschiedene
	Werkzeuge, wie ein Softwaremodem, das 300&nbsp;Baud
	unterstützt.</para>

      <para>&os; unterstützt eine ständig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von &os; unterstützte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterstützt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur für den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterstützt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
	Sie auf der
        <link xlink:href="http://www.freebsd-support.de/i4b/">Internetseite</link>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <link xlink:href="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</link>.
      </para>

      <para>Falls Sie an der Unterstützung eines zusätzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>Für Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind für ISDN, was Modems für
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den
	Standardbefehlssatz für Modems von Hayes (AT-Kommandos) und
	können daher als Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.
	Die Konfiguration von <link linkend="ppp">PPP</link> entspricht
	dabei exakt der eines Modems.  Stellen Sie dabei allerdings
	die serielle Geschwindigkeit so hoch wie möglich ein.
      </para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters
	zur Verbindung mit einem Internetanbieter ist die
	Möglichkeit zur Nutzung von dynamischem PPP.  Da
	IP-Adressen immer knapper werden, vergeben die meisten Provider
	keine statischen IP-Adressen mehr.  Die meisten Router
	unterstützen allerdings keine dynamische Zuweisung von
	IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilität und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher können Sie unter &os; einfach von
	einer Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilität interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
	nicht das <link linkend="userppp">User-PPP</link>.</para>

      <para>Folgende Terminaladapter werden von &os;
	unterstützt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	möglichst gut unterstützen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, ähnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <link xlink:href="&url.articles.serial-uart.en;/index.html">
        Anleitung für die Nutzung serieller Geräte unter
        &os;</link> ansehen, wenn Sie detaillierte Informationen
        über serielle Geräte und die Unterschiede zwischen
	asynchronen und synchronen seriellen Ports benötigen.
      </para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschränkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsfähigkeit von ISDN (128&nbsp;Kbs)
        nutzen zu können, müssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschließen.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu können.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie ein serielles sowie ein
	Stromkabel weniger benötigen.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-&os;-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist beinahe eine religiöse
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <link xlink:href="&url.base;/search/index.html"> Archiven</link>
        danach, wenn Sie an der kompletten Diskussion interessiert
        sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        &os; oder eines anderen Betriebssystems.  Für eine
        vollständigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterführende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer günstiger und
	damit auch immer beliebter.  Ein ISDN-Router ist eine kleine
	Box, die direkt an Ihr lokales Ethernet-Netzwerk angeschlossen
	wird und sich mit einem Router oder einer Bridge verbindet.
	Die eingebaute Software ermöglicht die Kommunikation
	über PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router ermöglicht einen deutlich höheren
        Datendurchsatz als ein herkömmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Geräten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        klären Sie daher vorher ab, welche Anforderungen Ihre
        Geräte erfüllen müssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	Lösung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung für beide Seiten kaufen müssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, könnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls nötig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          können Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Großes Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair"/>
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein großer Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabhängige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die über
        zwei getrennte serielle Ports verfügen.  Verwechseln Sie
        dies aber nicht mit Kanalbündelung oder MPP.</para>

      <para>Dies kann sehr nützlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem Büro haben, die sie
        aufteilen wollen, ohne eine zusätzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann über einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal für eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        für ein- oder ausgehende Verbindungen verwendet werden.
        Sie können ihn aber auch dynamisch mit dem ersten B-Kanal
        bündeln, um Ihre Bandbreite zu erhöhen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info>
      <title>IPv6 &ndash; Internet Protocol Version 6</title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Aaron</firstname>
            <surname>Kaplan</surname>
          </personname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <personname>
            <firstname>Tom</firstname>
            <surname>Rhodes</surname>
          </personname>
          <contrib>Überarbeitet und erweitert von </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <personname>
            <firstname>Brad</firstname>
            <surname>Davis</surname>
          </personname>
          <contrib>Erweitert von </contrib>
        </author>
      </authorgroup>
    </info>

    <para>Bei IPv6 (auch als IPng oder
      <foreignphrase>IP next generation</foreignphrase>
      bekannt) handelt es sich um die neueste Version des bekannten
      IP-Protokolls (das auch als <acronym>IPv4</acronym> bezeichnet
      wird).  &os; enthält, genauso wie die anderen frei
      erhältlichen BSD-Systeme, die IPv6-Referenzimplementation
      von KAME.  &os; erfüllt damit bereits
      alle für die Nutzung von IPv6 nötigen Voraussetzungen.
      Dieser Abschnitt konzentriert sich daher auf die Konfiguration
      und den Betrieb von IPv6.</para>

    <para>Anfang der 90er Jahre wurde man auf den stark steigenden
      Verbrauch von IPv4-Adressen aufmerksam.  Im Hinblick auf das
      Wachstums des Internets gab es zwei Hauptsorgen:</para>

    <itemizedlist>
      <listitem>
        <para>Die drohende Knappheit von IPv4-Adressen.  Dieses Problem
          konnte durch die Einführung von privaten
          Adressräumen gemäß RFC1918 (mit Adressen wie
          <systemitem class="ipaddress">10.0.0.0/8</systemitem>,
          <systemitem class="ipaddress">172.16.0.0/12</systemitem>, oder
          <systemitem class="ipaddress">192.168.0.0/16</systemitem>) sowie der
          Entwicklung von <foreignphrase>Network Address
          Translation</foreignphrase> (<acronym>NAT</acronym>)
          weitestgehend entschärft werden.</para>
      </listitem>

      <listitem>
        <para>Die immer größer werdenden Einträge in
          Router-Tabellen.  Dieses Problem ist auch heute noch
          aktuell.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 ist in der Lage, diese, aber auch viele andere Probleme
      zu lösen:</para>

    <itemizedlist>
      <listitem>
        <para>IPv6 hat einen 128&nbsp;Bit großen Adressraum. Es sind
          also theoretisch
          340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
          verfügbar.  In anderen Worten: Für jeden
          Quadratmeter der Erdoberfläche sind etwa
          6,67&nbsp;*&nbsp;10^27 IPv6-Adressen verfügbar.</para>
      </listitem>

      <listitem>
        <para>Router speichern nur noch Netzwerk-Aggregationsadressen in
          Ihren Routingtabellen.  Dadurch reduziert sich die
          durchschnittliche Größe  einer Routingtabelle auf
          8192&nbsp;Einträge.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere nützliche Eigenschaften von IPv6 sind:</para>

    <itemizedlist>
      <listitem>
        <para>Die automatische Konfiguration von Adressen, die im
          <link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</link>
          beschrieben wird.</para>
      </listitem>

      <listitem>
        <para>Anycast-Adressen (<quote>eine-von-vielen</quote>)</para>
      </listitem>

      <listitem>
        <para>Verpflichtende Multicast-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Unterstützung von IPsec (IP-Security)</para>
      </listitem>

      <listitem>
        <para>Eine vereinfachte Headerstruktur</para>
      </listitem>

      <listitem>
        <para>Mobile <acronym>IP</acronym>-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Umwandlung von IPv4- in IPv6-Adressen</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationsquellen:</para>

    <itemizedlist>
      <listitem>
        <para>Beschreibung von IPv6 auf
          <link xlink:href="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</link>
        </para>
      </listitem>

      <listitem>
        <para><link xlink:href="http://www.kame.net">KAME.net</link></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Hintergrundinformationen zu IPv6-Adressen</title>

      <para>Es gibt verschiedene Arten von IPv6-Adressen: Unicast-,
        Anycast- und Multicast-Adressen.</para>

      <para>Unicast-Adressen sind die herkömmlichen Adressen.  Ein
        Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an
        der Schnittstelle an, die dieser Adresse zugeordnet ist.</para>

      <para>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht
        von Unicast-Adressen, sie wählen allerdings aus
	mehreren Schnittstellen eine Schnittstelle aus.
	Ein für eine Anycast-Adresse
	bestimmtes Paket kommt an der nächstgelegenen
	(entsprechend der Router-Metrik) Schnittstelle
        an.  Anycast-Adressen werden nur von Routern verwendet.</para>

      <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
        Schnittstellen angehören.  Ein
        Paket, das an eine Multicast-Adresse geschickt wird, kommt an
        allen Schnittstellen an, die zur Multicast-Gruppe gehören.</para>

        <note><para>Die von IPv4 bekannte Broadcast-Adresse
          (normalerweise
          <systemitem class="ipaddress">xxx.xxx.xxx.255</systemitem>) wird bei IPv6
          durch Multicast-Adressen verwirklicht.</para></note>

      <table frame="none">
        <title>Reservierte IPv6-Adressen</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>IPv6-Adresse</entry>
              <entry>Präfixlänge</entry>
              <entry>Beschreibung</entry>
              <entry>Anmerkungen</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><systemitem>::</systemitem></entry>
              <entry>128 Bit</entry>
              <entry>nicht festgelegt</entry>
              <entry>entspricht <systemitem class="ipaddress">0.0.0.0</systemitem>
                bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>::1</systemitem></entry>
              <entry>128 Bit</entry>
              <entry>Loopback-Adresse</entry>
              <entry>entspricht <systemitem class="ipaddress">127.0.0.1</systemitem>
                bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>
              <entry>96 Bit</entry>
              <entry>Eingebettete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Wird auch als <quote>IPv4-kompatible IPv6-Adresse
                bezeichnet</quote>.</entry>
	    </row>

            <row>
              <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>
              <entry>96 Bit</entry>
	      <entry>Eine auf IPv6 abgebildete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Notwendig für Rechner, die IPv6 nicht
                unterstützen.</entry>
            </row>

            <row>
              <entry><systemitem>fe80::</systemitem> - <systemitem>feb::</systemitem></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>link-local</foreignphrase></entry>
              <entry>Entspricht der Loopback-Adresse bei IPv4</entry>
            </row>

            <row>
              <entry><systemitem>fec0::</systemitem> - <systemitem>fef::</systemitem></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>site-local</foreignphrase></entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><systemitem>ff::</systemitem></entry>
              <entry>8 Bit</entry>
              <entry>Multicast</entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><systemitem>001</systemitem>
		(im Dualsystem)</entry>
              <entry>3 Bit</entry>
              <entry>Globaler Unicast</entry>
              <entry>Alle globalen Unicastadressen stammen aus diesem
                Pool.  Die ersten 3&nbsp;Bit lauten <quote>001</quote>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-Adressen verstehen</title>

      <para>Die kanonische Form von IPv6-Adressen lautet
        <systemitem>x:x:x:x:x:x:x:x</systemitem>, jedes
        <quote>x</quote> steht dabei für einen
        16-Bit-Hexadezimalwert.  Ein Beispiel für eine IPv6-Adresse
        wäre etwa
        <systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem>.</para>

      <para>Eine IPv6-Adresse enthält oft Teilzeichenfolgen aus lauter
        Nullen.  Eine solche Zeichenfolge kann zu <quote>::</quote>
        verkürzt werden.  Bis zu drei führende Nullen eines
        Hexquads können ebenfalls weggelassen werden.
        <systemitem>fe80::1</systemitem> entspricht also der Adresse
        <systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.
      </para>

      <para>Eine weitere Möglichkeit ist die Darstellung der
        letzten 32&nbsp;Bit in  der bekannten (dezimalen) IPv4-Darstellung,
        bei der Punkte (<quote>.</quote>) zur Trennung verwendet werden.
        <systemitem>2002::10.0.0.1</systemitem> ist also nur eine
        andere Schreibweise für die (hexadezimale) kanonische Form
        <systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>,
        die wiederum der Adresse
        <systemitem>2002::a00:1</systemitem> entspricht.</para>

      <para>Sie sollten nun in der Lage sein, die folgende Ausgabe zu
        verstehen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei
        <systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem>
        handelt es sich um eine automatisch konfigurierte
        <foreignphrase>link-local</foreignphrase>-Adresse.  Sie
        wird im Rahmen der automatischen Konfiguration aus der
        MAC-Adresse erzeugt.</para>

      <para>Weitere Informationen zum Aufbau von IPv6-Adressen finden
        Sie im <link xlink:href="http://www.ietf.org/rfc/rfc3513.txt">
        RFC3513</link>.</para>
    </sect2>

    <sect2>
      <title>Eine IPv6-Verbindung herstellen</title>

      <para>Es gibt derzeit vier Möglichkeiten, sich mit anderen
        IPv6-Rechnern oder Netzwerken zu verbinden:</para>

      <itemizedlist>
        <listitem>
          <para>Fragen Sie Ihren Internetprovider, ob er IPv6
            bereits unterstützt.</para>
        </listitem>

        <listitem>
          <para><link xlink:href="http://www.sixxs.net">SixXS</link>
            bietet weltweit IPv6-Tunnelverbindungen an.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung eines 6-nach-4-Tunnels
            (<link xlink:href="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</link>).</para>
        </listitem>

        <listitem>
          <para>Die Verwendung des Ports
            <filename>/usr/ports/net/freenet6</filename> bei der Einwahl
            ins Internet.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>DNS in der IPv6-Welt</title>

      <para>Ursprünglich gab es zwei verschiedene DNS-Einträge
        für IPv6.  Da A6-Einträge von der IETF für
        obsolet erklärt wurden, sind AAAA-Einträge nun
        Standard.</para>

      <para>Weisen Sie die erhaltene IPv6-Adresse Ihrem Rechnernamen zu,
        indem Sie den Eintrag</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>in Ihre primäre DNS-Zonendatei einfügen.  Falls
        Sie nicht für Ihre <acronym>DNS</acronym>-Zone
        verantwortlich sind, bitten Sie den dafür
        Zuständigen, diese Änderung durchzuführen.
        Die aktuellen Versionen von <application>bind</application>
        (Version&nbsp;8.3 oder 9) sowie
        <package>dns/djbdns</package> (bei Verwendung
        des IPv6-Patches) unterstützen AAAA-Einträge.</para>
    </sect2>

    <sect2>
      <title><filename>/etc/rc.conf</filename> für die Nutzung von
        IPv6 anpassen</title>

      <sect3>
        <title>Einen Client unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt die Konfiguration eines
          Rechners, der in Ihrem LAN als Client, aber nicht als Router
          verwendet wird.  Um die Schnittstelle während des
          Systemstarts mit &man.rtsol.8; automatisch einzurichten,
	  fügen Sie folgende Zeile für
	  &os;&nbsp;9.<replaceable>x</replaceable> (und neuer) in
          <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_prefer="YES"</programlisting>

	<para>Für &os;&nbsp;8.<replaceable>x</replaceable> (und älter)
	  fügen Sie stattdessen folgende Zeile hinzu:</para>

	<programlisting>ipv6_enable="YES"</programlisting>

	<para>Unter &os;&nbsp;9.<replaceable>x</replaceable> weisen
	  Sie druch die folgende Zeile Ihrer Schnittstelle
	  <filename>fxp0</filename> die statische IP-Adresse
	  <systemitem>2001:471:1f11:251:290:27ff:fee0:2093</systemitem>
          zu:</para>

        <programlisting>ifconfig_fxp0_ipv6="inet6
2001:471:1f11:251:290:27ff:fee0:2093 prefixlen
<replaceable>64</replaceable>"</programlisting>

	<note>
	  <para>Achten Sie darauf, <replaceable>prefixlen
	  64</replaceable> auf den entsprechenden Wert für das Subnetz
	  zu ändern, mit dem der Computer vernetzt ist.</para>
	</note>

	<para>Für &os;&nbsp;8.<replaceable>x</replaceable> fügen
	  Sie dagegen folgende Zeile hinzu:</para>

	<programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

        <para>Um <systemitem>2001:471:1f11:251::1</systemitem>
          als Standardrouter festzulegen, fügen Sie folgende Zeile
          in <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
        <title>Gateways und Router unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt, wie Sie Ihren Rechner mit
          Hilfe der von Ihrem Tunnel-Anbieter erhaltenen
          Anweisungen dauerhaft für die Nutzung von IPv6
          einrichten.  Um den Tunnel beim Systemstart
          wiederherzustellen, passen Sie
          <filename>/etc/rc.conf</filename> wie folgt an:</para>

        <para>Listen Sie die einzurichtenden Tunnelschnittstellen
          (hier <filename>gif0</filename>) auf:</para>

        <programlisting>gif_interfaces="gif0"</programlisting>

        <para>Um den lokalen Endpunkt
          <replaceable>MY_IPv4_ADDR</replaceable> über diese
          Schnittstelle mit dem entfernten Endpunkt
          <replaceable>REMOTE_IPv4_ADDR</replaceable> zu
          verbinden, verwenden Sie folgende Zeile:</para>

        <programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

        <para>Um die Ihnen zugewiesene IPv6-Adresse als Endpunkt Ihres
	  IPv6-Tunnels zu verwenden, fügen Sie folgende Zeile für
	  &os;&nbsp;9.<replaceable>x</replaceable> (und neuer)
	  ein:</para>

        <programlisting>ifconfig_gif0_ipv6="inet6
<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"
</programlisting>

	<para>Für &os;&nbsp;8.<replaceable>x</replaceable> (und älter)
	  fügen Sie folgende Zeile ein:</para>

	<programlisting>ipv6_ifconfig_gif0="
<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"
</programlisting>

        <para>Nun müssen Sie nur noch die IPv6-Standardroute
          angeben.  Diese legt das andere Ende des IPv6-Tunnels
          fest.</para>

        <programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
        <title>Einen IPv6-Tunnel einrichten</title>

        <para>Wenn Ihr Server IPv6-Verkehr zwischen Ihrem Netzwerk und
          der Außenwelt routen muss, benötigen Sie
          zusätzlich die folgenden Zeilen in Ihrer
          <filename>/etc/rc.conf</filename>:</para>

        <programlisting>ipv6_gateway_enable="YES"</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Bekanntmachung von Routen und automatische
        Rechnerkonfiguration</title>

      <para>Dieser Abschnitt beschreibt die Einrichtung von
        &man.rtadvd.8;, das Sie bei der Bekanntmachung der
        IPv6-Standardroute unterstützt.</para>

      <para>Um &man.rtadvd.8; zu aktivieren, fügen Sie folgende
        Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Es ist wichtig, die Schnittstelle anzugeben, über die
        IPv6-Routen bekanntgemacht werden sollen.  Soll &man.rtadvd.8;
        <filename>fxp0</filename> verwenden, ist folgender Eintrag
        nötig:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Danach erzeugen Sie die Konfigurationsdatei
        <filename>/etc/rtadvd.conf</filename>.  Dazu ein Beispiel:</para>

      <programlisting>fxp0:\
    :addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Ersetzen Sie dabei <filename>fxp0</filename> durch die
        zu verwendende Schnittstelle.</para>

      <para>Anschließend ersetzen Sie
        <systemitem>2001:471:1f11:246::</systemitem> durch das
        Präfix der Ihnen zugewiesenen Verbindung.</para>

      <para>Wenn Sie eine <systemitem class="netmask">/64</systemitem>-Netzmaske
        verwenden, müssen Sie keine weiteren Anpassungen vornehmen.
        Anderenfalls müssen Sie <literal>prefixlen#</literal>
        auf den korrekten Wert setzen.</para>
    </sect2>
  </sect1>
<!--
  <sect1 xml:id="network-atm">
    <info><title>ATM - Asynchronous Transfer Mode</title>
      <authorgroup>
        <author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>



    <sect2>
      <title><foreignphrase>Classical IP over ATM</foreignphrase>
        als PVC-Verbindung einrichten</title>

      <para><foreignphrase>Classical IP over ATM</foreignphrase>
        (<acronym>CLIP</acronym>) ist die einfachste Möglichkeit,
        um IP-Verkehr über ATM (<foreignphrase>Asynchronous
        Transfer Mode</foreignphrase>-Verbindungen zu übertragen.
        CLIP kann sowohl mit geschalteten Verbindungen (SVCs) als auch
        mit permanenten Verbindungen (PVCs) verwendet werden.  Dieser
        Abschnitt beschreibt die Einrichtung eines PVC-basierten
        Netzwerks.</para>

      <sect3>
        <title>Ein vollständig vermaschtes Netzwerk aufbauen</title>

        <para>Bei einem vollständig vermaschten
          (<foreignphrase>fully meshed</foreignphrase>) Netzwerk ist
          jeder Rechner über eine dezidierte Verbindung mit jedem
          anderen Rechner des Netzwerks verbunden.  Die Konfiguration
          ist - vor allem für kleinere Netzwerke - relativ einfach.
          Unser Beispielnetzwerk besteht aus vier Rechnern, die jeweils
          über eine
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Adapterkarte
          mit dem
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Netzwerk
          verbunden sind.  Als ersten Konfigurationsschritt planen wir
          die Vergabe von IP-Adressen sowie die anzulegenden
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Verbindungen:
        </para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechner</entry>
		<entry>IP-Adresse</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostD</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Um ein vollständiges Netz aufzubauen, benötigen
          wir für jedes Rechnerpaar eine eigene ATM-Verbindung:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechnerpaar</entry>
		<entry>VPI.VCI-Paar</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostB</systemitem></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Die Werte VPI und VCI an den Verbindungsenden können
          natürlich unterschiedlich sein.  Wir nehmen hier aber an,
          dass sie gleich sind.  Nun müssen wir die
          ATM-Schnittstellen auf jedem Rechner einrichten:</para>

        <screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

        <para>Dabei setzen wir voraus, dass
          <filename>hatm0</filename> auf allen Rechnern die
          ATM-Schnittstelle darstellt.  Danach werden, beginnend mit
          <systemitem>hostA</systemitem>, die PVCs auf den einzelnen Rechnern
          eingerichtet (Wir nehmen an, dass die PVCs auf den
          ATM-Switches bereits eingerichet sind.  Lesen Sie die
          entsprechenden Handbücher, wenn Sie einen Switch
          einrichten müssen.):</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

        <para>Statt UBR können auch andere
          <foreignphrase>traffic contracts</foreignphrase> verwendet
          werden.  Voraussetzung ist allerdings, dass diese von Ihrem
          ATM-Adapter unterstützt werden.  Ist dies der Fall,
          folgen auf den Namen des
          <foreignphrase>traffic contracts</foreignphrase> die
          entsprechenden Konfigurationsparameter.  Weitere Informationen
          zur Konfiguration von ATM-Adapterkarten erhalten Sie über
          den Befehl</para>

        <screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

        <para>oder durch das Lesen von &man.atmconfig.8;.</para>

        <para>Die Konfiguration von ATM-Adaptern kann auch über die
          Datei <filename>/etc/rc.conf</filename> erfolgen.  Für
          <systemitem>hostA</systemitem> sähe die Konfiguration so
          aus:</para>

        <programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>Mit dem folgenden Befehl lässt sich der derzeitige
          Status aller <acronym>CLIP</acronym>-Routen anzeigen:</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
-->
  <sect1 xml:id="carp">
    <info><title>CARP - Common Address Redundancy Protocol</title>

      <authorgroup>
        <author>
          <personname>
            <firstname>Tom</firstname>
            <surname>Rhodes</surname>
          </personname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <personname>
            <firstname>Allan</firstname>
            <surname>Jude</surname>
          </personname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>CARP</primary>
    </indexterm>
    <indexterm>
      <primary>Common Address Redundancy Protocol (CARP)</primary>
    </indexterm>

    <para>Das <foreignphrase>Common Address Redundancy
	Protocol</foreignphrase> (<acronym>CARP</acronym>) erlaubt es,
      mehreren Rechnern die gleiche <acronym>IP</acronym>-Adresse
      zuzuweisen und <emphasis>Hochverfügbarkeit</emphasis>
      bereitzustellen.  Das bedeutet, dass ein oder mehrere Rechner
      ausfallen können und die anderen Rechner transparent
      einspringen, ohne das der Benutzer etwas von einem Ausfall
      mitbekommt.  Neben der gemeinsamen
      <acronym>IP</acronym>-Adresse, haben die jeweiligen Rechner auch
      eine eindeutige <acronym>IP</acronym>-Adresse zur Verwaltung und
      Konfiguration, wie in den folgenden Beispielen zu sehen
      ist.</para>

    <sect2 xml:id="carp-ha">
      <title>Hochverfügbarkeit mit <acronym>CARP</acronym></title>

      <para><acronym>CARP</acronym> wird häufig verwendet, um einen
	oder mehrere Dienste hochverfügbar zu machen.  Dieses Beispiel
	konfiguriert eine Failover-Unterstützung mit drei Servern (mit
	jeweils eigener, eindeutiger <acronym>IP</acronym>-Adresse),
	die alle den gleichen Web-Inhalt anbieten.  Die Lastverteilung
	dieser Maschinen wird dabei über <foreignphrase>Round
	  Robin</foreignphrase> <acronym>DNS</acronym> konfiguriert.
	Mit Ausnahme des Hostnamens und der
	<acronym>IP</acronym>-Management-Adresse sind Master- und
	Backup-Maschinen identisch konfiguriert.  Die Server müssen
	die gleiche Konfiguration und die gleichen Dienste aktiviert
	haben.  Tritt ein Failover auf, können Anfragen an den Dienst
	mit der gemeinsam genutzten <acronym>IP</acronym>-Adresse nur
	dann richtig beantwortet werden, wenn der Backup-Server
	Zugriff auf denselben Inhalt hat.  Die Backup-Maschine verfügt
	über zwei zusätzliche <acronym>CARP</acronym>-Schnittstellen,
	eine für jede <acronym>IP</acronym>-Adresse des
	Master-Content-Servers.  Sobald ein Fehler auftritt, übernimmt
	der Backup-Server die <acronym>IP</acronym>-Adresse des
	ausgefallenen Master-Servers.  Die Benutzer werden einen
	Dienstausfall überhaupt nicht bemerken.</para>

      <para>Dieses Beispiel benutzt zwei verschiedene Master namens
	<systemitem>hosta.example.org</systemitem> und
	<systemitem>hostb.example.org</systemitem> mit einem
	gemeinsamen Backup namens
	<systemitem>hostc.example.org</systemitem>.</para>

      <para>Jede virtuelle <acronym>IP</acronym>-Adresse hat eine
	eindeutige Identifikationsnummer, die als
	<foreignphrase>Virtual Host Identification</foreignphrase>
	(<acronym>VHID</acronym>) bekannt ist.  Alle Maschinen, die
	sich eine <acronym>IP</acronym>-Adresse teilen, verwenden die
	gleiche <acronym>VHID</acronym>.  Die <acronym>VHID</acronym>
	für jede einzelne <acronym>IP</acronym>-Adresse muss,
	entsprechend der Broadcast-Domäne der Netzwerkschnittstelle,
	eindeutig sein.</para>
    </sect2>

    <sect2 xml:id="carp-10x">
      <title><acronym>CARP</acronym> mit &os;&nbsp;10 (und neuer)
        benutzen</title>

      <para>Unterstützung für <acronym>CARP</acronym> erhalten Sie
	durch das Laden des Kernelmoduls <filename>carp.ko</filename>
	in <filename>/boot/loader.conf</filename>:</para>

      <programlisting>carp_load="YES"</programlisting>

      <para>Das <acronym>CARP</acronym>-Modul kann auch, wie in <xref
	  linkend="kernelconfig"/> beschrieben, direkt in den &os;
	Kernel eingebunden werden:</para>

      <programlisting>device  carp</programlisting>

      <para>Hostname, <acronym>IP</acronym>-Management-Adresse,
	Subnetzmaske, gemeinsame <acronym>IP</acronym>-Adresse und
	<acronym>VHID</acronym> werden durch das Hinzufügen in
	<filename>/etc/rc.conf</filename> gesetzt.  Dieses Beispiel
	ist für <systemitem>hosta.example.org</systemitem>:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_em0="inet <systemitem
class="ipaddress">192.168.1.3</systemitem> netmask 255.255.255.0"
ifconfig_em0_alias0="vhid 1 pass testpass alias <systemitem
class="ipaddress">192.168.1.50</systemitem>/32"</programlisting>

      <para>Beispiel für
        <systemitem>hostb.example.org</systemitem>:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_em0="inet <systemitem
class="ipaddress">192.168.1.4</systemitem> netmask 255.255.255.0"
ifconfig_em0_alias0="vhid 2 pass testpass alias <systemitem
class="ipaddress">192.168.1.51</systemitem>/32"</programlisting>

      <note>
	<para>Achten Sie unbedingt darauf, dass die durch die Option
	  <option>pass</option> an &man.ifconfig.8; übergebenen
	  Passwörter auf beiden Systemen identisch sind, da
	  <filename>carp</filename>-Geräte nur mit Systemen
	  kommunizieren können, die über ein korrektes Passwort
	  verfügen.</para>
      </note>

      <para>Die dritte Maschine,
	<systemitem>hostc.example.org</systemitem> ist so
	konfiguriert, das sie aktiviert wird, wenn eines der beiden
	zuvor konfigurierten Systeme ausfällt.  Diese Maschine ist mit
	zwei <acronym>CARP</acronym> <acronym>VHID</acronym>s
	konfiguriert, eine für jede virtuelle
	<acronym>IP</acronym>-Adresse der beiden Master-Server.  Die
	Option <option>advskew</option> (<acronym>CARP</acronym>
	advertising skew) wird gesetzt, um sicherzustellen, dass sich
	der Backup-Server später ankündigt wie der Master-Server.
	<option>advskew</option> steuert die Rangfolge für den Fall
	das mehrere Backup-Server zur Verfügung stehen.  Passen Sie
	die Konfiguration in <filename>/etc/rc.conf</filename>
	an:</para>

      <programlisting>hostname="hostc.example.org"
ifconfig_em0="inet <systemitem
class="ipaddress">192.168.1.5</systemitem> netmask 255.255.255.0"
ifconfig_em0_alias0="vhid 1 advskew 100 pass testpass alias <systemitem
class="ipaddress">192.168.1.50</systemitem>/32"
ifconfig_em1_alias0="vhid 2 advskew 100 pass testpass alias <systemitem
class="ipaddress">192.168.1.51</systemitem>/32"</programlisting>

      <para>Durch die zwei konfigurierten <acronym>CARP</acronym>
	<acronym>VHID</acronym>s ist
	<systemitem>hostc.example.org</systemitem> in der Lage
	festzustellen, wenn einer der Master-Server nicht mehr
	reagiert.  Wenn der Master-Server sich später ankündigt als
	der Backup-Server, übernimmt der Backup-Server die gemeinsame
	<acronym>IP</acronym>-Adresse, bis der Master-Server erneut
	verfügbar ist.</para>

      <para><foreignphrase>Preemption</foreignphrase> ist
	standardmäßig deaktiviert.  Wird
	<foreignphrase>Preemption</foreignphrase> aktiviert, kann es
	vorkommen, dass <systemitem>hostc.example.org</systemitem> die
	virtuelle <acronym>IP</acronym>-Adresse nicht wieder an den
	Master-Server zurückgibt.  Der Administrator kann jedoch den
	Backup-Server dazu zwingen, die übernommene
	<acronym>IP</acronym>-Adresse wieder an den Master-Server
	zurückzugeben:</para>

      <screen>&prompt.root; <userinput>ifconfig em0 vhid 1 state
backup</userinput></screen>

      <para>An dieser Stelle muss entweder das Netzwerk neu gestartet,
	oder die Maschine neu gebootet werden, um
	<acronym>CARP</acronym> zu aktivieren.</para>

      <para>Die Funktionalität von <acronym>CARP</acronym> kann, wie
	in der Manualpage &man.carp.4; beschrieben, über verschiedene
	&man.sysctl.8; Parameter kontrolliert werden.  Mit dem Einsatz
	von &man.devd.8; können weitere Aktionen zu
	<acronym>CARP</acronym>-Ereignissen ausgelöst werden.</para>
    </sect2>

    <sect2 xml:id="carp-9x">
      <title><acronym>CARP</acronym> mit &os;&nbsp;9 (und älter)
        benutzen</title>

      <para>Unterstützung für <acronym>CARP</acronym> erhalten Sie
	durch das Laden des Kernelmoduls <filename>carp.ko</filename>
	in <filename>/boot/loader.conf</filename>:</para>

      <programlisting>if_carp_load="YES"</programlisting>

      <para><acronym>CARP</acronym> kann auch direkt in den Kernel
	eingebunden werden.  Diese Prozedur wird in <xref
	  linkend="kernelconfig"/> beschrieben:</para>

      <programlisting>device    carp</programlisting>

      <para>Die <acronym>CARP</acronym>-Schnittstellen selbst können
	mittels &man.ifconfig.8; erstellt werden:</para>

      <screen>&prompt.root; <userinput>ifconfig carp0
create</userinput></screen>

      <para>Konfigurieren Sie Hostnamen,
	<acronym>IP</acronym>-Management-Adresse, die gemeinsam
	genutzte <acronym>IP</acronym>-Adresse und die
	<acronym>VHID</acronym>, indem Sie die erforderlichen Zeilen
	in <filename>/etc/rc.conf</filename> hinzufügen.  Hierzu ein
	Beispiel für
	<systemitem>hosta.example.org</systemitem>:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_fxp0="inet <systemitem
class="ipaddress">192.168.1.3</systemitem> netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass <systemitem
class="ipaddress">192.168.1.50</systemitem>/24"</programlisting>

      <para>Beispiel für
	<systemitem>hostb.example.org</systemitem>:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_fxp0="inet <systemitem
class="ipaddress">192.168.1.4</systemitem> netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass <systemitem
class="ipaddress">192.168.1.51</systemitem>/24"</programlisting>

      <note>
	<para><foreignphrase>Preemption</foreignphrase> ist im GENERIC
	  &os; Kernel deaktiviert.  Haben Sie jedoch
	  <foreignphrase>Preemption</foreignphrase> in einem
	  angepassten Kernel aktiviert, dass
	  <systemitem>hostc.example.org</systemitem> die virtuelle
	  <acronym>IP</acronym>-Adresse nicht wieder an den
	  Master-Server zurückgibt.  Der Administrator kann jedoch den
	  Backup-Server dazu zwingen, die übernommene
	  <acronym>IP</acronym>-Adresse wieder an den Master-Server
	  zurückzugeben:</para>

        <screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>Dieser Befehl muss auf dem
	  <filename>carp</filename>-Gerät ausgeführt werden, dass dem
	  betroffenen System zugeordnet ist.</para>
      </note>

      <para>An dieser Stelle muss entweder das Netzwerk neu gestartet,
	oder die Maschine neu gebootet werden, um
	<acronym>CARP</acronym> zu aktivieren.</para>

      <para>Die Funktionalität von <acronym>CARP</acronym> kann, wie
	in der Manualpage &man.carp.4; beschrieben, über verschiedene
	&man.sysctl.8; Parameter kontrolliert werden.  Mit dem Einsatz
	von &man.devd.8; können weitere Aktionen zu
	<acronym>CARP</acronym>-Ereignissen ausgelöst werden.</para>
    </sect2>
  </sect1>
</chapter>
