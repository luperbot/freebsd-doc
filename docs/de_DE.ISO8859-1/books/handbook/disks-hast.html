<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>19.18. Highly Available Storage (HAST)</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Das FreeBSD-Handbuch" /><link rel="up" href="disks.html" title="Kapitel 19. Speichermedien" /><link rel="prev" href="swap-encrypting.html" title="19.17. Den Auslagerungsspeicher verschlüsseln" /><link rel="next" href="GEOM.html" title="Kapitel 20. GEOM: Modulares Framework zur Plattentransformation" /><link rel="copyright" href="legalnotice.html" title="Rechtlicher Hinweis" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">19.18. Highly Available Storage (HAST)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="swap-encrypting.html">Zurück</a> </td><th width="60%" align="center">Kapitel 19. Speichermedien</th><td width="20%" align="right"> <a accesskey="n" href="GEOM.html">Weiter</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="disks-hast"></a>19.18. Highly Available Storage (HAST)</h2></div><div><span class="authorgroup">Beigetragen von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Daniel</span> <span class="surname">Gerzo</span></span>. </span></div><div><span class="authorgroup">Mit Beiträgen von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Freddie</span> <span class="surname">Cash</span></span>, <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Pawel Jakub</span> <span class="surname">Dawidek</span></span>, <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Michael W.</span> <span class="surname">Lucas</span></span> und <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Viktor</span> <span class="surname">Petersson</span></span>. </span></div><div><span class="authorgroup">Übersetzt von <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Benedict</span> <span class="surname">Reuschling</span></span>. </span></div></div></div><a id="idp82163664" class="indexterm"></a><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82164816"></a>19.18.1. Überblick</h3></div></div></div><p>Hochverfügbarkeit ist eine der Hauptanforderungen von
        ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher
        ist eine Schlüsselkomponente in solchen Umgebungen.  Highly
        Available STorage, oder <acronym class="acronym">HAST<em><span class="remark">Highly Available STorage</span></em></acronym>, wurde von
        Pawel Jakub Dawidek als ein Framework entwickelt, welches die transparente
        Speicherung der gleichen Daten über mehrere physikalisch getrennte
        Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden
        sind.  <acronym class="acronym">HAST</acronym> kann als ein netzbasiertes RAID1
        (Spiegel) verstanden werden und ist dem DRBD®-Speichersystem der
        GNU/<span class="trademark">Linux</span>®-Plattform ähnlich.  In Kombination mit anderen
        Hochverfügbarkeitseigenschaften von FreeBSD
        wie <acronym class="acronym">CARP</acronym>, ermöglicht es
        <acronym class="acronym">HAST</acronym>, hochverfügbare Speichercluster zu bauen,
        die in der Lage sind, Hardwareausfällen zu widerstehen.</p><p>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes
        wissen:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Was <acronym class="acronym">HAST</acronym> ist, wie es funktioniert und
	    welche Eigenschaften es besitzt.</p></li><li class="listitem"><p>Wie man <acronym class="acronym">HAST</acronym> auf FreeBSD aufsetzt und
	    verwendet.</p></li><li class="listitem"><p>Wie man <acronym class="acronym">CARP</acronym> und <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a> kombiniert, um
	    ein robustes Speichersystem zu bauen.</p></li></ul></div><p>Bevor Sie diesen Abschnitt lesen, sollten Sie:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>die Grundlagen von <span class="trademark">UNIX</span>® und FreeBSD verstanden haben
	    (<a class="xref" href="basics.html" title="Kapitel 4. Grundlagen des UNIX Betriebssystems">Kapitel 4, <em>Grundlagen des UNIX Betriebssystems</em></a>).</p></li><li class="listitem"><p>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme
	    von FreeBSD konfiguriert (<a class="xref" href="config-tuning.html" title="Kapitel 12. Konfiguration und Tuning">Kapitel 12, <em>Konfiguration und Tuning</em></a>).</p></li><li class="listitem"><p>ein gutes Verständnis der FreeBSD-Netzwerkfunktionalität
	    besitzen (<a class="xref" href="network-communication.html" title="Teil IV. Netzwerke">Teil IV, &#8222;Netzwerke&#8220;</a>).</p></li><li class="listitem"><p>FreeBSD 8.1-RELEASE oder höher einsetzen.</p></li></ul></div><p>Das <acronym class="acronym">HAST</acronym>-Projekt wurde von der FreeBSD Foundation
        mit Unterstützung der <a class="link" href="http://www.omc.net/" target="_top">OMCnet Internet Service GmbH</a> und
        <a class="link" href="http://www.transip.nl/" target="_top">TransIP BV</a>
        gesponsert.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82189136"></a>19.18.2. HAST-Merkmale</h3></div></div></div><p>Die Hauptmerkmale des <acronym class="acronym">HAST</acronym>-Systems sind:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten
	    eingesetzt werden.</p></li><li class="listitem"><p>Dateisystem-unabhängig, was es erlaubt, jedes von FreeBSD
	    unterstützte Dateisystem zu verwenden.</p></li><li class="listitem"><p>Effiziente und schnelle Resynchronisation: es werden nur die
	    Blöcke synchronisiert, die während der Ausfallzeit eines
	    Knotens geändert wurden.</p></li><li class="listitem"><p>Es kann in einer bereits bestehenden Umgebung eingesetzt
	    werden, um zusätzliche Redundanz zu erreichen.</p></li><li class="listitem"><p>Zusammen mit <acronym class="acronym">CARP</acronym>,
	    <span class="application">Heartbeat</span>, oder anderen Werkzeugen, ist
	    es möglich, ein robustes und dauerhaftes Speichersystem zu
	    bauen.</p></li></ul></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82200144"></a>19.18.3. HAST im Einsatz</h3></div></div></div><p><acronym class="acronym">HAST</acronym> stellt auf Block-Ebene eine synchrone
        Replikation eines beliebigen Speichermediums auf mehreren Maschinen zur
        Verfügung.  Daher werden mindestens zwei Knoten (physikalische
        Maschinen) benötigt: der <code class="literal">primary</code>
        (auch bekannt als <code class="literal">master</code>) Knoten, sowie der
        <code class="literal">secondary</code> (<code class="literal">slave</code>) Knoten.  Diese
        beiden Maschinen zusammen werden als Cluster bezeichnet.</p><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">HAST ist momentan auf insgesamt zwei Knoten im Cluster
	  beschränkt.</p></div><p>Da <acronym class="acronym">HAST</acronym> in einer
        primär-sekundär-Konfiguration funktioniert, ist immer nur ein
        Knoten des Clusters zu jeder Zeit aktiv.  Der
        <code class="literal">primäre</code> Knoten, auch
        <code class="literal">active</code> genannt, ist derjenige, der alle I/O-Anfragen
	verarbeitet, die an die <acronym class="acronym">HAST</acronym>-Schnittstelle gesendet
	werden.  Der <code class="literal">secondary</code>-Knoten wird automatisch vom
	<code class="literal">primary</code>-Knoten aus synchronisiert.</p><p>Die physischen Komponenten des <acronym class="acronym">HAST</acronym>-Systems
        sind:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>lokale Platte (am Primärknoten)</p></li><li class="listitem"><p>Platte am entfernten Rechner (Sekundärknoten)</p></li></ul></div><p><acronym class="acronym">HAST</acronym> arbeitet synchron auf Blockebene, was es
        für Dateisysteme und Anwendungen transparent macht.
        <acronym class="acronym">HAST</acronym> stellt gewöhnliche GEOM-Provider im
        Verzeichnis <code class="filename">/dev/hast/</code> für
        die Verwendung durch andere Werkzeuge oder Anwendungen zur
        Verfügung, somit gibt es keinen Unterschied zwischen dem Einsatz
        von durch <acronym class="acronym">HAST</acronym> bereitgestellten Geräten und
        herkömmlichen Platten, Partitionen, etc.</p><p>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die
        lokale und über TCP/IP zu der entfernt liegenden
        Platte gesendet.  Jede Leseoperation wird von der lokalen Platte
        durchgeführt, es sei denn, die lokale Platte ist nicht aktuell
        oder es tritt ein I/O-Fehler auf.  In solchen Fällen wird die
        Leseoperation an den Sekundärknoten geschickt.</p><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82215632"></a>19.18.3.1. Synchronisation und Replikationsmodi</h4></div></div></div><p><acronym class="acronym">HAST</acronym> versucht, eine schnelle Fehlerbereinigung
	  zu gewährleisten.  Aus diesem Grund ist es sehr wichtig, die
	  Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren.
	  Um eine schnelle Synchronisation zu ermöglichen, verwaltet
	  <acronym class="acronym">HAST</acronym> eine Bitmap von unsauberen Bereichen
	  auf der Platte und synchronisiert nur diese während einer
	  regulären Synchronisation (mit Ausnahme der initialen
	  Synchronisation).</p><p>Es gibt viele Wege, diese Synchronisation zu behandeln.
	  <acronym class="acronym">HAST</acronym> implementiert mehrere Replikationsarten, um
	  unterschiedliche Methoden der Synchronisation zu realisieren:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>memsync</em></span>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und der entfernt liegende Knoten die Ankunft der Daten
	      bestätigt hat, jedoch bevor die Daten wirklich gespeichert
	      wurden.  Die Daten werden auf dem entfernt liegenden Knoten
	      direkt nach dem Senden der Bestätigung gespeichert.  Dieser
	      Modus ist dafür gedacht, Latenzen zu verringern und
	      zusätzlich eine gute Verlässlichkeit zu bieten.  Der
	      <span class="emphasis"><em>memsync</em></span>-Replikationsmodus ist momentan noch
	      nicht implementiert.</p></li><li class="listitem"><p><span class="emphasis"><em>fullsync</em></span>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und die entfernte Schreiboperation ebenfalls abgeschlossen wurde.
	      Dies ist der sicherste und zugleich der langsamste
	      Replikationsmodus.  Er stellt den momentanen Standardmodus
	      dar.</p></li><li class="listitem"><p><span class="emphasis"><em>async</em></span>: meldet Schreiboperationen als
	      vollständig, wenn lokale Schreibvorgänge abgeschlossen
	      wurden.  Dies ist der schnellste und gefährlichste
	      Replikationsmodus.  Er sollte verwendet werden, wenn die Latenz
	      zu einem entfernten Knoten bei einer Replikation zu hoch ist
	      für andere Modi.  Der
	      <span class="emphasis"><em>async</em></span>-Replikationsmodus ist zum
	      gegenwärtigen Zeitpunkt nicht implementiert.</p></li></ul></div><div xmlns="" class="warning"><h3 class="admontitle">Warnung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Momentan wird nur der
	    <span class="emphasis"><em>fullsync</em></span>-Replikationsmodus
	    unterstützt.</p></div></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82223824"></a>19.18.4. HAST-Konfiguration</h3></div></div></div><p><acronym class="acronym">HAST</acronym> benötigt
        <code class="literal">GEOM_GATE</code>-Unterstützung, um korrekt zu
        funktionieren.  Der <code class="literal">GENERIC</code>-Kernel enthält
        jedoch <code class="literal">GEOM_GATE</code> <span class="emphasis"><em>nicht</em></span> von
        vornherein, jedoch ist in der Standardinstallation von FreeBSD
        <code class="filename">geom_gate.ko</code> als ladbares Modul vorhanden.
        Stellen Sie bei Systemen, bei denen nur das Allernötigste
        vorhanden sein soll, sicher, dass dieses Modul zur Verfügung
        steht.  Als Alternative lässt sich die
	<code class="literal">GEOM_GATE</code>-Unterstützung direkt in den Kernel
	statisch einbauen, indem Sie die folgende Zeile zu Ihrer
	Kernelkonfigurationsdatei hinzufügen:</p><pre class="programlisting">options	GEOM_GATE</pre><p>Das <acronym class="acronym">HAST</acronym>-Framework besteht aus Sicht des
        Betriebssystems aus mehreren Bestandteilen:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Dem <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastd</span>(8)</span></a>-Dienst, welcher für die
	    Datensynchronisation verantwortlich ist,</p></li><li class="listitem"><p>Dem <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastctl</span>(8)</span></a> Management-Werkzeug,</p></li><li class="listitem"><p>Der Konfigurationsdatei <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hast.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hast.conf</span>(5)</span></a>.</p></li></ul></div><p>Das folgende Beispiel beschreibt, wie man zwei Knoten als
        <code class="literal">master</code>-<code class="literal">slave</code> /
        <code class="literal">primary</code>-<code class="literal">secondary</code> mittels
        <acronym class="acronym">HAST</acronym> konfiguriert, um Daten zwischen diesen beiden
        auszutauschen.  Die Knoten werden als
        <code class="literal">hasta</code> mit der IP-Adresse
        <em class="replaceable"><code>172.16.0.1</code></em> und
        <code class="literal">hastb</code> mit der IP-Adresse
        <em class="replaceable"><code>172.16.0.2</code></em> bezeichnet.  Beide Knoten
        besitzen eine dedizierte Festplatte
        <code class="filename">/dev/ad6</code> mit der
        gleichen Grösse für den <acronym class="acronym">HAST</acronym>-Betrieb.
	Der <acronym class="acronym">HAST</acronym>-Pool (manchmal auch Ressource
	genannt, z.B. der GEOM-Provider in <code class="filename">/dev/hast/</code>) wird als
	<code class="filename">test</code> bezeichnet.</p><p>Die Konfiguration von <acronym class="acronym">HAST</acronym> wird in der Datei
        <code class="filename">/etc/hast.conf</code> vorgenommen.  Diese Datei sollte
        auf beiden Knoten gleich sein.  Die denkbar einfachste Konfiguration
        ist folgende:</p><pre class="programlisting">resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre><p>Schlagen Sie in der <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hast.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">hast.conf</span>(5)</span></a>-Manualpage nach, wenn Sie an
        erweiterten Konfigurationsmöglichkeiten interessiert sind.</p><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml">Es ist ebenfalls möglich, den Hostnamen in den
	  <code class="literal">remote</code>-Anweisungen zu verwenden.  Stellen Sie in
	  solchen Fällen sicher, dass diese Rechner auch aufgelöst
	  werden können, also in der Datei <code class="filename">/etc/hosts</code>
	  aufgeführt sind, oder alternativ im lokalen
	  <acronym class="acronym">DNS</acronym>.</p></div><p>Da nun die Konfiguration auf beiden Rechnern vorhanden
	ist, kann ein <acronym class="acronym">HAST</acronym>-Pool erstellt werden.
	Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die
	initialen Metadaten auf die lokale Platte zu schreiben und
	starten Sie anschliessend den <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastd</span>(8)</span></a>-Dienst:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hastctl create test</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>service hastd onestart</code></strong></pre><div xmlns="" class="note"><h3 class="admontitle">Anmerkung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Es ist <span class="emphasis"><em>nicht</em></span> möglich, GEOM-Provider mit
	  einem bereits bestehenden Dateisystem zu verwenden (z.B. um einen
	  bestehenden Speicher in einen von <acronym class="acronym">HAST</acronym> verwalteten
	  Pool zu konvertieren), weil diese Prozedur bestimmte Metadaten auf
	  den Provider schreiben muss und dafür nicht genug freier Platz
	  zur Verfügung stehen wird.</p></div><p>Die Rolle eines HAST Knotens (<code class="literal">primary</code>
	oder <code class="literal">secondary</code>) wird vom einem
	Administrator, oder einer Software wie
	<span class="application">Heartbeat</span>, mittels des
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastctl</span>(8)</span></a>-Werkzeugs festgelegt.  Auf dem primären
	Knoten (<code class="literal">hasta</code>) geben Sie diesen Befehl
	ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hastctl role primary test</code></strong></pre><p>Geben Sie folgendes Kommando auf dem sekundären
	Knoten (<code class="literal">hastb</code>) ein:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hastctl role secondary test</code></strong></pre><div xmlns="" class="caution"><h3 class="admontitle">Achtung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Es kann passieren, dass beide Knoten nicht in der Lage
	  sind, miteinander zu kommunizieren und dadurch beide als
	  primäre Knoten konfiguriert sind; die Konsequenz daraus wird
	  als <code class="literal">split-brain</code> bezeichnet.  Um diese
	  Situation zu bereinigen, folgen Sie den Schritten, die
	  in <a class="xref" href="disks-hast.html#disks-hast-sb" title="19.18.5.2. Auflösung des Split-brain-Zustands">Abschnitt 19.18.5.2, &#8222;Auflösung des Split-brain-Zustands&#8220;</a> beschrieben sind.</p></div><p>Überprüfen Sie das Ergebnis mit <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastctl&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastctl</span>(8)</span></a> auf beiden
        Knoten:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hastctl status test</code></strong></pre><p>Der wichtigste Teil ist die
	<code class="literal">status</code>-Textzeile, die auf jedem Knoten
	<code class="literal">complete</code> lauten sollte.  Falls der Status
	als <code class="literal">degraded</code> zurückgemeldet wird, ist etwas
	schief gegangen.  Zu diesem Zeitpunkt hat die Synchronisation
	zwischen den beiden Knoten bereits begonnen.  Die
	Synchronisation ist beendet, wenn
	<code class="command">hastctl status</code> meldet, dass die
	<code class="literal">dirty</code>-Bereiche 0 Bytes betragen.</p><p>Der nächste Schritt ist, ein Dateisystem auf dem
	<code class="filename">/dev/hast/test</code> GEOM-Provider anzulegen
	und dieses ins System einzuhängen.  Dies muss auf dem
	<code class="literal">primary</code>-Knoten durchgeführt werden, da
	<code class="filename">/dev/hast/test</code> nur auf dem
	<code class="literal">primary</code>-Knoten erscheint.  Die Erstellung
	des Dateisystems kann ein paar Minuten dauern, abhängig von
	der Grösse der Festplatte:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>newfs -U /dev/hast/test</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mkdir /hast/test</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>mount /dev/hast/test /hast/test</code></strong></pre><p>Sobald das <acronym class="acronym">HAST</acronym>-Framework richtig
	konfiguriert wurde, besteht der letzte Schritt nun darin,
	sicherzustellen, dass <acronym class="acronym">HAST</acronym> während des
	Systemstarts automatisch gestartet wird.  Fügen Sie diese
	Zeile in <code class="filename">/etc/rc.conf</code> hinzu:</p><pre class="programlisting">hastd_enable="YES"</pre><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82287568"></a>19.18.4.1. Failover-Konfiguration</h4></div></div></div><p>Das Ziel dieses Beispiels ist, ein robustes
	  Speichersystem zu bauen, welches Fehlern auf einem
	  beliebigen Knoten widerstehen kann.  Das Szenario besteht
	  darin, dass der <code class="literal">primary</code>-Knoten des
	  Clusters ausfällt.  Sollte das passieren, ist der
	  <code class="literal">secondary</code>-Knoten da, um nahtlos
	  einzuspringen, das Dateisystem zu prüfen, einzuhängen und
	  mit der Arbeit fortzufahren, ohne dass auch nur ein
	  einzelnes Bit an Daten verloren geht.</p><p>Um diese Aufgabe zu bewerkstelligen, wird eine
	  weitere Eigenschaft von FreeBSD benutzt,
	  welche ein automatisches Failover auf der IP-Schicht
	  ermöglicht: <acronym class="acronym">CARP</acronym>.
	  <acronym class="acronym">CARP</acronym> (Common Address Redundancy Protocol)
	  erlaubt es mehreren Rechnern im gleichen Netzsegment, die
	  gleiche IP-Adresse zu verwenden.  Setzen Sie
	  <acronym class="acronym">CARP</acronym> auf beiden Knoten des Clusters
	  anhand der Dokumentation in <a class="xref" href="carp.html" title="33.11. CARP - Common Address Redundancy Protocol">Abschnitt 33.11, &#8222;CARP - Common Address Redundancy Protocol&#8220;</a> auf.
	  Nach der Konfiguration wird jeder Knoten seine eigene
	  <code class="filename">carp0</code>-Schnittstelle, mit der geteilten
	  IP-Adresse <em class="replaceable"><code>172.16.0.254</code></em> besitzen.
	  Der primäre <acronym class="acronym">HAST</acronym>-Knoten des Clusters muss
	  der <acronym class="acronym">CARP</acronym>-Masterknoten sein.</p><p>Der <acronym class="acronym">HAST</acronym>-Pool, welcher im vorherigen Abschnitt
	  erstellt wurde, ist nun bereit für den Export über das
	  Netzwerk auf den anderen Rechner.  Dies kann durch den Export
	  über <acronym class="acronym">NFS</acronym>, <span class="application">Samba</span>
	  etc. erreicht werden, indem die geteilte IP-Addresse
	  <em class="replaceable"><code>172.16.0.254</code></em> verwendet wird.  Das einzige
	  ungelöste Problem ist der automatische Failover, sollte der
	  primäre Knoten einmal ausfallen.</p><p>Falls die <acronym class="acronym">CARP</acronym>-Schnittstelle
	  aktiviert oder deaktiviert wird, generiert das
	  FreeBSD-Betriebssystem ein <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>-Ereignis, was es
	  ermöglicht, Zustandsänderungen auf den
	  <acronym class="acronym">CARP</acronym>-Schnittstellen zu überwachen.  Eine
	  Zustandsänderung auf der
	  <acronym class="acronym">CARP</acronym>-Schnittstelle ist ein Indiz dafür,
	  dass einer der Knoten gerade ausgefallen oder wieder
	  verfügbar ist.  Diese Zustandsänderungen machen es möglich,
	  ein Skript zu starten, welches automatisch den HAST-Failover
	  durchführt.</p><p>Um  Zustandsänderungen auf der
	  <acronym class="acronym">CARP</acronym>-Schnittstelle abzufangen, müssen
	  diese Zeilen in <code class="filename">/etc/devd.conf</code> auf
	  jedem Knoten hinzugefügt werden:</p><pre class="programlisting">notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</pre><p>Starten Sie <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a> auf beiden Knoten neu, um
	  die neue Konfiguration wirksam werden zu lassen:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>service devd restart</code></strong></pre><p>Für den Fall, dass die
	  <code class="filename">carp0</code>-Schnittstelle aktiviert oder
	  deaktiviert wird (sich also der Status der Schnittstelle
	  ändert), erzeugt das System eine Meldung, was es dem
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>-Subsystem ermöglicht, ein beliebiges Skript zu
	  starten, in diesem Fall also
	  <code class="filename">/usr/local/sbin/carp-hast-switch</code>.  Dies ist das
	  Skript, dass den automatischen Failover durchführt.  Für
	  genauere Informationen zu der obigen <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">devd</span>(8)</span></a>-Konfiguration,
	  lesen Sie die <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=devd.conf&amp;sektion=5"><span class="citerefentry"><span class="refentrytitle">devd.conf</span>(5)</span></a>-Manualpage.</p><p>Ein Beispiel für ein solches Skript könnte so
	  aussehen:</p><pre class="programlisting">#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</pre><p>Im Kern führt das Skript die folgenden Aktionen durch,
	  sobald ein Knoten zum <code class="literal">master</code> /
	  <code class="literal">primary</code> wird:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Es ernennt den <acronym class="acronym">HAST</acronym>-Pool als den
	      primären für einen gegebenen Knoten.</p></li><li class="listitem"><p>Es prüft das Dateisystem, dass auf dem
	      <acronym class="acronym">HAST</acronym>-Pool erstellt wurde.</p></li><li class="listitem"><p>Es hängt die Pools an die richtige Stelle im System
	      ein.</p></li></ul></div><p>Wenn ein Knoten zum <code class="literal">backup</code> /
	  <code class="literal">secondary</code> ernannt wird:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Hängt es den <acronym class="acronym">HAST</acronym>-Pool aus dem
	      Dateisystem aus.</p></li><li class="listitem"><p>Degradiert es den <acronym class="acronym">HAST</acronym>-Pool zum
	      sekundären.</p></li></ul></div><div xmlns="" class="caution"><h3 class="admontitle">Achtung: </h3><p xmlns="http://www.w3.org/1999/xhtml">Bitte beachten Sie, dass dieses Skript nur ein Beispiel
	    für eine mögliche Lösung darstellt.  Es behandelt
	    nicht alle möglichen Szenarien, die auftreten können und
	    sollte erweitert bzw. abgeändert werden, so dass z.B.
	    benötigte Dienste gestartet oder gestoppt werden usw.</p></div><div xmlns="" class="tip"><h3 class="admontitle">Tipp: </h3><p xmlns="http://www.w3.org/1999/xhtml">Für dieses Beispiel wurde ein Standard-UFS Dateisystem
	    verwendet.  Um die Zeit für die Wiederherstellung zu
	    verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem
	    benutzt werden.</p></div><p>Weitere detaillierte Informationen mit zusätzlichen
	  Beispielen können auf der <a class="link" href="http://wiki.FreeBSD.org/HAST" target="_top">HAST Wiki</a>-Seite
	  abgerufen werden.</p></div></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82349520"></a>19.18.5. Fehlerbehebung</h3></div></div></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp82350160"></a>19.18.5.1. Allgemeine Tipps zur Fehlerbehebung</h4></div></div></div><p><acronym class="acronym">HAST</acronym> sollte generell ohne Probleme
	  funktionieren. Jedoch kann es, wie bei jeder anderen Software auch,
	  zu gewissen Zeiten sein, dass sie sich nicht so verhält wie
	  angegeben.  Die Quelle dieser Probleme kann unterschiedlich sein,
	  jedoch sollte als Faustregel gewährleistet werden, dass die
	  Zeit für beide Knoten im Cluster synchron läuft.</p><p>Für die Fehlersuche bei Problemen mit
	  <acronym class="acronym">HAST</acronym> sollte die Anzahl an
	  Debugging-Meldungen von <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastd</span>(8)</span></a> erhöht werden.  Dies
	  kann durch das Starten des <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastd</span>(8)</span></a>-Dienstes mit
	  der Option <code class="literal">-d</code> erreicht werden.  Wichtig
	  zu wissen ist, dass diese Option mehrfach angegeben werden
	  kann, um die Anzahl an Meldungen weiter zu erhöhen.  Sie
	  können viele nützliche Informationen auf diese Art bekommen.
	  Sie sollten ebenfalls die Verwendung der Option
	  <code class="literal">-F</code> in Erwägung ziehen, die den
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=hastd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">hastd</span>(8)</span></a>-Dienst in den Vordergrund bringt.</p></div><div class="sect3"><div xmlns="" class="titlepage"><div><div><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="disks-hast-sb"></a>19.18.5.2. Auflösung des Split-brain-Zustands</h4></div></div></div><p><code class="literal">split-brain</code> bezeichnet eine
	  Situation, in der beide Knoten des Clusters nicht in der
	  Lage sind, miteinander zu kommunizieren und dadurch beide
	  als primäre Knoten fungieren.  Dies ist ein
	  gefährlicher Zustand, weil es beiden Knoten erlaubt ist,
	  Änderungen an den Daten vorzunehmen, die miteinander nicht
	  in Einklang gebracht werden können.  Diese Situation muss
	  vom Systemadministrator händisch bereinigt werden.</p><p>Der Administrator muss entscheiden, welcher Knoten die
	  wichtigsten Änderungen von beiden besitzt (oder diese
	  manuell miteinander vermischen) und anschliessend den
	  <acronym class="acronym">HAST</acronym>-Knoten die volle Synchronisation mit
	  jenem Knoten durchführen zu lassen, welcher die beschädigten
	  Daten besitzt.  Um dies zu tun, geben Sie folgende
	  Befehle auf dem Knoten ein, der neu synchronisiert werden
	  soll:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>hastctl role init &lt;resource&gt;</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>hastctl create &lt;resource&gt;</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>hastctl role secondary &lt;resource&gt;</code></strong></pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="swap-encrypting.html">Zurück</a> </td><td width="20%" align="center"><a accesskey="u" href="disks.html">Nach oben</a></td><td width="40%" align="right"> <a accesskey="n" href="GEOM.html">Weiter</a></td></tr><tr><td width="40%" align="left" valign="top">19.17. Den Auslagerungsspeicher verschlüsseln </td><td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td><td width="40%" align="right" valign="top"> Kapitel 20. GEOM: Modulares Framework zur
    Plattentransformation</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Wenn Sie Fragen zu FreeBSD haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-questions@de.FreeBSD.org">de-bsd-questions@de.FreeBSD.org</a>&gt;.<br></br>
    Wenn Sie Fragen zu dieser Dokumentation haben, schicken Sie eine E-Mail an
    &lt;<a href="mailto:de-bsd-translators@de.FreeBSD.org">de-bsd-translators@de.FreeBSD.org</a>&gt;.</small></p></body></html>