<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $FreeBSD$ -->
<!-- The FreeBSD Documentation Project -->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
  <info><title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation in FreeBSD</title>
    

    <author xmlns:xlink="http://www.w3.org/1999/xlink"><personname xmlns:xlink="http://www.w3.org/1999/xlink"><firstname xmlns:xlink="http://www.w3.org/1999/xlink">Roman</firstname><surname xmlns:xlink="http://www.w3.org/1999/xlink">Divacky</surname></personname><affiliation xmlns:xlink="http://www.w3.org/1999/xlink">
	<address xmlns:xlink="http://www.w3.org/1999/xlink"><email xmlns:xlink="http://www.w3.org/1999/xlink">rdivacky@FreeBSD.org</email></address>
      </affiliation></author>

    <legalnotice xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="trademarks" role="trademarks">
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Adobe, Acrobat, Acrobat Reader, Flash and
  PostScript are either registered trademarks or trademarks of Adobe
  Systems Incorporated in the United States and/or other
  countries.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">IBM, AIX, OS/2,
  PowerPC, PS/2, S/390, and ThinkPad are
  trademarks of International Business Machines Corporation in the
  United States, other countries, or both.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD is a registered trademark of
  the FreeBSD Foundation.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Linux is a registered trademark of
  Linus Torvalds.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">NetBSD is a registered trademark of
  the NetBSD Foundation.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">RealNetworks, RealPlayer, and
  RealAudio are the registered trademarks of RealNetworks,
  Inc.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Oracle is a registered trademark
  of Oracle Corporation.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Sun, Sun Microsystems, Java, Java
  Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK,
  Solaris, StarOffice, SunOS
  and VirtualBox are trademarks or registered trademarks of
  Sun Microsystems, Inc. in the United States and other countries.</para>
      <para xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Many of the designations used by
  manufacturers and sellers to distinguish their products are claimed
  as trademarks.  Where those designations appear in this document,
  and the FreeBSD Project was aware of the trademark claim, the
  designations have been followed by the <quote xmlns:xlink="http://www.w3.org/1999/xlink">&#8482;</quote> or the
  <quote xmlns:xlink="http://www.w3.org/1999/xlink">®</quote> symbol.</para>
    </legalnotice>

    <pubdate xmlns:xlink="http://www.w3.org/1999/xlink">$FreeBSD$</pubdate>

    <releaseinfo xmlns:xlink="http://www.w3.org/1999/xlink">$FreeBSD$</releaseinfo>

    <abstract xmlns:xlink="http://www.w3.org/1999/xlink">
      <para xmlns:xlink="http://www.w3.org/1999/xlink">This masters thesis deals with updating the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer
	(the so called <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">Linuxulator</firstterm>).  The task was to update the layer to match
	the functionality of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6. As a reference implementation, the
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6.16 kernel was chosen.  The concept is loosely based on
	the NetBSD implementation.  Most of the work was done in the summer
	of 2006 as a part of the Google Summer of Code students program.
	The focus was on bringing the <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">NPTL</firstterm> (new <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark>
	thread library) support	into the emulation layer, including
	<firstterm xmlns:xlink="http://www.w3.org/1999/xlink">TLS</firstterm> (thread local storage),
	<firstterm xmlns:xlink="http://www.w3.org/1999/xlink">futexes</firstterm> (fast user space mutexes),
	<firstterm xmlns:xlink="http://www.w3.org/1999/xlink">PID mangling</firstterm>, and some other minor
	things.  Many small problems were identified and fixed in the
	process.  My work was integrated into the main FreeBSD source
	repository and will be shipped in the upcoming 7.0R release.  We,
	the emulation development team, are working on making the
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 emulation the default emulation layer in FreeBSD.</para>
    </abstract>
  </info>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="intro">
    <title xmlns:xlink="http://www.w3.org/1999/xlink">Introduction</title>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">In the last few years the open source <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> based operating systems
      started to be widely deployed on server and client machines.  Among
      these operating systems I would like to point out two: FreeBSD, for its BSD
      heritage, time proven code base and many interesting features and
      <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> for its wide user base, enthusiastic open developer community
      and support from large companies.  FreeBSD tends to be used on server
      class machines serving heavy duty networking tasks with less usage on
      desktop class machines for ordinary users.  While <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> has the same
      usage on servers, but it is used much more by home based users.  This
      leads to a situation where there are many binary only programs available
      for <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> that lack support for FreeBSD.</para>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">Naturally, a need for the ability to run <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> binaries on a FreeBSD
      system arises and this is what this thesis deals with: the emulation of
      the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> kernel in the FreeBSD operating system.</para>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">During the Summer of 2006 Google Inc. sponsored a project which
      focused on extending the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer (the so called Linuxulator)
      in FreeBSD to include <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 facilities.  This thesis is written as a
      part of this project.</para>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="inside">
    <title xmlns:xlink="http://www.w3.org/1999/xlink">A look inside&#8230;</title>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">In this section we are going to describe every operating system in
      question.  How they deal with syscalls, trapframes etc., all the low-level
      stuff. We also describe the way they understand common <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>
      primitives like what a PID is, what a thread is, etc.  In the third
      subsection we talk about how <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> on <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> emulation could be done
      in general.</para>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="what-is-unix">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">What is <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark></title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> is an operating system with a long history that has
	influenced almost every other operating system currently in use.
	Starting in the 1960s, its development continues to this day (although
	in different projects).  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> development soon forked into two main
	ways: the BSDs and System III/V families.  They mutually influenced
	themselves by growing a common <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> standard.  Among the
	contributions originated in BSD we can name virtual memory, TCP/IP
	networking, FFS, and many others.  The System V branch contributed to
	SysV interprocess communication primitives, copy-on-write, etc. <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>
	itself does not exist any more but its ideas have been used by many
	other operating systems world wide thus forming the so called <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-like
	operating systems.  These days the most influential ones are <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>,
	Solaris, and possibly (to some extent) FreeBSD.  There are in-company
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> derivatives (AIX, HP-UX etc.), but these have been more and
	more migrated to the aforementioned systems.  Let us summarize typical
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> characteristics.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="tech-details">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Technical details</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Every running program constitutes a process that represents a state
	of the computation.  Running process is divided between kernel-space
	and user-space.  Some operations can be done only from kernel space
	(dealing with hardware etc.), but the process should spend most of its
	lifetime in the user space.  The kernel is where the management of the
	processes, hardware, and low-level details take place.  The kernel
	provides a standard unified <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> API to the user space.  The most
	important ones are covered below.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="kern-proc-comm">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Communication between kernel and user space process</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Common <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> API defines a syscall as a way to issue commands
	  from a user space process to the kernel.  The most common
	  implementation is either by using an interrupt or specialized
	  instruction (think of
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">SYSENTER</literal>/<literal xmlns:xlink="http://www.w3.org/1999/xlink">SYSCALL</literal> instructions
	  for ia32).  Syscalls are defined by a number.  For example in FreeBSD,
	  the syscall number 85 is the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">swapon</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall and the
	  syscall number 132 is <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">mkfifo</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry>.  Some syscalls need
	  parameters, which are passed from the user-space to the kernel-space
	  in various ways (implementation dependant).  Syscalls are
	  synchronous.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Another possible way to communicate is by using a
	  <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">trap</firstterm>.  Traps occur asynchronously after
	  some event occurs (division by zero, page fault etc.).  A trap
	  can be transparent for a process (page fault) or can result in
	  a reaction like sending a <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">signal</firstterm>
	  (division by zero).</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="proc-proc-comm">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Communication between processes</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">There are other APIs (System V IPC, shared memory etc.) but the
	  single most important API is signal.  Signals are sent by processes
	  or by the kernel and received by processes.  Some signals
	  can be ignored or handled by a user supplied routine, some result
	  in a predefined action that cannot be altered or ignored.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="proc-mgmt">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Process management</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Kernel instances are processed first in the system (so called
	  init).  Every running process can create its identical copy using
	  the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">fork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall.  Some slightly modified versions of this
	  syscall were introduced but the basic semantic is the same.  Every
	  running process can morph into some other process using the
	  <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">exec</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> syscall.  Some modifications of this syscall were
	  introduced but all serve the same basic purpose.  Processes end
	  their lives by calling the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">exit</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall.  Every process is
	  identified by a unique number called PID.  Every process has a
	  defined parent (identified by its PID).</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="thread-mgmt">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Thread management</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Traditional <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> does not define any API nor implementation
	  for threading, while  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> defines its threading API but the
	  implementation is undefined.  Traditionally there were two ways of
	  implementing threads.  Handling them as separate processes (1:1
	  threading) or envelope the whole thread group in one process and
	  managing the threading in userspace (1:N threading).  Comparing
	  main features of each approach:</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">1:1 threading</para>

	<itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">- heavyweight threads</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">- the scheduling cannot be altered by the user
	      (slightly mitigated by the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> API)</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">+ no syscall wrapping necessary</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">+ can utilize multiple CPUs</para>
	  </listitem>
	</itemizedlist>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">1:N threading</para>

	<itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">+ lightweight threads</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">+ scheduling can be easily altered by the user</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">- syscalls must be wrapped </para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">- cannot utilize more than one CPU</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="what-is-freebsd">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">What is FreeBSD?</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD project is one of the oldest open source operating
	systems currently available for daily use.  It is a direct descendant
	of the genuine <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> so it could be claimed that it is a true <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>
	although licensing issues do not permit that.  The start of the project
	dates back to the early 1990's when a crew of fellow BSD users patched
	the 386BSD operating system.  Based on this patchkit a new operating
	system arose named FreeBSD for its liberal license.  Another group created
	the NetBSD operating system with different goals in mind.  We will
	focus on FreeBSD.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD is a modern <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-based operating system with all the
	features of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>.  Preemptive multitasking, multiuser facilities,
	TCP/IP networking, memory protection, symmetric multiprocessing
	support, virtual memory with merged VM and buffer cache, they are all
	there.  One of the interesting and extremely useful features is the
	ability to emulate other <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-like operating systems.  As of
	December 2006 and 7-CURRENT development, the following
	emulation functionalities are supported:</para>

      <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD/i386 emulation on FreeBSD/amd64</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD/i386 emulation on FreeBSD/ia64</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>-emulation of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> operating system on FreeBSD</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">NDIS-emulation of Windows networking drivers interface</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">NetBSD-emulation of NetBSD operating system</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">PECoff-support for PECoff FreeBSD executables</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">SVR4-emulation of System V revision 4 <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark></para>
	</listitem>
      </itemizedlist>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Actively developed emulations are the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> layer and various
	FreeBSD-on-FreeBSD layers.  Others are not supposed to work properly nor
	be usable these days.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD development happens in a central CVS repository where only
	a selected team of so called committers can write.  This repository
	possesses several branches; the most interesting are the HEAD branch,
	in FreeBSD	nomenclature called -CURRENT, and RELENG_X branches, where X
	stands for a number indicating a major version of FreeBSD.  As of
	December 2006, there are development branches for 6.X development
	(RELENG_6) and for the 5.X development (RELENG_5).  Other branches are
	closed and not actively maintained or only fed with security patches
	by the Security Officer of the FreeBSD project.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Historically the active development was done in the HEAD branch so
	it was considered extremely unstable and supposed to happen to break
	at any time.  This is not true any more as the
	<application xmlns:xlink="http://www.w3.org/1999/xlink">Perforce</application> (commercial	version control system)
	repository was introduced so that active development happen there.
	There are many branches in <application xmlns:xlink="http://www.w3.org/1999/xlink">Perforce</application> where
	development of certain parts of the system happens and these branches
	are from time to time merged back to the main CVS repository thus
	effectively putting the given feature to the FreeBSD operating system.
	The same happened with the <filename xmlns:xlink="http://www.w3.org/1999/xlink">rdivacky_linuxolator</filename>
	branch where development of this thesis code was going on.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">More info about the FreeBSD operating system can be found
	at [2].</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-tech-details">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Technical details</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD is traditional flavor of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> in the sense of dividing the
	  run of processes into two halves: kernel space and user space run.
	  There are two types of process entry to the kernel: a syscall and a
	  trap.  There is only one way to return.  In the subsequent sections
	  we will describe the three gates to/from the kernel.  The whole
	  description applies to the i386 architecture as the Linuxulator
	  only exists there but the concept is similar on other architectures.
	  The information was taken from [1] and the source code.</para>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-sys-entries">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">System entries</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD has an abstraction called an execution class loader,
	    which is a wedge into the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">execve</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall.  This employs a
	    structure <literal xmlns:xlink="http://www.w3.org/1999/xlink">sysentvec</literal>, which describes an
	    executable ABI.  It contains things like errno translation table,
	    signal translation table, various functions to serve syscall needs
	    (stack fixup, coredumping, etc.).  Every ABI the FreeBSD kernel wants
	    to support must define this structure, as it is used later in the
	    syscall processing code and at some other places.  System entries
	    are handled by trap handlers, where we can access both the
	    kernel-space and the user-space at once.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-syscalls">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Syscalls</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Syscalls on FreeBSD are issued by executing interrupt
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">0x80</literal> with register <varname xmlns:xlink="http://www.w3.org/1999/xlink">%eax</varname> set
	    to a desired syscall number with arguments passed on the stack.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">When a process issues an interrupt <literal xmlns:xlink="http://www.w3.org/1999/xlink">0x80</literal>, the
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">int0x80</literal> syscall trap handler is issued (defined
	    in <filename xmlns:xlink="http://www.w3.org/1999/xlink">sys/i386/i386/exception.s</filename>), which prepares
	    arguments (i.e. copies them on to the stack) for a
	    call to a C function <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">syscall</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> (defined in
	    <filename xmlns:xlink="http://www.w3.org/1999/xlink">sys/i386/i386/trap.c</filename>), which processes the
	    passed in trapframe.  The processing consists of preparing the
	    syscall (depending on the <literal xmlns:xlink="http://www.w3.org/1999/xlink">sysvec</literal> entry),
	    determining if the syscall is 32-bit or 64-bit one (changes size
	    of the parameters), then the parameters are copied, including the
	    syscall.  Next, the actual syscall function is executed with
	    processing of the return code (special cases for
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">ERESTART</literal> and <literal xmlns:xlink="http://www.w3.org/1999/xlink">EJUSTRETURN</literal>
	    errors).  Finally an <literal xmlns:xlink="http://www.w3.org/1999/xlink">userret()</literal> is scheduled,
	    switching the process back to the users-pace.  The parameters to
	    the actual syscall handler are passed in the form of
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">struct thread *td</literal>,
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">struct syscall args *</literal> arguments where the second
	    parameter is a pointer to the copied in structure of
	    parameters.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-traps">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Traps</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Handling of traps in FreeBSD is similar to the handling of
	    syscalls.  Whenever a trap occurs, an assembler handler is called.
	    It is chosen between alltraps, alltraps with regs pushed or
	    calltrap depending on the type of the trap.  This handler prepares
	    arguments for a call to a C function <literal xmlns:xlink="http://www.w3.org/1999/xlink">trap()</literal>
	    (defined in <filename xmlns:xlink="http://www.w3.org/1999/xlink">sys/i386/i386/trap.c</filename>), which then
	    processes the occurred trap.  After the processing it might send a
	    signal to the process and/or exit to userland using
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">userret()</literal>.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-exits">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Exits</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Exits from kernel to userspace happen using the assembler
	    routine <literal xmlns:xlink="http://www.w3.org/1999/xlink">doreti</literal> regardless of whether the kernel
	    was entered via a trap or via a syscall.  This restores the program
	    status from the stack and returns to the userspace.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-unix-primitives">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> primitives</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD operating system adheres to the traditional <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> scheme,
	    where every process has a unique identification number, the so
	    called <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">PID</firstterm> (Process ID).  PID numbers are
	    allocated either linearly or randomly ranging from
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">0</literal> to <literal xmlns:xlink="http://www.w3.org/1999/xlink">PID_MAX</literal>.  The allocation
	    of PID numbers is done using linear searching of PID space.  Every
	    thread in a process receives the same PID number as result of the
	    <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">getpid</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> call.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">There are currently two ways to implement threading in FreeBSD.
	    The first way is M:N threading followed by the 1:1 threading model.
	    The default library used is M:N threading
	    (<literal xmlns:xlink="http://www.w3.org/1999/xlink">libpthread</literal>) and you can switch at runtime to
	    1:1 threading (<literal xmlns:xlink="http://www.w3.org/1999/xlink">libthr</literal>).  The plan is to switch
	    to 1:1 library by default soon.  Although those two libraries use
	    the same kernel primitives, they are accessed through different
	    API(es).  The M:N library uses the <literal xmlns:xlink="http://www.w3.org/1999/xlink">kse_*</literal> family
	    of syscalls while the 1:1 library uses the <literal xmlns:xlink="http://www.w3.org/1999/xlink">thr_*</literal>
	    family of syscalls.  Because of this, there is no general concept
	    of thread ID shared between kernel and userspace.  Of course, both
	    threading libraries implement the pthread thread ID API.  Every
	    kernel thread (as described by <literal xmlns:xlink="http://www.w3.org/1999/xlink">struct thread</literal>)
	    has td tid identifier but this is not directly accessible
	    from userland and solely serves the kernel's needs.  It is also
	    used for 1:1 threading library as pthread's thread ID but handling
	    of this is internal to the library and cannot be relied on.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">As stated previously there are two implementations of threading
	    in FreeBSD.  The M:N library divides the work between kernel space and
	    userspace.  Thread is an entity that gets scheduled in the kernel
	    but it can represent various number of userspace threads.
	    M userspace threads get mapped to N kernel threads thus saving
	    resources while keeping the ability to exploit multiprocessor
	    parallelism.  Further information about the implementation can be
	    obtained from the man page or [1].  The 1:1 library directly maps a
	    userland thread to a kernel thread thus greatly simplifying the
	    scheme.  None of these designs implement a fairness mechanism (such
	    a mechanism was implemented but it was removed recently because it
	    caused serious slowdown and made the code more difficult to deal
	    with).</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="what-is-linux">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">What is <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark></title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> is a <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-like kernel originally developed by Linus
	Torvalds, and now being contributed to by a massive crowd of
	programmers all around the world.  From its mere beginnings to todays,
	with wide support from companies such as IBM or Google, <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> is
	being associated with its fast development pace, full hardware support
	and benevolent dictator model of organization.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> development started in 1991 as a hobbyist project at
	University of Helsinki in Finland.  Since then it has obtained all the
	features of a modern <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-like OS: multiprocessing, multiuser
	support, virtual memory, networking, basically everything is there.
	There are also highly advanced features like virtualization etc.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">As of 2006 <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> seems to be the most widely used open source
	operating system with support from independent software vendors like
	Oracle, RealNetworks, Adobe, etc.  Most of the commercial software
	distributed for <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> can only be obtained in a binary form so
	recompilation for other operating systems is impossible.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Most of the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> development happens in a
	<application xmlns:xlink="http://www.w3.org/1999/xlink">Git</application> version control system.
	<application xmlns:xlink="http://www.w3.org/1999/xlink">Git</application> is a distributed system so there is
	no central source of the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> code, but some branches are considered
	prominent and official.  The version number scheme implemented by
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> consists of four numbers A.B.C.D.  Currently development
	happens in 2.6.C.D, where C represents major version, where new
	features are added or changed while D is a minor version for bugfixes
	only.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">More information can be obtained from [4].</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-tech-details">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Technical details</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> follows the traditional <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> scheme of dividing the run
	of a process in two halves: the kernel and user space.  The kernel can
	be entered in two ways: via a trap or via a syscall.  The return is
	handled only in one way.  The further description applies to
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 on the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">i386</trademark> architecture.  This information was
	taken from [3].</para>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-syscalls">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Syscalls</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Syscalls in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> are performed (in userspace) using
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">syscallX</literal> macros where X substitutes a number
	    representing the number of parameters of the given syscall.  This
	    macro translates to a code that loads <varname xmlns:xlink="http://www.w3.org/1999/xlink">%eax</varname>
	    register with a number of the syscall and executes interrupt
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">0x80</literal>.  After this syscall return is called,
	    which translates negative return values to positive
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">errno</literal> values and sets <literal xmlns:xlink="http://www.w3.org/1999/xlink">res</literal> to
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">-1</literal> in case of an error.  Whenever the interrupt
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">0x80</literal> is called the process enters the kernel in
	    system call trap handler.  This routine saves all registers on the
	    stack and calls the selected syscall entry.  Note that the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	    calling convention expects parameters to the syscall to be passed
	    via registers as shown here:</para>

	  <orderedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ebx</varname></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ecx</varname></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%edx</varname></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%esi</varname></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%edi</varname></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">parameter -&gt; <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ebp</varname></para>
	    </listitem>
	  </orderedlist>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">There are some exceptions to this, where <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> uses different
	    calling convention (most notably the <literal xmlns:xlink="http://www.w3.org/1999/xlink">clone</literal>
	    syscall).</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-traps">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Traps</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The trap handlers are introduced in
	    <filename xmlns:xlink="http://www.w3.org/1999/xlink">arch/i386/kernel/traps.c</filename> and most of these
	    handlers live in <filename xmlns:xlink="http://www.w3.org/1999/xlink">arch/i386/kernel/entry.S</filename>,
	    where handling of the traps happens.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-exits">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Exits</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Return from the syscall is managed by syscall <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">exit</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry>,
	    which checks for the process having unfinished work, then checks
	    whether we used user-supplied selectors.  If this happens stack
	    fixing is applied and finally the registers are restored from the
	    stack and the process returns to the userspace.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-unix-primitives">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> primitives</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">In the 2.6 version, the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> operating system redefined some
	    of the traditional <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> primitives, notably PID, TID and thread.
	    PID is defined not to be unique for every process, so for some
	    processes (threads) <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">getppid</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> returns the same value.  Unique
	    identification of process is provided by TID.  This is because
	    <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">NPTL</firstterm> (New <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> Thread Library) defines
	    threads to be normal processes (so called 1:1 threading).  Spawning
	     a new process in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 happens using the
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">clone</literal> syscall (fork variants are reimplemented using
	    it).  This clone syscall defines a set of flags that affect
	    behaviour of the cloning process regarding thread implementation.
	    The semantic is a bit fuzzy as there is no single flag telling the
	    syscall to create a thread.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Implemented clone flags are:</para>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_VM</literal> - processes share their memory
		space</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_FS</literal> - share umask, cwd and
		namespace</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_FILES</literal> - share open
		files</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SIGHAND</literal> - share signal handlers
		and blocked signals</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_PARENT</literal> - share parent</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_THREAD</literal> - be thread (further
		explanation below)</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_NEWNS</literal> - new namespace</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SYSVSEM</literal> - share SysV undo
		structures</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SETTLS</literal> - setup TLS at supplied
		address</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_PARENT_SETTID</literal> - set TID in the
		parent</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_CHILD_CLEARTID</literal> - clear TID in the
		child</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_CHILD_SETTID</literal> - set TID in the
		child</para>
	    </listitem>
	  </itemizedlist>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_PARENT</literal> sets the real parent to the
	    parent of the caller.  This is useful for threads because if thread
	    A creates thread B we want thread B to be parented to the parent of
	    the whole thread group.  <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_THREAD</literal> does
	    exactly the same thing as <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_PARENT</literal>,
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_VM</literal> and <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SIGHAND</literal>,
	    rewrites PID to be the same as PID of the caller, sets exit signal
	    to be none and enters the thread group.
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SETTLS</literal> sets up GDT entries for TLS
	    handling.  The <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_*_*TID</literal> set of flags
	    sets/clears user supplied address to TID or 0.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">As you can see the <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_THREAD</literal> does most
	    of the work and does not seem to fit the scheme very well.  The
	    original intention is unclear (even for authors, according to
	    comments in the code) but I think originally there was one
	    threading flag, which was then parcelled among many other flags
	    but this separation was never fully finished.  It is also unclear
	    what this partition is good for as glibc does not use that so only
	    hand-written use of the clone permits a programmer to access this
	    features.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">For non-threaded programs the PID and TID are the same.  For
	    threaded programs the first thread PID and TID are the same and
	    every created thread shares the same PID and gets assigned a
	    unique TID (because <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_THREAD</literal> is passed in)
	    also parent is shared for all processes forming this threaded
	    program.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The code that implements <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_create</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> in NPTL defines
	    the clone flags like this:</para>

	  <programlisting xmlns:xlink="http://www.w3.org/1999/xlink">int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL

 | CLONE_SETTLS | CLONE_PARENT_SETTID

| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
#if __ASSUME_NO_CLONE_DETACHED == 0

| CLONE_DETACHED
#endif

| 0);</programlisting>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SIGNAL</literal> is defined like</para>

	  <programlisting xmlns:xlink="http://www.w3.org/1999/xlink">#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)</programlisting>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">the last 0 means no signal is sent when any of the threads
	    exits.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="what-is-emu">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">What is emulation</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">According to a dictionary definition, emulation is the ability of
	a program or device to imitate another program or device.  This is
	achieved by providing the same reaction to a given stimulus as the
	emulated object.  In practice, the software world mostly sees three
	types of emulation - a program used to emulate a machine (QEMU, various
	game console emulators etc.), software emulation of a hardware facility
	(OpenGL emulators, floating point units emulation etc.) and operating
	system emulation (either in kernel of the operating system or as a
	userspace program).</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Emulation is usually used in a place, where using the original
	component is not feasible nor possible at all.  For example someone
	might want to use a program developed for a different operating
	system than they use.  Then emulation comes in handy.  Sometimes
	there is no other way but to use emulation - e.g. when the hardware
	device you try to use does not exist (yet/anymore) then there is no
	other way but emulation.  This happens often when porting an operating
	system to a new (non-existent) platform.  Sometimes it is just
	cheaper to emulate.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Looking from an implementation point of view, there are two main
	approaches to the implementation of emulation.  You can either emulate
	the whole thing - accepting possible inputs of the original object,
	maintaining inner state and emitting correct output based on the state
	and/or input.  This kind of emulation does not require any special
	conditions and basically can be implemented anywhere for any
	device/program.  The drawback is that implementing such emulation is
	quite difficult, time-consuming and error-prone.  In some cases we can
	use a simpler approach.  Imagine you want to emulate a printer that
	prints from left to right on a printer that prints from right to left.
	It is obvious that there is no need for a complex emulation layer but
	simply reversing of the printed text is sufficient.  Sometimes the
	emulating environment is very similar to the emulated one so just a
	thin layer of some translation is necessary to provide fully working
	emulation!  As you can see this is much less demanding to implement,
	so less time-consuming and error-prone than the previous approach.  But
	the necessary condition is that the two environments must be similar
	enough.  The third approach combines the two previous.  Most of the
	time the objects do not provide the same capabilities so in a case of
	emulating the more powerful one on the less powerful we have to emulate
	the missing features with full emulation described above.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">This master thesis deals with emulation of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> on <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>, which
	is exactly the case, where only a thin layer of translation is
	sufficient to provide full emulation.  The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> API consists of a set
	of syscalls, which are usually self contained and do not affect some
	global kernel state.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">There are a few syscalls that affect inner state but this can be
	dealt with by providing some structures that maintain the extra
	state.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">No emulation is perfect and emulations tend to lack some parts but
	this usually does not cause any serious drawbacks.  Imagine a game
	console emulator that emulates everything but music output.  No doubt
	that the games are playable and one can use the emulator.  It might
	not be that comfortable as the original game console but its an
	acceptable compromise between price and comfort.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The same goes with the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> API.  Most programs can live with a
	very limited set of syscalls working.  Those syscalls tend to be the
	oldest ones (<citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">read</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry>/<citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">write</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry>, <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">fork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> family,
	<citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">signal</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> handling, <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">exit</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry>, <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">socket</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> API) hence it is
	easy to emulate because their semantics is shared among all
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>es, which exist todays.</para>
    </sect2>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-emulation">
    <title xmlns:xlink="http://www.w3.org/1999/xlink">Emulation</title>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">How emulation works in FreeBSD</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">As stated earlier, FreeBSD supports running binaries from several
	other <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>es.  This works because FreeBSD has an abstraction called the
	execution class loader.  This wedges into the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">execve</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall,
	so when <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">execve</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> is about to execute a binary it examines its
	type.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">There are basically two types of binaries in FreeBSD.  Shell-like text
	scripts which are identified by <literal xmlns:xlink="http://www.w3.org/1999/xlink">#!</literal> as their first
	two characters and normal (typically <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">ELF</firstterm>)
	binaries, which are a representation of a compiled executable object.
	The vast majority (one could say all of them) of binaries in FreeBSD are
	from type ELF.  ELF files contain a header, which specifies the OS ABI
	for this ELF file.  By reading this information, the operating system
	can accurately determine what type of binary the given file is.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Every OS ABI must be registered in the FreeBSD kernel.  This applies
	to the FreeBSD native OS ABI, as well.  So when <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">execve</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> executes a
	binary it iterates through the list of registered APIs and when it
	finds the right one it starts to use the information contained in the
	OS ABI description (its syscall table, <literal xmlns:xlink="http://www.w3.org/1999/xlink">errno</literal>
	translation table, etc.).  So every time the process calls a syscall,
	it uses its own set of syscalls instead of some global one.  This
	effectively provides a very elegant and easy way of supporting
	execution of various binary formats.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The nature of emulation of different OSes (and also some other
	subsystems) led developers to invite a handler event mechanism.  There
	are various places in the kernel, where a list of event handlers are
	called.  Every subsystem can register an event handler and they are
	called accordingly.  For example, when a process exits there is a
	handler called that possibly cleans up whatever the subsystem needs
	to be cleaned.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Those simple facilities provide basically everything that is needed
	for the emulation infrastructure and in fact these are basically the
	only things necessary to implement the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-common-primitives">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Common primitives in the FreeBSD kernel</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Emulation layers need some support from the operating system.  I am
	going to describe some of the supported primitives in the FreeBSD
	operating system.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-locking-primitives">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Locking primitives</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Contributed by: Attilio Rao <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">attilio@FreeBSD.org</email></para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD synchronization primitive set is based on the idea to
	  supply a rather huge number of different primitives in a way that
	  the better one can be used for every particular, appropriate
	  situation.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">To a high level point of view you can consider three kinds of
	  synchronization primitives in the FreeBSD kernel:</para>

	<itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">atomic operations and memory barriers</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">locks</para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">scheduling barriers</para>
	  </listitem>
	</itemizedlist>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Below there are descriptions for the 3 families.  For every lock,
	  you should really check the linked manpage (where possible) for
	  more detailed explanations.</para>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-atomic-op">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Atomic operations and memory barriers</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Atomic operations are implemented through a set of functions
	    performing simple arithmetics on memory operands in an atomic way
	    with respect to external events (interrupts, preemption, etc.).
	    Atomic operations can guarantee atomicity just on small data types
	    (in the magnitude order of the <literal xmlns:xlink="http://www.w3.org/1999/xlink">.long.</literal>
	    architecture C data type), so should be rarely used directly in the
	    end-level code, if not only for very simple operations (like flag
	    setting in a bitmap, for example).  In fact, it is rather simple
	    and common to write down a wrong semantic based on just atomic
	    operations (usually referred as lock-less).  The FreeBSD kernel offers
	    a way to perform atomic operations in conjunction with a memory
	    barrier.  The memory barriers will guarantee that an atomic
	    operation will happen following some specified ordering with
	    respect to other memory accesses.  For example, if we need that an
	    atomic operation happen just after all other pending writes (in
	    terms of instructions reordering buffers activities) are completed,
	    we need to explicitly use a memory barrier in conjunction to this
	    atomic operation.  So it is simple to understand why memory
	    barriers play a key role for higher-level locks building (just
	    as refcounts, mutexes, etc.).  For a detailed explanatory on atomic
	    operations, please refer to <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">atomic</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry>.  It is far, however,
	    noting that atomic operations (and memory barriers as well) should
	    ideally only be used for building front-ending locks (as
	    mutexes).</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-refcounts">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Refcounts</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Refcounts are interfaces for handling reference counters.
	    They are implemented through atomic operations and are intended to
	    be used just for cases, where the reference counter is the only
	    one thing to be protected, so even something like a spin-mutex is
	    deprecated.  Using the refcount interface for structures, where
	    a mutex is already used is often wrong since we should probably
	    close the reference counter in some already protected paths.  A
	    manpage discussing refcount does not exist currently, just check
	    <filename xmlns:xlink="http://www.w3.org/1999/xlink">sys/refcount.h</filename> for an overview of the
	    existing API.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-locks">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Locks</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">FreeBSD kernel has huge classes of locks.  Every lock is defined
	    by some peculiar properties, but probably the most important is the
	    event linked to contesting holders (or in other terms, the
	    behaviour of threads unable to acquire the lock).  FreeBSD's locking
	    scheme presents three different behaviours for contenders:</para>

	  <orderedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">spinning</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">blocking</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sleeping</para>
	    </listitem>
	  </orderedlist>

	  <note xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">numbers are not casual</para>
	  </note>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-spinlocks">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Spinning locks</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Spin locks let waiters to spin until they cannot acquire the
	    lock.  An important matter do deal with is when a thread contests
	    on a spin lock if it is not descheduled.  Since the FreeBSD kernel
	    is preemptive, this exposes spin lock at the risk of deadlocks
	    that can be solved just disabling interrupts while they are
	    acquired.  For this and other reasons (like lack of priority
	    propagation support, poorness in load balancing schemes between
	    CPUs, etc.), spin locks are intended to protect very small paths
	    of code, or ideally not to be used at all if not explicitly
	    requested (explained later).</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-blocking">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Blocking</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Block locks let waiters to be descheduled and blocked until
	    the lock owner does not drop it and wakes up one or more
	    contenders.  In order to avoid starvation issues, blocking locks
	    do priority propagation from the waiters to the owner.  Block
	    locks must be implemented through the turnstile interface and are
	    intended to be the most used kind of locks in the kernel, if no
	    particular conditions are met.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-sleeping">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Sleeping</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Sleep locks let waiters to be descheduled and fall asleep
	    until the lock holder does not drop it and wakes up one or more
	    waiters.  Since sleep locks are intended to protect large paths
	    of code and to cater asynchronous events, they do not do any form
	    of priority propagation.  They must be implemented through the
	    <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sleepqueue</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> interface.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The order used to acquire locks is very important, not only for
	    the possibility to deadlock due at lock order reversals, but even
	    because lock acquisition should follow specific rules linked to
	    locks natures.  If you give a look at the table above, the
	    practical rule is that if a thread holds a lock of level n (where
	    the level is the number listed close to the kind of lock) it is not
	    allowed to acquire a lock of superior levels, since this would
	    break the specified semantic for a path.  For example, if a thread
	    holds a block lock (level 2), it is allowed to acquire a spin lock
	    (level 1) but not a sleep lock (level 3), since block locks are
	    intended to protect smaller paths than sleep lock (these rules are
	    not about atomic operations or scheduling barriers,
	    however).</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This is a list of lock with their respective behaviours:</para>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">spin mutex - spinning - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">mutex</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sleep mutex - blocking - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">mutex</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">pool mutex - blocking - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">mtx_pool</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sleep family - sleeping - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sleep</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> pause tsleep
		msleep msleep spin msleep rw msleep sx</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">condvar - sleeping - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">condvar</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">rwlock - blocking - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">rwlock</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sxlock - sleeping - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sx</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">lockmgr - sleeping - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">lockmgr</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">semaphores - sleeping - <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sema</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry></para>
	    </listitem>
	  </itemizedlist>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Among these locks only mutexes, sxlocks, rwlocks and lockmgrs
	    are intended to handle recursion, but currently recursion is only
	    supported by mutexes and lockmgrs.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-scheduling">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Scheduling barriers</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Scheduling barriers are intended to be used in order to drive
	    scheduling of threading.  They consist mainly of three
	    different stubs:</para>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">critical sections (and preemption)</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sched_bind</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink">sched_pin</para>
	    </listitem>
	  </itemizedlist>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Generally, these should be used only in a particular context
	    and even if they can often replace locks, they should be avoided
	    because they do not let the diagnose of simple eventual problems
	    with locking debugging tools (as <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">witness</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">4</manvolnum></citerefentry>).</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-critical">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Critical sections</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD kernel has been made preemptive basically to deal with
	    interrupt threads.  In fact, in order to avoid high interrupt
	    latency, time-sharing priority threads can be preempted by
	    interrupt threads (in this way, they do not need to wait to be
	    scheduled as the normal path previews).  Preemption, however,
	    introduces new racing points that need to be handled, as well.
	    Often, in order to deal with preemption, the simplest thing to do
	    is to completely disable it.  A critical section defines a piece of
	    code (borderlined by the pair of functions <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">critical_enter</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry>
	    and <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">critical_exit</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry>, where preemption is guaranteed to not
	    happen (until the protected code is fully executed).  This can
	    often replace a lock effectively but should be used carefully in
	    order to not lose the whole advantage that preemption
	    brings.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-schedpin">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">sched_pin/sched_unpin</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Another way to deal with preemption is the
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_pin()</function> interface.  If a piece of code
	    is closed in the <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_pin()</function>  and
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_unpin()</function> pair of functions it is
	    guaranteed that the respective thread, even if it can be preempted,
	    it will always be executed on the same CPU.  Pinning is very
	    effective in the particular case when we have to access at
	    per-cpu datas and we assume other threads will not change those
	    data.  The latter condition will determine a critical section
	    as a too strong condition for our code.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-schedbind">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">sched_bind/sched_unbind</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">sched_bind</function> is an API used in order to bind
	    a thread to a particular CPU for all the time it executes the code,
	    until a <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_unbind</function> function call does not
	    unbind it.  This feature has a key role in situations where you
	    cannot trust the current state of CPUs (for example, at very early
	    stages of boot), as you want to avoid your thread to migrate on
	    inactive CPUs.  Since <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_bind</function> and
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_unbind</function> manipulate internal scheduler
	    structures, they need to be enclosed in
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">sched_lock</function> acquisition/releasing when
	    used.</para>
	</sect4>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-proc">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Proc structure</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Various emulation layers sometimes require some additional
	  per-process data.  It can manage separate structures (a list, a tree
	  etc.) containing these data for every process but this tends to be
	  slow and memory consuming.  To solve this problem the FreeBSD
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">proc</literal> structure contains
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">p_emuldata</literal>, which is a void pointer to some
	  emulation layer specific data.  This <literal xmlns:xlink="http://www.w3.org/1999/xlink">proc</literal> entry
	  is protected by the proc mutex.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD <literal xmlns:xlink="http://www.w3.org/1999/xlink">proc</literal> structure contains a
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">p_sysent</literal> entry that identifies, which ABI this
	   process is running.  In fact, it is a pointer to the
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">sysentvec</literal> described above.  So by comparing this
	  pointer to the address where the <literal xmlns:xlink="http://www.w3.org/1999/xlink">sysentvec</literal>
	  structure for the given ABI is stored we can effectively determine
	  whether the process belongs to our emulation layer.  The code
	  typically looks like:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">if (__predict_true(p-&gt;p_sysent != &amp;elf_<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>_sysvec))
	  return;</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">As you can see, we effectively use the
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">__predict_true</literal> modifier to collapse the most
	  common case (FreeBSD process) to a simple return operation thus
	  preserving high performance.  This code should be turned into a
	  macro because currently it is not very flexible, i.e. we do not
	  support <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>64 emulation nor A.OUT <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> processes
	  on i386.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-vfs">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">VFS</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD VFS subsystem is very complex but the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation
	  layer uses just a small subset via a well defined API.  It can either
	  operate on vnodes or file handlers.  Vnode represents a virtual
	  vnode, i.e. representation of a node in VFS.  Another representation
	  is a file handler, which represents an opened file from the
	  perspective of a process.  A file handler can represent a socket or
	  an ordinary file.  A file handler contains a pointer to its vnode.
	  More then one file handler can point to the same vnode.</para>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-namei">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">namei</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> routine is a central entry point to pathname
	    lookup and translation.  It traverses the path point by point from
	    the starting point to the end point using lookup function, which is
	    internal to VFS.  The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> syscall can cope with symlinks,
	    absolute and relative paths.  When a path is looked up using
	    <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> it is inputed to the name cache.  This behaviour can
	    be suppressed.  This routine is used all over the kernel and its
	    performance is very critical.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-vn">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">vn_fullpath</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vn_fullpath</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> function takes the best effort to
	   traverse VFS name cache and returns a path for a given (locked)
	   vnode.  This process is unreliable but works just fine for the most
	   common cases.  The unreliability is because it relies on VFS cache
	   (it does not traverse the on medium structures), it does not work
	   with hardlinks, etc.  This routine is used in several places in the
	   Linuxulator.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-vnode">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Vnode operations</title>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">fgetvp</function> - given a thread and a file
		descriptor number it returns the associated vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vn_lock</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - locks a vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">vn_unlock</function> - unlocks a vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">VOP_READDIR</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - reads a directory referenced by
		a vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">VOP_GETATTR</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - gets attributes of a file or a
		directory referenced by a vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">VOP_LOOKUP</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - looks up a path to a given
		directory</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">VOP_OPEN</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - opens a file referenced by a
		vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">VOP_CLOSE</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - closes a file referenced by a
		vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vput</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - decrements the use count for a vnode and
		unlocks it</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vrele</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - decrements the use count for a vnode</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vref</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> - increments the use count for a vnode</para>
	    </listitem>
	  </itemizedlist>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="freebsd-file-handler">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">File handler operations</title>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">fget</function> - given a thread and a file
		descriptor number it returns associated file handler and
		references it</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">fdrop</function> - drops a reference to a file
		handler</para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><function xmlns:xlink="http://www.w3.org/1999/xlink">fhold</function> - references a file
		handler</para>
	    </listitem>
	  </itemizedlist>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="md">
    <title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer -MD part</title>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">This section deals with implementation of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer in
      FreeBSD operating system.  It first describes the machine dependent part
      talking about how and where interaction between userland and kernel is
      implemented.  It talks about syscalls, signals, ptrace, traps, stack
      fixup.  This part discusses i386 but it is written generally so other
      architectures should not differ very much.  The next part is the machine
      independent part of the Linuxulator.  This section only covers i386 and ELF
      handling.  A.OUT is obsolete and untested.</para>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="syscall-handling">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Syscall handling</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Syscall handling is mostly written in
	<filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_sysvec.c</filename>, which covers most of the routines
	pointed out in the <literal xmlns:xlink="http://www.w3.org/1999/xlink">sysentvec</literal> structure.  When a
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> process running on FreeBSD issues a syscall, the general syscall
	routine calls linux prepsyscall routine for the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> ABI.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-prepsyscall">
	<title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> prepsyscall</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> passes arguments to syscalls via registers (that is why
	  it is limited to 6 parameters on i386) while FreeBSD uses the stack.
	  The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> prepsyscall routine must copy parameters from registers
	  to the stack.  The order of the registers is:
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ebx</varname>, <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ecx</varname>,
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%edx</varname>, <varname xmlns:xlink="http://www.w3.org/1999/xlink">%esi</varname>,
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%edi</varname>, <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ebp</varname>.  The catch is that
	  this is true for only <emphasis xmlns:xlink="http://www.w3.org/1999/xlink">most</emphasis> of the syscalls.
	  Some (most notably <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function>) uses a different
	  order but it is luckily easy to fix by inserting a dummy parameter
	  in the <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_clone</function> prototype.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="syscall-writing">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Syscall writing</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Every syscall implemented in the Linuxulator must have its
	  prototype with various flags in <filename xmlns:xlink="http://www.w3.org/1999/xlink">syscalls.master</filename>.
	  The form of the file is:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">...
	AUE_FORK STD		{ int linux_fork(void); }
...
	AUE_CLOSE NOPROTO	{ int close(int fd); }
...</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The first column represents the syscall number.  The second
	  column is for auditing support.  The third column represents the
	  syscall type.  It is either <literal xmlns:xlink="http://www.w3.org/1999/xlink">STD</literal>,
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">OBSOL</literal>, <literal xmlns:xlink="http://www.w3.org/1999/xlink">NOPROTO</literal> and
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">UNIMPL</literal>.  <literal xmlns:xlink="http://www.w3.org/1999/xlink">STD</literal> is a standard
	  syscall with full prototype and implementation.
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">OBSOL</literal> is obsolete and defines just the prototype.
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">NOPROTO</literal> means that the syscall is implemented
	  elsewhere so do not prepend ABI prefix, etc.
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">UNIMPL</literal> means that the syscall will be
	  substituted with the <function xmlns:xlink="http://www.w3.org/1999/xlink">nosys</function> syscall
	  (a syscall just printing out a message about the syscall not being
	  implemented and returning <literal xmlns:xlink="http://www.w3.org/1999/xlink">ENOSYS</literal>).</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">From <filename xmlns:xlink="http://www.w3.org/1999/xlink">syscalls.master</filename> a script generates
	  three files: <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_syscall.h</filename>,
	  <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_proto.h</filename> and
	  <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_sysent.c</filename>.  The
	  <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_syscall.h</filename> contains definitions of syscall
	  names and their numerical value, e.g.:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">...
#define LINUX_SYS_linux_fork 2
...
#define LINUX_SYS_close 6
...</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_proto.h</filename> contains structure
	  definitions of arguments to every syscall, e.g.:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct linux_fork_args {
  register_t dummy;
};</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">And finally, <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_sysent.c</filename> contains
	  structure describing the system entry table, used to actually
	  dispatch a syscall, e.g.:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */
{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close */</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">As you can see <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_fork</function> is implemented
	  in Linuxulator itself so the definition is of <literal xmlns:xlink="http://www.w3.org/1999/xlink">STD</literal>
	  type and has no argument, which is exhibited by the dummy argument
	  structure.  On the other hand <function xmlns:xlink="http://www.w3.org/1999/xlink">close</function> is just an
	  alias for real FreeBSD <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">close</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> so it has no linux arguments
	  structure associated and in the system entry table it is not prefixed
	  with linux as it calls the real <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">close</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> in the kernel.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="dummy-syscalls">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Dummy syscalls</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer is not complete, as some syscalls are
	  not implemented properly and some are not implemented at all.  The
	  emulation layer employs a facility to mark unimplemented syscalls
	  with the <literal xmlns:xlink="http://www.w3.org/1999/xlink">DUMMY</literal> macro.  These dummy definitions
	  reside in <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_dummy.c</filename> in a form of
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">DUMMY(syscall);</literal>, which is then translated to
	  various syscall auxiliary files and the implementation consists
	  of printing a message saying that this syscall is not implemented.
	  The <literal xmlns:xlink="http://www.w3.org/1999/xlink">UNIMPL</literal> prototype is not used because we want
	  to be able to identify the name of the syscall that was called in
	  order to know what syscalls are more important to implement.</para>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="signal-handling">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Signal handling</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Signal handling is done generally in the FreeBSD kernel for all
	binary compatibilities with a call to a compat-dependent layer.
	<trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> compatibility layer defines
	<function xmlns:xlink="http://www.w3.org/1999/xlink">linux_sendsig</function> routine for this purpose.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-sendsig">
	<title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> sendsig</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">This routine first checks whether the signal has been installed
	  with a <literal xmlns:xlink="http://www.w3.org/1999/xlink">SA_SIGINFO</literal> in which case it calls
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_rt_sendsig</function> routine instead.  Furthermore,
	   it allocates (or reuses an already existing) signal handle context,
	  then it builds a list of arguments for the signal handler.  It
	  translates the signal number based on the signal translation table,
	  assigns a handler, translates sigset.  Then it saves context for the
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">sigreturn</function> routine (various registers, translated
	  trap number and signal mask).  Finally, it copies out the signal
	  context to the userspace and prepares context for the actual
	  signal handler to run.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-rt-sendsig">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">linux_rt_sendsig</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">This routine is similar to <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_sendsig</function>
	  just the signal context preparation is different.  It adds
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">siginfo</literal>, <literal xmlns:xlink="http://www.w3.org/1999/xlink">ucontext</literal>, and some
	  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> parts.  It might be worth considering whether those two
	  functions could not be merged with a benefit of less code duplication
	  and possibly even faster execution.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-sigreturn">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">linux_sigreturn</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">This syscall is used for return from the signal handler.  It does
	  some security checks and restores the original process context.  It
	  also unmasks the signal in process signal mask.</para>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="ptrace">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Ptrace</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Many <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> derivates implement the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall in order
	to allow various tracking and debugging features.  This facility
	enables the tracing process to obtain various information about the
	traced process, like register dumps, any memory from the process
	address space, etc. and also to trace the process like in stepping an
	instruction or between system entries (syscalls and traps).
	<citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> also lets you set various information in the traced
	process (registers etc.).  <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> is a <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>-wide standard
	implemented in most <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark>es around the world.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation in FreeBSD implements the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> facility
	in <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_ptrace.c</filename>.  The routines for converting
	registers between <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> and FreeBSD and the actual <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry>
	syscall emulation syscall.  The syscall is a long switch block that
	implements its counterpart in FreeBSD for every <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> command.
	The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> commands are mostly equal between <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> and FreeBSD
	so usually just a small modification is needed.  For example,
	<literal xmlns:xlink="http://www.w3.org/1999/xlink">PT_GETREGS</literal> in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> operates on direct data while
	FreeBSD uses a pointer to the data so after performing a (native)
	<citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscall, a copyout must be done to preserve <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	semantics.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> implementation in Linuxulator has some known
	weaknesses.  There have been panics seen when using
	<command xmlns:xlink="http://www.w3.org/1999/xlink">strace</command> (which is a <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">ptrace</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> consumer) in the
	Linuxulator environment.  Also <literal xmlns:xlink="http://www.w3.org/1999/xlink">PT_SYSCALL</literal> is not
	implemented.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="traps">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Traps</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Whenever a <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> process running in the emulation layer traps
	the trap itself is handled transparently with the only exception of
	the trap translation.  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> and FreeBSD differs in opinion on what a
	trap is so this is dealt with here. The code is actually very
	short:</para>

      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink">static int
translate_traps(int signal, int trap_code)
{

  if (signal != SIGBUS)
    return signal;

  switch (trap_code) {

    case T_PROTFLT:
    case T_TSSFLT:
    case T_DOUBLEFLT:
    case T_PAGEFLT:
      return SIGSEGV;

    default:
      return signal;
  }
}</programlisting>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="stack-fixup">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Stack fixup</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The RTLD run-time link-editor expects so called AUX tags on stack
	during an <function xmlns:xlink="http://www.w3.org/1999/xlink">execve</function> so a fixup must be done to ensure
	this.  Of course, every RTLD system is different so the emulation layer
	must provide its own stack fixup routine to do this.  So does
	Linuxulator.  The <function xmlns:xlink="http://www.w3.org/1999/xlink">elf_linux_fixup</function> simply copies
	out AUX tags to the stack and adjusts the stack of the user space
	process to point right after those tags.  So RTLD works in a
	smart way.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="aout-support">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">A.OUT support</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer on i386 also supports <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> A.OUT
	binaries.  Pretty much everything described in the previous sections
	must be implemented for A.OUT support (beside traps translation and
	signals sending).  The support for A.OUT binaries is no longer
	maintained, especially the 2.6 emulation does not work with it but
	this does not cause any problem, as the linux-base in ports probably
	do not support A.OUT binaries at all.  This support will probably be
	removed in future.  Most of the stuff necessary for loading <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	A.OUT binaries is in <filename xmlns:xlink="http://www.w3.org/1999/xlink">imgact_linux.c</filename> file.</para>
    </sect2>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="mi">
    <title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer -MI part</title>

    <para xmlns:xlink="http://www.w3.org/1999/xlink">This section talks about machine independent part of the
      Linuxulator.  It covers the emulation infrastructure needed for <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
      2.6 emulation, the thread local storage (TLS) implementation (on i386)
      and futexes.  Then we talk briefly about some syscalls.</para>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="nptl-desc">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Description of NPTL</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">One of the major areas of progress in development of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6
	was threading.  Prior to 2.6, the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> threading support was
	implemented in the <application xmlns:xlink="http://www.w3.org/1999/xlink">linuxthreads</application> library.
	The library was a partial implementation of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> threading.  The
	threading was implemented using separate processes for each thread
	using the <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> syscall to let them share the
	address space (and other things).  The main weaknesses of this
	approach was that every thread had a different PID, signal handling
	was broken (from the pthreads perspective), etc.  Also the performance
	was not very good (use of <literal xmlns:xlink="http://www.w3.org/1999/xlink">SIGUSR</literal> signals for
	threads synchronization, kernel resource consumption, etc.) so to
	overcome these problems a new threading system was developed and
	named NPTL.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The NPTL library focused on two things but a third thing came
	along so it is usually considered a part of NPTL.  Those two things
	were embedding of threads into a process structure and futexes.  The
	additional third thing was TLS, which is not directly required by NPTL
	but the whole NPTL userland library depends on it.  Those improvements
	yielded in much improved performance and standards conformance.  NPTL
	is a standard threading library in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> systems these days.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The FreeBSD Linuxulator implementation approaches the NPTL in three
	main areas.  The TLS, futexes and PID mangling, which is meant to
	simulate the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> threads.  Further sections describe each of these
	areas.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux26-emu">
      <title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 emulation infrastructure</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">These sections deal with the way <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> threads are managed and
	how we simulate that in FreeBSD.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux26-runtime">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Runtime determining of 2.6 emulation</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer in FreeBSD supports runtime setting of
	  the emulated version.  This is done via <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sysctl</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">8</manvolnum></citerefentry>, namely
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">compat.linux.osrelease</literal>, which is set to 2.4.2 by
	  default (as of April 2007) and with all <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> versions up to 2.6
	  it just determined what <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">uname</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">1</manvolnum></citerefentry> outputs.  It is different with
	  2.6 emulation where setting this <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sysctl</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">8</manvolnum></citerefentry> affects runtime
	  behaviour of the emulation layer.  When set to 2.6.x it sets the
	  value of <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_use_linux26</literal> while setting to
	  something else keeps it unset.  This variable (plus per-prison
	  variables of the very same kind) determines whether 2.6
	  infrastructure (mainly PID mangling) is used in the code or not.
	  The version setting is done system-wide and this affects all <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	  processes.  The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">sysctl</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">8</manvolnum></citerefentry> should not be changed when running any
	  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> binary as it might harm things.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-proc-thread">
	<title xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> processes and thread identifiers</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The semantics of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> threading are a little confusing and
	  uses entirely different nomenclature to FreeBSD.  A process in
	  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> consists of a <literal xmlns:xlink="http://www.w3.org/1999/xlink">struct task</literal> embedding two
	  identifier fields - PID and TGID.  PID is <emphasis xmlns:xlink="http://www.w3.org/1999/xlink">not</emphasis>
	  a process ID but it is a thread ID.  The TGID identifies a thread
	  group in other words a process.  For single-threaded process the
	  PID equals the TGID.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The thread in NPTL is just an ordinary process that happens to
	  have TGID not equal to PID and have a group leader not equal to
	  itself (and shared VM etc. of course).  Everything else happens in
	  the same way as to an ordinary process.  There is no separation of
	  a shared status to some external structure like in FreeBSD.  This
	  creates some duplication of information and possible data
	  inconsistency.  The <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> kernel seems to use task -&gt; group
	  information in some places and task information elsewhere and it is
	  really not very consistent and looks error-prone.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Every NPTL thread is created by a call to the
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> syscall with a specific set of flags
	  (more in the next subsection).  The NPTL implements strict
	  1:1 threading.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">In FreeBSD we emulate NPTL threads with ordinary FreeBSD processes that
	  share VM space, etc. and the PID gymnastic is just mimicked in the
	  emulation specific structure attached to the process.  The
	  structure attached to the process looks like:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct linux_emuldata {
  pid_t pid;

  int *child_set_tid; /* in clone(): Child.s TID to set on clone */
  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */

  struct linux_emuldata_shared *shared;

  int pdeath_signal; /* parent death signal */

  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */
};</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The PID is used to identify the FreeBSD process that attaches this
	  structure.  The <function xmlns:xlink="http://www.w3.org/1999/xlink">child_se_tid</function> and
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">child_clear_tid</function> are used for TID address
	  copyout when a process exits and is created.  The
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">shared</varname> pointer points to a structure shared
	  among threads.  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">pdeath_signal</varname> variable
	  identifies the parent death signal  and the
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">threads</varname> pointer is used to link this structure
	  to the list of threads.  The <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_emuldata_shared</literal>
	  structure looks like:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct linux_emuldata_shared {

  int refs;

  pid_t group_pid;

  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */
};</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <varname xmlns:xlink="http://www.w3.org/1999/xlink">refs</varname> is a reference counter being used
	  to determine when we can free the structure to avoid memory leaks.
	  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">group_pid</varname> is to identify PID ( = TGID) of the
	  whole process ( = thread group).  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">threads</varname>
	  pointer is the head of the list of threads in the process.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_emuldata</literal> structure can be obtained
	  from the process using <function xmlns:xlink="http://www.w3.org/1999/xlink">em_find</function>.  The prototype
	  of the function is:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct linux_emuldata *em_find(struct proc *, int locked);</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Here, <varname xmlns:xlink="http://www.w3.org/1999/xlink">proc</varname> is the process we want the emuldata
	  structure from and the locked parameter determines whether we want to
	  lock or not.  The accepted values are <literal xmlns:xlink="http://www.w3.org/1999/xlink">EMUL_DOLOCK</literal>
	  and <literal xmlns:xlink="http://www.w3.org/1999/xlink">EMUL_DOUNLOCK</literal>.  More about locking
	  later.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="pid-mangling">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">PID mangling</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Because of the described different view knowing what a process
	  ID and thread ID is between FreeBSD and <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> we have to translate
	  the view somehow.  We do it by PID mangling.  This means that we
	  fake what a PID (=TGID) and TID (=PID) is between kernel and
	  userland.  The rule of thumb is that in kernel (in Linuxulator)
	  PID = PID and TGID = shared -&gt; group pid and to userland we
	  present <literal xmlns:xlink="http://www.w3.org/1999/xlink">PID = shared -&gt; group_pid</literal> and
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">TID = proc -&gt; p_pid</literal>.
	  The PID member of <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_emuldata structure</literal> is
	  a FreeBSD PID.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The above affects mainly getpid, getppid, gettid syscalls.  Where
	  we use PID/TGID respectively.  In copyout of TIDs in
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">child_clear_tid</function> and
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">child_set_tid</function> we copy out FreeBSD PID.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="clone-syscall">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Clone syscall</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> syscall is the way threads are
	  created in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>.  The syscall prototype looks like this:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,
void * child_tidptr);</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <varname xmlns:xlink="http://www.w3.org/1999/xlink">flags</varname> parameter tells the syscall how
	  exactly the processes should be cloned.  As described above, <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	  can create processes sharing various things independently, for
	  example two processes can share file descriptors but not VM, etc.
	  Last byte of the <varname xmlns:xlink="http://www.w3.org/1999/xlink">flags</varname> parameter is the exit
	  signal of the newly created process.  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">stack</varname>
	  parameter if non-<literal xmlns:xlink="http://www.w3.org/1999/xlink">NULL</literal> tells, where the thread
	  stack is and if it is <literal xmlns:xlink="http://www.w3.org/1999/xlink">NULL</literal> we are supposed to
	  copy-on-write the calling process stack (i.e. do what normal
	  <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">fork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> routine does).  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">parent_tidptr</varname>
	  parameter is used as an address for copying out process PID (i.e.
	  thread id) once the process is sufficiently instantiated but is
	  not runnable yet.  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">dummy</varname> parameter is here
	  because of the very strange calling convention of this syscall on
	  i386.  It uses the registers directly and does not let the compiler
	  do it what results in the need of a dummy syscall.  The
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">child_tidptr</varname> parameter is used as an address
	  for copying out PID once the process has finished forking and when
	  the process exits.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The syscall itself proceeds by setting corresponding flags
	  depending on the flags passed in.  For example,
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_VM</literal> maps to RFMEM (sharing of VM), etc.
	  The only nit here is <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_FS</literal> and
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_FILES</literal> because FreeBSD does not allow setting
	  this separately so we fake it by not setting RFFDG (copying of fd
	  table and other fs information) if either of these is defined.  This
	  does not cause any problems, because those flags are always set
	  together.  After setting the flags the process is forked using
	  the internal <function xmlns:xlink="http://www.w3.org/1999/xlink">fork1</function> routine, the process is
	  instrumented not to be put on a run queue, i.e. not to be set
	  runnable.  After the forking is done we possibly reparent the newly
	  created process to emulate <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_PARENT</literal> semantics.
	  Next part is creating the emulation data.  Threads in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> does
	  not signal their parents so we set exit signal to be 0 to disable
	  this.  After that setting of <varname xmlns:xlink="http://www.w3.org/1999/xlink">child_set_tid</varname> and
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">child_clear_tid</varname> is performed enabling the
	  functionality later in the code.  At this point we copy out the PID
	  to the address specified by <varname xmlns:xlink="http://www.w3.org/1999/xlink">parent_tidptr</varname>.  The
	  setting of process stack is done by simply rewriting thread frame
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%esp</varname> register (<varname xmlns:xlink="http://www.w3.org/1999/xlink">%rsp</varname> on amd64).
	  Next part is setting up TLS for the newly created process.  After
	  this <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vfork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> semantics might be emulated and finally the newly
	  created process is put on a run queue and copying out its PID to the
	  parent process via <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> return value is
	  done.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> syscall is able and in fact is
	  used for emulating classic <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">fork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> and <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vfork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscalls.
	  Newer glibc in a case of 2.6 kernel uses <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function>
	  to implement <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">fork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> and <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">vfork</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">2</manvolnum></citerefentry> syscalls.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="locking">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Locking</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The locking is implemented to be per-subsystem because we do not
	  expect a lot of contention on these.  There are two locks:
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">emul_lock</literal> used to protect manipulating of
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_emuldata</literal> and
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">emul_shared_lock</literal> used to manipulate
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">linux_emuldata_shared</literal>.  The
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">emul_lock</literal> is a nonsleepable blocking mutex while
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">emul_shared_lock</literal> is a sleepable blocking
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">sx_lock</literal>.  Because of the per-subsystem locking we
	  can coalesce some locks and that is why the em find offers the
	  non-locking access.</para>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="tls">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">TLS</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">This section deals with TLS also known as thread local
	storage.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="trheading-intro">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Introduction to threading</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Threads in computer science are entities within a process that
	  can be scheduled independently from each other.  The threads in the
	  process share process wide data (file descriptors, etc.) but also
	  have their own stack for their own data.  Sometimes there is a need
	  for process-wide data specific to a given thread.  Imagine a name of
	  the thread in execution or something like that.  The traditional
	  <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> threading API, <application xmlns:xlink="http://www.w3.org/1999/xlink">pthreads</application> provides
	  a way to do it via <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_key_create</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry>,
	  <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_setspecific</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> and <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_getspecific</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> where a
	  thread can create a key to the thread local data and using
	  <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_getspecific</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> or <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">pthread_getspecific</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">3</manvolnum></citerefentry> to
	  manipulate those data.  You can easily see that this is not the most
	  comfortable way this could be accomplished.  So various producers of
	  C/C++ compilers introduced a better way.  They defined a new modifier
	  keyword thread that specifies that a variable is thread specific.  A
	  new method of accessing such variables was developed as well (at
	  least on i386).  The <application xmlns:xlink="http://www.w3.org/1999/xlink">pthreads</application> method tends
	  to be implemented in userspace as a trivial lookup table.  The
	  performance of such a solution is not very good.  So the new method
	  uses (on i386) segment registers to address a segment, where TLS area
	  is stored so the actual accessing of a thread variable is just
	  appending the segment register to the address thus addressing via it.
	  The segment registers are usually <varname xmlns:xlink="http://www.w3.org/1999/xlink">%gs</varname> and
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%fs</varname> acting like segment selectors.  Every thread
	  has its own area where the thread local data are stored and the
	  segment must be loaded on every context switch.  This method is very
	  fast and used almost exclusively in the whole i386 <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">UNIX</trademark> world.
	  Both FreeBSD and <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> implement this approach and it yields very good
	  results.  The only drawback is the need to reload the segment on
	  every context switch which can slowdown context switches.  FreeBSD tries
	  to avoid this overhead by using only 1 segment descriptor for this
	  while <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> uses 3.  Interesting thing is that almost nothing uses
	  more than 1 descriptor (only <application xmlns:xlink="http://www.w3.org/1999/xlink">Wine</application> seems to
	  use 2) so <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> pays this unnecessary price for context
	  switches.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="i386-segs">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Segments on i386</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The i386 architecture implements the so called segments.  A
	  segment is a description of an area of memory.  The base address
	  (bottom) of the memory area, the end of it (ceiling), type,
	  protection, etc.  The memory described by a segment can be accessed
	  using segment selector registers (<varname xmlns:xlink="http://www.w3.org/1999/xlink">%cs</varname>,
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ds</varname>, <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ss</varname>,
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%es</varname>, <varname xmlns:xlink="http://www.w3.org/1999/xlink">%fs</varname>,
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%gs</varname>).  For example let us suppose we have a
	  segment which base address is 0x1234 and length and this code:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">mov %edx,%gs:0x10</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">This will load the content of the <varname xmlns:xlink="http://www.w3.org/1999/xlink">%edx</varname>
	  register into memory location 0x1244.  Some segment registers have
	  a special use, for example <varname xmlns:xlink="http://www.w3.org/1999/xlink">%cs</varname> is used for code
	  segment and <varname xmlns:xlink="http://www.w3.org/1999/xlink">%ss</varname> is used for stack segment but
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">%fs</varname> and <varname xmlns:xlink="http://www.w3.org/1999/xlink">%gs</varname> are generally
	  unused.  Segments are either stored in a global GDT table or in a
	  local LDT table.  LDT is accessed via an entry in the GDT.  The
	  LDT can store more types of segments.  LDT can be per process.
	  Both tables define up to 8191 entries.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="linux-i386">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Implementation on <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> i386</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">There are two main ways of setting up TLS in <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>.  It can be
	  set when cloning a process using the <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function>
	  syscall or it can call <function xmlns:xlink="http://www.w3.org/1999/xlink">set_thread_area</function>.  When a
	  process passes <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SETTLS</literal> flag to
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function>, the kernel expects the memory pointed to
	  by the <varname xmlns:xlink="http://www.w3.org/1999/xlink">%esi</varname> register a <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> user space
	  representation of a segment, which gets translated to the machine
	  representation of a segment and loaded into a GDT slot.  The
	  GDT slot can be specified with a number or -1 can be used meaning
	  that the system itself should choose the first free slot.  In
	  practice, the vast majority of programs use only one TLS entry and
	  does not care about the number of the entry.  We exploit this in the
	  emulation and in fact depend on it.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="tls-emu">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Emulation of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> TLS</title>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="tls-i386">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">i386</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Loading of TLS for the current thread happens by calling
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">set_thread_area</function> while loading TLS for a
	    second process in <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function> is done in the
	    separate block in <function xmlns:xlink="http://www.w3.org/1999/xlink">clone</function>.  Those two functions
	    are very similar.  The only difference being the actual loading of
	    the GDT segment, which happens on the next context switch for the
	    newly created process while <function xmlns:xlink="http://www.w3.org/1999/xlink">set_thread_area</function>
	    must load this directly.  The code basically does this.  It copies
	    the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> form segment descriptor from the userland.  The code
	    checks for the number of the descriptor but because this differs
	    between FreeBSD and <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> we fake it a little.  We only support
	    indexes of 6, 3 and -1.  The 6 is genuine <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> number, 3 is
	    genuine FreeBSD one and -1 means autoselection.  Then we set the
	    descriptor number to constant 3 and copy out this to the
	    userspace.  We rely on the userspace process using the number from
	    the descriptor but this works most of the time (have never seen a
	    case where this did not work) as the userspace process typically
	    passes in 1.  Then we convert the descriptor from the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> form
	    to a machine dependant form (i.e. operating system independent
	    form) and copy this to the FreeBSD defined segment descriptor.
	    Finally we can load it.  We assign the descriptor to threads PCB
	    (process control block) and load the <varname xmlns:xlink="http://www.w3.org/1999/xlink">%gs</varname>
	    segment using <function xmlns:xlink="http://www.w3.org/1999/xlink">load_gs</function>.  This loading must be
	    done in a critical section so that nothing can interrupt us.
	    The <literal xmlns:xlink="http://www.w3.org/1999/xlink">CLONE_SETTLS</literal> case works exactly like this
	    just the loading using <function xmlns:xlink="http://www.w3.org/1999/xlink">load_gs</function> is not
	    performed.  The segment used for this (segment number 3) is
	    shared for this use between FreeBSD processes and <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> processes
	    so the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer does not add any overhead over
	    plain FreeBSD.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="tls-amd64">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">amd64</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The amd64 implementation is similar to the i386 one but there
	    was initially no 32bit segment descriptor used for this purpose
	    (hence not even native 32bit TLS users worked) so we had to add
	    such a segment and implement its loading on every context switch
	    (when a flag signaling use of 32bit is set).  Apart from this the
	    TLS loading is exactly the same just the segment numbers are
	    different and the descriptor format and the loading differs
	    slightly.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futexes">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Futexes</title>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="sync-intro">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Introduction to synchronization</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Threads need some kind of synchronization and <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> provides
	  some of them: mutexes for mutual exclusion, read-write locks for
	  mutual exclusion with biased ratio of reads and writes and condition
	  variables for signaling a status change.  It is interesting to note
	  that <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">POSIX</trademark> threading API lacks support for semaphores.  Those
	  synchronization routines implementations are heavily dependant on
	  the type threading support we have.  In pure 1:M (userspace) model
	  the implementation can be solely done in userspace and thus be very
	  fast (the condition variables will probably end up being implemented
	  using signals, i.e. not fast) and simple.  In 1:1 model, the
	  situation is also quite clear - the threads must be synchronized
	  using kernel facilities (which is very slow because a syscall must be
	  performed).  The mixed M:N scenario just combines the first and
	  second approach or rely solely on kernel.  Threads synchronization is
	  a vital part of thread-enabled programming and its performance can
	  affect resulting program a lot.  Recent benchmarks on FreeBSD operating
	  system showed that an improved sx_lock implementation yielded 40%
	  speedup in <firstterm xmlns:xlink="http://www.w3.org/1999/xlink">ZFS</firstterm> (a heavy sx user), this
	  is in-kernel stuff but it shows clearly how important the performance
	  of synchronization primitives is.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Threaded programs should be written with as little contention on
	  locks as possible.  Otherwise, instead of doing useful work the
	  thread just waits on a lock.  Because of this, the most well written
	  threaded programs show little locks contention.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-intro">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Futexes introduction</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> implements 1:1 threading, i.e. it has to use in-kernel
	  synchronization primitives.  As stated earlier, well written threaded
	  programs have little lock contention.  So a typical sequence
	  could be performed as two atomic increase/decrease mutex reference
	  counter, which is very fast, as presented by the following
	  example:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">pthread_mutex_lock(&amp;mutex);
....
pthread_mutex_unlock(&amp;mutex);</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">1:1 threading forces us to perform two syscalls for those mutex
	  calls, which is very slow.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The solution <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6 implements is called futexes.
	  Futexes implement the check for contention in userspace and call
	  kernel primitives only in a case of contention.  Thus the typical
	  case takes place without any kernel intervention.  This yields
	  reasonably fast and flexible synchronization primitives
	  implementation.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-api">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Futex API</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The futex syscall looks like this:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">int futex(void *uaddr, int op, int val, struct timespec *timeout, void *uaddr2, int val3);</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">In this example <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname> is an address of the
	  mutex in userspace, <varname xmlns:xlink="http://www.w3.org/1999/xlink">op</varname> is an operation we are
	  about to perform and the other parameters have per-operation
	  meaning.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Futexes implement the following operations:</para>

	<itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAIT</literal></para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE</literal></para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_FD</literal></para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_REQUEUE</literal></para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_CMP_REQUEUE</literal></para>
	  </listitem>
	  <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE_OP</literal></para>
	  </listitem>
	</itemizedlist>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-wait">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAIT</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operation verifies that on address
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname> the value <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname>
	    is written.  If not, <literal xmlns:xlink="http://www.w3.org/1999/xlink">EWOULDBLOCK</literal> is
	    returned, otherwise the thread is queued on the futex and gets
	    suspended.  If the argument <varname xmlns:xlink="http://www.w3.org/1999/xlink">timeout</varname> is
	    non-zero it specifies the maximum time for the sleeping,
	    otherwise the sleeping is infinite.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-wake">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operation takes a futex at <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname>
	    and wakes up <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname> first futexes queued
	    on this futex.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-fd">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_FD</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operations associates a file descriptor with a given
	    futex.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-requeue">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_REQUEUE</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operation takes <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname> threads
	    queued on futex at <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname>, wakes them up,
	    and takes <varname xmlns:xlink="http://www.w3.org/1999/xlink">val2</varname> next threads and requeues them
	    on futex at <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr2</varname>.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-cmp-requeue">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_CMP_REQUEUE</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operation does the same as
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_REQUEUE</literal> but it checks that
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">val3</varname> equals to <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname>
	    first.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-wake-op">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE_OP</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">This operation performs an atomic operation on
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">val3</varname> (which contains coded some other value)
	    and <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname>.  Then it wakes up
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname> threads on futex at
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname> and if the atomic operation returned a
	    positive number it wakes up <varname xmlns:xlink="http://www.w3.org/1999/xlink">val2</varname> threads on
	    futex at <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr2</varname>.</para>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The operations implemented in
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE_OP</literal>:</para>

	  <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_OP_SET</literal></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_OP_ADD</literal></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_OP_OR</literal></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_OP_AND</literal></para>
	    </listitem>
	    <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	      <para xmlns:xlink="http://www.w3.org/1999/xlink"><literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_OP_XOR</literal></para>
	    </listitem>
	  </itemizedlist>

	  <note xmlns:xlink="http://www.w3.org/1999/xlink">
	    <para xmlns:xlink="http://www.w3.org/1999/xlink">There is no <varname xmlns:xlink="http://www.w3.org/1999/xlink">val2</varname> parameter in the
	      futex prototype.  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">val2</varname> is taken from the
	      <varname xmlns:xlink="http://www.w3.org/1999/xlink">struct timespec *timeout</varname> parameter
	      for operations <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_REQUEUE</literal>,
	      <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_CMP_REQUEUE</literal> and
	      <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE_OP</literal>.</para>
	  </note>
	</sect4>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-emu">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Futex emulation in FreeBSD</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The futex emulation in FreeBSD is taken from NetBSD and further
	  extended by us.  It is placed in <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_futex.c</filename>
	  and <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_futex.h</filename> files.  The
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">futex</literal> structure looks like:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct futex {
  void *f_uaddr;
  int f_refcount;

  LIST_ENTRY(futex) f_list;

  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;
};</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">And the structure <literal xmlns:xlink="http://www.w3.org/1999/xlink">waiting_proc</literal> is:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">struct waiting_proc {

  struct thread *wp_t;

  struct futex *wp_new_futex;

  TAILQ_ENTRY(waiting_proc) wp_list;
};</programlisting>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-get">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">futex_get / futex_put</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">A futex is obtained using the <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_get</function>
	    function, which searches a linear list of futexes and returns the
	    found one or creates a new futex.  When releasing a futex from the
	    use we call the <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_put</function> function, which
	    decreases a reference counter of the futex and if the refcount
	    reaches zero it is released.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-sleep">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">futex_sleep</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">When a futex queues a thread for sleeping it creates a
	    <literal xmlns:xlink="http://www.w3.org/1999/xlink">working_proc</literal> structure and puts this structure
	    to the list inside the futex structure then it just performs a
	    <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">tsleep</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> to suspend the thread.  The sleep can be timed out.
	    After <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">tsleep</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> returns (the thread was woken up or it timed
	    out) the <literal xmlns:xlink="http://www.w3.org/1999/xlink">working_proc</literal> structure is removed
	    from the list and is destroyed.  All this is done in the
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_sleep</function> function.  If we got woken up
	    from <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_wake</function> we have
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">wp_new_futex</varname> set so we sleep on it.  This way
	    the actual requeueing is done in this function.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-wake-2">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">futex_wake</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Waking up a thread sleeping on a futex is performed in the
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_wake</function> function.  First in this function
	    we mimic the strange <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> behaviour, where it wakes up N threads
	    for all operations, the only exception is that the REQUEUE
	    operations are performed on N+1 threads.  But this usually does not
	    make any difference as we are waking up all threads.  Next in the
	    function in the loop we wake up n threads, after this we check if
	    there is a new futex for requeueing.  If so, we requeue up to n2
	    threads on the new futex.  This cooperates with
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">futex_sleep</function>.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-wake-op-2">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">futex_wake_op</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The <literal xmlns:xlink="http://www.w3.org/1999/xlink">FUTEX_WAKE_OP</literal> operation is quite
	    complicated.  First we obtain two futexes at addresses
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname> and <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr2</varname> then we
	    perform the atomic operation using <varname xmlns:xlink="http://www.w3.org/1999/xlink">val3</varname> and
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr2</varname>.  Then <varname xmlns:xlink="http://www.w3.org/1999/xlink">val</varname> waiters
	    on the first futex is woken up and if the atomic operation
	    condition holds we wake up <varname xmlns:xlink="http://www.w3.org/1999/xlink">val2</varname> (i.e.
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">timeout</varname>) waiter on the second futex.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-atomic-op">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">futex atomic operation</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The atomic operation takes two parameters
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">encoded_op</varname> and <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname>.
	    The encoded operation encodes the operation itself,
	    comparing value, operation argument, and comparing argument.
	    The pseudocode for the operation is like this one:</para>

	  <programlisting xmlns:xlink="http://www.w3.org/1999/xlink">oldval = *uaddr2
*uaddr2 = oldval OP oparg</programlisting>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">And this is done atomically.  First a copying in of the number
	    at <varname xmlns:xlink="http://www.w3.org/1999/xlink">uaddr</varname> is performed and the operation is
	    done.  The code handles page faults and if no page fault occurs
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">oldval</varname> is compared to
	    <varname xmlns:xlink="http://www.w3.org/1999/xlink">cmparg</varname> argument with cmp comparator.</para>
	</sect4>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="futex-locking">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Futex locking</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Futex implementation uses two lock lists protecting
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">sx_lock</function> and global locks (either Giant
	    or another <function xmlns:xlink="http://www.w3.org/1999/xlink">sx_lock</function>).  Every operation is
	    performed locked from the start to the very end.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="syscall-impl">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Various syscalls implementation</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">In this section I am going to describe some smaller syscalls that
	are worth mentioning because their implementation is not obvious or
	those syscalls are interesting from other point of view.</para>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="syscall-at">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">*at family of syscalls</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">During development of <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6.16 kernel, the *at syscalls
	  were added.  Those syscalls (<function xmlns:xlink="http://www.w3.org/1999/xlink">openat</function> for example)
	  work exactly like their at-less counterparts with the slight
	  exception of the <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> parameter.  This
	  parameter changes where the given file, on which the syscall is to be
	  performed, is.  When the <varname xmlns:xlink="http://www.w3.org/1999/xlink">filename</varname> parameter is
	  absolute <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> is ignored but when the path to
	  the file is relative, it comes to the play.  The
	  <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> parameter is a directory relative to which
	  the relative pathname is checked.  The <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname>
	  parameter is a file descriptor of some directory or
	  <literal xmlns:xlink="http://www.w3.org/1999/xlink">AT_FDCWD</literal>.  So for example the
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">openat</function> syscall can be like this:</para>

	<programlisting xmlns:xlink="http://www.w3.org/1999/xlink">file descriptor 123 = /tmp/foo/, current working directory = /tmp/

openat(123, /tmp/bah\, flags, mode)	/* opens /tmp/bah */
openat(123, bah\, flags, mode)		/* opens /tmp/foo/bah */
openat(AT_FDWCWD, bah\, flags, mode)	/* opens /tmp/bah */
openat(stdio, bah\, flags, mode)	/* returns error because stdio is not a directory */</programlisting>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">This infrastructure is necessary to avoid races when opening
	  files outside the working directory.  Imagine that a process consists
	  of two threads, thread A and thread B.  Thread A
	  issues <literal xmlns:xlink="http://www.w3.org/1999/xlink">open(./tmp/foo/bah., flags, mode)</literal> and
	  before returning it gets preempted and thread B runs.
	  Thread B does not care about the needs of thread A and
	  renames or removes <filename xmlns:xlink="http://www.w3.org/1999/xlink">/tmp/foo/</filename>.  We got a race.
	  To avoid this we can open <filename xmlns:xlink="http://www.w3.org/1999/xlink">/tmp/foo</filename> and use it
	  as <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> for <function xmlns:xlink="http://www.w3.org/1999/xlink">openat</function>
	  syscall.  This also enables user to implement per-thread
	  working directories.</para>

	<para xmlns:xlink="http://www.w3.org/1999/xlink"><trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> family of *at syscalls contains:
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_openat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_mkdirat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_mknodat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_fchownat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_futimesat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_fstatat64</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_unlinkat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_renameat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_linkat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_symlinkat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_readlinkat</function>,
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_fchmodat</function> and
	  <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_faccessat</function>.  All these are implemented
	  using the modified <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> routine and simple
	  wrapping layer.</para>

	<sect4 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="implementation">
	  <title xmlns:xlink="http://www.w3.org/1999/xlink">Implementation</title>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">The implementation is done by altering the
	     <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> routine (described above) to take
	     additional parameter <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> in its
	     <literal xmlns:xlink="http://www.w3.org/1999/xlink">nameidata</literal> structure, which specifies the
	     starting point of the pathname lookup instead of using the
	     current working directory every time.  The resolution of
	     <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> from file descriptor number to a
	     vnode is done in native *at syscalls.  When
	     <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> is <literal xmlns:xlink="http://www.w3.org/1999/xlink">AT_FDCWD</literal> the
	     <varname xmlns:xlink="http://www.w3.org/1999/xlink">dvp</varname> entry in <literal xmlns:xlink="http://www.w3.org/1999/xlink">nameidata</literal>
	     structure is <literal xmlns:xlink="http://www.w3.org/1999/xlink">NULL</literal> but when
	     <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> is a different number we obtain a
	     file for this file descriptor, check whether this file
	     is valid and if there is vnode attached to it then we get a vnode.
	     Then we check this vnode for being a directory.  In the actual
	     <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> routine we simply substitute the
	     <varname xmlns:xlink="http://www.w3.org/1999/xlink">dvp</varname> vnode for <varname xmlns:xlink="http://www.w3.org/1999/xlink">dp</varname> variable
	     in the <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> function, which determines the
	     starting point.  The <citerefentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"><refentrytitle xmlns:xlink="http://www.w3.org/1999/xlink">namei</refentrytitle><manvolnum xmlns:xlink="http://www.w3.org/1999/xlink">9</manvolnum></citerefentry> is not used
	     directly but via a trace of different functions on various
	     levels.  For example the <function xmlns:xlink="http://www.w3.org/1999/xlink">openat</function> goes like
	     this:</para>

	  <programlisting xmlns:xlink="http://www.w3.org/1999/xlink">openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()</programlisting>

	  <para xmlns:xlink="http://www.w3.org/1999/xlink">For this reason <function xmlns:xlink="http://www.w3.org/1999/xlink">kern_open</function> and
	    <function xmlns:xlink="http://www.w3.org/1999/xlink">vn_open</function> must be altered to incorporate
	    the additional <varname xmlns:xlink="http://www.w3.org/1999/xlink">dirfd</varname> parameter.  No compat
	    layer is created for those because there are not many users of
	    this and the users can be easily converted.  This general
	    implementation enables FreeBSD to implement their own *at syscalls.
	    This is being discussed right now.</para>
	</sect4>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="ioctl">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Ioctl</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">The ioctl interface is quite fragile due to its generality.
	  We have to bear in mind that devices differ between <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> and FreeBSD
	  so some care must be applied to do ioctl emulation work right.  The
	  ioctl handling is implemented in <filename xmlns:xlink="http://www.w3.org/1999/xlink">linux_ioctl.c</filename>,
	  where <function xmlns:xlink="http://www.w3.org/1999/xlink">linux_ioctl</function> function is defined.  This
	  function simply iterates over sets of ioctl handlers to find a
	  handler that implements a given command.  The ioctl syscall has three
	  parameters, the file descriptor, command and an argument.  The
	  command is a 16-bit number, which in theory is divided into high
	  8 bits determining class of the ioctl command and low
	  8 bits, which are the actual command within the given set.
	  The emulation takes advantage of this division.  We implement
	  handlers for each set, like <function xmlns:xlink="http://www.w3.org/1999/xlink">sound_handler</function>
	  or <function xmlns:xlink="http://www.w3.org/1999/xlink">disk_handler</function>.  Each handler has a maximum
	  command and a minimum command defined, which is used for determining
	  what handler is used.  There are slight problems with this approach
	  because <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> does not use the set division consistently so
	  sometimes ioctls for a different set are inside a set they should
	  not belong to (SCSI generic ioctls inside cdrom set, etc.).  FreeBSD
	  currently does not implement many <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> ioctls (compared to
	  NetBSD, for example) but the plan is to port those from NetBSD.
	  The trend is to use <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> ioctls even in the native FreeBSD drivers
	  because of the easy porting of applications.</para>
      </sect3>

      <sect3 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="debugging">
	<title xmlns:xlink="http://www.w3.org/1999/xlink">Debugging</title>

	<para xmlns:xlink="http://www.w3.org/1999/xlink">Every syscall should be debuggable.  For this purpose we
	  introduce a small infrastructure.  We have the ldebug facility, which
	  tells whether a given syscall should be debugged (settable via a
	  sysctl).  For printing we have LMSG and ARGS macros.  Those are used
	  for altering a printable string for uniform debugging messages.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="conclusion">
    <title xmlns:xlink="http://www.w3.org/1999/xlink">Conclusion</title>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="results">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Results</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">As of April 2007 the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> emulation layer is capable of
	emulating the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> 2.6.16 kernel quite well.  The remaining
	problems concern futexes, unfinished *at family of syscalls,
	problematic signals delivery, missing <function xmlns:xlink="http://www.w3.org/1999/xlink">epoll</function> and
	<function xmlns:xlink="http://www.w3.org/1999/xlink">inotify</function> and probably some bugs we have not
	discovered yet.  Despite this we are capable of running basically all
	the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> programs included in FreeBSD Ports Collection with
	Fedora Core 4 at 2.6.16 and there are some rudimentary
	reports of success with Fedora Core 6 at 2.6.16.  The
	Fedora Core 6	linux_base was recently committed enabling
	some further testing of the emulation layer and giving us some more
	hints where we should put our effort in implementing missing
	stuff.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">We are able to run the most used applications like
	<package xmlns:xlink="http://www.w3.org/1999/xlink">www/linux-firefox</package>,
	<package xmlns:xlink="http://www.w3.org/1999/xlink">www/linux-opera</package>,
	<package xmlns:xlink="http://www.w3.org/1999/xlink">net-im/skype</package> and some games from
	the Ports Collection.  Some of the programs exhibit bad behaviour
	under 2.6 emulation but this is currently under investigation and
	hopefully will be fixed soon.  The only big application that is
	known not to work is the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">Java</trademark> Development Kit and this is
	because of the requirement of <function xmlns:xlink="http://www.w3.org/1999/xlink">epoll</function>
	facility which is not directly related to the <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark>
	kernel 2.6.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">We hope to enable 2.6.16 emulation by default some time after
	FreeBSD 7.0 is released at least to expose the 2.6 emulation parts for
	some wider testing.  Once this is done we can switch to
	Fedora Core 6 linux_base, which is the ultimate plan.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="future-work">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Future work</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Future work should focus on fixing the remaining issues with
	futexes, implement the rest of the *at family of syscalls, fix the
	signal delivery and possibly implement the <function xmlns:xlink="http://www.w3.org/1999/xlink">epoll</function>
	and <function xmlns:xlink="http://www.w3.org/1999/xlink">inotify</function> facilities.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">We hope to be able to run the most important programs flawlessly
	soon, so we will be able to switch to the 2.6 emulation by default and
	make the Fedora Core 6 the default linux_base because our
	currently used Fedora Core 4 is not supported any
	more.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">The other possible goal is to share our code with NetBSD and
	DragonflyBSD.  NetBSD has some support for 2.6 emulation but its far
	from finished and not really tested.  DragonflyBSD has expressed some
	interest in porting the 2.6 improvements.</para>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">Generally, as <trademark xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" class="registered">Linux</trademark> develops we would like to keep up with their
	development, implementing newly added syscalls.  Splice comes to mind
	first.  Some already implemented syscalls are also heavily crippled,
	for example <function xmlns:xlink="http://www.w3.org/1999/xlink">mremap</function> and others.  Some performance
	improvements can also be made, finer grained locking and others.</para>
    </sect2>

    <sect2 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="team">
      <title xmlns:xlink="http://www.w3.org/1999/xlink">Team</title>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">I cooperated on this project with (in alphabetical order):</para>

      <itemizedlist xmlns:xlink="http://www.w3.org/1999/xlink">
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">John Baldwin <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">jhb@FreeBSD.org</email></para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Konstantin Belousov <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">kib@FreeBSD.org</email></para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Emmanuel Dreyfus</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Scot Hetzel</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Jung-uk Kim <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">jkim@FreeBSD.org</email></para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Alexander Leidinger <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">netchild@FreeBSD.org</email></para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Suleiman Souhlal <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">ssouhlal@FreeBSD.org</email></para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">Li Xiao</para>
	</listitem>
	<listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	  <para xmlns:xlink="http://www.w3.org/1999/xlink">David Xu <email xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">davidxu@FreeBSD.org</email></para>
	</listitem>
      </itemizedlist>

      <para xmlns:xlink="http://www.w3.org/1999/xlink">I would like to thank all those people for their advice, code
	reviews and general support.</para>
    </sect2>
  </sect1>

  <sect1 xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="literatures">
    <title xmlns:xlink="http://www.w3.org/1999/xlink">Literatures</title>

    <orderedlist xmlns:xlink="http://www.w3.org/1999/xlink">
      <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	<para xmlns:xlink="http://www.w3.org/1999/xlink">Marshall Kirk McKusick - George V. Nevile-Neil. Design
	  and Implementation of the FreeBSD operating system. Addison-Wesley,
	  2005.</para>
      </listitem>
      <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	<para xmlns:xlink="http://www.w3.org/1999/xlink"><uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri></para>
      </listitem>
      <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	<para xmlns:xlink="http://www.w3.org/1999/xlink"><uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://tldp.org">http://tldp.org</uri></para>
      </listitem>
      <listitem xmlns:xlink="http://www.w3.org/1999/xlink">
	<para xmlns:xlink="http://www.w3.org/1999/xlink"><uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.linux.org">http://www.linux.org</uri></para>
     </listitem>
    </orderedlist>
  </sect1>
</article>
