<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>4.9. Daemon、信號及終止程序</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="FreeBSD 使用手冊" /><link rel="up" href="basics.html" title="章 4. UNIX 基礎概念" /><link rel="prev" href="basics-processes.html" title="4.8. 程序" /><link rel="next" href="shells.html" title="4.10. Shells" /><link rel="copyright" href="legalnotice.html" title="Copyright" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.9. Daemon、信號及終止程序</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="basics-processes.html">前一頁</a> </td><th width="60%" align="center">章 4. UNIX 基礎概念</th><td width="20%" align="right"> <a accesskey="n" href="shells.html">下一頁</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="basics-daemons"></a>4.9. Daemon、信號及終止程序</h2></div></div></div><p>當在執行文書編輯器時，您可以很容易地使用它，叫它讀取檔案或是什麼的。
      可以這樣做是因為編輯器有提供這些功能，
      還有就是編輯器依附在一個<em class="firstterm">終端機 (Terminal) </em>之上。
      有些程式並不是設計成一直在接收使用者的輸入的，
      所以它們在一開始執行的時候就從終端機斷開了。 例如說，
      網頁伺服器整天都在回應網頁方面的要求，它通常不需要您輸入任何東西。
      另外，像是把信從一個站傳送到另一個站的程式，也是這種類型的應用程式。
      </p><p>我們把這種程式稱作 <em class="firstterm">daemon</em>。
      Daemon (惡魔、守護神)
      是希臘神話中的角色：祂們不屬於善良陣營或邪惡陣營，是守護的小精靈。
      大致上來說祂們就是在替人類做一些有用的事情，
      跟今天的網頁伺服器或是郵件伺服器很像。  這也就是為何 BSD
      的吉祥物，長期以來都是一隻穿著帆布鞋拿著三叉耙的快樂小惡魔的原因。</p><p>通常來說 deamon 程式的名字後面都會加一個字母 <span class="quote">“<span class="quote">d</span>”</span>。
      <span class="application">BIND</span> 是 Berkeley Internet Name Domain
      的縮寫 (但實際上執行的程式名稱是 <code class="command">named</code>)、Apache
      網頁伺服器的程式名稱是 <code class="command">httpd</code>、印表機服務程式是
      <code class="command">lpd</code>，依此類推。
      這是習慣用法，並沒有硬性規定，例如 <span class="application">Sendmail</span>
      主要的寄信 daemon 是叫做 <code class="command">sendmail</code> 而不是
      <code class="command">maild</code>，跟您想像的不一樣。</p><p>有些時候會需要跟某個 daemon 程序溝通，
      這些溝通是透過所謂的<em class="firstterm">信號(signal)</em>來傳遞給該 daemon
      程序(或是其他執行中的程序)。
      藉由送出信號，您可以和一個 daemon (或是任何一個正在跑的程序) 溝通。
      信號有很多種——有些有特定的意義，有些則是會由應用程式來解讀。
      應用程式的說明文件會告訴您該程式是如何解讀信號的。
      您只能送信號給您擁有的程序，送 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> 或 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">kill</span>(2)</span></a>
      的信號給別人的程序是不被允許的。 不過 <code class="systemitem"> root </code>
      不受此限制，他可以送信號給任何人的程序。</p><p>FreeBSD 本身在某些情況也會送信號給應用程式。
      假設有個應用程式寫得很爛，然後企圖要存取它不該碰的記憶體的時候，FreeBSD
      會送一個 <em class="firstterm">Segmentation Violation</em> 信號
      (<code class="literal">SIGSEGV</code>) 給這個程序。
      又如果有一個應用程式用了 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=alarm&amp;sektion=3"><span class="citerefentry"><span class="refentrytitle">alarm</span>(3)</span></a> 的 system call
      要求系統在過一段時間之後叫他一下，時間到了的時候鬧鐘的信號
      (<code class="literal">SIGALRM</code>) 就會被送出了，其他的依此類推。</p><p><code class="literal">SIGTERM</code> and <code class="literal">SIGKILL</code>
      這兩個信號可以拿來終止程序。 用 <code class="literal">SIGTERM</code>
      結束程序是比較有禮貌的方式，該程序會<span class="emphasis"><em>捕捉 (catch) </em></span>
      這個信號而了解到您想要把他關掉。 接著下來它會把它自已開的記錄檔通通關掉，
      然後在關掉程序之前結束掉手邊的工作。 在某些情況下程序有可能會裝作沒看見
      <code class="literal">SIGTERM</code>，假如它正在做一些不能中斷的工作的話。</p><p><code class="literal">SIGKILL</code> 就沒有辦法被程序忽略了。
      這是一個<span class="quote">“<span class="quote">我管你正在幹嘛，現在就給我停下來</span>”</span>的信號。
      如果您送了 <code class="literal">SIGKILL</code> 信號給某個程序，FreeBSD
      將會把它停掉<a href="#ftn.idp70413392" class="footnote" id="idp70413392"><sup class="footnote">[4]</sup></a>。</p><p>這些是其他您有可能會要用到的信號：
      <code class="literal">SIGHUP</code>，<code class="literal">SIGUSR1</code>，以及
      <code class="literal">SIGUSR2</code>。
      這些是通用的信號，當送出時不同的應用程式會有不同的反應。</p><p>假設您更動了您的網頁伺服器的設定檔——
      您想要叫網頁伺服器去重新讀取設定值。 您可以關閉後再重新啟動
      <code class="command">httpd</code>，但是這麼做會造成網頁伺服器暫停服務一段時間，
      這樣子可能不太好。
      大部份的 daemon 都寫成會去回應 <code class="literal">SIGHUP</code>。
      當收到這個信號之後，它們會去重新讀取自已的設定檔。
      因此您可以用送 <code class="literal">SIGHUP</code> 信號來取代關掉重開。
      又因為沒有標準在規範如何回應這些信號，不同的 daemon
      可能會有不同的行為，所以有疑問的話請先確認並翻閱 deamon
      的說明文件。</p><p>信號是由 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> 指令送出的，如範例所示：</p><div class="procedure"><a id="idp70419152"></a><div class="procedure-title">過程 4.1. 送信號給程序</div><p>這個範例將會示範如何送一個信號給 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>。
        <code class="command">inetd</code> 的設定檔是
        <code class="filename">/etc/inetd.conf</code>，而 <code class="command">inetd</code>
        會在收到 <code class="literal">SIGHUP</code> 的時候重新讀取這個設定檔。</p><ol class="procedure" type="1"><li class="step"><p>找出您想要送信號的那個程序的 ID。 您會用到 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> 以及
          <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a> 這兩個指令。  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=grep&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">grep</span>(1)</span></a> 是用來在輸出中搜尋，
	  找出您指定的字串。  這個指令是由一般使用者執行，而 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a>
          是由 <code class="systemitem">root</code> 執行，所以在使用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> 時需要加上
	  <code class="option">ax</code> 選項。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ps -ax | grep inetd</code></strong>
  198  ??  IWs    0:00.00 inetd -wW</pre><p>因此可知 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> 的 PID 為 198。  在某些情況下
	  <code class="literal">grep inetd</code> 這個指令本身也會出現在輸出裡。
          這是因為 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ps&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ps</span>(1)</span></a> 乃是找所有執行中的程序的方式造成的。</p></li><li class="step"><p>用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a> 來送信號。 又因為 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=inetd&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">inetd</span>(8)</span></a> 是由
	  <code class="systemitem">root</code> 執行的，您必須用 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=su&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">su</span>(1)</span></a> 切換成
          <code class="systemitem">root</code>先。</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>su</code></strong>
<code class="prompt">Password:</code>
<code class="prompt">#</code> <strong class="userinput"><code>/bin/kill -s HUP 198</code></strong></pre><p>一般情況對大多數 <span class="trademark">UNIX</span>® 指令來講，當 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a>
	  執行成功時並不會輸出任何訊息。
	  假設您送一個信號給某個不是您所擁有的程序，
	  那麼您就會吃到這個錯誤訊息： <span class="errorname">kill:
	  <em class="replaceable"><code>PID</code></em>: Operation not permitted</span>。
	  而如果您打錯 PID 的話，那就會把信號送給錯誤的程序。 這樣可能會很糟，
	  不過如果您夠幸運的話，可能剛好就只是把信號送給一個非使用中的
	  PID，那您就只會看到 <span class="errorname">kill:
	  <em class="replaceable"><code>PID</code></em>: No such process</span> 而已。
	  </p><div xmlns="" class="note"><h3 class="admontitle">為什麼用 <code xmlns="http://www.w3.org/1999/xhtml" class="command">/bin/kill</code>？: </h3><p xmlns="http://www.w3.org/1999/xhtml">很多 shell 有提供內建的 <code class="command">kill</code> 指令。
	    也就是說這種 shell 會直接送信號，而不是執行
	    <code class="filename">/bin/kill</code>。
	    這樣是蠻方便的沒錯啦，但是不同的 shell
	    會有不同的語法來指定信號的名稱等。
	    與其嘗試去把它們通通學會，不如就單純的直接用 <code class="command">/bin/kill
	    ...</code> 吧。</p></div></li></ol></div><p>要送其他的信號的話也是非常類似，就視需要把指令中的
      <code class="literal">TERM</code> 或 <code class="literal">KILL</code>
      替換掉即可。</p><div xmlns="" class="important"><h3 class="admontitle">重要: </h3><p xmlns="http://www.w3.org/1999/xhtml">隨便抓一個系統中的程序然後把他砍掉並不是個好主意。
        特別是 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=init&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">init</span>(8)</span></a>， process ID 1，一個非常特別的程序。
        執行 <code class="command">/bin/kill -s KILL 1</code>
        的結果就是系統立刻關機。 因此在您按下 <span class="keycap"><strong>Return</strong></span>
        要執行 <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=kill&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">kill</span>(1)</span></a><span class="emphasis"><em>之前</em></span>，
        請<span class="emphasis"><em>一定</em></span>要記得再次確認您下的參數。</p></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp70413392" class="footnote"><p><a href="#idp70413392" class="para"><sup class="para">[4] </sup></a>不完全正確——還是有少數東西不能被中斷。
	  例如有個程序正在從網路上的別的電腦讀一個檔案，
	  而那部電腦因為某些理由連不到 (機器被關掉，或是網路爛掉了)，
	  那這個程序我們就說他是一個<span class="quote">“<span class="quote">不能中斷的</span>”</span>程序。
	  通常在經過兩分鐘左右之後這個程序會逾時。
	  當發生逾時的時候這個程序就會被結束掉了。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="basics-processes.html">前一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="basics.html">上一層</a></td><td width="40%" align="right"> <a accesskey="n" href="shells.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">4.8. 程序 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 4.10. Shells</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>本文及其他文件，可由此下載：
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a>。</small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>若有 FreeBSD 方面疑問，請先閱讀
    <a href="http://www.FreeBSD.org/docs.html">FreeBSD 相關文件</a>，如不能解決的話，再洽詢
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;。<br></br>
    關於本文件的問題，請洽詢
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;。</small></p></body></html>