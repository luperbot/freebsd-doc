<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook XML V4.5-Based Extension//EN"
	"../../../share/xml/freebsd45.dtd" [
<!ENTITY bibliography SYSTEM "../../../share/xml/bibliography.xml">
]>

<!-- The FreeBSD Traditional Chinese Documentation Project -->
<!-- Original Revision: 1.772 -->

<book lang='zh_tw'>
  <bookinfo>
    <title>FreeBSD 5.X、6.X 常見問答集</title>

    <corpauthor>FreeBSD 文件計畫</corpauthor>

    <copyright>
      <year>1995</year>
      <year>1996</year>
      <year>1997</year>
      <year>1998</year>
      <year>1999</year>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <year>2008</year>
      <holder>FreeBSD 文件計畫</holder>
    </copyright>

    &legalnotice;

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.3com;
      &tm-attrib.adobe;
      &tm-attrib.creative;
      &tm-attrib.cvsup;
      &tm-attrib.ibm;
      &tm-attrib.ieee;
      &tm-attrib.intel;
      &tm-attrib.iomega;
      &tm-attrib.linux;
      &tm-attrib.microsoft;
      &tm-attrib.mips;
      &tm-attrib.netscape;
      &tm-attrib.opengroup;
      &tm-attrib.oracle;
      &tm-attrib.sgi;
      &tm-attrib.sparc;
      &tm-attrib.sun;
      &tm-attrib.usrobotics;
      &tm-attrib.xfree86;
      &tm-attrib.general;
    </legalnotice>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>這份文件是 FreeBSD 5.X 及 6.X 的常見問答集。
        除非有特別加註，否則這些項目都適用於 FreeBSD 5.0 及以後的版本。
	(如果條目內容中有 &lt;XXX&gt; 則是尚未完成中譯的部份。)
	如果您對協助本文件/翻譯計畫的進行有興趣的話，請寄 e-mail 到
	&a.doc;。此外，隨時可從 <ulink
	url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/faq/index.html">
	FreeBSD 網站</ulink> 拿到這份文件的最新版本。
	也可以利用 HTTP 來下載一份龐大的 <ulink url="book.html">HTML</ulink>
	文件，或是經由 <ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">
	FreeBSD FTP 站</ulink> 下載純文字、&postscript;、或 PDF 版本的檔案。
	您也可以在這裡使用 <ulink
	url="&url.base;/search/search.html">搜尋資料</ulink> 的功能。</para>
    </abstract>
  </bookinfo>

  <chapter id="introduction">
    <chapterinfo>
      <author>
	<firstname>Ying-Chieh</firstname>
	<surname>Liao</surname>
	<affiliation>
	  <address><email>ijliao@FreeBSD.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>前言、一般問題</title>

    <para>歡迎使用 FreeBSD 4.X-6.X FAQ!</para>

    <para>跟其他 Usenet 上的 FAQ 一樣，這份文件涵蓋了有關 FreeBSD
      這套作業系統最常被問到的問題 (當然包括了回答！)。
      雖然說我們本來的目的是為了減少網路頻寬的浪費，
      以及避免同樣的問題一再出現，但事實上 FAQ
      已被公認為是值得閱讀的文件資源。</para>

    <para>我們已經儘可能地使這份 FAQ 更豐富了。如果您對如何改善、
      進步方面有任何建議，請隨時寄電子郵件給 &a.doc;。</para>

    <qandaset>
      <qandaentry>
        <question id="what-is-FreeBSD">
          <para>什麼是 FreeBSD？</para>
        </question>

        <answer>
         <para>簡單地來說，FreeBSD 是一套可以在 Alpha/AXP, AMD64 及
	   &intel; EM64T, &i386; IA-64, PC-98, &ultrasparc; 上執行的
           UN*X-like 作業系統，它是根據 U.C. Berkeley 所開發出來的
           <quote>4.4BSD-Lite</quote>，並加上了許多 <quote>4.4BSD-Lite2</quote>
	   的增強功能。它同時也間接使用了 U.C. Berkeley 所開發出來並由
	   William Jolitz 移植到 i386 的 <quote>Net/2</quote>，也就是
	   <quote>386BSD</quote>，
	   不過現在 386BSD 的程式碼只剩下極少數還留存在 FreeBSD 中。
	   您可以在 <ulink url="&url.base;/index.html">FreeBSD 首頁
	   </ulink> 找到 FreeBSD 以及它可以幫您做些什麼的相關資訊。</para>

	 <para>FreeBSD 已被廣泛地被世界各地的公司行號、ISP、研究人員、
	   電腦專家、學生，以及家庭用戶所使用，用在工作、教育以及娛樂上。</para>

         <para>如果想看關於 FreeBSD 更深入的資料，請看
	   <ulink url="&url.books.handbook;/index.html">FreeBSD 使用手冊
	 </ulink>。</para>
       </answer>
      </qandaentry>

      <qandaentry>
        <question id="FreeBSD-goals">
          <para>發展 FreeBSD 的目的是什麼？</para>
        </question>

        <answer>
	  <para>FreeBSD 計畫的目的是提供可以任意使用且沒有限制的軟體。
	    我們在程式碼 (以及計晝本身) 上付出了大量心血，
	    當然不會介意來點金錢上的回饋，不過我們絕對不會如此堅持。
	    我們相信我們首要的<quote>任務</quote>
	    就是提供程式碼給每一個使用者，
	    不管他們打算用來幹嘛；這麼一來，
	    這些程式碼才能被用在最多地方，也才能發揮它們最大的效益。
	    我們相信這就是自由軟體最基本的目標之一，
	    而且我們會盡全力去支持它。</para>

          <para>在我們 source tree 中有部份的程式碼是採用所謂的 <ulink
            url="http://www.FreeBSD.org/copyright/COPYING">GPL</ulink> 或是
            <ulink url="http://www.FreeBSD.org/copyright/COPYING.LIB">LGPL
	    </ulink> 版權宣告，
	    雖然這些版權宣告是用來保障而非限制使用者的權利，
	    畢竟是不那麼自由了些。
	    由於這些 GPL 的軟體在商業使用上會引起非常複雜的版權問題，
	    因此只要有機會，我們會盡量以採用比較寬鬆的
            <ulink url="http://www.FreeBSD.org/copyright/freebsd-license.html">
            FreeBSD 版權</ulink>的軟體來取代這些 GPL 版權宣告的軟體。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bsd-license-restrictions">
          <para>FreeBSD 版權有任何限制嗎？</para>
        </question>

        <answer>
          <para>有的。但是這並不是限制你怎麼去使用這些程式碼，而是你怎麼看待
            FreeBSD 這個計畫。如果你有版權焦慮症的話，請閱讀<ulink
            url="http://www.FreeBSD.org/copyright/freebsd-license.html">
            版權本文</ulink>。簡單地來說，這份版權的重點可以條列如下。</para>

          <itemizedlist>
            <listitem>
              <para>請勿宣稱是您寫了這個程式。</para>
            </listitem>

            <listitem>
              <para>如果它出問題了，不要控告我們。</para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="replace-current-OS">
          <para>FreeBSD 可以取代我現在在用的作業系統嗎？</para>
        </question>

        <answer>
          <para>對大部份的人來說是這樣沒錯，
	    但事實上這問題並沒有這麼好回答。</para>

	  <para>大部份的人並不是真正在使用一個作業系統。
	    他們使用的是應用程式；而那些應用程式才是真正用到作業系統的東西。
	    FreeBSD 是設計用來提供一個強韌且功能完整的作業環境給應用程式來執行。
	    它支援了多種瀏覽器，辦公室套件軟體，電子郵件閱讀軟體，繪圖程式，
	    程式設計環境，網路伺服器軟體，以及幾乎所有你想要的東西。
	    大部份的程式都可以靠 <ulink
	    url="http://www.freebsd.org/ports/">Ports Collection</ulink>
	    來管理。</para>

          <para>但是如果你想要使用的應用程式只能在某個特定的作業系統上面執行
            的話，你就不能輕易地把它換掉，或者指望在 FreeBSD 上有很相似的應用
	    程式才有機會。如果你想要的是一個強健的辦公室或是網路伺服器，或是
	    一部穩定的工作站，或是想在不被中斷的環境下工作的話，FreeBSD 無疑
	    是您的最佳選擇。世界各地有很多使用者，包括初學或資深的 &unix; 管理
	    人員都選用 FreeBSD 當他們唯一的桌上作業系統。</para>

	  <para>如果你是從其他的 &unix; 環境轉換到 FreeBSD 的話，
	    基本上是大同小異的。但是如果你之前用的是圖形界面的作業系統，
	    例如說是 &windows; 或是比較古老的 &macos; 的話，
	    可能就要多花一點時間來學習怎麼用 &unix; 的方式來做。
	    你可以從這份 FAQ 和 <ulink
	    url="&url.books.handbook;/index.html">
	    FreeBSD 使用手冊</ulink> 來入門。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="why-called-FreeBSD">
          <para>為什麼要叫做 FreeBSD？</para>
        </question>

        <answer>
          <itemizedlist>
            <listitem>
              <para>您可以免費使用它，即使是用於商業用途。</para>
            </listitem>

            <listitem>
              <para>整個 FreeBSD 作業系統完整的原始程式都可以免費取得，而且不
                管是在使用，散佈或是整合進其他程式等各方面也只受到最小的限
                制 (不論是否用於商業用途)。</para>
            </listitem>

            <listitem>
              <para>任何人都可以自由地把他對系統的改良或錯誤修正的程式碼加入
                source tree 之中 (當然要符合幾個先決條件)。</para>
            </listitem>
          </itemizedlist>

          <para>特別值得注意的是這裡的 <quote>free</quote> 出現了兩次，而且它們
            的意思是不一樣的：一種代表 <quote>免費</quote>，另一種代表
	    <quote>自由</quote>。您可以拿 FreeBSD 去做任何您想要做的事，除了一些
            <emphasis>例外</emphasis>，例如您宣稱 FreeBSD 是您寫的。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="differences-to-other-bsds">
	  <para>FreeBSD 及 NetBSD, OpenBSD 以及其他
	    open source BSD 作業系統之間有何不同之處呢？</para>
	</question>

	<answer>
	  <para>James Howard 在 <ulink url="http://www.daemonnews.org/">
	    DaemonNews</ulink> 上面寫了 <ulink
	    url="http://ezine.daemonnews.org/200104/bsd_family.html">
	    The BSD Family Tree</ulink> 的文件，裡面說明了這些歷史淵源及這些
	    *BSD 家族計畫之間的差異。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="latest-version">
          <para>最新版的 FreeBSD 是那一版？</para>
        </question>

<!--
  This answer is a hack to deal with the fact that for now there are
  multiple "latest" versions of FreeBSD.
  這個有點難以回答，事實上 FreeBSD 有許多種類的『最新版』。
-->

	<answer>
	  <para>就 FreeBSD 目前的發展而言，有兩個主要發展分支：
	    由 <emphasis>5-STABLE</emphasis> 所發行(release)的 5.X 系列、
	    由 <emphasis>6-STABLE</emphasis> 所發行(release)的 6.X
	    系列這兩個分支。</para>

	  <para>在 5.3 release 之前，4.X 系列仍屬
	    <emphasis>-STABLE</emphasis> 分支。
	    自從 5.3 開始，5.X 系列開始規劃新的
	    <emphasis>-STABLE</emphasis> 分支發展重點，
	    而 4.X 將只著重在重大問題上(比如：漏洞修補、安全維護)
	    以及所謂的 &quot;extended support&quot;
	    ，不再會有新的突破性發展。另一方面，5-STABLE
	    分支雖然仍將繼續發行，但是由於它只是 “legacy” 過渡期分支，
	    所以大多數主力都已轉移到 6-STABLE 繼續開發。</para>

<!-- note: the entity definitions are out of date -->
	  <para>於 &rel.current.date; 所發行的 <ulink
	    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE">&rel.current;</ulink>
	    版是目前最新的 <emphasis>6-STABLE</emphasis> 分支；
	    而於 &rel2.current.date; 所發行的 <ulink
	    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel2.current;-RELEASE/">&rel2.current;</ulink>
	    版則是目前最新的 <emphasis>5-STABLE</emphasis> 分支。</para>

          <para>簡單地來說，<emphasis>-STABLE</emphasis> 的主要訴求對象是對於
            穩定性及低變異性的需求遠勝過對最新 <emphasis>-CURRENT</emphasis>
            snapshot 中特別新功能的需求，例如 ISP 或公司行號的使用者。這兩個
            branch 都有可能會產生 release 版，但只有當你能接受
            <emphasis>-CURRENT</emphasis> 遠比 <emphasis>-STABLE</emphasis>
            容易更動這一點，才應該用 <emphasis>-CURRENT</emphasis>。</para>

          <para>Release 版<link linkend="release-freq">每幾個月</link>才會發
            行一次。雖然如此，有很多人和 FreeBSD 原始碼同步更新（詳見
            <link linkend="current">&os.current;</link> 和 <link
            linkend="stable">&os.stable;</link> 的相關問題)，但因為原始碼
            是一直不斷地在變動的，所以如果要這麼做的話得要花上更多的精
            力。</para>

	  <para>其他更多相關 FreeBSD 發行情報，可由 FreeBSD 網站上的 <ulink
	    url="http://www.FreeBSD.org/releng/index.html">
	    Release Engineering</ulink> 得知。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="current">
          <para>什麼是 &os.current;？</para>
        </question>

        <answer>
          <para><ulink
            url="&url.books.handbook;/cutting-edge.html#CURRENT">
	    &os.current;</ulink> 指的是正在發展中的作業系統版本，
	    它終將在適當的時機成為 &os.stable; 分支。
	    它實在是只適合給系統發展者以及有毅力的業餘愛好者使用。
	    如果想要得到有關如何使用 -CURRENT 的深入資訊，請參考 <ulink
            url="&url.books.handbook;/index.html">使用手冊</ulink> 的 <ulink
            url="&url.books.handbook;/cutting-edge.html#CURRENT">相關部份
	    </ulink>。</para>

          <para>如果您對作業系統本身並不是很熟悉，或是您沒辦法分辨您遇到的問
            題是真的發生了問題亦或是暫時性的小狀況，那麼您就不應該使用
            &os.current;。這個分支的程式碼有時候變動得很快，而且可能會因此
            而使您有好幾天的時間無法更新您的系統。我們假設使用
            &os.current; 的使用者都有能力去分析他們所遇到的問題並且只回報
            真正的問題而非<quote>小狀況</quote>。如果您在 -CURRENT mailing
            list 中提到類似<quote>make world 造成一些有關 groups 的錯
            誤</quote>之類的問題的話，也許會被其他人輕視。</para>

          <para>我們每天都會根據目前 -CURRENT 和 -STABLE 的狀況對這兩個分支各
	    發行一個 <ulink url="&url.base;/snapshots/">snapshot
            </ulink> 版。有的時候甚至還會發行可供取得的版本。發表這些 snapshot
            的目的在於：</para>

          <itemizedlist>
            <listitem>
              <para>測試最新版的安裝程式。</para>
            </listitem>

            <listitem>
              <para>提供一個簡單的方法給那些喜歡使用 -CURRENT 或是 -STABLE，
		但是沒有時間和頻寬去每天昇級的使用者。</para>
            </listitem>

            <listitem>
              <para>為了替我們發展中的程式保留一個固定的參考點，以防止我們未
                來造成不幸。(雖然一般而言 CVS 可以防止類似這種的可怕事件 :)
                </para>
            </listitem>

            <listitem>
              <para>為了確保所有需要測試的新功能都可以得到最多的測試。</para>
            </listitem>
          </itemizedlist>

          <para>我們不對 -CURRENT snapshot 做任何形式的<quote>品質保
            證</quote>。如果你想要的是一個穩定且經過充分測試過的系統的話，
            最好選擇使用完整 release 的版本，或是使用 -STABLE snapshots。</para>

          <para>您可以直接從 <ulink
	    url="&url.base;/snapshots/">
            snapshots</ulink> 處取得 -CURRENT 的
            snapshot release。</para>

          <para>對每個有在活動的分支而言，平均每天都會產生一次 snapshots。
            </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="stable">
          <para>什麼是 &os.stable;？</para>
        </question>

        <answer>
          <para>回溯到 FreeBSD 2.0.5 剛發表的時候，我們決定把 FreeBSD 的發展
	    分成兩支。一支叫做 <ulink
	    url="&url.books.handbook;/current-stable.html#STABLE">-STABLE
	    </ulink>，我們只對它做錯誤修正及小幅度的修改 (這是給 ISP
	    和商業公司等，對實驗中功能不感興趣的單位所使用的)。
	    另外一支叫做 <ulink
	    url="&url.books.handbook;/current-stable.html#CURRENT">-CURRENT
	    </ulink>，從 2.0 版發行以後，就不斷地朝著 6.2-RELEASE
	    (含後續的版本)前進著。</para>

	  <para>6-STABLE 分支是從 6.0-RELEASE 開始 (5-STABLE 分支算是
	    5.3-RELEASE 之後才開始的)，然後原本的 &os.current;
	    就會成為 7-CURRENT。</para>


          <para>2.2-STABLE 這個分支隨著 2.2.8 的發表而功成身退。3-STABLE 這個
            分支則是結束在 3.5.1 發表之後，它也是 3.X 的最後一次發表。之後除了
            安全漏洞的後續修正之外，這些分支就幾乎沒有再更動過。  而
	    5-STABLE 分支的支援將仍持續一段時間，
	    但主要焦點僅在於安全方面的漏洞、臭蟲及其他嚴重問題的修補。</para>

	  <para>6-STABLE 是目前正在發展中的 -STABLE 分支。  6-STABLE
	    的最新的一次發表是在 &rel.current.date; 發行的
	    &rel.current;-RELEASE。</para>

	  <para>7-CURRENT 這個分支是 &os; 的 -CURRENT 分支，
	    仍然不斷地在發展當中。  如果想要知道更多關於這個分支的資訊的話，
	    請參考 <link
            linkend="current">什麼是 &os;-CURRENT？</link>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="naming">
          <para>FreeBSD 版本命名原則是什麼呢？</para>
        </question>

        <answer>
          <para>您可能會看到以下幾種 FreeBSD 的版本名稱：</para>
          <itemizedlist>
	    <listitem>
	      <para>1) 4.4.2-RELEASE、4.4-BETA：最前面的數字 A.B.C 裡，
		A 表示主要的作業系統版本(Major)，
		B 表示次要的作業系統版本(Minor)，
		C 表示些微修正版本(Patch)。  後面的英文表示是否為正式版，
		通常是測試版(ALPHA、BETA、GAMMA)、正式版(RELEASE)。</para>
            </listitem>

            <listitem>
	      <para>2) 6.0-STABLE、7.0-CURRENT：
		通常 FreeBSD 會有一個以發展新功能為主的版本，稱為 -CURRENT
		，目前 CURRENT 版本是 7.0；  FreeBSD
		也會有一個以維護穩定性及系統安全為主的版本，稱為 -STABLE，
		目前 STABLE 的版本是 6.0。  雖然如此，並不代表 -STABLE
		就沒有新功能，也不代表 _CURRENT 就不穩定不安全，
		這兩個版本是相輔相成的，而且終有一天 7.0-CURRENT
		會變成 7.0-STABLE，而開始 8.0-CURRENT 的發展。  不過一般來說，
		由於 -CURRENT 系統開發的速度相當快，跟 -STABLE
		相比較不穩定，而且最好是有相當經驗的使用者才來使用。
		如果是商業環境或是伺服器站台，最好還是跑 -STABLE 與
		-RELEASE 比較好。  由於 -STABLE 與 -CURRENT
		都是一直在開發維護中的版本，
		因此沒有一個特定的數字版本可以稱呼，
		因此通常我們會以編譯日期來代表是哪個時候的 -STABLE 或 -CURRENT
		，例如「4.4-STABLE、編譯日期 2001/10/08」。</para>
            </listitem>

            <listitem><para>
3) 5.0-011025-SNAP、4.2-010816-RELENG：
   SNAP 與 RELENG 並不是正式發行的版本，其中 3.0-970625-SNAP 表示是
   在 2001 年 10 月 25 日發行的 5.0 測試版(SNAPshot)，通常是指 CURRENT
   的版本。而 4.2-010816-RELENG 表示是在 2001 年 8 月 16 日發行的
   4.2 非正式的穩定版，通常是指 STABLE 的版本。
   通常 FreeBSD 核心小組會不定時釋出 SNAP 以供測試，然後有一天 SNAP
   會變成 ALPHA->BETA->GAMMA，再來是 RELEASE，而後可能會有不定時的
   RELENG 以供測試使用，但是 RELENG 的穩定性通常又比前期的 RELEASE
   來的好。</para>
            </listitem>
          </itemizedlist>

<para>
您要是習慣微軟的術語，這樣說好了，SNAP 是開發期間的內部流出版，
那個日期(011025)就是Build Number，而 ALPHA 與 BETA 是搶鮮版，
RELEASE(RELENG 勉強也算)是正式版，這樣應該了解了吧。
</para>
         </answer>
      </qandaentry>

      <qandaentry>
        <question id="release-freq">
          <para>每次新的 FreeBSD 將於什麼時候推出？</para>
        </question>

        <answer>
          <para>一般而言，&a.re; 平均每四個月發行一次 release，每次新版本的發表時程都會事先公告，
	    相關的開發人員就會知道，什麼時候該先把手邊的計劃完成並且測試過，
	    此外，這些更動都已經完整地測試過，且不會影響系統穩定度。
	    雖然，等這些好東西進入 -STABLE 的時間令人等得有些不耐煩，
	    但是大多數的使用者都認為這種謹慎的態度是 FreeBSD 最好的優點之一。</para>

	  <para>有關發行情報的更多細節部分(包括 release 的行程表、進度)，都可在 FreeBSD 網站上的
	    <ulink url="http://www.FreeBSD.org/releng/index.html">發行情報</ulink> 上面獲得。</para>

          <para>為了滿足那些需要 (或想要) 新鮮刺激感的使用者，
	    上面(-CURRENT的部分)已經提到我們每天都會發行 snapshots 版可供使用。</para>
         </answer>
      </qandaentry>

      <qandaentry>
        <question id="responsible">
          <para>誰負責 FreeBSD 的發展？</para>
        </question>

        <answer>
          <para>如果是一些有關 FreeBSD 計畫的關鍵性決定，像是整個計畫的走向
            或是決定誰可以改 source tree 裡的程式碼這類的事，是由一個由 9 個
            人所組成的 <ulink
	    url="&url.articles.contributors;/article.html#STAFF-CORE">core
            team</ulink> 來決定。而有另一群超過 300 個人的 <ulink
            url="&url.articles.contributors;/article.html#STAFF-COMMITTERS">
            commiters</ulink> 有權利可以直接修改 FreeBSD 的 source tree。
            </para>

          <para>無論如何，大多數的改變都會事前在 <link linkend="mailing">
            mailing lists</link> 先討論過，而且不分角色，每個人都可以參與討論。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="where-get">
          <para>我要如何取得 FreeBSD？</para>
        </question>

        <answer>
          <para>每個 FreeBSD 的重要版本都可以經由匿名 ftp 從 <ulink
            url="ftp://ftp.FreeBSD.org/pub/FreeBSD/">FreeBSD FTP 站</ulink>取得：</para>

	  <itemizedlist>
	    <listitem>
	      <para>如果需要 6-STABLE 的最新版，也就是 &rel.current;-RELEASE，請到 <ulink
	        url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">&rel.current;-RELEASE </ulink>這個目錄</para>
	    </listitem>

	    <listitem>
	      <para><ulink url="ftp://current.FreeBSD.org/pub/FreeBSD/">7-CURRENT Snapshot</ulink>
	        通常也是每天都會做一份，這是從 <link linkend="current">-CURRENT</link> 分支做出來的，
	        主要是為了提供給那些熱心的測試者和開發人員。</para>
	    </listitem>

	    <listitem>
	      <para>如果需要 5-STABLE 的最新版，也就是 &rel2.current;-RELEASE，請到 <ulink
	        url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel2.current;-RELEASE/">&rel2.current;-RELEASE </ulink>這個目錄</para>
	    </listitem>

	    <listitem>
	      <para><ulink
	        url="ftp://current.FreeBSD.org/pub/FreeBSD/snapshots/">5.X、6X snapshots</ulink>
	        通常每天都會做一份。</para>
	    </listitem>
          </itemizedlist>

	  <para>FreeBSD 的 CD、DVD，還有其他取得方式可以在 <ulink url="&url.books.handbook;/mirrors.html">使用手冊</ulink> 中找到解答。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="access-pr">
          <para>我要如何去查詢、提交問題回報(Problem Report，簡稱PR)資料庫呢？</para>
        </question>

        <answer>
          <para>所有使用者的變更要求都可以經由網頁介面的
            <ulink url="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query">
            PR查詢介面</ulink> 來察看 (或是回報) 我們的錯誤回報資料庫。</para>

	  <para>也可以使用 &man.send-pr.1; 這個指令透過電子郵件來回報問題、要求變更。
	  或者是經由 <ulink url="http://www.FreeBSD.org/send-pr.html">網頁介面的 PR</ulink> 來送出問題回報。</para>

          <para>然而，在您回報問題之前，請先閱讀 <ulink
            url="&url.articles.problem-reports;/article.html">如何撰寫
            FreeBSD 的問題回報單</ulink>，這是一篇告訴你怎樣才能寫出一篇真正有用的
            問題回報單。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="other-info-sources">
          <para>還有其他有關 FreeBSD 的資訊嗎？</para>
        </question>

        <answer>
          <para>詳見 <ulink
            url="http://www.FreeBSD.org">FreeBSD</ulink> 網站上的 <ulink
            url="http://www.FreeBSD.org/docs.html">文件</ulink> 列表。</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="support">
    <chapterinfo>
      <author>
	<firstname>Chin-San</firstname>
	<surname>Huang</surname>
	<affiliation>
	  <address><email>chinsan.tw@gmail.com</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>文件與技術支援</title>

    <qandaset>
      <qandaentry>
	<question id="books">
	  <para>關於 FreeBSD 有哪些好書可以推薦閱讀的嗎？</para>
	</question>

	<answer>
	  <para>FreeBSD 文件計畫已陸續發表了相當廣泛範圍的文件，可在 <ulink
	    url="http://www.FreeBSD.org/docs.html"></ulink> 取得。另外，
	    FreeBSD 本身的 manual(一般通稱的man)、doc也如同套件軟體一樣，可以輕鬆地裝在您系統上。
	    </para>

	    <para>此外，也建議參閱本份 FAQ 最後所列的參考書目表(Bibliography)與 FreeBSD 使用手冊。
	    </para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="doc-formats">
          <para>這些文件有其他格式的嗎？像是：純文字(ASCII)或 &postscript; 之類的格式？</para>
        </question>

        <answer>
          <para>有的。這些文件都分別以不同格式儲存以及壓縮處理，放在
            FTP 上面，可以從各 FreeBSD FTP 站的 <ulink
            url="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">/pub/FreeBSD/doc/</ulink>
            目錄內找到你要的。</para>

          <para>文件的分類方面主要是一些不同性質所組成：</para>

          <itemizedlist>
            <listitem>
	      <para>文件名稱，比如：<literal>faq(常見問答集)</literal>或是
                <literal>handbook(FreeBSD 使用手冊)</literal>等等。</para>
            </listitem>

            <listitem>
              <para>各國翻譯的的文件：這主要是由 locale 名稱來決定的
	        (不清楚的話，可參考您的 FreeBSD 作業系統上的 <filename>/usr/share/locale</filename>)
	        目前文件總共有下列幾種語言(及編碼)有翻譯：</para>

              <informaltable frame="none" pgwide="1">
                <tgroup cols="2">
                  <thead>
                    <row>
                      <entry>Locale 名稱</entry>

                      <entry>說明(所代表的語系、編碼)</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><literal>en_US.ISO8859-1</literal></entry>

                      <entry>美式英文(US English)</entry>
                    </row>

                    <row>
                      <entry><literal>de_DE.ISO8859-1</literal></entry>

                      <entry>德文(German)</entry>
                    </row>

                    <row>
                      <entry><literal>es_ES.ISO8859-1</literal></entry>

                      <entry>西班牙文(Spanish)</entry>
                    </row>

                    <row>
                      <entry><literal>fr_FR.ISO8859-1</literal></entry>

                      <entry>法文(French)</entry>
                    </row>

		    <row>
		      <entry><literal>it_IT.ISO8859-15</literal></entry>

		      <entry>義大利文(Italian)</entry>
		    </row>

                    <row>
                      <entry><literal>ja_JP.eucJP</literal></entry>

                      <entry>日文(Japanese，編碼方式：EUC)</entry>
                    </row>

                    <row>
                      <entry><literal>ru_RU.KOI8-R</literal></entry>

                      <entry>俄文(Russian，編碼方式：KOI8-R)</entry>
                    </row>

                    <row>
                      <entry><literal>zh_CN.GB2312</literal></entry>

                      <entry>簡體中文(Simplified Chinese，編碼方式：GB2312)</entry>
                    </row>

                    <row>
                      <entry><literal>zh_TW.UTF-8</literal></entry>

                      <entry>正體中文(Traditional Chinese，編碼方式：UTF-8)</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>

              <note>
                <para>上列的各國翻譯語系文件中，並非所有文件都有翻譯。</para>
              </note>
            </listitem>

            <listitem>
	      <para>文件的格式：每份文件都以各種不同格式儲存，每種格式都各有好壞，
	        有些格式適合線上閱讀，而有些則適合列印出美觀的文件。
	        我們都提供這些不同格式的文件，來確保無論是螢幕上、列印紙本，每個人都可以正常地閱讀內容，
                目前可供使用的格式如下:</para>

              <informaltable frame="none" pgwide="1">
                <tgroup cols="2">
                  <thead>
                    <row>
                      <entry>格式</entry>

                      <entry>說明</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><literal>html-split</literal></entry>

                      <entry>章節模式</entry>
                    </row>

                    <row>
                      <entry><literal>html</literal></entry>

                      <entry>完整模式</entry>
                    </row>

                    <row>
                      <entry><literal>pdb</literal></entry>

                      <entry>Palm Pilot 資料格式，使用
                        <ulink url="http://www.iSilo.com/">iSilo</ulink>
                        程式來閱讀</entry>
                    </row>

                    <row>
                      <entry><literal>pdf</literal></entry>

                      <entry>Adobe's PDF 格式</entry>
                    </row>

                    <row>
                      <entry><literal>ps</literal></entry>

                      <entry>&postscript; 格式</entry>
                    </row>

                    <row>
                      <entry><literal>rtf</literal></entry>

                      <entry>Microsoft's RTF格式<footnote>
                          <para>當使用 MS Word 來開啟 RTF 格式的話，頁數顯示並不會自動更新。
                          (在開啟文件後，要按 <keycombo
                          action="simul"><keycap>CTRL</keycap><keycap>A</keycap></keycombo>,
                          <keycombo
                          action="simul"><keycap>CTRL</keycap><keycap>END</keycap></keycombo>,
                          <keycap>F9</keycap>，這樣子才會更新頁數的顯示。)</para>
                        </footnote>
                      </entry>
                    </row>

                    <row>
                      <entry><literal>txt</literal></entry>

                      <entry>純文字(ASCII)</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </listitem>

            <listitem>
              <para>文件的壓縮、打包方式：目前有三種方式：</para>

              <orderedlist>
                <listitem>
                  <para>當採用
                    <literal>章節模式(html-split)</literal>，章節模式所產生的各檔案會先使用
	              &man.tar.1; 來壓縮。檔名結尾有 <filename>.tar</filename> 的檔案就是 tar 格式。
		      接著，會再以下列方式再壓縮。
	          </para>
                </listitem>

                <listitem>
                  <para>其他格式的檔案都會是單一檔案，檔名通常會是：
                    <filename>book.<replaceable>格式</replaceable></filename>
                    (舉例： <filename>book.pdb</filename>，
                    <filename>book.html</filename> 等等..後面通常加上『.格式』).</para>
		  <para>而這些檔案會分別以兩種壓縮型態進行壓縮，而存成兩種壓縮型態。</para>

                  <informaltable frame="none" pgwide="1">
                    <tgroup cols="2">
                      <thead>
                        <row>
                          <entry>格式</entry>

                          <entry>說明</entry>
                        </row>
                      </thead>

                      <tbody>
                        <row>
                          <entry><literal>zip</literal></entry>

                          <entry>Zip 格式，若要在 FreeBSD 上解壓 zip 檔，則必須先安裝
	                    <filename role="package">chinese/unzip</filename> 或
		            <filename role="package">archivers/unzip</filename>。
                            </entry>
                        </row>

                        <row>
                          <entry><literal>bz2</literal></entry>

                          <entry>BZip2 格式，雖然不如 zip 格式的廣泛使用，但是好處在於可壓縮成更小的檔案。
	                    要解壓 bz2 格式的話，需先安裝 <filename role="package">archivers/bzip2
	                    </filename>。</entry>
                        </row>
                      </tbody>
                    </tgroup>
                  </informaltable>

                  <para>所以像是 Handbook 的 &postscript; 版格式，會以 BZip2 格式壓縮，
	             存放在 <filename>handbook/</filename> 目錄內，
	             檔名就是<filename>book.ps.bz2</filename>。</para>
                </listitem>
              </orderedlist>
            </listitem>
          </itemizedlist>

          <para>選擇想要下載的文件格式與壓縮型態之後，則要決定是否以 FreeBSD <emphasis>套件(package)</emphasis>
	    型態來下載。</para>

          <para>下載、安裝『package』的好處在於：可以透過一般 FreeBSD
	    套件管理方式來進行管理，比如 &man.pkg.add.1; 及
            &man.pkg.delete.1;。</para>


	  <para>若決定好要下載、安裝『package』的話，必須要確認所要下載的檔名。
	    文件計畫的套件(package)通常是放在是 <filename>packages</filename> 的目錄內，
            每個文件計畫的套件檔名通常是：
	    <filename><replaceable>文件名稱</replaceable>.<replaceable>語系</replaceable>.<replaceable>編碼</replaceable>.<replaceable>格式</replaceable>.tgz</filename>
	    。</para>

          <para>舉個例子，英文版的 FAQ (格式選擇 PDF)在 package 就叫做
            <filename>faq.en_US.ISO8859-1.pdf.tgz</filename>。</para>

          <para>再舉個例子，中文版的 FAQ (格式選擇 PDF)在 package 就叫做
            <filename>faq.zh_TW.UTF-8.pdf.tgz</filename>。</para>

          <para>知道這點之後，就可以用下面指令來安裝中文版 FAQ 套件：</para>

          <screen>&prompt.root; <userinput>pkg_add ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/packages/faq.zh_TW.UTF-8.pdf.tgz</userinput></screen>

          <para>完成之後，可以用 &man.pkg.info.1; 來找出檔案裝在哪邊：</para>

          <screen>&prompt.root; <userinput>pkg_info -f faq.zh_TW.UTF-8.pdf</userinput>
Information for faq.zh_TW.UTF-8.pdf:

Packing list:
        Package name: faq.zh_TW.UTF-8.pdf
        CWD to /usr/share/doc/zh_TW.UTF-8/books/faq
File: book.pdf
        CWD to .
File: +COMMENT (ignored)
File: +DESC (ignored)</screen>

          <para>如同您所看到的 <filename>book.pdf</filename> 會被安裝到
            <filename>/usr/share/doc/zh_TW.UTF-8/books/faq</filename> 內。</para>

          <para>若不想用 package 方式安裝，那麼就需手動下載、解壓縮、複製到你想要擺放的位置去。</para>

          <para>舉例，章節模式(split HTML)版的英文 FAQ (壓縮為 &man.bzip2.1;)會放在
            <filename>doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</filename>
            要下載、解壓的話，則要打：</para>

          <screen>&prompt.root; <userinput>fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</userinput>
&prompt.root; <userinput>bzip2 -d book.html-split.tar.bz2</userinput>
&prompt.root; <userinput>tar xvf book.html-split.tar</userinput></screen>

          <para>這時你會看到一堆 <filename>.html</filename> 的檔案，
	    主要的目錄檔為 <filename>index.html</filename>
	    內含主目錄及連結到其他文件。(若有需要的話，也可以複製或搬移這些檔案到同一目錄下)</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mailing">
          <para>哪裡有關於 FreeBSD 的郵遞論壇(mailing lists)呢？</para>
        </question>

        <answer>
          <para>這個問題，可以從 FreeBSD 使用手冊上面的 <ulink
	  url="&url.books.handbook;/eresources.html#ERESOURCES-MAIL">郵遞論壇(mailing-lists)</ulink>
	  部分獲得答案。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="newsgroups">
          <para>有哪些可以使用的 FreeBSD 新聞群組(news groups)呢?</para>
        </question>

        <answer>
          <para>這答案可以從 FreeBSD 使用手冊上面的  <ulink
            url="&url.books.handbook;/eresources-news.html">新聞群組(newsgroups)</ulink>
	    部分獲得答案。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="man">
          <para>在文件中常看到類似 "pf(4)"、"pfctl(8)" 等這些字樣代表什麼意思呢？</para>
        </question>

        <answer>
          <para>這表示 man 的章節，系統上一般有八個章節：</para>
          <itemizedlist>
            <listitem>
              <para>1->generl commands</para>
            </listitem>

            <listitem>
              <para>2->system calls and error numbers </para>
            </listitem>

            <listitem>
              <para>3->C libraries</para>
            </listitem>

            <listitem>
              <para>4->devices and device drivers</para>
            </listitem>

            <listitem>
              <para>5->file formats</para>
            </listitem>

            <listitem>
              <para>6->games</para>
            </listitem>

            <listitem>
              <para>7->miscellaneous information pages</para>
            </listitem>

            <listitem>
              <para>8->system maintenance and operation commands</para>
            </listitem>
          </itemizedlist>

	  <para>比如：pf(4) 就是指 <command>man 4 pf</command>。</para>
        </answer>
      </qandaentry>
      <qandaentry>
        <question id="irc">
          <para>有哪些 FreeBSD IRC (Internet Relay Chat)頻道呢？</para>
        </question>

        <answer>
          <para>有的，大部分的 IRC 主機都有 FreeBSD 聊天頻道：</para>

          <itemizedlist>
            <listitem>
              <para><ulink url="http://www.efnet.org/index.php">EFNet</ulink> 的
		<literal>#FreeBSD</literal> 頻道是個 FreeBSD 論壇，
	        但可不適合那些想不勞而獲或者搬救兵用的。
	        這裡是聊天用的頻道，話題範圍甚至涉及『性、運動、核武』等，
	        請注意：我們已經警告過你了！本頻道可經由
		<hostid>irc.chat.org</hostid> 進入。</para>
            </listitem>

            <listitem>
              <para><ulink url="http://www.efnet.org/index.php">EFNet</ulink> 的
	        <literal>#FreeBSDhelp</literal> 頻道乃是給 FreeBSD
		使用者之間交流的，來這裡提問會比 <literal>#FreeBSD</literal>
		好一些，當然請不要一股腦隨便亂問。</para>
            </listitem>

            <listitem>
              <para><ulink url="http://www.dal.net/">DALNET</ulink> 的
	        <literal>#FreeBSD</literal> 頻道，可由
		<hostid>irc.dal.net</hostid>(位於美國)及
                <hostid>irc.eu.dal.net</hostid>(位於歐洲)進入。</para>
            </listitem>

            <listitem>
              <para><ulink url="http://www.dal.net/">DALNET</ulink> 的
	        <literal>#FreeBSDHelp</literal> 頻道，可由
		<hostid>irc.dal.net</hostid>(位於美國)及
	        <hostid>irc.eu.dal.net</hostid>(位於歐洲)進入。</para>
            </listitem>

            <listitem>
              <para><ulink url="http://www.undernet.org/">UNDERNET</ulink> 的
	        <literal>#FreeBSD</literal> 頻道，可由
		<hostid>us.undernet.org</hostid>(位於美國)及
	        <hostid>eu.undernet.org</hostid>(位於歐洲)進入。
		由於這是個輔助新手用的頻道，
	        請記得閱讀別人向你提及的連結或檔案。</para>
            </listitem>

	    <listitem>
	      <para><ulink url="http://www.rusnet.org.ru/">RUSNET</ulink> 的
		<literal>#FreeBSD</literal> 頻道是俄語國家的 &os; 使用者頻道。
		這裡同時也是一般交流的討論好去處。</para>
	    </listitem>

	    <listitem>
	      <para><ulink
		url="http://freenode.net/irc_servers.shtml">freebsd-gnome
		</ulink> 的 <literal>#FreeBSD</literal> 頻道，可由
		<hostid>irc.freenode.net</hostid> 進入，
	        這是 Gnome 的 &os; 使用者頻道。</para>
	    </listitem>

	    <listitem>
	      <para><ulink url="http://freenode.net/irc_servers.shtml">freenode</ulink>
		的 <literal>#bsdchat</literal> 頻道，可由
		<hostid>irc.freenode.net</hostid> 進入，
	        這是台灣的 &os; 使用者頻道。(UTF-8 編碼)</para>
	    </listitem>
          </itemizedlist>

          <para>上述每個頻道都不一樣，風格迥異而各具特色，且並沒有相連，
	    因此，你得多方嘗試才能找到適合自己的頻道。
	    而有些地方與所有的 IRC 文化類似，就是請注意自己言行是否恰當，
	    另外可能跟頻道內一些年輕/老一輩的會有些代溝需要適應，
	    總之請多保持禮貌。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="training">
	  <para>可以從哪邊獲得 FreeBSD 的教育課程訓練及技術支援呢？</para>
	</question>

	<answer>
	  <para>DaemonNews 有專門提供 FreeBSD 的教育課程訓練及技術支援。
	    詳情請到 <ulink url="http://www.bsdmall.com/">BSD Mall</ulink>
	    察看，謝謝。</para>

          <para>FreeBSD Mall 有提供 BSD 技術支援付費服務，
            詳情請到 <ulink
            url="http://www.freebsdmall.com/">FreeBSD Mall</ulink> 察看，謝謝。</para>


	  <para>其他任何有提供教育課程訓練及技術支援的組織、單位，若也想列表於此的話，
	    請與 &a.doc; 聯絡，謝謝。</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter
    id="install">
    <chapterinfo>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
	<affiliation>
	  <address><email>nik@FreeBSD.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>安裝</title>

    <qandaset>
      <qandaentry>
        <question id="floppy-download">
          <para>若要用軟碟片開機來安裝 FreeBSD 的話，要下載哪些檔案呢？</para>
        </question>

        <answer>
          <para>&os; 4.X 的話，需要兩個 image 檔：
            <filename>floppies/kernel.flp</filename> 及
            <filename>floppies/mfsroot.flp</filename>。image 檔必須用工具像是
	    <command>fdimage</command> 或 &man.dd.1; 來傳送到磁片上。
            若是在 &os; 5.3 (及之後版本)有重新規劃開機片架構，所以要抓的是
            <filename>floppies/boot.flp</filename> 以及 <filename>floppies/kern<replaceable>X</replaceable></filename>
            檔案(目前 X 為 1 跟 2 兩個，加上 <filename>floppies/boot.flp</filename>，總共是 3 個檔案)。</para>

          <para>若想自己下載 distributions 的話(比如以 &ms-dos; 檔案系統格式安裝)，
            以下是建議要抓的 distributions ：</para>


          <itemizedlist>
            <listitem>
              <para>base/ (4.X 版本則為 bin/)</para>
            </listitem>

            <listitem>
              <para>manpages/</para>
            </listitem>

            <listitem>
              <para>compat*/</para>
            </listitem>

            <listitem>
              <para>doc/</para>
            </listitem>

            <listitem>
              <para>src/ssys.*</para>
            </listitem>
          </itemizedlist>


          <para>完整安裝步驟以及大部分的安裝問題，請參閱 FreeBSD 使用手冊的
            <ulink url="&url.books.handbook;/install.html">安裝 FreeBSD</ulink> 章節</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="floppy-image-too-large">
          <para>若磁片裝不下 image 檔的話，該怎麼辦呢？</para>
        </question>

        <answer>
          <para>一張 3.5 英吋(1.44MB) 的磁碟片是可以裝上 1474560 bytes 的資料
            ，而開機片的 image 檔案大小實際上也是 1474560 bytes。</para>

          <para>在製作開機片時，常見錯誤有：</para>

          <itemizedlist>
            <listitem>
              <para>使用 <acronym>FTP</acronym> 來下載檔案時，
	        未選擇 <emphasis>binary</emphasis> 傳輸模式來下載。</para>


              <para>有些 FTP client端程式，是預設將傳輸模式設定為
                <emphasis>ascii</emphasis> 模式，而且會修改接收到的檔案行尾字串為 client 端的作業系統方式
		，比如 newline(&unix;格式) 到了作業系統為 &windows; 的 client 端會被改為 CR-LF(&ms-dos;格式)，
		這會使得 image 檔本身遭到修改而無法正常使用。因此，如果下載的 image
	        檔案大小若與 FTP 主機上面的檔案『<emphasis>不一致</emphasis>』
	        的話，請重新使用 binary 傳輸模式下載即可。</para>

              <para>FTP 指令: 進入 FTP 之後，打 <emphasis>binary</emphasis>
	        指令，即可切換到 binary 傳輸模式，然後再下載相關 image 檔案。</para>
            </listitem>

            <listitem>
              <para>直接用 &ms-dos; 的 <command>copy</command> 指令(或類似
                的 GUI 程式、或是視窗上直接複製)來複製開機用的 image 檔到磁片上。
                </para>

              <para>不可以用像是 <command>copy</command> 這類程式直接將 image
	        檔複製到磁片上，因為 image 檔本身包含了完整的磁軌資料，所以不能單純用複製方式，
	        而必須使用低階工具程式(像是 <command>fdimage</command> 或 <command>rawrite</command>)，
	        以 <quote>raw</quote> 方式傳送到磁片上。(這部分可參閱 FreeBSD 使用手冊上的 <ulink
	        url="&url.books.handbook;/install.html">安裝 FreeBSD</ulink>)</para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="install-instructions-location">
          <para>可以在哪邊找到安裝 FreeBSD 的解說步驟呢？</para>
        </question>

        <answer>
          <para>安裝步驟的解說，請參閱 FreeBSD 使用手冊上的
            <ulink url="&url.books.handbook;/install.html">安裝 FreeBSD</ulink> 章節部分。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="need-to-run">
          <para>要跑 FreeBSD 需要什麼的配備呢？</para>
        </question>

        <answer>
          <para>&os; 4.X 之前的版本，硬體需求為 386 或更高級的 PC
            ，記憶體(RAM)至少要 5 MB 或更多，硬碟空間至少要 60 MB 或更多。
            不過，&os; 『系統安裝程式』的記憶體(RAM)需求為至少 16 MB。</para>

	  <para>從 &os; 5.X 起，硬體需求為 486 或更高級的 PC
	    ，記憶體(RAM)至少要 24 MB 或更多，硬碟空間至少要 150 MB 或更多。
            </para>

	  <para>&os; 的所有版本都可以只用低階的 MDA 規格顯示卡，不過...要跑 X11R6 視窗的話，
	    還是至少用 VGA 或更好規格的顯示卡來用吧。</para>

          <para>這部分也可參閱 <xref linkend="hardware"/>。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="four-meg-ram-install">
          <para>我電腦 RAM 只有 4MB 而已，可以裝 FreeBSD 嗎？</para>
        </question>

        <answer>
          <para>安裝 &os; 4.X 的記憶體需求為至少 5 MB ，而
            安裝 &os; 5.X (含之後版本) 則是至少要 8 MB 。</para>

          <para>在 5.X 之前的所有 &os; 版本，都可以只用 4 MB 的記憶體來
	    <emphasis>『運作』</emphasis>，不過，前面那節我們說過了『系統安裝程式』的話，
	    則無法只用 4 MB 的記憶體來執行。因此，你可以先在『系統安裝程式』這步驟之前，
	    先將記憶體加到 16 MB 以上，安裝完 FreeBSD 之後，就可以把多餘的記憶體拿下來。
	    或者是，先把要安裝的硬碟拿到有足夠記憶體的機器上先裝好，
	    然後再把硬碟放回原機器。</para>

          <para>此外，只用 4 MB 的記憶體來運作的話，必須要自製 kernel(拿掉不必要的以及犧牲一些東西)。
	    也有人成功只用 2 MB 的記憶體以 &os; 開機(雖然這樣的系統幾乎等於廢了..)</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="custom-boot-floppy">
          <para>要怎樣才能自行打造專用的開機、安裝磁片呢？</para>
        </question>

        <answer>
	  <para>目前，還沒有辦法<emphasis>『只』</emphasis>自製專用的開機、安裝磁片。
            必須透過自行打造完整作業系統的 release(發行)，這樣裡面才會包括自己的開機、安裝磁片。</para>

          <para>若想自行打造、發行(release)一個完整的作業系統，請參閱這篇
            <ulink url="&url.articles.releng;/article.html">Release Engineering</ulink> 文章。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="windows-coexist">
          <para>&windows; 可以與 FreeBSD 共存於電腦上嗎？</para>
        </question>

        <answer>
          <para>先裝 &windows; 再裝 FreeBSD。
            那麼 FreeBSD 多重開機管理員(boot manager)就會出現選單讓你選擇要以 &windows; 或
            FreeBSD 來開機。不過，若你是先裝 FreeBSD 再裝 &windows; 的話，
	    那麼  &windows; 將會不問先宰，把  FreeBSD 的多重開機管理員(boot manager)蓋掉，
	    當你遇上這種情況時，請參考下一節說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="win95-damaged-boot-manager">
          <para>嗚.. &windows; 把我的多重開機管理員(boot manager)拿掉了！要怎麼救回來呢？</para>
        </question>

        <answer>
          <para>可以用以下三種方式之一，來救回你的 FreeBSD 多重開機管理員(boot manager)：</para>

          <itemizedlist>
            <listitem>
              <para>可以從各 FreeBSD FTP 站的 <ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">/pub/FreeBSD/tools/</ulink>
	         找到 <filename>bootinst.exe</filename> 及 <filename>boot.bin</filename> 這兩個檔，
		 以 binary 傳輸模式下載後，複製到磁片上，再用 DOS 開機片開機，
                接著打類似下面的指令：</para>

              <screen><prompt>&gt;</prompt> <userinput>bootinst.exe boot.bin</userinput></screen>

              <para>這樣，多重開機管理員(boot manager)就會重裝完畢了。</para>
            </listitem>

            <listitem>
              <para>用 FreeBSD 開機片開機，然後選單那邊選 Custom installation(自訂安裝)，
	         再選 Partition，接著選擇你要裝多重開機管理員(boot manager)的硬碟(通常是第一顆)，
		 然後會出現 partition editor 的畫面，這時請不要做任何修改，直接按 W 儲存，
	         這時程式就會問是否要確定 Write ，最後出現 Boot Manager 選擇畫面，
	         記得要選 <quote>Boot Manager</quote> ，這樣就會重新將多重開機管理員(boot manager)
	         安裝到硬碟上。現在，就大功告成可以離開安裝選單並重開機了。</para>
            </listitem>

            <listitem>
              <para>用 FreeBSD 開機片或是開機光碟開機，然後選單那邊選 <quote>Fixit</quote>
                ，或是以 Fixit 開機片或是光碟安裝的第二片(選擇 <quote>live</quote> filesystem
                選項)然後就會進入 fixit shell 了，接著打下列指令：</para>

              <screen><prompt>Fixit#</prompt> <userinput>fdisk -B -b /boot/boot0 <replaceable>bootdevice</replaceable></userinput></screen>

              <para>請將上面的 <replaceable>bootdevice</replaceable> 修改為您實際的開機硬碟代號
                比如 <devicename>ad0</devicename> (第一顆 IDE 硬碟)
                ，或是<devicename>ad4</devicename> (first IDE disk on
                auxiliary controller), <devicename>da0</devicename> (第一顆
                SCSI 硬碟)等等。</para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="boot-on-thinkpad">
          <para>IBM Thinkpad A系列、T系列或 X系列的筆記型電腦裝完 FreeBSD 之後重開機，就當了，該怎麼辦呢？</para>
        </question>

        <answer>
          <para>(本問題主要是發生在 2000 ~ 2001 四月間時)這些 IBM 機器上的 BIOS 早期版本有個臭蟲(bug)會把
	    FreeBSD 分割區誤認為是 FAT 格式分割區，然後當 BIOS 試著偵測 FreeBSD 分割區時，就會當了。</para>

          <para>根據 IBM 方面的說法<footnote><para>一封來自 Keith
                Frechette 的 e-mail <email>kfrechet@us.ibm.com</email>。</para></footnote>
	    ，以下型號/BIOS版本的機種，已經都有修正：</para>

          <informaltable frame="none" pgwide="1">
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>型號</entry>
                  <entry>BIOS 版本</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>T20</entry>
                  <entry>IYET49WW(含之後)</entry>
                </row>

                <row>
                  <entry>T21</entry>
                  <entry>KZET22WW(含之後)</entry>
                </row>

                <row>
                  <entry>A20p</entry>
                  <entry>IVET62WW(含之後)</entry>
                </row>

                <row>
                  <entry>A20m</entry>
                  <entry>IWET54WW(含之後)</entry>
                </row>

                <row>
                  <entry>A21p</entry>
                  <entry>KYET27WW(含之後)</entry>
                </row>

                <row>
                  <entry>A21m</entry>
                  <entry>KXET24WW(含之後)</entry>
                </row>

                <row>
                  <entry>A21e</entry>
                  <entry>KUET30WW</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

	  <para>這些後期的 IBM BIOS 修訂版大多已經修正此一臭蟲。Jacques Vidrine 寫給 &a.mobile; 的
	    <ulink url="http://docs.FreeBSD.org/cgi/mid.cgi?20010427133759.A71732">這封信
	    </ulink> 上面說明了若你新的 IBM 筆記型電腦無法順利以 FreeBSD 開機的解法步驟
	    (假設可以升級或降級 BIOS 版本的話)。</para>

          <para>如果機器用的是較古早版本的 BIOS，而且不適合更新 BIOS 的話，那麼以下我們會介紹暫時解法，
	    教你如何修改 FreeBSD 分割區所使用的 ID ，並安裝相關修補程式。</para>

          <para>First, you will need to restore the machine to a state where
            it can get through its self-test screen.  Doing this requires
            powering up the machine without letting it find a FreeBSD
            partition on its primary disk.  One way is to remove the hard disk
            and temporarily move it to an older ThinkPad (such as a ThinkPad
            600) or a desktop PC with an appropriate conversion cable.  Once
            it is there, you can delete the FreeBSD partition and move the hard
            disk back.  The ThinkPad should now be in a bootable state
            again.</para>

          <para>With the machine functional again, you can use the workaround
            procedure described here to get a working FreeBSD
            installation.</para>

          <procedure>
            <step>
              <para>從 <ulink url="http://people.FreeBSD.org/~bmah/ThinkPad/"></ulink>
	        來下載 <filename>boot1</filename> 及 <filename>boot2</filename> 這兩個檔。
                把這兩個檔案放在磁片、光碟或其他硬碟上。</para>
            </step>

            <step>
              <para>以一般安裝 FreeBSD 裝到 ThinkPad 上，記得
                <emphasis>『不要用』</emphasis> <literal>Dangerously
                  Dedicated</literal> 模式。  此外，<emphasis>『不要』</emphasis>
                在完成安裝之後就重開機。</para>
            </step>

            <step>
              <para>進入 shell：(按 <keycombo action="simul"><keycap>ALT</keycap><keycap>F4</keycap></keycombo>)
	        切換到<quote>Emergency Holographic Shell</quote> 或是選單上面選擇
                <quote>fixit</quote> shell。</para>
            </step>

            <step>
              <para>用 &man.fdisk.8; 把 FreeBSD 分割區 ID 由 <literal>165</literal> 改為
	        <literal>166</literal>(OpenBSD所使用的ID)。</para>
            </step>

            <step>
              <para>把剛剛提的 <filename>boot1</filename> 跟
                <filename>boot2</filename> 這兩個檔案放到目前的硬碟檔案系統上。</para>
            </step>

            <step>
              <para>以 &man.disklabel.8; 把 <filename>boot1</filename> 及
                <filename>boot2</filename> 存到你的 FreeBSD slice 上面。</para>

              <screen>&prompt.root; <userinput>disklabel -B -b boot1 -s boot2 ad0s<replaceable>n</replaceable></userinput></screen>

              <para><replaceable>「n」</replaceable> 是你裝 FreeBSD 的 slice，
	        請將 <replaceable>「n」</replaceable> 改為符合你系統現況的 slice。</para>
            </step>

            <step>
              <para>重開機，在 boot prompt 會看到有 <literal>OpenBSD</literal> 的選項，
	        選它，這樣就會以 FreeBSD 開機。</para>
            </step>
          </procedure>

          <para>另外，至於如何讓 OpenBSD 及 FreeBSD 並存在同一台 IBM ThinkPad 上...
	    這個問題就交給各位看倌們去嘗試了 :p</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="install-bad-blocks">
          <para>有壞軌的硬碟可以拿來裝 FreeBSD 嘛？</para>
        </question>

        <answer>
          <para>(如果很堅持的話)也是可以，不過這想法顯然不太明智。:(</para>

	  <para>如果在一般較新的 IDE 硬碟上看到有壞軌，很有可能代表：這顆硬碟即將掛點了。
	    (因為目前所有較新的 IDE 硬碟，內部都有自動 remapping 壞軌的能力。
	    如果看到有壞軌，則表示它內部自動 remapping 功能失效，無法處理壞軌，
	    也就是說這顆硬碟已經是嚴重損壞程度了。)我們建議買顆新硬碟比較乾脆些唷。</para>

          <para>如果是 SCSI 硬碟有壞軌的話，請試著參考這個
            <link linkend="awre">解法</link>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="boot-floppy-strangeness">
          <para>用安裝磁片開機時，卻有些怪現象發生！這是什麼情況呢？</para>
        </question>

        <answer>
          <para>若看到一些怪異現象，像是開機片開機開到一半就當了，磁碟機完全沒任何動作、
	    或是不斷反覆重開機，請先檢查以下幾個線索：</para>

          <orderedlist>
            <listitem>
              <para>請確定是否為全新、沒有磁軌錯誤的磁片？
	        (最好使用新買的，而非雜誌、書本附贈的，甚至還放在床底下三年了...=_="")</para>
            </listitem>

            <listitem>
              <para>請確定是否有用 binary(或image)傳輸模式來下載 image 檔？
	        (不用覺得不好意思，即使是我們也曾意外以 ASCII 傳輸模式來下載 binary 檔案！)</para>
            </listitem>

            <listitem>
              <para>若你是 &windows; 95/98/ME/NT/2000/XP/2003 來下載、製作開機磁片的話，
	        請確定是否有在 DOS 模式使用 <command>fdimage</command> 或
                <command>rawrite</command> 這兩個工具程式？剛講的這些作業系統，
	        都會影響程式去直接寫入硬體，像是製作開機片之類的動作。
	        有時候，在 GUI 介面上的 DOS shell 也可能會發生這樣的問題。
                </para>
            </listitem>
          </orderedlist>

          <para>此外，直接透過 &netscape; 瀏覽器下載 image 檔的話，也有類似現象。
	    所以，如果可以的話，請改用其他可以調整設定的 FTP client端程式來進行下載。
	    (當然，要記得調 binary 傳輸模式)</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="no-install-cdrom">
          <para>用光碟開機片來安裝，但光碟開機後，安裝程式說找不到光碟...這是怎麼了？</para>
        </question>

        <answer>
	  <para>通常問題在於光碟機設定錯誤。目前很多電腦的出廠標準配備都有光碟機，並且
	    會預先設定為 IDE 通道上面 Secondary 的 Slave 設備，而 Secondary 上面的
	    卻沒有 Master 設備。以 ATAPI 的規格而言，這是錯誤的設定，然而 &windows; 的作法
	    是不理會這些規格上的設定問題，而且開機時 BIOS 偵測也會略過這點。
	    這也就是為什麼 BIOS 可以看到光碟，並且可用光碟開機，但 FreeBSD
	    無法正常抓到光碟以順利進行安裝。</para>

          <para>解法：重新設定系統，讓光碟成為它所連接那條 IDE 通道的 Master，
	    或者只有一條 IDE 通道的話，那就讓光碟機成為 Slave
	    ，當然該 IDE 通道上至少要有 Master 設備。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="install-PLIP">
          <para>我可以用 PLIP(Parallel Line IP)方式來安裝 FreeBSD 到筆記型電腦上嗎？</para>
        </question>

        <answer>
          <para>可以，用一條普通的 Laplink 線就可以囉。若有這方面需求的話，請參閱 FreeBSD 使用手冊中的
            <ulink url="&url.books.handbook;/network-plip.html">PLIP
            章節</ulink> 的細部設定</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="geometry">
          <para>該用哪一種硬碟設定參數(geometry)呢？</para>
        </question>

        <answer>
            <note>
              <para>這裡的『硬碟設定參數(geometry)』，指的是硬碟上的
              「cylinders」、「heads」、「sectors/track」 這三個設定參數。
	      接下來的文章內，為了方便介紹，將簡稱為『C/H/S』。
	      這些設定參數是讓 PC 上的 BIOS 能順利地正常判別硬碟，
	      與硬碟本身讀寫的重要因素。</para>
            </note>

          <para>對剛接手的系統管理者新手而言，這些設定參數常造成一些困擾。
	    首先，SCSI 硬碟上的 <emphasis>physical</emphasis> geometry
	    跟 FreeBSD 上的 disk blocks 是完全無關的。事實上，
	    就硬碟上磁區密度的變化而言，並沒有所謂『physical geometry』這種東西。
	    硬碟製造商所說的『physical geometry』通常是指：
	    硬碟上所使用最小空間來存放資料的設定參數(geometry)。
	    以 IDE 硬碟而言，FreeBSD 用以存取硬碟設定的方式是 C/H/S ，
	    然而，目前市面上的硬碟早就在內部運作時，就自動轉換為 block 方式
	    了。</para>

          <para>真正關鍵的地方，其實是在於 『<emphasis>logical</emphasis>
            geometry』— 這是 BIOS 偵測硬碟時所得到的設定，並且用來決定硬碟存取方式。
            由於 FreeBSD 是採用 BIOS 的偵測設定值，所以如何來讓 BIOS 偵測到的設定值保持正確，
	    是十分重要。尤其是同一顆硬碟上有多個作業系統的情況，
	    它們都必須採用一致的硬碟設定參數(geometry)，
	    否則就會有開機進不去作業系統的嚴重問題了。</para>

          <para>以 SCSI 硬碟而言，硬碟設定參數(geometry)是由 SCSI 卡上的
	   extended translation(通常指的是有標示 <quote>support &gt;1GB</quote>(支援 1GB 以上容量，或類似名詞)
	   支援與否來作決定。
           如果不支援，那麼就會採用 <replaceable>N</replaceable> cylinders、
	   64 heads、 32 sectors/track 作為硬碟設定參數(geometry)，這裡講的『<replaceable>N</replaceable>』
	   是指硬碟的容量(單位：MB)。舉個例子來說，一顆 2GB 硬碟應該是
	   2048 cylinders、64 heads、32 sectors/track。</para>

          <para>如果該 SCSI 有支援使用 extended translation 的話，
	    (通常這個方式在 &ms-dos; 使用上有某些限制)，並且硬碟容量大於 1GB，
	    那麼硬碟設定參數(geometry)就會使用像是：
	    M cylinders、255 heads、每磁軌 63 sectors(請注意：不是『64』哦)，
	    這裡講的『<literal>M</literal>』是指硬碟的容量(單位：MB)再除以
	    7.844238 所得出的數值喔！所以，這個例子的話，同樣是 2GB 硬碟應該是
	    261 cylinders、255 heads、每磁軌 63 sectors。</para>

          <para>若對上面講的不瞭解，或是 FreeBSD 在安裝時所偵測到的硬碟設定參數(geometry)
	    有問題的話，最簡單的解法通常是在硬碟上建立一塊小小的 DOS 分割區(partition)。
	    這樣一來，就可以偵測到正確的硬碟設定參數了，而且，
	    如果不想繼續留著那小塊 DOS 分割區的話，可以隨時用 partition editor
	   來拿掉它。或者把它留著當作網路卡驅動程式使用，或隨你高興怎麼用它。</para>

	  <para>此外呢，有個免費好用的工具程式叫做『<filename>pfdisk.exe</filename>』，
	    這個程式放在各 FreeBSD FTP 站或光碟的 <filename>tools</filename> 目錄下，
	    它可以用來找出硬碟上其他作業系統所使用的硬碟設定參數，
	    然後就可以在 partition editor 內輸入剛剛找到的那些設定參數就可以了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="disk-divide-restrictions">
          <para>分割磁碟機時有任何限制嗎﹖</para>
        </question>

        <answer>
          <para>有，你必須確認你的 root 分割區是在 1024 cylinders 之內，讓
	    BIOS 可以從其中啟動核心。(注意：這是 PC 的 BIOS 功能限制，而不
	    是 FreeBSD 的)</para>

          <para>以 SCSI 硬碟而言，通常是把 <literal>root</literal> (<filename>/</filename>)
	    分割區放到硬碟最前面的 1024MB (如果有支援 extended translation 的話，
	    那麼是最前面的 4096MB — 這點請參考上一小節)。而 IDE 硬碟的話，相對應的則是 504MB。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="disk-manager">
          <para>可以使用哪些磁碟管理程式(disk managers)呢？</para>
        </question>

        <answer>
          <para>FreeBSD 可以用 Ontrack Disk Manager 並且運作正常，
            至於其他的 disk manager 則不在正式支援之列。</para>

          <para>若整顆硬碟只裝 FreeBSD ，那麼就不用再裝  disk manager 了。
            只要把硬碟設定為 BIOS 所能抓到的最大空間，那麼 FreeBSD 就可算出實際上可使用的空間了。
	    如果，正在使用的是古早 MFM 控制卡的舊式硬碟，
	    那麼就需要在 FreeBSD內作 cylinders 相關設定了。</para>

          <para>如果想在磁碟上使用 FreeBSD 和另外的作業系統，也可以不裝 disk manager，
	    只要確定 FreeBSD 的啟動分割區跟其他作業系統的 slice 都位於開始的 1024 cylinders
	    內就可以了。如果你相當地高明的話，一個 20MB 的啟動分割區應該就夠用了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-os">
          <para>FreeBSD 安裝完畢後重開機，但是電腦卻說 <errorname>Missing Operating
            System</errorname>這是怎麼了？</para>
        </question>

        <answer>
          <para>通常原因出在 FreeBSD 及 DOS 或其他作業系統在硬碟的 <link
	    linkend="geometry">設定參數(geometry)</link>上的規劃有相衝。解法是重裝，但是請照
	    上述的相關章節步驟來做。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="stop-at-boot-manager">
          <para>為什麼機器上多重開機管理員(boot manager)出現了 <prompt>F?</prompt> 這個選單畫面，
	        但卻不會自動跳過而繼續開機呢？</para>
        </question>

        <answer>
          <para>這個症狀是本文上面所提的另外一個問題了，原因在於 BIOS 上跟 FreeBSD
	    上面兩邊的硬碟的 <link linkend="geometry">設定參數(geometry)</link> 並不一致。
            若你硬碟或 BIOS 支援 cylinder translation
	    (通常會被標為 <quote>support &gt;1GB(支援 1 GB以上容量)</quote>的話，
	    試試看更改相關設定，並重裝 FreeBSD。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="need-complete-sources">
          <para>安裝 FreeBSD 時，需要安裝完整的 sources 嗎？</para>
        </question>

        <answer>
          <para>一般來說，這是用不著的。然而，我們強烈建議您的 source 至少要裝
	    <literal>base</literal>(包含了本文中所提的一些檔案)、以及
	    <literal>sys</literal> (kernel 的 source 檔)。
            雖然，作業系統本身運是不需要裝 source 檔，但是 &man.config.8; 這個 kernel設定程式則需要 src 。
	    若沒裝 kernel 的 source 檔，仍然可以用其他地方透過 NFS 掛載的唯讀檔案系統，
	    來編譯程式。
            但由於 kernel-source 本身的限制，我們建議不要直接 mount 在 <filename>/usr/src</filename>，
	    最好是用 symbolic link(參閱 &man.ln.1;) 將掛載的路徑，設定連結到<filename>/usr/src</filename>
	    目錄。</para>

          <para>在機器上直接裝有 source 並且瞭解相關編譯過程，這樣子日後升級
	    FreeBSD 會來得方便多。</para>

          <para>若忘了裝相關 source 的話，可以事後用 <command>sysinstalll</command>
	    (&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>) 來補裝，選單：Configure → Distributions → src。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="need-kernel">
          <para>需要重新 build kernel 嗎？</para>
        </question>

        <answer>
          <para>在很久很久以前，原本重新 build kernel 在 FreeBSD 安裝過程中，
	    是絕對必需的步驟之一。但目前早就不用這麼麻煩了，
	    目前主要常見的版本都使用更友善的 kernel 設定指令。
	    &os; 4.X(含之前版本)，在 FreeBSD 啟動提示號(boot:)時，使用 <option>"-c"</option> flag
	    就會進入設定畫面，來對 kernel 作常見的 ISA 卡細節設定。
	    而 &os; 5.X(含之後版本)的話，則是以更具彈性的 "hints" 設定方式。</para>

          <para>如果想更節省 RAM 的使用、縮短開機流程，那麼建議：新的 kernel 設定檔只要包含你需要的驅動程式，
	    然後重新編譯、安裝 kernel 並重開機。然而呢，這點對大多數的系統來說，
	    這不一定是必要的。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="password-encryption">
          <para>密碼編碼該採用 DES、Blowfish 或 MD5 的哪一種？該怎麼設定呢？</para>
        </question>

        <answer>
          <para>FreeBSD 預設的密碼編碼方式是採 <emphasis>MD5</emphasis>。
	    就密碼編碼方式而言，MD5 方式一般被視為比傳統 &unix; 的 <emphasis>DES</emphasis> 方式較為安全。
            然而，若有需要在使用舊環境(較不安全的密碼編碼方式的)，DES 密碼編碼方式一樣可以使用。
	    (若使用 sysinstall 時有選擇 <quote>crypto</quote> 套件，或是從 source 內編譯安裝)
            有裝 crypto 的話，crypto libraries 也支援更安全的 Blowfish 編碼方式。</para>

	  <para>密碼編碼的方式是由 <filename>/etc/login.conf</filename> 內的
	    <quote>passwd_format</quote> 欄位來決定的。該欄設定值，(若有裝 crypto 的話)可以是
	    <quote>des</quote> 或 <quote>blf</quote> 或是原本的 <quote>md5</quote>。
            詳情請參閱 &man.login.conf.5; 說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="boot-floppy-hangs">
          <para>為什麼開機磁片開到一半，就出現
            <literal>Probing Devices...</literal> 的畫面訊息，然後就停住了？</para>
        </question>

        <answer>

          <para>若機器上有裝 IDE 介面的 Iomega &iomegazip; 或是 &jaz; 的話，
	    因為這些設備可能跟開機片有相衝，請先拿掉這些設備再重試。
	    當整個作業系統裝好後，就可以把這些設備接回去使用了。
	    希望這點在日後 release 的 FreeBSD 可以獲得徹底解決。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="panic-on-install-reboot">
          <para>系統裝完並重開機後，為什麼卻出現 <errorname>panic: can't mount root</errorname>？</para>
        </question>

        <answer>
          <para>這個錯誤是因為啟動磁區跟 kernel 兩者對磁碟裝置的認知不相同。
	    通常這問題會發生在有兩顆 IDE 硬碟的系統，比如：硬碟 Jumper 設定為 Master、
	    或是兩條 IDE 排線各只連接一顆硬碟，但是裝 FreeBSD 那顆開機硬碟，
	    卻接在 Secondary IDE 排線上。
	    如此一來，在開機時當 kernel 指定第二個 IDE 控制器的第一個磁碟機 ad2，
	    啟動磁區卻認為系統是裝在 ad0(BIOS偵測的第二顆硬碟)！
	    偵測完裝置後，kernel 試著把啟動磁區所認為的開機硬碟(ad0) mount
	    起來，事實上應該是 ad2 才對，所以就會出現上面的錯誤訊息了。</para>

          <para>解法如下，請選擇其中一種方式就好：</para>

            <orderedlist>
              <listitem>
                <para>重開機並在出現『<literal>Booting kernel in 10 seconds; hit [Enter] to interrupt</literal>』
		  提示的時候，按下 <keycap>Enter</keycap>鍵。
	          這樣子就會進入 boot loader 畫面：</para>

                <para>請輸入
                  <literal>
                  set
                  root_disk_unit="<replaceable>disk_number</replaceable>"
                  </literal> 這裡的『<replaceable>disk_number</replaceable>』請依據情況換成相關代號：
		  若 FreeBSD 硬碟是設定裝在 Primary IDE 接線的 Master，就設為 0 ；
	          若是 Primary IDE 接線的 Slave，就設為 1；
	          若是 Secondary IDE 接線的 Master，就設為 2；
	          若是 Secondary IDE 接線的 Slave，就設為 3。</para>

                <para>接著請再輸入 <literal>boot</literal>，然後系統應該就可以正常開機了。</para>

                <para>若要每次開機都自動設定，而不必每次都打一次，那麼就在 <filename>/boot/loader.conf.local</filename>
	          檔案內加上 <literal>root_disk_unit="<replaceable>disk_number</replaceable>"</literal>
	          這行
		  (當然，『<replaceable>disk_number</replaceable>』要改成相關代號)</para>
              </listitem>

              <listitem>
                <para>把 FreeBSD 硬碟改接到 Primary IDE 接線上，如此一來就可順利使用。</para>
              </listitem>
            </orderedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="memory-limits">
          <para>記憶體最大限制為多少？</para>
        </question>

        <answer>
          <para>一般 &i386; 機器上最多可支援到 4 GB(gigabytes)。
            而自 &os; 4.9 及 5.1 可以開始使用 &man.pae.4; 來支援更多的記憶體。
            有關這點，需要在 kernel 設定檔內加入下列內容並重新編譯 kernel，才能使用 PAE。</para>

            <programlisting>options       PAE</programlisting>

          <para>&os; 在 pc98 機器上最多則只支援 4 GB ，而且不能使用 PAE。
            在 Alpha 機器上，記憶體限制方面要視所使用的型號支援程度而定，這點請參閱
	    所使用的 Alpha 硬體規格表。至於其他架構的 &os; 理論上最多可使用的記憶體，有較多的限制。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ffs-limits">
          <para>檔案系統最大限制為多少？</para>
        </question>

        <answer>
          <para>就檔案系統方面，理論上的限制是最多到 8TB(2G blocks)，
	    或是使用內定 8K block 大小時，限制是 16TB。
	    實際上，目前軟體使用上限制只能用到 1 TB，
	    然而如果是有另行改造過檔案系統，那麼達到 4TB 的目標是可行的
	    (也有人成功過)。</para>

          <para>單一檔案的大小方面，假如 block 以 4K 作規劃的話，
	    則最大是趨近 1G blocks(4TB)。</para>

          <table>
            <title>檔案大小的最大限制</title>

            <tgroup cols="3">
              <thead>
                <row>
                  <entry>檔案系統 block 大小</entry>

                  <entry>works</entry>

                  <entry>should work</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>4K</entry>

                  <entry>4T-1</entry>

                  <entry>&gt;4T</entry>
                </row>

                <row>
                  <entry>8K</entry>

                  <entry>&gt;32G</entry>

                  <entry>32T-1</entry>
                </row>

                <row>
                  <entry>16K</entry>

                  <entry>&gt;128G</entry>

                  <entry>32T-1</entry>
                </row>

                <row>
                  <entry>32K</entry>

                  <entry>&gt;512G</entry>

                  <entry>64T-1</entry>
                </row>

                <row>
                  <entry>64K</entry>

                  <entry>&gt;2048G</entry>

                  <entry>128T-1</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>When the fs block size is 4K, triple indirect blocks work
            and everything should be limited by the maximum fs block number
            that can be represented using triple indirect blocks (approx.
            1K^3 + 1K^2 + 1K), but everything is limited by a (wrong) limit
            of 1G-1 on fs block numbers. The limit on fs block numbers
            should be 2G-1. There are some bugs for fs block numbers near
            2G-1, but such block numbers are unreachable when the fs block
            size is 4K.</para>

          <para>block 大小如果是 8K 或更大，檔案系統 block 數目會被限制在 2G-1
	    ，但實際上應該說限制是 1G-1 才對，因為採用 2G-1 block 的檔案系統會導致一些問題。
	    </para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="archsw-readin-failed-error">
          <para>為何在啟動新的 kernel 時，看到
	    <errorname>archsw.readin.failed</errorname> 錯誤訊息？</para>
        </question>

        <answer>
          <para>原因出在你的 world 以及 kernel 並不同步，舉例：kernel 用 4.11，
	    而 world 卻是 4.8，這樣是會有問題的。
	    請再次確認，是否有以 <command>make buildworld</command> 及
	    <command>make buildkernel</command> 來正常更新 kernel。</para>

	  <para>在啟動 loader 之前，會看到 "|" 這個符號在轉動，這時可以按任何鍵中斷，
	    然後再指定要載入哪個 kernel 來開機。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="security-profiles">
          <para><quote>security profiles</quote> 是指什麼？</para>
        </question>

        <answer>
          <para>A <quote>security profile</quote> is a set of configuration
            options that attempts to achieve the desired ratio of security
            to convenience by enabling and disabling certain programs and
            other settings.  For full details, see the <ulink
            url="&url.books.handbook;/install-post.html#SECURITYPROFILE">Security
            Profile</ulink> section of the Handbook's <ulink
            url="&url.books.handbook;/install-post.html">post-install
            chapter</ulink>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="boot-acpi">
	  <para>在開機時，選擇使用 ACPI 則在安裝過程就掛了，該怎麼辦？</para>
	</question>

	<answer>
	  <para>試試看關閉 ACPI support。 當在載入 bootloader時，按下空白鍵。
	    系統會顯示 <screen>OK</screen> 這時輸入
	    <screen><userinput>unset acpi_load</userinput></screen> 接著打
	    <screen><userinput>boot</userinput></screen>
	    以繼續開機，這樣子應該就可以了。</para>
	</answer>
      </qandaentry>

    </qandaset>
  </chapter>

  <chapter
    id="hardware">
    <title>硬體支援方面</title>

      <sect1 id="compatibility-general">
	<title>一般問題</title>

    <qandaset>
      <qandaentry>
        <question id="which-hardware-to-get">
          <para>我想組裝自己的 FreeBSD 機器，有哪些型號、品牌、規格是支援程度最好的呢？</para>
        </question>

        <answer>
          <para>有關這點，在 FreeBSD 討論區上時常有人討論。雖然硬體汰換速度很快，
	    可能隨時有新規格、新產品出現，然而這些都在我們意料之中，
	    我們 <emphasis>仍然</emphasis> 強烈建議：在詢問有關最新規格硬體的支援問題之前，
	    請先參閱 &os;
	    <ulink url="&rel.current.hardware;">&rel.current;</ulink>
	    或
	    <ulink url="&rel2.current.hardware;">&rel2.current;</ulink>的支援硬體列表，
	    或是搜尋<ulink url="http://www.FreeBSD.org/search/#mailinglists">討論區的舊文章</ulink>，
            也許，上週才剛恰巧有人討論過你所要問的硬體。</para>

          <para>如果要找有關筆記型電腦方面，請到 FreeBSD-mobile 筆記型電腦討論區。
            不然，就到 FreeBSD-questions 討論區，或是特定硬體規格(比如 pc98, Alpha)的專屬討論區吧。
            </para>
        </answer>
      </qandaentry>

    </qandaset>
      </sect1>

      <sect1 id="compatibility-processors">
	<title>硬體架構及 CPU</title>

    <qandaset>
      <qandaentry>
        <question id="architectures">
          <para>FreeBSD 有支援 x86 之外的硬體架構平台嗎？</para>
        </question>

        <answer>

          <para>有的，FreeBSD 目前可以在 Intel x86 and DEC
            (現在的 HP-Compaq) Alpha 架構上面運作。自 FreeBSD 5.0 之後的版本，則
            可支援 AMD64 及 Intel EM64T, IA-64 以及 &sparc64; 架構。
            未來平台支援上還會有 &mips; 及
            &powerpc;，細節請分別參閱 &a.mips; 或 &a.ppc;。
            一般而言，新的硬體架構平台方面，都是到 &a.platforms; 討論。</para>

          <para>若你機器不是以上架構或是比較奇特的，而想立刻試試看 BSD 的魔力，
	    我們建議你可以考慮使用 <ulink
            url="http://www.netbsd.org/">NetBSD</ulink> 或 <ulink
            url="http://www.openbsd.org/">OpenBSD</ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="smp-support">
          <para>FreeBSD 支援 CPU 對稱多工處理(SMP, Symmetric Multiprocessing)嗎？</para>
        </question>

        <answer>
          <para>有的。 SMP 在 &os; 5.2 預設的 kernel(<emphasis>GENERIC</emphasis>)已有啟動。
	    </para>

          <para>在 &os; 5.3 要 release 時，SMP相關設定也是預設就有啟動。
	    然而，在一些較新型的機器(像是 emt64)上卻又有些問題，
	    所以還是決定在相關問題、安全議題未獲解決前，先關閉 SMP 的相關啟動。
	    這點，正是 &os; 5.4 所優先考慮的方向。</para>

          <para>&os; 4.X 的話，預設的 kernel 並沒有啟動 SMP，
            因此，必須要把 options SMP 加入 kernel 設定檔並重新編譯才能啟動。
	    至於還有哪些相關設定要放入 kernel 設定檔，請參閱<filename>/sys/i386/conf/LINT</filename>。
	   </para>
        </answer>
      </qandaentry>
        </qandaset>
      </sect1>

      <sect1 id="compatibility-drives">
	<title>硬碟、磁帶機以及光碟、DVD、燒錄機</title>

	<qandaset>

      <qandaentry>
        <question id="supported-hard-drives">
          <para>FreeBSD 可支援哪些種類的硬碟呢？</para>
        </question>

        <answer>
          <para>FreeBSD 都支援 EIDE 及 SCSI 介面的硬碟(以及 SCSI 卡，請看下一節說明)
            以及 <quote>Western Digital</quote> 介面的硬碟 (MFM、 RLL、
            ESDI，當然包含 IDE)，不過有一些少數的 ESDI 晶片組的(型號：WD1002/3/6/7)
	    可能無法正常運作。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="supported-scsi-controllers">
          <para>支援哪些 SCSI 卡、設備呢？</para>
        </question>

        <answer>
          <para>請參閱 &os; 的硬體支援表(
	    <ulink url="&rel.current.hardware;">&rel.current;</ulink> 或
	    <ulink url="&rel2.current.hardware;">&rel2.current;</ulink>)</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="tape-support">
          <para>支援哪些磁帶機呢？</para>
        </question>

        <answer>

          <para>FreeBSD 支援 SCSI 及 QIC-36 (QIC-02 介面) 規格的磁帶機。
            同時包含了 8-mm (也就是 Exabyte) 及 DAT 磁帶機。</para>

          <para>有些早期版本的 8-mm 磁帶機並不是完全相容於 SCSI-2 規格，
	    所以可能在 FreeBSD 上表現不是很好。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="tape-changer-support">
          <para>FreeBSD 支援磁帶自動換帶機嗎？</para>
        </question>

        <answer>
          <para>FreeBSD 可以用 &man.ch.4; 上面所列的機種，搭配 &man.chio.1; 指令，
	    來使用 SCSI 種類的自動換帶機，細節部分請參閱 &man.chio.1; 說明。</para>

          <para>If you are not using <application>AMANDA</application>
            or some other product that already understands changers,
            remember that they only know how to move a tape from one
            point to another, so you need to keep track of which slot a
            tape is in, and which slot the tape currently in the drive
            needs to go back to.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="supported-cdrom-drives">
          <para>FreeBSD 可支援哪些種類的光碟機呢？</para>
        </question>

        <answer>
          <para>只要是有支援的 SCSI 卡上所接的任一  SCSI 光碟機都有支援。</para>

          <para>此外，也支援下列的光碟機：</para>

            <itemizedlist>
              <listitem>
                <para>Mitsumi LU002 (8bit), LU005 (16bit) 及 FX001D
                  (16bit 2x Speed)</para>
              </listitem>

              <listitem>
                <para>Sony CDU 31/33A</para>
              </listitem>

              <listitem>
                <para>Sound Blaster 非 SCSI 介面的光碟機</para>
              </listitem>

              <listitem>
                <para>Matsushita/Panasonic 光碟機</para>
              </listitem>

              <listitem>
                <para>相容 ATAPI 規格的 IDE CDROMs</para>
              </listitem>
            </itemizedlist>

          <para>相對於 SCSI 機種而言，其他非 SCSI 的光碟機都是比較慢，
	    此外，有些 ATAPI 種類的光碟機可能無法順利運作</para>

          <para>Daemon News 以及 FreeBSD Mall 所發行的正式 FreeBSD 光碟以及燒錄用的影像檔(ISO)，
	    都可以直接用於開機光碟使用。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="supported-cdrw-drives">
          <para>FreeBSD 支援哪些光碟燒錄機的驅動程式呢？</para>
        </question>

	<answer>
	  <para>FreeBSD 支援任何相容 ATAPI 標準的 IDE CD-R 或 CD-RW 光碟燒錄機，
	    細節請參閱 &man.burncd.8; 說明。</para>

	  <para>FreeBSD 也支援任何 SCSI CD-R 或 CD-RW 光碟燒錄機。
	    請用 port 或 packag 機制來安裝、使用 <command>cdrecord</command> ，
	    並確定您的 kernel 內有將 <devicename>pass</devicename>設備一併編譯在內。
	    (預設的 kernel.GENERIC 都會有 device pass 這段)</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="zip-support">
          <para>FreeBSD 支援 Iomega &iomegazip; 嗎?</para>
        </question>

        <answer>
          <para>FreeBSD 支援外接式的 SCSI 及 ATAPI(IDE) 介面的 Iomega &iomegazip;。
	    不過 SCSI ZIP 只能被設為 SCSI ID 5 或是 6 才可以運作，但如果
	    SCSI 卡上的 BIOS 支援它，你甚至可以用它來開機。
	    我們不曉得哪一塊卡可以把卡的 ID 設在除了 0 或 1 以外的地方而開機成功，
	    因此，如果想改 SCSI ID 的話，請務必參閱該型號的說明手冊。</para>

          <para>FreeBSD 同時也支援 Parallel Port Zip磁碟機。請檢查 kernel
	    設定檔是否有：
            <devicename>scbus0</devicename>、
            <devicename>da0</devicename>、
            <devicename>ppbus0</devicename>，以及
            <devicename>vp0</devicename> 這些驅動程式 (預設的 GENERIC kernel
            除了 <devicename>vp0</devicename> 沒包進去，其他三者都會有)。
	    加了這幾個驅動程式之後，Parallel Port Zip 就會成為
	    <devicename>/dev/da0s4</devicename>。</para>

	  <para>這時，就可以用像是 <command>mount /dev/da0s4 /mnt</command> 或
	    (DOS 檔案系統)<command>mount_msdos /dev/da0s4 /mnt</command>
	    之類的指令來掛載、讀寫。</para>

          <para>也可以參閱下面有關<link linkend="media-change">隨身磁片
            </link>部分，以及<link
            linkend="removable-drives">抽取碟、隨身碟的『格式化』討論</link>
            的部分</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="jaz-zip-removable-support">
          <para>FreeBSD 有支援 &jaz;、EZ 及其他類似的隨身磁片嗎？</para>
        </question>

        <answer>
          <para>可以啊，除了 IDE 的 EZ drive 外，其他的應該都是 SCSI 介面，
	    所以在 FreeBSD 上都會以 SCSI 硬碟來處理。</para>

	  <para>當然，你必須確定在開機時，這些設備的電源是打開的，
	    以便讓 FreeBSD 可以偵測到。</para>

          <para><anchor id="media-change"/>如果在磁碟運中狀態中，要更換磁片的話，
	    記得先看一下 &man.mount.8;、&man.umount.8;、
	    以及(SCSI的話)&man.camcontrol.8; 或 &man.atacontrol.8; 還有 FAQ 後面有關
	    <link linkend="removable-drives">使用抽取碟、隨身碟的討論
            </link>。</para>
        </answer>
      </qandaentry>

	</qandaset>

      </sect1>

      <sect1 id="compatibility-kbd-mice">
	<title>鍵盤、滑鼠</title>

	<qandaset>

      <qandaentry>
        <question id="usbkbd">
          <para>FreeBSD 有支援 USB 鍵盤嗎？</para>
        </question>

        <answer>
          <para>FreeBSD (尤其是有支援 USB keyboards。  Enable USB support in
            <filename>/etc/rc.conf</filename>.</para>

          <para>若有開 USB 鍵盤支援而且同時接上 AT 跟 USB 鍵盤的話，那麼 AT 鍵盤會變成
	    <devicename>/dev/kbd0</devicename>，而 USB 鍵盤則是
	    <devicename>/dev/kbd1</devicename>。如果只接 USB 鍵盤，那麼它就是
	    <devicename>/dev/ukbd0</devicename> 囉。</para>

          <para>如果想在 console 上使用 USB 鍵盤的話，那麼必須設定 console 指定用 USB 鍵盤。
	    可以在系統開機程序時，加上下列指令：</para>

          <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>

          <para>注意：若只有 USB 鍵盤的話，也就是 <devicename>/dev/ukbd0</devicename>，
	    那麼請改用下列指令：</para>

          <screen>&prompt.root; <userinput>kbdcontrol -k /dev/ukbd0 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>

          <para>建議：可以把上述指令放入 <filename>/etc/rc.i386</filename> 。</para>

          <para>設定成功之後，USB 鍵盤不用作任何特別設定，就可以在 X 視窗環境上正常運作囉。</para>

          <para>USB 鍵盤的熱插拔(Hot-plugging and unplugging)在 &os; 可能還無法完全正常運作，
	    建議：在系統開機前就先接上鍵盤，直到關機為止，以避免不必要的困擾。</para>

          <para>相關細節請參閱 &man.ukbd.4; 的說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="busmouse">
          <para>古早的 bus 滑鼠，要怎麼設定呢？</para>
        </question>

        <answer>
          <para>FreeBSD 支援一些廠商(像是：Microsoft、Logitech、ATI)所做的 bus 及 InPort bus 介面的滑鼠。
            然而，預設的 kernel(GENERIC)已經不內含它們的驅動程式。
	    因此，要加入下列到 kernel 設定檔並重新編譯、安裝，才能啟用：</para>

          <programlisting>device mse0 at isa? port 0x23c irq5</programlisting>

          <para>Bus 滑鼠通常要搭配專用的介面卡才能使用。
            這些卡可以設定 port address 及 IRQ 值，這些細節請參閱你的滑鼠說明手冊及
            &man.mse.4; 說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ps2mouse">
          <para>PS/2 (<quote>mouse port</quote> 或
            <quote>keyboard</quote>)的滑鼠要怎麼設定才好呢？</para>
        </question>

        <answer>
          <para>PS/2 滑鼠都有支援，所需要用到的驅動程式 <devicename>psm</devicename>
	     在預設的 kernel(GENERIC)已有內含了。</para>

          <para>若你自訂的 kernel 內漏了 psm 的話，那麼就再把下列內容加到 kernel
		設定檔並重新編譯、安裝：</para>

          <programlisting>device psm0 at atkbdc? irq 12</programlisting>

          <para>當開機時 kernel 有正確偵測到 <devicename>psm0</devicename>
            ，請務必確認在 <filename>/dev</filename> 內有
            <devicename>psm0</devicename> 。
	    如果沒有的話，那麼就用 <username>root</username> 來打下列指令來建立吧：</para>

          <screen>&prompt.root; <userinput>cd /dev; sh MAKEDEV psm0</userinput></screen>

          <note>
	    <para>如果是 &os; 5.0-RELEASE(含之後版本)的話，因為採用 &man.devfs.5; 機制的因素，
	      所以會自動在 <filename>/dev</filename> 下建立相關設備的節點，因此就可以略過上面這一步。</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="moused">
          <para>如果不用 X Window 環境的話，也可以用滑鼠嗎？</para>
        </question>

        <answer>
          <para>若使用 console 的預設驅動程式(也就是 &man.syscons.4;)，
	    那麼就可以在文字介面的 console 上面用滑鼠來剪貼文字了。
	    那麼要啟動 &man.moused.8; 並開啟游標顯示，
	    請打下列指令：</para>

          <screen>&prompt.root; <userinput>moused -p /dev/<replaceable>xxxx</replaceable> -t <replaceable>yyyy</replaceable></userinput>
&prompt.root; <userinput>vidcontrol -m on</userinput></screen>

          <para>其中『<replaceable>xxxx</replaceable>』是滑鼠的設備名稱，而
            『<replaceable>yyyy</replaceable>』則是滑鼠所使用的 protocol 種類。
            目前的 moused 可以自動偵測(除了舊式的 serial
	    滑鼠之外)大多數滑鼠所使用的 protocol 種類，而不用刻意去指定。
            『protocol 種類』設定用
            <literal>auto</literal> 就會自動偵測了。若自動偵測失敗的話，請參閱 &man.moused.8;
	    裡面的 type 那段說明。</para>

          <para>如果用的是 PS/2 滑鼠，只要把
            <literal>moused_enable="YES"</literal> 加到
            <filename>/etc/rc.conf</filename> ，這樣每次開機就會自動啟動了。
            此外，如果要在所有 virtual terminals 上也能使用滑鼠，
	    而不限定只有 console 的話，那麼請再把
            <literal>allscreens_flags="-m on"</literal> 加到 <filename>/etc/rc.conf</filename> 裡面即可。</para>

          <para>moused 在執行中的時候，如果要使用滑鼠相關功能，都必須透過 moused
	    或其他程式像是 X 視窗來進行。請參閱 FAQ 中有關<link
            linkend="x-and-moused">『為什麼不能在 X 視窗裡使用滑鼠？』</link>以瞭解相關細節。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="text-mode-cut-paste">
          <para>在文字模式的 console 環境要怎麼用滑鼠來剪貼文字呢？</para>
        </question>

        <answer>
          <para>當執行 moused 後，(參閱<link linkend="moused">前一節</link>)
	    按住左鍵，接著移動滑鼠來選擇一個區域之後放開，這樣就完成『複製』。
	    要『貼上』的話，按滑鼠中鍵就可以了。
	    要『延伸選取區』的話，按滑鼠右鍵</para>


	  <para>如果你的滑鼠沒有中鍵，你可以用模擬的方式，或是重新定義滑鼠按鍵的方式，
	    來達成「延伸」的功能。詳情請參閱 &man.moused.8; 說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mouse-wheel-buttons">
          <para>我滑鼠上面的滾輪、滾輪按鈕，可以在 console 上使用嗎？</para>
        </question>

        <answer>
	  <para>這個答案嘛...，很不幸地，在大多數的情況下不行。
	    這些有滾輪的滑鼠需要用特殊驅動程式才行，
	    除非，滑鼠驅動程式或使用者自己的應用程式有支援，
	    不然，這些滑鼠只能夠當成是普通的兩鍵或三鍵的滑鼠來用而已。
            </para>

          <para>如果要在 X 視窗環境上使用滾輪的話，請參閱
            <link linkend="x-and-wheel"> X 視窗上的滾輪使用
            </link>說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="laptop-mouse-trackball">
          <para>要怎麼在筆記型電腦上使用滑鼠、軌跡球、觸控板呢？</para>
        </question>

        <answer>
          <para>請參閱<link linkend="ps2mouse">前面的 PS/2 滑鼠的問答
            </link>。</para>
        </answer>
      </qandaentry>

	</qandaset>

      </sect1>

      <sect1 id="compatibility-networking">
	<title>網路跟 serial 設備</title>

	<qandaset>

      <qandaentry>
        <question id="network-cards">
          <para>FreeBSD 支援哪些網路卡呢？</para>
        </question>

        <answer>
          <para>請參考 &os; 各版本的硬體支援列表。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="internal-plugnplay-modem">
          <para>為什麼 FreeBSD 找不到 PnP(隨插隨用，Plug &amp; Play)規格的 modem?</para>
        </question>

        <answer>
          <para>原因在於：需要把 modem 的 PnP ID 加到 serial 驅動程式的 PnP ID 表，作法如下：</para>
	    <orderedlist>
	      <listitem>
	        <para>首先，在 kernel 設定檔內加入 <literal>controller pnp0</literal>，
	           並重新編譯、安裝 kernel，最後重開機就會啟動 PnP 支援。</para>
	      </listitem>

	      <listitem>
	        <para>然後，kernel 會把偵測到所有設備上的 PnP ID 都列出。
	          這時，修改 <filename>/usr/src/sys/isa/sio.c</filename>(大約第752行左右的地方)，
	          可以搜尋 <literal>SUP1310</literal> 當關鍵字(位於 <literal>sio_ids[]</literal> 表內)，
	          請將剛才 kernel 顯示的 modem 的 PnP ID 複製到相關位置。</para>
	      </listitem>

	      <listitem>
	        <para>這時，再重新編譯、安裝 kernel，最後重開機應該就會正確偵測到 modem 了。</para>
	      </listitem>
	    </orderedlist>

          <para>此外，也可以在開機時以 <literal>pnp</literal> 指令來手動設定 PnP 設備，
	     來讓 kernel 得以正確偵測，舉例：</para>

          <programlisting>pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8</programlisting>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="support-winmodem">
          <para>FreeBSD 支援像是 Winmodems 之類的軟體 modem 嗎？</para>
        </question>

        <answer>
          <para>FreeBSD 可以安裝額外的軟體來支援軟體 modem。
            像是 <filename role="package">comms/ltmdm</filename> 可支援常見的 Lucent LT 晶片，
	    <filename role="package">comms/mwavem</filename> 則可支援 IBM Thinkpad 600 及 700
	    筆記型電腦上面的 modem。</para>

          <para>然而，並不能用軟體 modem 來安裝 FreeBSD，
	    因為：這類軟體必須在作業系統安裝完畢之後，才能安裝。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="support-broadcom">
	  <para>有 Broadcom 43xx 無線網卡的原生驅動程式(Native driver)嗎？</para>
	</question>

	<answer>
	  <para>沒有，而且也不太可能會有。</para>

	  <para>Broadcom 拒絕公開有關無線網卡晶片的驅動程式相關說明，
	    主因大概是他們用軟體來控制無線傳輸方式。
	    事實上，因為要能通過美國聯邦電信委員會(FCC)檢磁安規的話，
	    必須確保產品不能讓使用者不能隨意更動相關設定，比如：電磁波頻率、相關模組參數、輸出電源等。
	    但是，如果我們不知道如何去控制晶片的話，那麼撰寫驅動程式之路恐怕不太可行。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="multiport-serial-support">
          <para>FreeBSD 支援哪些 multi-port serial卡呢？</para>
        </question>

        <answer>
          <para>請參閱使用手冊上的 <ulink
	    url="&url.books.handbook;/install.html#INSTALL-MISC">安裝篇—其他硬體
            </ulink> 列表。</para>

          <para>雖然有些卡是沒牌的(尤其是有標明：相容 AST 規格)但也可以正常使用。</para>

          <para>至於卡的設定方面，請參閱 &man.sio.4; 的說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="serial-console-prompt">
          <para>在 serial console 上要如何才會出現 boot: 提示呢？</para>
        </question>

        <answer>
            <orderedlist>
              <listitem>
                <para>kernel 設定檔加入
                  <literal>options COMCONSOLE</literal></para>
              </listitem>

              <listitem>
                <para>建立 /boot.config 檔，並且該檔裡面內容只填上 <option>-P</option></para>
              </listitem>

              <listitem>
                <para>把鍵盤從機器上拔掉</para>
              </listitem>
            </orderedlist>

          <para>細節請看
            <filename>/usr/src/sys/i386/boot/biosboot/README.serial</filename>
            </para>
        </answer>
      </qandaentry>

	</qandaset>

      </sect1>

      <sect1 id="compatibility-sound">
	<title>音效卡</title>

	<qandaset>

      <qandaentry>
        <question id="sound-card-support">
          <para>FreeBSD 支援哪些音效卡？</para>
        </question>

        <answer>
          <para>&os; 支援各種音效卡，包括了 &soundblaster;、
	    &soundblaster; Pro、&soundblaster; 16、Pro Audio Spectrum 16、
            AdLib、及 Gravis UltraSound sound cards (細節請參閱
            <ulink url="&url.base;/releases/">&os; 發行情報</ulink>
            以及 &man.snd.4; 的說明)。
            此外，對 MPU-401 及 MIDI 相容規格的也有一定程度的支援，而
            &microsoft; Sound System 規格也有支援。</para>

            <note>
              <para>驅動程式僅適用於『音效』部分！ 除了 &soundblaster; 之外，
	        目前音效驅動程式並不支援這些音效卡上的光碟機, SCSI設備或搖桿。
	        &soundblaster; 的 SCSI 介面及某些非 SCSI 的光碟機是有支援，但無法用來開機。
		</para>
             </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="es1370-silent-pcm">
          <para>&man.pcm.4; 所支援的音效卡沒有聲音，有什麼暫時解決方式嗎？</para>
        </question>

        <answer>
          <para>因為有些像是 es1370 晶片的音效卡會在每次開機時把音量調為零。
	    暫時解法是在每次開機時執行下面指令，或是加到 /etc/rc.local 內：</para>

          <screen>&prompt.root; <userinput>mixer pcm 100 vol 100 cd 100</userinput></screen>
        </answer>
      </qandaentry>

	</qandaset>

      </sect1>

      <sect1 id="compatibility-other">
	<title>其他怪異問題(ACPI、重開機後掛了..等)</title>

	<qandaset>

      <qandaentry>
        <question id="other-device-support">
          <para>FreeBSD 還支援其他哪些硬體呢？</para>
        </question>

        <answer>
          <para>請參閱使用手冊上的 <ulink
	    url="&url.books.handbook;/install.html#INSTALL-MISC">安裝篇—其他硬體</ulink>
            。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="power-management-support">
          <para>FreeBSD 支援筆記型電腦的省電管理功能嗎？</para>
        </question>

        <answer>
          <para>FreeBSD 4.X(含之後版本)在某些機種上都有支援 <acronym>APM</acronym>。
            細節請參閱 &man.apm.4; 的說明。</para>

	  <para>FreeBSD 5.X(含之後版本)支援在目前大部分機種上都有的
	    <acronym>ACPI</acronym> 功能。
	    細節請參閱 &man.acpi.4; 的說明。若機器上同時都有 <acronym>APM</acronym>
	    及 <acronym>ACPI</acronym> 功能的話，我們建議你可以兩者都試試看，
	    看看哪一種比較符合你的需求。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="disable-acpi">
          <para>該如何關閉 ACPI？</para>
        </question>

        <answer>
          <para>把 <screen>hint.acpi.0.disabled="1"</screen>
		這段加到 <filename>/boot/device.hints</filename> 即可。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="micron-hang-boot">
          <para>Micron 電腦總是在 &os; 啟動時就掛掉，該怎麼辦呢？</para>
        </question>

        <answer>
          <para>有些 Micron 主機板上的 BIOS 在 PCI 方面會有問題，
	    這會導致 PCI 設備會被 BIOS 偵測為不正確設定，而進入 FreeBSD 就掛掉。</para>

          <para>暫時解決方式：關閉 BIOS 內 <quote>Plug and Play Operating System</quote>
            的設定。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="micron-3comnic-failure">
          <para>&tm.3com; PCI 介面網路卡無法在 Micron 電腦上使用，該怎麼辦？</para>
        </question>

        <answer>
          <para>這問題跟前面的問題因素一樣，總之，就是關閉 BIOS 中有關 OS PnP 的設定。</para>

          <para>暫時解決方式：關閉 BIOS 內 <quote>Plug and Play Operating System</quote>
            的設定。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="asusk7v-boot-failure">
          <para>主機板是用華碩(ASUS) K7V，可是用開機片開到一半就當了，怎麼辦呢？</para>
        </question>

        <answer>
          <para>進入 BIOS 設定，並關閉 <quote>boot virus protection</quote> 設定即可。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="newcard-does-not-work">
	  <para>PCMCIA 卡無法使用，並出現錯誤訊息
	    <quote>cbb0: unsupported card type detected.</quote>
	    該怎麼辦？</para>
	</question>

	<answer>
	  <para>可以試試看改用舊的方式，請先修改 kernel 設定檔，拿掉下面這幾行：
	    <programlisting>device cbb
device pccard
device cardbus</programlisting>
	    然後加上：
	    <programlisting>device pcic
device card 1</programlisting>
	    最後請參閱 Handbook 中
	    <ulink url="&url.books.handbook;/kernelconfig.html">調整 FreeBSD Kernel</ulink>
	    章節，以重新編譯、安裝新的 kernel。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="dell-poweredge-failure">
          <para>為什麼 &dell; &poweredge; 2850 裝完 FreeBSD 之後，重開機接著鍵盤就掛了？</para>
        </question>

        <answer>
          <para>(本題由 cdsheen 提供)嚐試在 &dell; &poweredge; 2850 上面安裝 &os; 6.0，
	    不過安裝完成、並重新開機之後，發現 console 的鍵盤不能動了，
	    同樣的情況似乎也存在於 &os; 5.3 及 &os; 5.4，
	    經過一番搜尋，發覺是因為這台機器上面有一個 <quote>Dell Remote Access Controller (DRAC)</quote>，
	    這個裝置會被系統辨識成一個 USB Keyboard，所以導致開完機之後，正常的 PS/2 鍵盤反而不能動了！</para>

	  <para>暫時解決方式如下：</para>

            <orderedlist>
              <listitem>
                <para>先以 Single User Mode 進入系統</para>
              </listitem>

              <listitem>
                <para>在命令列模式下，先執行下列命令：</para>
		  <screen>&prompt.root; <userinput>fsck -y <filename>/</filename></userinput></screen>
	          <screen>&prompt.root; <userinput>mount -u <filename>/</filename></userinput></screen>
              </listitem>

              <listitem>
                <para>然後編輯 <filename>/etc/devd.conf</filename>，把對於 USB Keyboard 的支援暫時拿掉，
	          也就是把下面幾行開頭加上 #</para>
	        <programlisting>
# When a USB keyboard arrives, attach it as the console keyboard.
#attach 100 {
#       device-name "ukbd0";
#       action "kbdcontrol -k /dev/ukbd0 &lt; /dev/console &amp;&amp; /etc/rc.d/syscons restart";
#};
#detach 100 {
#       device-name "ukbd0";
#       action "kbdcontrol -k /dev/kbd0 &lt; /dev/console";
#};
</programlisting>
              </listitem>

              <listitem>
                <para>然後輸入 <command>exit</command>離開 Single User Mode 之後，
	          就可以順利進入系統、而且鍵盤也可以正常運作，下次開機也不會有問題！</para>
              </listitem>
            </orderedlist>

          <para>另外，&dell; 的 DRAC/BMC 看起來有蠻多不錯的遠端存取功能，有興趣的人可以玩玩看...</para>
        </answer>
      </qandaentry>
    </qandaset>

      </sect1>

  </chapter>

  <chapter id="troubleshoot">
    <chapterinfo>
      <author>
	<firstname>William</firstname>
        <surname>Liao</surname>
        <affiliation>
          <address><email>chliao@tpts4.seed.net.tw</email></address>
        </affiliation>
      </author>
    </chapterinfo>

    <title>常見問題解決</title>

    <qandaset>
      <qandaentry>
        <question id="pae">
          <para>為什麼 &os; 抓到錯誤的記憶體容量？</para>
        </question>

        <answer>
	  <para>抓到錯誤的記憶體容量是因為物理位址跟虛擬位址兩者是不同的。</para>

	  <para>The convention for most PC hardware is to use the memory area
	    between 3.5G and 4G for a special purpose (usually for PCI).  This
	    address space is used to access PCI hardware.  As a result real,
	    physical memory can not appear in that address space.</para>

	  <para>What happens to the memory that should appear in that location
	    is dependent on your hardware.  Unfortunately, some hardware does
	    nothing and the ability to use that last 500M of RAM is entirely
	    lost.</para>

	  <para>Luckily, most hardware remaps the memory to a higher location
	    so that it can still be used.  However, this can cause some
	    confusion if you watch the boot messages.</para>

	  <para>On a 32 bit version of &os;, the memory appears lost, since it
	    will be remapped above 4G, which a 32 bit kernel is unable to
	    access.  In this case, the solution is to build a PAE enabled
	    kernel.  See <link linkend="memory-limits">this FAQ entry</link>
	    for more information.</para>

	  <para>On a 64 bit version of &os;, or when running a PAE-enabled
	    kernel, &os; will correctly detect and remap the memory so it is
	    usable.  During boot, however, it may seem as if &os; is detecting
	    more memory than the system really has.  This is normal and the
	    available memory will be corrected as the boot process
	    completes.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="awre">
          <para>硬碟有壞軌時該怎麼辦?</para>
        </question>

        <answer>
          <para>若是 SCSI 硬碟的話，那麼磁碟機應該有能力自動作 re-mapping
            的動作。然而，因為一些未知的因素，在出廠時，很多硬碟的這項
            功能是關閉的...</para>

          <para>要將其重新開啟，您需要編輯裝置的第一個 page 模式
            （first device page mode），在 FreeBSD 上可以用下面的指令辦到
            （以 <username>root</username>身分執行）</para>

          <screen>&prompt.root; <userinput>scsi -f /dev/rsd0c -m 1 -e -P 3</userinput></screen>

          <para>然後將 AWRE 和 ARRE 的數值從 0 變成 1:-</para>

          <programlisting>AWRE（Auto Write Reallocation Enbld）： 1
ARRE（Auto Read Reallocation Enbld）： 1</programlisting>

          <para>以下這段是由 Ted Mittelstaedt
            <email>tedm@toybox.placo.com</email>所提供：</para>

          <para>若為 IDE 硬碟，任何的壞軌通常都是麻煩的預兆。目前所有較新的
            IDE 硬碟，內部都有自動 remapping 壞軌的能力。目前所有 IDE 硬碟
            製造商，都提供了更久的保證，而且會幫您更換出現壞軌的硬碟。</para>

          <para>如果您仍想要修復產生壞軌的 IDE 硬碟，您仍可以試著去下載 IDE
            硬碟製造商所提供的檢測程式，並用它來檢查您的硬碟。有時這些軟體可
            以強迫重新檢查硬碟的壞軌，並將它們標示出來。</para>

          <para>對 ESDI，RLL 及 MFM 的硬碟來說，通常壞軌是正常現象，也不是什
            麼麻煩的前兆。在 PC 上，磁碟控制卡和 BIOS 負責標示壞軌的任務。這
            對一些使用 BIOS來存取磁碟的作業環境（如 DOS）是沒有問題的。然而，
            FreeBSD 的磁碟驅動程式並不經過 BIOS 來存取磁碟，所以，有個 bad144
            的機制用來取代這項功能。bad144 只能用在 wd 這個磁碟驅動程式上（這
            個代表了 FreeBSD 4.0 並不支援它），它也無法用在 SCSI 硬碟上。
            bad144的工作方法是將所有找到的壞軌資料存到一個特別的檔案裏。</para>

          <para>使用 bad144 的警告 - 存著壞軌資料的特別檔案是放在硬碟的最後
            一軌上。因為這個檔案儲存的壞軌資料中，有可能有些資料是指向硬碟最
            前端所發生的壞軌情形，就是可能儲存 /kernel 這個檔的地方，所以它
            一定要能被開機程式所讀取，而開機程式是透過 BIOS 來讀取 kernel
            檔。這表示了使用 bad144 的硬碟絕不能擁有超過 1024 個 cylinder，
            16 個 head 及 63 個 sector。而這使得欲使用 bad144 的硬碟的大小不
            能大於 500 MB。</para>

          <para>要使用 bad144 很簡單，只要在開始安裝時，在 FreeBSD fdisk 畫面
            把<quote>Bad Block</quote> 掃瞄設為 ON 即可。在 FreeBSD 2.2.7 以
            後都可以使用此方法。但這個硬碟的 cylinder 一定要在 1024 以下。使
            用前，我們建議這個硬碟要至少先使用四個小時，以便熱膨脹與磁軌偏移
            達一般狀態。</para>

          <para>如果這個硬碟擁有超過 1024 個 cylinder（像大容量的 ESDI 硬碟）
            ，ESDI 控制卡利用一個特別的轉換模式使它能在 DOS 下工作。而如果您
            在 fdisk 裏的 <quote>set geometry</quote> 中輸入
	    <quote>轉換過</quote> 的 geometry，wd 這個驅動程式能了解這些轉換
	    模式。您也絕對不能使用 dangerously dedicated 模式來建立 FreeBSD
	    的分割區，因為它會忽略 geometry 這個參數。此外，就算 fdisk 使用
	    您所輸入的 geometry 參數，它依然會去讀取這硬碟的真正資料，而會嘗
	    試去建立一個過大的 FreeBSD 分割區。如果磁碟的 geometry 已經被
	    <quote>轉換</quote> 過了，那麼 這個分割區 <quote>必須</quote>
	    以手動輸入 block 數目的方法來建立。</para>

          <para>一個快速的小技巧是利用 ESDI 控制卡來設定大容量的 ESDI 硬碟，
            用 DOS 開機片開機，再將它 format 為 DOS 的分割區。然後重開機進入
            FreeBSD 安裝程序，在 fdisk 畫面，把DOS 分割區的 blocksize 和
            block number 抄下來。然後重新設定 geometry 使其跟 DOS 使用的一樣。
            刪除 DOS 分割區，然後使用您剛剛抄下的 blocksize 來建立一個
            <quote>cooperative</quote> FreeBSD 分割區。然後設定這個分割區為可
            開機，再打開壞軌掃瞄。在真正的安裝過程中，bad144 會在任何檔案系統
            被建立前先被執行。（您可以按 Alt-F2 來監看這一切）如果在建立壞軌資
            料檔時發生了問題，您會需要設定一個較大的磁碟 geometry - 這表示您
            需要重開機，然後全部再重新開始（包括重新分割以及在 DOS 下重新
            format）。</para>

          <para>如果 remapping 的功能已經啟動了，而您依然一直看到壞軌產生，
            那麼考慮換一台硬碟吧。壞軌的情形只會隨時間增加而更為嚴重。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="hpnetserver-scsi-failure">
          <para>為什麼 FreeBSD 抓不到 HP Netserver 的 SCSI 控制卡？</para>
        </question>

        <answer>
          <para>基本上這個是一個已知的問題。在 HP Netserver 機器上的 on-board
            EISA 介面 SCSI 控制卡占據了定址為第 11 的 EISA 槽，因此所有的
            <quote>真實</quote> EISA 槽都在它之前。可是，在 EISA 定址空間
            &gt;= 10 時，會與指定給 PCI 用的定址空間相衝突，且 FreeBSD 的
            auto-configuration 無法正確的處理這個情形。</para>

          <para>因此，現在你能做的最好事情就是在 kernel 裏設定
	    <literal>EISA_SLOTS</literal> 這個選項為 12 ，然後當作沒有這個
	    問題 :)。請依照 <ulink url="../../handbook/kernelconfig.html">
	    Handbook 中有關 kernel 的設定</ulink> 裏所說的方法來設定與編譯
	    您的 kernel。</para>

          <para>當然，在安裝 FreeBSD 到這種機器上時，這是一個雞生蛋蛋生雞的
            問題。為了解決這個問題，在 <emphasis>UserConfig</emphasis> 中有
            一個特別的方法，安裝時不要進入 <quote>visual</quote> 介面，相反
            的，在命令列模式中，鍵入</para>

          <programlisting>eisa 12
quit</programlisting>

          <para>然後就如以往一樣安裝您的系統。不過我們建議您編譯與安裝一個
            屬於自己的 kernel，但</para>

          <para>希望在未來的版本中能對這個問題有一個好的解決方法。</para>

            <note>
              <para>您無法在 HP Netserver 上使用
	        <literal>dangerously dedicated</literal> 磁碟模式。您可以參考
		<link linkend="dedicate">這份註解</link> 以獲得更多資訊。</para>
            </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ed1-timeout">
          <para>一直看到類似
            <errorname>ed1: timeout</errorname> 的訊息。它們是什麼意思呢？
	  </para>
        </question>

        <answer>
          <para>這個通常是由於中斷衝突(interrupt conflict)所造成的
	    (例如：兩塊卡使用到了相同的 IRQ)。 FreeBSD 在 2.0.5 版以前都容許這個情形，
            就算有 IRQ 衝突情形，網路卡也應該仍可正常運作。然而，在 2.0.5 版及其以後，
	    已不再容許有 IRQ 衝突的情形了。請於開機時使用 -c 這個選項，
	    然後更改 ed0/de0/..等的設定，使其和您網路卡本身的設定一致。</para>

          <para>如果您是使用您網路卡上的 BNC 接頭，您或許也會因不良的終端電阻設定，
	    而發生裝置(device) timeout 的情形。要檢查是否有這種情形，
	    您可以在網路卡上直接接上終端電阻(不要接網路線)，
	    然後，看看這個錯誤訊息是不是就消失了。</para>

          <para>有些 NE2000 的相容卡，如果它的 UTP 埠沒有接網路線，
            或是該網路線並沒被使用的話，也會出現這個錯誤訊息。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bad-3c509">
          <para>&tm.3com; 3C509 網路卡莫名其妙罷工？</para>
        </question>

        <answer>
          <para>這塊卡有個不好的地方在於它常常會遺失本身的設定資料。請使用該
            卡的 DOS 工具 <command>3c5x9.exe</command> 來更新卡上設定。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="printer-slow">
          <para>平行埠印表速度破天荒的慢，該怎麼辦？</para>
        </question>

        <answer>
          <para>如果唯一的問題就是速度很慢的話，試著改變您的 <ulink
            url="../handbook/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE">
            印表機連接埠設定</ulink> 這個在手冊中的
            <ulink url="../handbook/printing-intro-setup.html">印表機設定
            </ulink> 這個章節有加以討論。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="signal11">
          <para>程式有時會因 <errorname>Signal 11</errorname> 錯誤而停止？</para>
        </question>

        <answer>
          <para>Signal 11 這個錯誤是因為你的 process 嘗試要存取一塊記憶體，
            而你的作業系統並不允許它做這個動作而發生的。如果這種情形常常不
            定時發生，那麼你應該要開始看看是不是哪裡出問題了。</para>

          <para>這些問題可能是與下列情形有關：</para>

          <orderedlist>
            <listitem>
              <para>如果這個問題只在某一個您自己寫的某個特定程式發生，那
                麼很有可能是您的程式碼有問題。</para>
            </listitem>

            <listitem>
              <para>如果這個問題是在 FreeBSD 的某些系統檔案發生，有可能是
                因為程式有問題，但通常在我們這群讀 FAQ 的使用者去跑這些有
                問題的程式碼前，它們早就就已經被解決了（這是 -current 在做
                的事）。</para>
            </listitem>
          </orderedlist>

          <para>尤其如果你在編譯一個程式，但是每次編譯器跑出來的結果都不一樣
	    的話，這是一個無解的問題，而<emphasis>不是</emphasis> FreeBSD 臭蟲。</para>

          <para>舉例來說，假設您正在跑 <quote>make buildworld</quote>，
	    而 compiler 在將 <filename>ls.c</filename> 編譯成
	    <filename>ls.o</filename> 時發生錯誤，這時請再跑一次
	    <quote>make buildworld</quote>，如果 compiler 依然在同樣的地方發
	    生問題，那麼就是程式碼有問題－－請更新原始碼然後再試試看。而如果
	    compiler 是在其他的地方發生錯誤，那麼幾乎可以確定是硬體的問題了。
          </para>

          <para>您這時應該做什麼：</para>

          <para>如果是第一種情形，可以使用一些 debugger，如：gdb，來找出程式
	    是在那兒會去嘗試存取錯誤的記憶體位址，然後再修正它。</para>

          <para>如果是第二種情形，就需要檢查看看是不是硬體的問題了。</para>

          <para>一些造成硬體不穩的原因包括：</para>

          <orderedlist>
            <listitem>
              <para>可能是硬碟過熱：請檢查機殼內的風扇是否運作正常，因為您
	        的硬碟（或者還有其他的硬體裝置）過熱了。</para>
            </listitem>

            <listitem>
              <para>處理器過熱：這個有可能是因為超頻，或者是處理器的風扇掛了。
	        不論是哪種原因，您都需要將所有的元件回復到它們原先設定的工作狀
		態，這樣才能解決這個問題。舉個例子來說：將處理器調回原先的工作
		頻率。</para>

              <para>如果您還是堅持要超頻的話，請謹記，與其燒壞而需要換新的一台
	        主機，不如將速度調慢一點！除此之外，不管你覺得它安不安全，一般
		人對於您因為超頻而發生的問題，是不會有什麼同情心的。</para>
            </listitem>

            <listitem>
              <para>不穩定的記憶體：如果主機上有安裝數根 SIMM/DIMM 記憶體，
	        試著把它們全拆下來，然後一根一根插上去做測試，藉此縮小範圍，
		以便找出有問題的某根記憶體或是某種記憶體組合。</para>
            </listitem>

            <listitem>
              <para>最佳化過頭的主機板設定：在 BIOS 裏或是有些主機板的 jumper
	        上，有時可以更改一些 timing，但在大多數的情形裏，使用預設值就
		已經足夠了。況且有時候把 RAM 的 wait states 設太小，或是在
		BIOS 裏，把 <quote>RAM Speed: Turbo</quote> 這個或是其他類似
		的選項打開都有可能會造成一些不正常的現象。一個解決的方法是把
		BIOS 設回預設值，不過在這之前記得先記下目前的設定！</para>
            </listitem>

            <listitem>
              <para>供給主機板的電力不乾淨或是不足。試著把系統內沒有用到的
	        I/O 卡．硬碟或是 CDROM 暫時拆掉或是拔掉電源線，看看你的電源
		供應器是不是能夠在小一點的負荷下正常工作。不然就是換上另一
		個新的電源供應器，最好是瓦數高一點的（打個比方來說，如果原
		先的電源供應器是 250 瓦的，那麼就換上 300 瓦的試試）。</para>
            </listitem>

          </orderedlist>

          <para>請順便參閱 SIG11 FAQ（連結在下面），雖然它是站在 Linux 的角
	    度寫的，可是裡面對這些問題有許多很棒的解說。它裡面也有討論為什麼
	    有問題的記憶體能通過軟體或硬體的測試的原因。</para>

          <para>最後，如果上面這些原因都排除了，那麼有可能是遇到了 FreeBSD
	    裏的一隻臭蟲，請參閱指示做一個問題回報。</para>

          <para>這兒有一個更詳細的 FAQ － <ulink
	    url="http://www.bitwizard.nl/sig11/">
	    the SIG11 problem FAQ</ulink></para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question id="trap-12-panic">
            <para>當機時出現：<errorname>Fatal trap 12: page fault in kernel mode</errorname>
              ，或是 <errorname>panic:</errorname> 以及一堆錯誤訊息，該怎麼辦？</para>
          </question>

          <answer>
            <para>FreeBSD 的開發者對於這些錯誤訊息相當的有興趣，但是他們需要
              更詳細的一些細節。請把您的當機的訊息全部複製下來，接著查閱 FAQ
              裏 <link linkend="kernel-panic-troubleshooting">kernel
	      panics</link> 這節，依說明編譯一個含除錯碼的 kernel，以取得函式
	      呼叫順序（backtrace）。這個聽起來很難，但實際上並不需要任何程式
	      設計的能力，您只需要依照指示做即可。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question id="screen-loses-sync">
            <para>為什麼當我開機時，螢幕變黑，且不停閃動？</para>
          </question>

          <answer>
            <para>這個問題，已知是由 ATI Mach 64 顯示卡所引起的。因為這塊卡
              使用到 <literal>2e8</literal> 這個位址，而這與第四個序列埠
	      （serial port）所使用的位址相同。而在 &man.sio.4; 這個驅動
	      程式裏，不知道是 bug 或是功能（feature），就算您沒有第四個序
	      列埠，或是已經將 sio3（第四個序列埠）取消了，它
	      <emphasis>依然</emphasis>會去嘗試驅動它。</para>

            <para>直到這個問題被解決以前，您可以使用這個方法：</para>

              <orderedlist>
                <listitem>
                  <para>在看到開機提示時輸入 <option>-c</option>
                    （這會讓 kernel 進入設定模式）。</para>
                </listitem>

                <listitem>
                  <para>取消 <devicename>sio0</devicename> ，
                    <devicename>sio1</devicename> ，
                    <devicename>sio2</devicename> 和
                    <devicename>sio3</devicename>（全部）。
                    這可以讓 sio 驅動程式不動作 -&gt; 於是問題解決。</para>
                </listitem>

                <listitem>
                  <para>輸入 exit 以繼續啟動程序。</para>
                </listitem>
              </orderedlist>

          <para>如果您想要使用您的序列埠，您需要修改
            <filename>/usr/src/sys/i386/isa/sio.c</filename>，在該檔中找出
            <literal>0x2e8</literal> 這個字串，移除這個字串及它前面的逗號
           （保留後面的），然後重新編譯一個新的 kernel。</para>

          <para>就算使用了上面這些方法，X Window 仍然有可能無法順利執行。
            如果發生了這種情形，請確定你用的 XFree86 的版本是最新的 XFree86
            3.3.3 或是其後的版本。它們有內建支援 Mach 64 這張卡，甚至為了這
            些卡還附有一個特別的 X Server</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="reallybigram">
          <para>為什麼我的系統裝有 128 MB 的 RAM，而 FreeBSD 只用了其中的
	    64MB？</para>
        </question>

        <answer>
          <para>因為 FreeBSD 是使用呼叫 BIOS 來取得記憶體大小的方法，因此它
            只能偵測到 16 bits 位元長度的 KByte 大小（65535 KBytes = 64MB）
            （或者更少..。有些 BIOS 將最高記憶體大小限為只有 16MB）
            如果您擁有 64MB 以上的 RAM，FreeBSD 會嘗試去偵測出它，但是有可能
            會失敗。</para>

          <para>要解決這個問題，您需要使用下面所提的 kernel 設定選項。雖然有
	    方法可以從 BIOS 中取得記憶體的完整資訊，但是目前我們在開機區中並
	    沒有多餘的空間來做這件事。當某天開機區空間不足的情形獲得解決時，
	    我們將會使用 BIOS 的延伸功能來取得記憶體的完整資訊...但現在我們
	    將它放在 kernel 設定選項中。</para>

          <para><literal>options "MAXMEM=<replaceable>n</replaceable>"</literal></para>

          <para><replaceable>n</replaceable> 是指您的記憶體大小，以 KB
            為單位。以一台有 128MB RAM 的機器來說，您可使用
            <literal>131072</literal>這個數字。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="kmem-map-too-small">
	  <para>機器上的 RAM 有 1GB 以上，可是為何卻收到 <quote>kmem_map too small</quote>
	        的 panic 錯誤訊息？
	    </para>
	</question>

	<answer>
	  <para>通常 FreeBSD 會依據機器狀況來自動調整 kernel 相關參數設定，比如：
	    根據機器所裝的 RAM 大小來決定同時可開啟的檔案數量多寡。
	    然而，在 1GB RAM(含以上) 的機器上，這個『自動調整』的機制可能有時會高估：
	    比方說..開機時，kernel 會先配置各種不同用途的表格及其他架構放到記憶體上，
	    然後，當整個作業系統都開始運作之後，kernel 就會開始不夠空間來做記憶體配置的動態調整，
	    於是就 panic 掛了。</para>

	  <para>解法是：把 <option>VM_KMEM_SIZE_MAX</option> 加到 kernel 設定檔內，
	    並重新編譯 kernel，比如：</para>

	  <para><literal><option>options VM_KMEM_SIZE_MAX=419430400</option></literal></para>

	  <para>
	    這樣會設定 400&nbsp;MB 來給 kernel 使用，而且採用 400&nbsp;MB 的話，
	    目前在 6GB RAM 的機器上都可被有效運用。</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="panic-kmemmap-too-small">
	  <para>機器上 RAM 不到 1GB ，但仍會出現
	    <errorname>kmem_map too small!</errorname> 的 panic 錯誤訊息
	    </para>
	</question>

        <answer>
          <para>之所以 panic 的原因在於系統用光了給 network buffer 用途的 virtual memory
	    (尤其是 mbuf clusters)。解法是增加給 mbuf clusters 用的 virtual memory
	    數量，這步驟請參閱 FreeBSD 使用手冊的
	    <ulink
	    url="&url.books.handbook;/configtuning-kernel-limits.html#NMBCLUSTERS">網路限制篇</ulink>
	    。</para>
        </answer>
      </qandaentry>

<!--
以下為舊版 faq 內容
          <para>這個 panic 的原因是表示系統用光了給網路緩衝區的所有的虛
            擬記憶體（特別是 mbuf clusters）。您可以增加給 mbuf clusters
            的 VM 的數量，只要加入:</para>

          <para><literal>options "NMBCLUSTERS=<replaceable>n</replaceable>"</literal></para>

          <para>在您的 kernel 設定檔中，<replaceable>n</replaceable>
	    是一個在 512-4096 間的數字，依您想提供多少同時的 TCP 連接數目
	    多寡而定。我會建議試試 2048 - 這數字應該可以完全避免這個 panic
	    了。您可以執行: <command>netstat -m</command>
	    （see &man.netstat.1;）來監看有多少 mbuf clusters 在系統上正被
	    配置/使用。NMBCLUSTERS 的數值內定為 <literal>512 + MAXUSERS * 16
	    </literal>。</para>
-->

      <qandaentry>
        <question id="proc-table-full">
          <para>為什麼我一直看到 <errorname>/kernel: proc: table
            is full</errorname> 這個錯誤訊息？</para>
        </question>

        <answer>
          <para>FreeBSD kernel 只允許一定數量的 process 在同一時間裡同
	    時運作。而這個數目是根據 kernel 設定檔裡面的
	    <literal>MAXUSERS</literal> 值來決定的。<literal>MAXUSERS</literal>
	    這個值也會影響其他的 kernel 內定值，比如說 network buffer
	    (請參閱<link linkend="panic-kmemmap-too-small">這個</link>之前討
	    論過的問題)。如果機器負荷(load)很重，您可能需要增加
	    <literal>MAXUSERS</literal> 這個值。這麼作會一併提高系統的其他內
	    定值，包括最大可擁有的 process 數等。</para>

	  <para>若要調整 <literal>MAXUSERS</literal>，請參閱 FreeBSD 使用手冊中的 <ulink
	    url="&url.books.handbook;/configtuning-kernel-limits.html#KERN-MAXFILES">
	    檔案/Process的限制</ulink> 章節。
	    (雖然該處指的是『檔案的開啟數量限制』，但也適用於 process部分。)</para>

          <para>在 FreeBSD 4.4 之後，<literal>MAXUSERS</literal> 已經變成可
	    以靠著更改 <filename>/boot/loader.conf</filename> 裏的
	    <varname>kern.maxusers</varname> 這個值而調整的變數了。而在之前
	    的 FreeBSD 版本中，這個值只能在 kernel 設定檔裏調整。</para>

          <para>如果機器負荷並不重，而您只是需要同時跑很多很多 process，
	    那麼也可以直接用 sysctl 調整 <varname>kern.maxproc</varname> 值。
	    假如這些 process 都是屬於某個使用者的，那麼您還需要另
	    外調整 <varname>kern.maxprocperuid</varname> 這個值，使它比新
	    的 <varname>kern.maxproc</varname> 這個值少 1 (一定要少 1 ，
	    因為 &man.init.8; 這個系統程式絕對要保持在運作狀態)。</para>

          <para>如果想在每次開機都要更改 sysctl 的值，而且您的 FreeBSD 是
	    最近的版本的話，請在 <filename>/etc/sysctl.conf</filename> 這
	    個檔中設定，而如果是舊的版本，可以在
	    <filename>/etc/rc.local</filename> 中作設定。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cmap-busy-panic">
          <para>為什麼用新 kernel 開機時，出現 <errorname>CMAP
              busy</errorname> 這個錯誤訊息？</para>
        </question>

        <answer>
          <para>用來偵測 <filename>/var/db/kvm_*.db</filename> 過時檔案的機制偶爾會發生問題，而使用到了一個不協調
            (mismatch)的檔案有時就會導致 panic。</para>

          <para>如果發生了這個問題，請重新開機，進入 single 使用者模式，然後執行：</para>

          <screen>&prompt.root; <userinput>rm /var/db/kvm_*.db</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="brkadrint-illegal-host-access">
          <para>請問這個訊息：<errorname>ahc0: brkadrint, Illegal Host Access at seqaddr 0x0</errorname>
            是什麼意思？</para>
        </question>

        <answer>
          <para>這是一個和 Ultrastor SCSI 控制卡有關的衝突（conflict）。</para>

          <para>在開機時，進入 kernel 設定選單取消
            <devicename>uha0</devicename>，它是造成這個問題的原因。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="aci0-illegal-cable">
          <para>開機時，看到這個錯誤訊息 <errorname>ahc0: illegal cable configuration</errorname>。
            我的排線確定有接對。 是出了什麼問題呢？</para>
        </question>

        <answer>
           <para>您的主機板可能不支援自動終端電阻設定。請進到 SCSI 的 BIOS
             裡面手動指定正確的終端電阻順序，而不要使用自動設定。
             AIC7XXX 的驅動程式並無法知道有沒有這些排線偵測(以及自動終端電阻設定)的電路(external logic)
             存在。如果 EEPROM 裡面的設定是 "automatic termination" 時，它只會單純假定這些電路當然是存在的。
				     若缺少了這個電路，驅動程式在設定終端電阻時就常常出問題。
             而這種問題將導致 SCSI 匯流排的可靠性降低。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mail-loopback">
          <para>為什麼 Sendmail 一直出現
	    <quote><errorname>mail loops back to myself</errorname></quote>
	    這個錯誤訊息？</para>
        </question>

        <answer>
          <para>這個問題在 sendmail 的 FAQ 中是這樣回答的:-</para>

<literallayout>        * 我一直收到有關 "Local configuration error" 的信件，例如：

        553 relay.domain.net config error: mail loops back to myself
        554 &lt;user@domain.net&gt;... Local configuration error

        我要如何解決這個問題？

        您利用 MX 設定，讓要寄到某 domain（如: domain.net）的信件，
        寄到您所指定的機器（在這個例子中為 relay.domain.net），但是這
        部機器並未被設定接受 domain.net 的信件。請把 domain.net 加到
        /etc/sendmail.cw 中（如果您有使用 FEATURE(use_cw_file)) 或是
        在 sendmail.cf 中加入 "Cw domain.net"
            </literallayout>

          <para>最新版本的 <ulink  url="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq">sendmail
            FAQ</ulink> 現在已不再隨著 sendmail <quote>出貨</quote>。
            它目前是被定期的發表在 <ulink
            url="news:comp.mail.sendmail">comp.mail.sendmail</ulink>，
            <ulink url="news:comp.mail.misc">comp.mail.misc</ulink>，<ulink
            url="news:comp.mail.smail">comp.mail.smail</ulink>，<ulink
            url="news:comp.answers">comp.answers</ulink>，和 <ulink
            url="news:news.answers">news.answers</ulink>. 您也可以寄一封
	    Email 到 <email>mail-server@rtfm.mit.edu</email>，然後在信件內文
	    中寫上
            <literal>send usenet/news.answers/mail/sendmail-faq</literal>
            以取得這份 FAQ 文件。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="remote-fullscreen">
          <para>為什麼執行遠端機器（remote machine）的全螢幕的軟體時，
	    有不正常的情形？</para>
        </question>

        <answer>
          <para>或許遠端機器並非將您的終端機模式設為 FreeBSD console 所用的
	    <literal>cons25</literal>，而是設為其它模式。</para>

          <para>這兒有幾個解決這個問題的方法：</para>
            <itemizedlist>
              <listitem>
                <para>在 logging 進遠端機器後，更改您的 shell 變數 TERM 為
		  <literal>ansi</literal> 或是 <literal>sco</literal>
		  ﹙如果遠端機器支援這些模式的話）。</para>
              </listitem>

              <listitem>
                <para>使用支援 VT100 的模擬軟體，如 FreeBSD console 下的
                  <application>screen</application> 軟體。
                  <application>screen</application> 提供您在一個 terminal
		  裏同時跑好幾個 session 的能力，而且它本身也是一個相當好
		  的軟體。每個 <application>screen</application> 都像是一個
		  VT100 的終端機，所以遠端機器的 TERM 變數應該設為
		  <literal>vt100</literal>。</para>
              </listitem>

              <listitem>
                <para>在遠端機器的終端機資料庫（terminal database）中加入
		  <literal>cons25</literal> 的資料。加入的方法視遠端機器的
		  作業系統不同而有所差異。請參閱遠端機器給系統管理員的說明
		  書，應該會有所幫助。</para>
              </listitem>

              <listitem>
                <para>啟動 FreeBSD 的 X 伺服器，然後使用一些 X Window 下的
		  終端機模擬器來登入遠端機器，例如 <command>xterm</command>
		  或 <command>rxvt</command>。而遠端機器的 TERM 變數應該要
		  設為 <literal>xterm</literal> 或 <literal>vt100</literal>。
		  </para>
              </listitem>
            </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="calcru-negative">
          <para>為什麼我的機器一直顯示
            <errorname>calcru: negative time...</errorname>？</para>
        </question>

        <answer>
          <para>跟中斷（interrupt）有關的不同硬體 與/或 軟體的搭配都有可能造成
            這個問題。這有可能是 bug 或是某個裝置本身的問題。在平行埠上使用
            大的 MTU 來作 TCP/IP 傳輸可以重現這個問題。若是圖形加速卡造成這個
            問題的話，您應該先檢查卡的中斷設定。</para>

          <para>這個問題的邊際效應是會造成有些 process 出現
            <quote>SIGXCPU exceeded cpu time limit</quote> 的訊息，而不正常
	    停止。</para>

          <para>若是 FreeBSD 3.0 或是 1998 年 11 月 29 日以後其他版本，萬一
	    這個問題一直無法以其他方法解決，就只能設定 sysctl 變數：</para>

          <screen>&prompt.root; <userinput>sysctl -w kern.timecounter.method=1</userinput></screen>

          <para>這樣會對效能有些影響，但是若考慮到這個問題帶來的後果，這樣做
	    是值得的。如果這個問題還是存在的話，讓 sysctl 那個值依然設為 1，
	    然後增加 kernel 設定檔中 <literal>NTIMECOUNTER</literal> 這個選
	    項的數值。如果您將 <literal>NTIMECOUNTER</literal> 增加到 20 依
	    然無法解決這個問題，那麼您機器上的中斷已經多到無法讓計數器維持在
	    可靠的狀態了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="pcm0-not-found">
          <para>出現 <errorname>pcm0 not found</errorname> 這個訊息，或者是
	    我的音效卡變成了 <devicename>pcm1</devicename>，但在 kernel 設定
	    檔裏我是設 <literal>device pcm0</literal> 啊。這是怎麼回事呢？
	  </para>
	</question>

        <answer>
          <para>如果您在 FreeBSD 3.x 上使用 PCI 音效卡就會發生這種問題。
	    因為<devicename>pcm0</devicename> 這個 device 是內定保留給 ISA
	    的音效卡的，所以如果您有一張 PCI 的音效卡，您就會遇到這個問題，
	    而您的卡會變成 <devicename>pcm1</devicename>。</para>

            <note>
              <para>如果您只把 kernel 設定檔中的設定改成
	        <literal>device pcm1</literal> 是無法除去這個警告訊息的，
		這樣會造成 <devicename>pcm1</devicename> 被保留給 ISA 音效卡，
		而 PCI 音效卡則會變成 <devicename>pcm2</devicename>
		（外加 <errorname>pcm1 not found</errorname> 的警告訊息）。
              </para>
            </note>

            <para>如果您有一張 PCI 的音效卡，您需要 make
            <devicename>snd1</devicename> 這個 device，而不是
            <devicename>snd0</devicename>：</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV snd1</userinput></screen>

          <para>這個問題在 FreeBSD 4.x 上並不會發生，因為很多人投下了許多心
	    力讓它更<emphasis>PnP 導向</emphasis>，而且
	    <devicename>pcm0</devicename> 這個 device 也不再是只保留給 ISA
	    的音效卡了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="pnp-not-found">
          <para>為什麼在更新到 FreeBSD 4.X 後會抓不到我的 PnP 卡
	  （或者是抓成 <literal>unknown</literal>）？</para>
        </question>

        <answer>
          <para>FreeBSD 4.X 現在已經更 <emphasis>PnP 導向</emphasis>了，
	    而邊際效應就是會發生有些在 FreeBSD 3.X 可以用的 PnP 裝置
	    （如音效卡或是內插式數據機）變成無法使用。</para>

          <para>這個原因可以用一封由 Peter Wemm 發到 freebsd-questions
	    這個 mailing list 上的信來解釋，它原本是解釋為什麼有一個內
	    插式數據機，在系統升級到 FreeBSD 4.x 後，就沒法被抓到了
	    （在 <literal>[]</literal> 裏的是另外加的註解，讓內容更易懂）。
          </para>

          <blockquote>
            <para>The PNP bios preconfigured it [the modem] and left it
              laying around in port space，so [in 3.x] the old-style ISA
              probes <quote>found</quote> it there.</para>

            <para>Under 4.0，the ISA code is much more PnP-centric. It was
              possible [in 3.x] for an ISA probe to find a
              <quote>stray</quote> device and then for the PNP device id to
              match and then fail due to resource conflicts. So，it
              disables the programmable cards first so this double probing
              cannot happen. It also means that it needs to know the PnP
              id's for supported PnP hardware. Making this more user
              tweakable is on the TODO list.</para>
          </blockquote>

          <para>如果要讓裝置能再度運作，我們需要找出它的 PnP id，然後再將它
	    加入一份在偵測 ISA 裝置時會使用的表中。可以執行 &man.pnpinfo.8;
	    來偵測這個裝置，舉例來說，下面是 &man.pnpinfo.8; 抓到的一個內插
	    式數據機的資料：</para>

          <screen>&prompt.root; <userinput>pnpinfo</userinput>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341)，Serial Number 0xffffffff
PnP Version 1.0，Vendor Version 0
Device Description: Pace 56 Voice Internal Plug & Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8，alignment 0x8，len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</screen>

          <para>[more TAG lines elided]</para>

          <screen>TAG End DF
End Tag

Successfully got 31 resources，1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341)，Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</screen>

          <para>您所需要的資訊是一開始看到的 <quote>Vendor ID</quote>
	    這一行。括號中的十六位元碼（這個例子中是 0x3024a341）就是
	    PnP id，而在這之前的字串（PMC2430）則是一個獨一無二的 ASCII id。
	    而這些資料需要被加到 <filename>/usr/src/sys/isa/sio.c</filename>
	    這個檔案裏。</para>

          <para>為了防止任何東西出錯，您應該要先備份目前的
	    <filename>sio.c</filename>。而且您要 submit PR 時也需要這個
	    原始檔案來做出 patch（您應該會將它 submit PR 吧..：）..）。
	    接著就編輯 <filename>sio.c</filename> 找尋下面這行</para>

          <programlisting>static struct isa_pnp_id sio_ids[] = {</programlisting>

          <para>接著往下捲動，找個正確的位置來插入您的裝置資訊。您看到的就
	    下面這個樣子，它們是照右邊註解裡面的 ASCII 這個 Vender ID 做排
	    序的，或是 &man.pnpinfo.8; 所找到的一部分
	    <emphasis>裝置描述</emphasis>：</para>

          <programlisting>{0x0f804f3f，NULL}，    /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f，NULL}，    /* OZO8039 - Zoom 56k flex */
{0x3024a341，NULL}，    /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49，NULL}，    /* ROK0010 - Rockwell ? */
{0x5002734a，NULL}，    /* RSS0250 - 5614Jx3(G) Internal Modem */</programlisting>

          <para>把您這個裝置的十六進位的 Vender ID 加到正確的地方，存檔，
	    然後重新編一個 kernel，再重開機。之後這個裝置應該就會像在
	    FreeBSD 3.X 下，被偵測為 <literal>sio</literal> 裝置了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="nlist-failed">
          <para>為什麼我常常在跑一些程式（例如 <command>top</command> 或
	    <command>systat</command>）的時候出現
	    <errorname>nlist failed</errorname> 這個錯誤訊息？</para>
        </question>

        <answer>
          <para>這個問題是因為您跑的程式需要一個特別的 kernel symbol，可是
	    不知道什麼原因而找不到﹔而會發生這個問題可能是因為下面兩個原因：
          </para>

          <itemizedlist>
            <listitem>
              <para>您的 kernel 和 userland 的檔案版本並不一致（例如說，您
	        編了一個新的 kernel，但是並沒有執行對應的
		<maketarget>installworld</maketarget>，或是其他類似情形），
		因此 symbol table 的內容就和應用程式編譯時的不太一樣了。如
		果是這種情形，請執行完整的升級步驟（請參閱
		<filename>/usr/src/UPDATING</filename> 以得知正確的流
		程）。</para>
            </listitem>

            <listitem>
              <para>您沒有用 <command>/boot/loader</command> 來載入您的
	        kernel，而是直接由 boot2 開機（請參閱 &man.boot.8;）。
		雖然說跳過 <command>/boot/loader</command> 並沒有什麼錯，
		但是它在 kernel symbols 跟應用程式的溝通方面佔了很重的份量。
              </para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="connection-delay">
          <para>為什麼我用  <command>ssh</command> 或 <command>telnet</command>
	    連到我的電腦時，會等待很長的一段時間才能連上？</para>
        </question>

        <answer>
          <para>症狀：TCP 連線建立之後和詢問密碼之前（如果是在說 &man.telnet.1;
	    的話，則是 login 提示符號跳出來之前），要等待很長的一段時
	    間。</para>

          <para>問題所在：這種延遲情形常常是因為伺服軟體（server software）
	    嘗試要將客戶端（client）的 IP 位址轉換成主機名稱。因為很多伺服
	    軟體，包括 FreeBSD 內建的 Telnet 和 SSH，為了將主機名稱寫入紀
	    錄檔中以供管理者作參考，而會做這項動作。</para>

          <para>解決方法：如果這個問題在您連接不同的伺服器時都會發生，那麼
	    問題是在您客戶端這一方﹔同樣的，如果別人只有在連到您的伺服器上
	    才會發生這個情形，那麼問題就是在伺服器這邊了。</para>

          <para>如果是客戶端這方有問題，唯一的方法就是將 DNS 伺服器修好，
	    這樣對方伺服器才能正確的轉換名稱。如果問題是在內部區域網路發
	    生的，這應該是伺服器有問題，請詳細檢查一下﹔相反的，如果是您
	    在上 Internet 時發生的，那麼您需要跟您的 ISP 聯絡，請他們解決
	    這個問題。</para>

          <para>如果是伺服器這邊的問題，而且是發生在內部區域網路，那麼您需
	    要設定這個伺服器，使它能正確將內部網路的 IP 位址轉換為主機名稱。
	    請參閱 &man.hosts.5; 和 &man.named.8; 的說明以獲得更多資訊。如
	    果是在 Internet 上的伺服器發生這個問題，那麼有可能是您伺服器的
	    轉換功能出問題。您可以試試查詢另一個主機名稱，比如：
	    <hostid>www.yahoo.com</hostid>。如果查不到，那麼可以確定是您這
	    邊出問題了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="stray-irq">
          <para><errorname>stray IRQ</errorname> 這個錯誤訊息是什麼意思？</para>
        </question>
	<answer>
          <para>Stray IRQs 是硬體 IRQ 有點小問題的現象，大多是因為硬體本身
	    在發出中斷需求後，又取消了它自己的中斷要求。</para>
          <para>有三個方法可以應付這個問題：</para>
	  <itemizedlist>
	    <listitem>
              <para>不理會這個警告。反正一個 irq 出現五次警告後系統就不會
	        再顯示了。</para>
	    </listitem>
	    <listitem>
              <para>把 <function>isa_strayintr()</function> 裏的值，由 5
	        改成 0，這樣所有的警告訊息都不會出現。</para>
	    </listitem>
	    <listitem>
              <para>安裝使用 irq 7 的平行埠硬體設備，以及它的 PPP 驅動程式
	        （這個大部分系統都有做），接著安裝 ide 硬碟或是其他會使用
	        irq 15 的硬體設備以及它的驅動程式。</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="file-table-full">
          <para>為什麼 <errorname>file: table is full</errorname> 這個訊息
	    一直在 dmesg 裏重複出現？</para>
        </question>
        <answer>
          <para>這個錯誤訊息代表了您系統的 file descriptors 已經使用光了。
	    請參閱手冊內 <ulink url="../handbook/configtuning-kernel-limits.html">
	    Tuning  Kernel Limits</ulink> 裡面的 <ulink
	    url="../handbook/configtuning-kernel-limits.html#KERN-MAXFILES">
	    kern.maxfiles</ulink> 這個章節，裡面有一些討論及解決方法。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="laptop-clock-skew">
          <para>為什麼我筆記型電腦上的時鐘一直顯示錯誤的時間？</para>
	</question>

	<answer>
          <para>您的筆記型電腦裡有兩個以上的時鐘，而 FreeBSD 選到了錯的
	    那個。</para>

           <para>執行 &man.dmesg.8;，檢查一下有 <literal>Timecounter</literal>
	     字串的那幾行。最後一行是 FreeBSD 選用的，通常是
	     <literal>TSC</literal>。</para>

	  <screen>&prompt.root; <userinput>dmesg | grep Timecounter</userinput>
Timecounter "i8254"  frequency 1193182 Hz
Timecounter "TSC"  frequency 595573479 Hz</screen>

          <para>您可以執行 &man.sysctl.3; 看一下
	    <varname>kern.timecounter.hardware</varname> 這個值做確認。</para>

	  <screen>&prompt.root; <userinput>sysctl kern.timecounter.hardware</userinput>
kern.timecounter.hardware: TSC</screen>

          <para>BIOS 可能在一些情形下會更改 TSC 的時脈&mdash;有時候是因為
	    在使用電池工作時會更改處理器的速度，另外也有可能是進入了省電模
	    式，可是 FreeBSD 並不會察覺到這些調整，而會發生時間增加或是減
	    少的情形。</para>

          <para>在上面的例子當中，我們看到還有 <literal>i8254</literal>
	    這個時鐘可以選擇，執行 &man.sysctl.3; 用手動的方式將這個值寫入
	    <varname>kern.timecounter.hardware</varname> 中。</para>

	  <screen>&prompt.root; <userinput>sysctl -w kern.timecounter.hardware=i8254</userinput>
kern.timecounter.hardware: TSC -&gt; i8254</screen>

          <para>這樣您的筆記型電腦應該就可以保持正確的時間了。</para>

          <para>如果要讓這個更改的動作再每次開機時自動執行，在
	    <filename>/etc/sysctl.conf</filename> 裏加入下面這行。</para>

	  <programlisting>kern.timecounter.hardware=i8254</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="null-null">
          <para>為什麼我的筆記型電腦無法正確的偵測到 PC card ？</para>
	</question>

	<answer>
          <para>這個問題常常發生在灌了多個作業系統的筆記型電腦上。有些非
	    BSD 的作業系統會讓 PC card 的硬體裝置處在一個不一致的狀態下
	    （inconsistent state）。使得 <command>pccardd</command> 在偵
	    測這片卡時，無法抓到正確的型號，而是
	    <errorname>"(null)""(null)"</errorname>。</para>

          <para>您需要移除 PC card 插槽的電源以重置這個硬體裝置。一個方法是
	    將您的筆記型電腦關機（不是休眠模式，也不是待命模式﹔要完全的關
	    機）。等個幾秒鐘再重開機。這樣您的 PC card 應該就正常了。</para>

          <para>有時有些筆記型電腦雖然看起來已經關機了，但實際上並沒有。
	    如果您發現上面那個方法沒有用，請關機，移除電池，等個幾秒鐘，
	    把電池裝上去然後重開機。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="boot-read-error">
          <para>為什麼在 BIOS 畫面之後，FreeBSD 的 boot loader 顯示
	    <errorname>Read error</errorname> 然後就停止不動了？</para>
        </question>

        <answer>
          <para>這是因為FreeBSD 的 boot loader 無法正確的找出硬碟的
	    geometry。這樣的話，就需要在用 fdisk 分割或是修改 FreeBSD
	    的 slice 時，手動將正確的值輸入進去了。</para>
          <para>正確的硬碟 geometry 值在 BIOS 裡面可以查的到。注意該硬碟的
	    cylinders，heads 以及 sectors 這些數值。</para>
          <para>在執行 &man.sysinstall.8;的 fdisk 時，按下 <keycap>G</keycap>
	    以便手動設定硬碟的 geometry。</para>
          <para>這時會有一個對話框跳出來，詢問您有關 cylinders，heads 以及
	    sectors 這些東西的值。請將剛剛在 BIOS 查到的數字，以 / 作分隔輸
	    入進去。</para>
          <para>舉例來說，如果是 5000 cylinders，250 sectors 和 60 sectors
	    就輸入 <userinput>5000/250/60</userinput></para>
          <para>輸入完後請按 enter 鍵確認，最後按下 <keycap>W</keycap> 鍵把
	    新的分割區表寫入硬碟當中。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bootmanager-restore">
          <para>另一個作業系統摧毀了我的 Boot Manager。我要怎麼樣才能把它還
	    原回來？</para>
        </question>

        <answer>
          <para>執行 &man.sysinstall.8; 接著選 Configure，然後選 Fdisk。
	    再來用<keycap>空白</keycap>鍵選擇原先 Boot Manager 所在的硬碟。
	    按下 <keycap>W</keycap> 鍵來作寫入的動作。這時會跳出一個提示
	    訊息，詢問您要安裝哪一個 boot loader。請選擇 Boot Manager，
	    這樣就可以將它還原了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="indefinite-wait-buffer">
          <para>這個錯誤訊息：<errorname>swap_pager: indefinite
            wait buffer:</errorname> 是什麼意思呢？</para>
        </question>

        <answer>
          <para>這個訊息是說有一個執行程序正在嘗試將分頁記憶體（page memory）
	  寫入硬碟中，而這個動作嘗試了 20 秒鐘仍然無法成功。這個有可能是因為
	  硬碟有壞軌、電路或排線有問題、以及其他跟硬碟讀出寫入有關的硬體設備。
	  如果真的是硬碟壞軌的問題，您應該會在
	  <filename>/var/log/messages</filename>這個檔案中，或是在執行
	  <command>dmesg</command>這個指令後，看到有關磁碟錯誤的訊息。
	  如果沒有，那麼請檢查您的排線還有接頭連接是否良好。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="touch-not-found">
	  <para>為何在 buildworld/installworld 時，會趴在
	    <errorname>touch: not found</errorname> 的錯誤訊息?</para>
        </question>

	<answer>
	  <para>這錯誤訊息並不是指 &man.touch.1; 程式不見了，事實上可能是該檔檔案時間被設為未來的時間。
	      若機器上的 CMOS-clock 時鐘設定為當地時間
	      (非格林威治時間，比如台灣時間為 GMT +08:00 ，也就是 CST 中原標準時間)，
	      那麼請在開機時，先選 single user 模式進入，然後打
	      <command>adjkerntz&nbsp;-i</command>
	      來調整 kernel clock 與機器上的 CMOS-clock 來同步。</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="commercial">
    <chapterinfo>
      <author>
	<firstname>Vanilla</firstname>
	<surname>Shu</surname>
	<affiliation>
	  <address><email>vanilla@FreeBSD.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>商業軟體</title>

      <note>
        <para>這一節的內容還是相當少，不過我們當然希望各個公司能為它加點內容 :)
          FreeBSD 組織和列在這裡的任何一家公司都沒有金錢上的利害關係，列出來純粹只是對大眾公開介紹(同時也認為在 FreeBSD
          上的商機若興旺，會對 FreeBSD 可長可久有極正面的效益)。我們鼓勵商業軟體的廠商把他們的產品包括在下面的名單中，在
          <ulink url="../../../../commercial/index.html">Vendors page</ulink> 可以看到更長的列表。</para>
      </note>

    <qandaset>
      <qandaentry>
        <question id="officesuite">
          <para>在哪邊找到給 FreeBSD 用的 Office 套件呢？</para>
        </question>

        <answer>
	  <para><ulink
	    url="http://www.openoffice.org">OpenOffice</ulink> 這套 open-source 性質的 office
	    可以在 FreeBSD  上正常運用自如，而 &linux; 版的
	    <ulink
	    url="http://www.sun.com/staroffice/">StarOffice</ulink>,
	    這套 closed-source 的 OpenOffice 加值版，也可以在 FreeBSD 上正常使用。</para>

	  <para>FreeBSD 上還有許多編排軟體、試算表(Spreadsheet)以及繪圖軟體都可用 Ports
	    Collection 來安裝喔。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="motif">
          <para>在哪邊可找到給 FreeBSD 用的 Motif？</para>
        </question>

        <answer>
	  <para>Open Group 釋出了 Motif 2.1.30 的原始碼，可以透過
	    <literal>open-motif</literal> package 安裝，或是由 ports 自行
	    編譯。相關的資訊，請參考 handbook 中的 <ulink
	    url="../handbook/ports.html">ports</ulink> 章節。

	    <note>
	      <para>Open Motif 只能在同樣也是 <ulink
	        url="http://www.opensource.org/">open source</ulink>
		的作業系統或計劃中使用。</para>
	    </note>
	  </para>

          <para>另外，也是有商業版本的 Motif 存在。也許這種版本的 Motif
	    不是免費的，但是絕對允許用在 closed-source 的環境下。
	    <link linkend="apps2go">Apps2go</link> 提供了最便宜的 FreeBSD
	    (包括 i386 跟 alpha)版本的 ELF Motif 2.1.20 套件。
	    <anchor id="apps2go"/></para>

          <para>目前提供兩種不同環境的版本， <quote>發展用版本</quote> 及
	    <quote>runtime 版本</quote> 。這兩種套件都包括：</para>

            <itemizedlist>
              <listitem>
                <para>OSF/Motif manager, xmbind, panner, wsm.</para>
              </listitem>

              <listitem>
                <para>Development kit with uil, mrm, xm, xmcxx, include
                  and Imake files.</para>
              </listitem>

              <listitem>
                <para>Static and dynamic ELF libraries (for use with
                  FreeBSD 3.0 and above).</para>
              </listitem>

              <listitem>
                <para>Demonstration applets.</para>
              </listitem>
            </itemizedlist>

          <para>因為 <emphasis>Apps2go</emphasis> 也有提供 NetBSD 和 OpenBSD
	    的版本，所以在訂購時請特別指定是要 FreeBSD 版本的 Motif！
	    他們目前只提供以 FTP 的方式取得這份套件。</para>

            <variablelist>
              <varlistentry>
                <term>更多資訊</term>
                <listitem>
                  <para><ulink url="http://www.apps2go.com/">
                    Apps2go WWW page</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>或</term>
                  <listitem>
                    <para>
                      <email>sales@apps2go.com</email> 或
                      <email>support@apps2go.com</email>
                      </para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>或</term>
                  <listitem>
                    <para>phone (817) 431 8775  or +1 817 431-8775</para>
                  </listitem>
                </varlistentry>
              </variablelist>

          <para>也可以聯絡 <link linkend="xig">Xi Graphics</link>，他們提供了一個
	    FreeBSD a.out 格式的 Motif 2.0 套件。</para>

          <para>在這套件中包括了：</para>
            <itemizedlist>
              <listitem>
                <para>OSF/Motif manager, xmbind, panner, wsm.</para>
              </listitem>

              <listitem>
                <para>Development kit with uil, mrm, xm, xmcxx, include
                  and Imake files.</para>
              </listitem>

              <listitem>
                <para>Static and dynamic libraries (for use with FreeBSD
                  2.2.8 and earlier).</para>
              </listitem>

              <listitem>
                <para>Demonstration applets.</para>
              </listitem>

              <listitem>
                <para>Preformatted man pages.</para>
              </listitem>
            </itemizedlist>

          <para>在你跟他們訂購 Motif 時，請一定註明你要的是 FreeBSD 的版本！
	    因為 <emphasis>Xi Graphics</emphasis> 也同時提供了 BSDI 跟 Linux
	    版本的 Motif。目前發行的版本是放在四塊磁片中，將來他們會將所有的
	    東西都放到光碟裡，就像他們所發行的 CDE 一樣。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cde">
          <para>在哪邊可找到給 FreeBSD 用的 CDE？</para>
        </question>

        <answer>
          <para><link linkend="xig">Xi Graphics</link> 以前有賣 FreeBSD 用的
	   CDE，不過現已停止發售了。</para>

          <para>就許多方面而言，<ulink url="http://www.kde.org/">KDE</ulink> 這個 open
            source 的桌面環境與 CDE 相當類似。此外，你可能會喜歡使用 <ulink
            url="http://www.xfce.org/">xfce</ulink>。KDE 及 xfce 都可由 <ulink url="&url.base;/ports/index.html">ports
            機制</ulink>來安裝。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="commercial-xserver">
          <para>有沒有要錢，但是高效率的 X servers？</para>
        </question>

        <answer>
          <para>有， <ulink url="http://www.xig.com/">Xi Graphics</ulink>
            有提供給 FreeBSD（或其他 Intel 平台上）用的 X 視窗加速產品。</para>


          <para>Xi Graphics 所提供的高效能 X Server 有非常簡單的設定方式，
	    並且支援了目前市面上當紅的各大廠牌的顯示卡。它只給你 Binary 檔案，
	    是用磁片的方式發行，FreeBSD 跟 Linux 版本都相同。Xi Graphics 同時
	    也提供了專門給筆記型電腦用的高效能 X Server。<anchor id="xig"/></para>

          <para>5.0 版有提供免費的相容 <quote>demo</quote> 版本</para>

          <para>Xi Graphics 也有在賣 FreeBSD 用的 Motif 跟 CDE（往上面看看）。
	    </para>

            <variablelist>
              <varlistentry>
                <term>更多的資訊</term>
                <listitem>
                  <para><ulink url="http://www.xig.com/">
                    Xi Graphics WWW page</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>或</term>
                  <listitem>
                    <para><email>sales@xig.com</email>
                      或 <email>support@xig.com</email>
                      </para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>或</term>
                  <listitem>
                    <para>phone (800) 946 7433  or +1 303 298-7478.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="database-systems">
          <para>在 FreeBSD 上有任何的資料庫嗎？</para>
        </question>

        <answer>
          <para>有! 請看 FreeBSD 網站上 <ulink
            url="../../../../commercial/software_bycat.html#CATEGORY_DATABASE">
            商業軟體公司 </ulink> 這一部份。</para>

          <para>還有請參考 ports 中 <ulink
            url="../../../../ports/databases.html">
            Databases</ulink> 相關的收集。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="oracle-support">
          <para>可以在 FreeBSD 上執行 Oracle 嗎？</para>
        </question>

        <answer>
          <para>可以，下面這個網頁會說明如何在 FreeBSD 上執行 Linux
	    版的 Oracle：</para>

            <itemizedlist>
              <listitem>
                <para><ulink
                  url="http://www.scc.nl/~marcel/howto-oracle.html">
                  http://www.scc.nl/~marcel/howto-oracle.html</ulink></para>
              </listitem>

              <listitem>
                <para><ulink
                  url="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd">

                  http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</ulink></para>

              </listitem>
            </itemizedlist>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="applications">
    <chapterinfo>
      <author>
	<firstname>Kang-min</firstname>
	<surname>Liu</surname>
	<affiliation>
	  <address><email>gugod@gugod.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>一般應用程式</title>

    <qandaset>
      <qandaentry>
        <question id="user-apps">
	  <para>嗯..我要在哪找到我要的程式呢?</para>
	</question>

	<answer>
	  <para>請看看 <ulink url="../../../../ports/index.html">ports
	    目錄</ulink> 吧。這邊有份已經 port 到 FreeBSD 的軟體列表。
	    目前有超過 &os.numports; 個軟體已經被port 到 FreeBSD 上，並且每天
	    都在增加中。所以有空就多看看這份列表，不然你也可以訂閱
	    <literal>freebsd-announce</literal> <link linkend="mailing">
	    這份 mailing list</link>，會有人將每個星期最新的軟體列表貼在上面。</para>

	  <para>大部份的 ports 應該都可以在 4.X、5.X 跟 6.X 的系統上使用。
	    每次當 FreeBSD release 新版時，都會有一份 ports tree 被放在這一個
            release cd 裡面的 <filename>ports/</filename> 目錄裡。</para>

          <para>我們也支援一種叫 <quote>package</quote> 的概念，基本上
            就是 gzip 壓縮、可用來發行的 binary 檔案，但是裡面藏了一
            些相當有用的資訊，可以給各種自訂安裝來使用。使用者不必知
            道某個 package 裡究竟有包括哪些檔案，就可`以很方便地重複將
            它安裝/反安裝。</para>

          <para>你可以執行 <filename>sysinstall</filename>(&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>) 後，
            在 post-configuration 選單下選擇 package 這個安裝選項；或
            是對某個有興趣的 package 檔案執行 &man.pkg.add.1;
	    把它裝起來。Package 檔案通常以 <filename>.tgz</filename> 或 <filename>.tbz</filename>
	    為副檔名，手上有 FreeBSD CDROM 的人可以在 <filename>packages/All</filename> 這個目錄下找到這類檔案。
	    對不同的 FreeBSD 版本，也可以從下列位址由網路上取得：</para>

          <variablelist>
            <varlistentry>
              <term>給 4.X-RELEASE/4-STABLE 用的</term>
              <listitem>
                <para><ulink
                   url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/">
                   ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/</ulink></para>
              </listitem>
            </varlistentry>

	    <varlistentry>
              <term>給 5.X-RELEASE/5-STABLE 用的</term>
              <listitem>
                <para><ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-stable/">
                  ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-stable</ulink></para>
              </listitem>
            </varlistentry>

  	    <varlistentry>
              <term>給 6.X-RELEASE/6-STABLE 用的</term>
              <listitem>
                <para><ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable/">
                  ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable</ulink></para>
              </listitem>
            </varlistentry>

  	    <varlistentry>
              <term>給 7-CURRENT 用的</term>
              <listitem>
                <para><ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-current/">
                  ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-current</ulink></para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>或是離你最近的 mirror 站。</para>

          <para>要注意的是，因為新的 port 一直在增加中，所以並不是所有 port
	    都有相對應的 package。最好定時檢查<ulink
            url="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org</ulink>
            ，看看有哪些 package 可以用。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="configure-inn">
          <para>該怎麼設定 INN(Internet News) 來當 news server？</para>
        </question>

        <answer>
          <para>以 package 或 port 方式來裝好 <filename
            role="package">news/inn</filename> 之後，<ulink
            url="http://www.visi.com/~barr/INN.html">Dave
            Barr's INN Page</ulink> 是個非常好的 INN 入門處，你可以在那邊找到 INN 的 FAQ。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="java">
          <para>FreeBSD 有支援 &java; 嗎？</para>
        </question>

        <answer>
          <para>有啊，請看 <ulink
            url="&url.base;/java/index.html">
            http://www.FreeBSD.org/java/</ulink></para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-libcso30">
          <para>我可以在哪邊找到 libc.so.3.0?</para>
        </question>

        <answer>
          <para>你可能在一台 2.1.x 的機器上，跑著給 2.2/3.x/4.0 的軟體。
            請再往上面一個章節看，正確的取得給你機器用的 port/package。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-libcso40">
          <para>為何我得到了這個訊息 ?<errorname>Error: can't find
            libc.so.4.0</errorname>?</para>
        </question>

        <answer>
	  <para>你不小心抓了給 4.X 及 5.X 系統用的 package，並且嘗試著
            去裝在你的 2.X 或 3.X 的系統上面。請下載正確版本的 package。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="emul">
          <para> ghostscript 在我的 386/486SX 上有點問題呢！</para>
        </question>

        <answer>
          <para>你沒有浮點運算器，對吧？你必須在你的 kernel 中加入數學
            運算模擬器，你可以跟著下面的步驟做，並在更改過你的 kernel 設定
	    檔後，重新編譯過一次。</para>

          <programlisting>options GPL_MATH_EMULATE</programlisting>

            <note>
	      <para>當你加入上一行的同時，你必須將
	        <literal>MATH_EMULATE</literal> 移除掉。</para>
            </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="sco-socksys">
          <para>為什麼當我執行 SCO/iBCS2 的程式時，它在
	    <errorname>socksys</errorname> 這個地方出了問題？
	    (FreeBSD 3.0 以及更早的版本才有此問題。)</para></question>

        <answer>
          <para>你必須先修改 <filename>/etc/sysconfig</filename> (或是
            <filename>/etc/rc.conf</filename>, 請讀 &man.rc.conf.5;)
            這檔案最後一個章節，將下面所講到的變數設成
	    <literal>YES</literal>：</para>

          <programlisting># Set to YES if you want ibcs2 (SCO) emulation
	    loaded at startup ibcs2=NO</programlisting>

          <para>這會在開機時將 ibcs2 這一個 kernel 模組載入。</para>

          <para>你還要將你的 /compat/ibcs2/dev 改成下面這樣：</para>

	  <screen>lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx</screen>

          <para>你只需要將 socksys 轉向到 <devicename>/dev/null</devicename>
            (請讀 &man.null.4;) 去騙過 open &amp; close 的動作。在 -current
	    裡面的 ibcs2 相關程式碼將會處理其餘的部份，這種作法比以前的方式
	    乾淨太多了。假如你想要使用 <devicename>spx</devicename> 方面的
	    程式，在你的 kernel 設定檔裡面 加上<literal>SPX_HACK</literal>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ms-frontpage">
	  <para>我該使用那個版本的 Microsoft FrontPage？</para>
	</question>

	<answer>
          <para>Use the Port, Luke！在 ports tree 中已經有一個包含 FrontPage
	    的 Apache 版本了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ports-3x">
          <para>為什麼我無法在 3.X-STABLE 機器上順利編好這個 port?</para>
        </question>

        <answer>
      	  <para>如果你的 FreeBSD 版本相較 -CURRENT 或 -STABLE 之下是很古
	    早的話，或許你會需要一個升級 ports 的工具，在
	    <ulink url="../../../../ports/index.html">
	    http://www.FreeBSD.org/ports/</ulink>。如果你以將其更新卻仍無用，
	    那麼一定是某人更動之後造成 -CURRENT 才能用，-STABLE 無法用的情況。
	    由於 ports 內所收集的軟體在 -CURRENT 或是 -STABLE 上都要能用，
	    所以請儘速送出關於此問題的蟲報告；請使用 &man.send-pr.1; 這個指
	    令來送蟲報告。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="find-ldso">
          <para>那裡可以找得到 ld.so？</para>
	</question>

	<answer>
          <para>有些 a.out 格式的應用程式會需要 a.out 格式的函式庫，
	    Netscape Navigator 就是一個例子。不過用 ELF 函式庫編起來
	    的 FreeBSD 預設並不會安裝舊的 a.out 函式庫，所以您可能會得
	    到類似找不到 <filename>/usr/libexec/ld.so</filename> 的抱怨訊
            息。如果說您的系統有這安裝 a.out 函式庫的必要，這些函式庫
	    (compat22) 也能夠利用 &man.sysinstall.8; 來安裝。或者利用
	    FreeBSD 原始碼來安裝：</para>

          <screen>&prompt.root; <userinput>cd /usr/src/lib/compat/compat22</userinput>&prompt.root; <userinput>make install clean</userinput></screen>

	  <para>如果你希望每次 <command>make world</command> 時會自動更新
            compat22 函式庫，那麼修改 <filename>/etc/make.conf</filename>，
            加入 <varname>COMPAT22=YES</varname>。這些相容於古老版本的函式庫
            已經沒什麼在更新了，所以一般說來是不需要這樣的。</para>

          <para>同時也請您看一下 3.1-RELEASE 和 3.2-RELEASE 的勘誤表(ERRATA)。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="ports-update">
          <para>我更新了系統原始碼，現在我要怎樣升級某個已經安裝上
	    的 ports ?</para>
        </question>

        <answer>
          <para>FreeBSD 本身並沒有自動升級 ports 的工具，但有一些可以讓升級
            簡化一些的小程式。你也可以自己裝上額外的工具來處理。</para>

          <para>&man.pkg.version.1; 指令可以自動產生用來達到自動升級到
	    ports tree 最新版本的 script。</para>

          <screen>&prompt.root; <userinput>pkg_version <option>-c</option> > <replaceable>/tmp/myscript</replaceable></userinput></screen>

          <para><emphasis>一定要</emphasis>在手動修改一下產生出來的 script。
            目前的 &man.pkg.version.1; 在 script 最前面加入 &man.exit.1; 強
            迫你去修改它。</para>

          <para>你應將執行 script 所產生的輸出記錄下來，因為裡面會有記載某些
            尚未升級但已經更新的 ports。不過你不一定要去升級它們。通常是因為
            有某個共用的函式庫已經改變版本號了，才要去重編一次那些使用到該函
            式庫的 ports。</para>

          <para>如果你的硬碟空間很夠，那麼可以用 <command>portupgrade</command>
	    這個工具來做全自動處裡。<command>portupgrade</command> 裡面也有
	    一些小程式來簡化 package 升級，它在
	    <filename role="package">sysutils/portupgrade</filename>。
	    這個工具是用 Ruby 這個語言寫的，所以並不適合加入到 FreeBSD 的原
	    始碼中，不過並不會因此讓某些人不用它。</para>

          <para>如果你的系統一直都處於開機狀態，可利用 &man.periodic.8; 系統，
            每個星期產生一張需要升級的清單。只要在
            <filename>/etc/periodic.conf</filename> 加入
            <literal>weekly_status_pkg_enable="YES"</literal> 就可以了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="minima-sh">
          <para>為什麼 <command>/bin/sh</command>這麼的小？為什麼 FreeBSD
            不改用 <command>bash</command> 或者是其他比較強悍的 shell？</para>
        </question>

        <answer>
          <para>因為 POSIX 說，該要有這麼樣的一個 shell 在才行。</para>

          <para>比較繁瑣的答案：許多人需要寫可以跨很多平台的 shell script 。
            這也是為何 POSIX 將 shell 以及工具命稱都定義的非常詳細的緣故。
            大部份的 script 都適用於 Bourne shell，又因為有幾個重要的
            寫程式所用到的程式或者函式 (&man.make.1; , &man.system.3;,
            &man.popen.3;, 還有在 Perl 或者 Tcl 裡面呼叫系統程式的地方)
            都指定用 Bourne shell 。那麼因為 Bourne Shell 如此的廣泛常用，
            那麼它的執行效率便很重要，快速是它決定性的要點之一，還要不佔太多
            記憶體。</para>

          <para>目前的 <command>/bin/sh</command> 已是我們嘔心瀝血之作，它已
            經盡量地符合標準規定。為了讓它非常小，我們拿掉了一些其他 shell
            有的方便功能。這也是為什麼 ports 裡面還有很多強悍的 shell ，像是
            bash, scsh, tcsh 以及 zsh 。 (你可以自己比較一下這些 shell 執行
            時所佔的記憶體大小，去看看 <command>ps -u</command> 列出來的
            <quote>VSZ</quote> 和 <quote>RSS</quote> 這兩個欄位就知道了。)
            </para>
         </answer>
      </qandaentry>

      <qandaentry>
        <question id="netscape-slow-startup">
          <para>為什麼 Netscape 和 Opera 要花好久的時間才能啟動？</para>
      </question>

      <answer>
        <para>通常是因為你的 DNS 沒有設定好。 Netscape 跟 Opera 在啟動的時候
	  都會去檢查一下 DNS。直到 DNS 有回應，或者是斷定網路目前是斷線之後，
	  它們才會顯示畫面出來。</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>


  <chapter id="kernelconfig">
    <chapterinfo>
      <author>
	<firstname>Kang-min</firstname>
	<surname>Liu</surname>
	<affiliation>
	  <address><email>gugod@gugod.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>kernel 設定</title>

    <qandaset>
      <qandaentry>
        <question id="make-kernel">
          <para>我想自訂 kernel，這會很困難嗎？</para>
        </question>

        <answer>
          <para>不會！請查閱 <ulink url="../../handbook/kernelconfig.html">
            使用手冊中的 kernel 設定一節</ulink>。</para>

            <note>
              <para>我會建議你在你讓核心能正常工作後，做一個
	        <filename>kernel.YYMMDD</filename> 日期形式的備份，同時也備份
		<filename>/module</filename>這個目錄至
		<filename>/modules.YYMMDD</filename>。這樣下次如果你很不幸的玩
		壞了設定，至少可以不需要使用最原始的
		<filename>kernel.GENERIC</filename>。如你正從一個 GENERIC
		kernel 裡面不支援的控制器裡啟動時，這就顯得特別重要。</para>
            </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-hw-float">
          <para>我的核心因為 <literal>_hw_float</literal>遺失而編譯失敗。
	    該怎麼修正呢？</para>
	</question>

        <answer>
          <para>讓我猜看看，你把 <devicename>npx0</devicename>
	    (詳見 &man.npx.4;) 從你的 kernel 設定檔移除了，因為你沒有數學運算器，
	    對嗎？錯了！:-) 這個 <devicename>npx0</devicename>是
	    <emphasis>必須要有的</emphasis>。就算你沒有數學運算器，你還是
	    <emphasis>必須</emphasis> 引入 <devicename>npx0</devicename> 裝置。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="why-kernel-big">
          <para>為什麼造出來的 kernel 這麼大 (10MB 以上) ？</para>
        </question>

        <answer>
          <para>這很有可能是因為，你把 kernel 編成 <emphasis>偵錯模式</emphasis>
	    了。偵錯模式之下的 kernel 裡面會存著偵錯用的許多符號，因此會大幅
	    增加 kernel 的大小。如果說你的 FreeBSD 是 3.0 以後的版本，這對於
	    效能來說影響並不大，幾乎是沒有。而在系統會因某些原因 panic 時，
	    有個偵錯模式的 kernel 在也挺有用的。</para>

          <para>不過呢，如果你的磁碟空間很小，或者你就是不想用偵錯模式的
	    kernel 的話，請確認以下事情：</para>

          <itemizedlist>
            <listitem>
              <para>kernel 設定檔裡面沒有這一行：</para>

              <programlisting>makeoptions DEBUGS=-g </programlisting>
            </listitem>

            <listitem>
              <para>執行 &man.config.8; 時沒有加上 <option>-g</option>
	        這個選項。</para>
            </listitem>
          </itemizedlist>

          <para>以上兩件事情都會讓你編出一個偵錯模式的 kernel。但只要避免之，
	    就可以編出一個正常的 kernel，而你也會注意到，kernel 明顯的變小了；
	    大部份的 kernel 都差不多在 1.5MB 到 2MB 之間。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="multiport-serial-interrupts">
          <para>為何出現了 multi-port serial code 的中斷衝突？</para>
        </question>

        <answer>
          <para>當我編譯一個 multi-port serial code 的核心時，它告訴我只有
	    第一個被偵測到，其他的則因中斷衝突而跳過了，我該怎麼修正它？</para>

          <para>這個問題是因為 FreeBSD 使用內建程式碼避免因為硬體或軟體衝突
	    導致 kernel 過於肥大或無用。要修正這種情形的方法是除了一個 port
	    外把其他所有的 IRQ 設定都做保留。這裡有一個範例：</para>

          <programlisting>#
# Multiport high-speed serial line - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="generic-kernel-build-failure">
          <para>為什麼我一個 kernel 都編不起來？甚至 GENERIC 也不行？</para>
	</question>

        <answer>
          <para>這有很多種可能的原因：</para>

          <itemizedlist>
            <listitem>
              <para>你沒有用新的 <command>make buildkernel</command> 與
	        <command>make installkernel</command> 這兩個方法來編，而正好
		你的系統原始碼的版本和正在執行的系統核心版本不一樣 (像是，
		在跑 4.0-RELEASE 的系統上嘗試著編 4.3-RELEASE)。如果說你要升
		級系統的話，請務必去看看 <filename>/usr/src/UPDATING</filename>
		這個檔案，特別注意最後面的 <quote>COMMON ITEMS</quote>
		這個小節。</para>
            </listitem>

            <listitem>
              <para>你已經用上 <command>make buildkernel</command> 以及
	        <command>make installkernel</command> 了，但是在
		<command>make buildworld</command> 時失敗了。可惜的是，
		<command>make buildkernel</command> 要成功，需要依賴
		<command>make buildworld</command> 後造出來的一些檔案。</para>
            </listitem>

            <listitem>
              <para>就算是你在編 <link linkend="stable">&os.stable;</link>，
	        還是有可能你抓到了正在修改中，或著因為某些緣故而根本還沒改好
		的原始碼；雖然說 <link linkend="stable">&os.stable;</link>
		大部份的時候都是可以編的，但只有 RELEASE 才是保證可以編的。碰
		到這個問題時，再次更新原始碼並且再試試看。也有可能是放原始碼的
		伺服器出現某些問題，所以更新原始碼時也試試從不同伺服器來更新看
		看。</para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="disks">
    <title>硬碟、檔案系統、Boot Loader</title>

    <qandaset>
      <qandaentry>
        <question id="new-huge-disk">
          <para>我要怎麼把我的系統搬到新硬碟上面去？</para>
        </question>

        <answer>
          <para>理想的方式是先在新硬碟上重裝好作業系統，然後把使用者相關程式、資料搬過去就好。
            This is highly
            recommended if you have been tracking -STABLE for more
            than one release, or have updated a release instead of
            installing a new one.  You can install booteasy on both
            disks with &man.boot0cfg.8;, and dual boot them until
            you are happy with the new configuration.  Skip the
            next paragraph to find out how to move the data after
            doing this.</para>

          <para>Should you decide not to do a fresh install, you
            need to partition and label the new disk with either
            <filename>sysinstall</filename>(&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>), or &man.fdisk.8;
            and &man.disklabel.8;.  You should also install booteasy
            on both disks with &man.boot0cfg.8;, so that you can
            dual boot to the old or new system after the copying
            is done.</para>

          <para>Now you have the new disk set up, and are ready
            to move the data.  Unfortunately, you cannot just blindly
            copy the data.  Things like device files (in
	    <filename>/dev</filename>), flags, and links tend to
            screw that up.  You need to use tools that understand
            these things, which means &man.dump.8;.
            Although it is suggested that you move the data in single user
            mode, it is not required.</para>

          <para>You should never use anything but &man.dump.8; and
            &man.restore.8; to move the root filesystem.  The
            &man.tar.1; command may work - then again, it may not.
            You should also use &man.dump.8; and &man.restore.8;
            if you are moving a single partition to another empty
            partition.  The sequence of steps to use dump to move
            a partitions data to a new partition is:</para>

          <procedure>
            <step>
              <para>newfs the new partition.</para>
            </step>

            <step>
              <para>mount it on a temporary mount point.</para>
            </step>

            <step>
              <para>cd to that directory.</para>
            </step>

            <step>
              <para>dump the old partition, piping output to the
                new one.</para>
            </step>
          </procedure>

          <para>For example, if you are going to move root to
            <devicename>/dev/ad1s1a</devicename>, with
            <filename>/mnt</filename> as the temporary mount point,
            it is:</para>

          <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput></screen>

          <para>Rearranging your partitions with dump takes a bit more
            work. To merge a partition like <filename>/var</filename>
            into its parent, create the new partition large enough
            for both, move the parent partition as described above,
            then move the child partition into the empty directory
            that the first move created:</para>

          <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput>
&prompt.root; <userinput>cd var</userinput>
&prompt.root; <userinput>dump 0af - /var | restore xf -</userinput></screen>

	  <para>To split a directory from its parent, say putting
	    <filename>/var</filename> on its own partition when it was not
	    before, create both partitions, then mount the child partition
	    on the appropriate directory in the temporary mount point, then
	    move the old single partition:</para>

          <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>newfs /dev/ad1s1d</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>mkdir /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/ad1s1d /mnt/var</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput></screen>

          <para>You might prefer &man.cpio.1;, &man.pax.1;,
            &man.tar.1; to &man.dump.8; for user data. At the time of
            this writing, these are known to lose file flag information,
            so use them with caution.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dangerously-dedicated">
          <para>Will a <quote>dangerously dedicated</quote> disk endanger
            my health?</para>
        </question>

        <answer>

          <para><anchor id="dedicate"/>The installation procedure allows
            you to chose two different methods in partitioning your
            hard disk(s). The default way makes it compatible with other
            operating systems on the same machine, by using fdisk table
            entries (called <quote>slices</quote> in FreeBSD), with a
            FreeBSD slice that employs partitions of its own. Optionally,
            one can chose to install a boot-selector to switch between the
            possible operating systems on the disk(s). The alternative uses
            the entire disk for FreeBSD, and makes no attempt to be
            compatible with other operating systems.</para>

          <para>So why it is called <quote>dangerous</quote>?  A disk
            in this mode does not contain what normal PC utilities
            would consider a valid fdisk table. Depending on how well
            they have been designed, they might complain at you once
            they are getting in contact with such a disk, or even
            worse, they might damage the BSD bootstrap without even
            asking or notifying you. In addition, the
            <quote>dangerously dedicated</quote> disk's layout is
            known to confuse many BIOSes, including those from AWARD
            (e.g. as found in HP Netserver and Micronics systems as
            well as many others) and Symbios/NCR (for the popular
            53C8xx range of SCSI controllers). This is not a complete
            list, there are more. Symptoms of this confusion include
            the <errorname>read error</errorname> message printed by
            the FreeBSD bootstrap when it cannot find itself, as well
            as system lockups when booting.</para>

          <para>Why have this mode at all then?  It only saves a few kbytes
            of disk space, and it can cause real problems for a new
            installation. <quote>Dangerously dedicated</quote> mode's
            origins lie in a desire to avoid one of the most common
            problems plaguing new FreeBSD installers - matching the BIOS
            <quote>geometry</quote> numbers for a disk to the disk
            itself.</para>

          <para><quote>Geometry</quote> is an outdated concept, but one
            still at the heart of the PC's BIOS and its interaction with
            disks. When the FreeBSD installer creates slices, it has to
            record the location of these slices on the disk in a fashion
            that corresponds with the way the BIOS expects to find them. If
            it gets it wrong, you will not be able to boot.</para>

          <para><quote>Dangerously dedicated</quote> mode tries to work
            around this by making the problem simpler. In some cases, it
            gets it right. But it is meant to be used as a last-ditch
            alternative - there are better ways to solve the problem 99
            times out of 100.</para>

          <para>So, how do you avoid the need for <quote>DD</quote> mode
            when you are installing? Start by making a note of the geometry
            that your BIOS claims to be using for your disks. You can
            arrange to have the kernel print this as it boots by specifying
            <option>-v</option> at the <literal>boot:</literal> prompt, or
            using <command>boot -v</command> in the loader. Just before the
            installer starts, the kernel will print a list of BIOS
            geometries. Do not panic - wait for the installer to start and
            then use scrollback to read the numbers. Typically the BIOS
            disk units will be in the same order that FreeBSD lists your
            disks, first IDE, then SCSI.</para>

          <para>When you are slicing up your disk, check that the disk
            geometry displayed in the FDISK screen is correct (ie. it
            matches the BIOS numbers); if it is wrong, use the
            <keycap>g</keycap> key to fix it. You may have to do this if
            there is absolutely nothing on the disk, or if the disk has been
            moved from another system. Note that this is only an issue with
            the disk that you are going to boot from; FreeBSD will sort
            itself out just fine with any other disks you may have.</para>

          <para>Once you have got the BIOS and FreeBSD agreeing about the
            geometry of the disk, your problems are almost guaranteed to be
            over, and with no need for <quote>DD</quote> mode at all. If,
            however, you are still greeted with the dreaded <errorname>read
            error</errorname> message when you try to boot, it is time to cross
            your fingers and go for it - there is nothing left to
            lose.</para>

          <para>To return a <quote>dangerously dedicated</quote> disk
            for normal PC use, there are basically two options. The first
            is, you write enough NULL bytes over the MBR to make any
            subsequent installation believe this to be a blank disk. You
            can do this for example with</para>

          <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda0 count=15</userinput></screen>

          <para>Alternatively, the undocumented DOS
            <quote>feature</quote></para>

          <screen><prompt>C:\&gt;</prompt> <userinput>fdisk /mbr</userinput></screen>

          <para>will to install a new master boot record as well, thus
            clobbering the BSD bootstrap.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="safe-softupdates">
          <para>Which partitions can safely use Soft Updates?  I have
            heard that Soft Updates on <filename>/</filename> can cause
            problems.</para>
        </question>

        <answer>
          <para>Short answer: you can usually use Soft Updates safely
            on all partitions.</para>

          <para>Long answer: There used to be some concern over using
            Soft Updates on the root partition.  Soft Updates has two
            characteristics that caused this.  First, a Soft Updates
            partition has a small chance of losing data during a
            system crash.  (The partition will not be corrupted; the
            data will simply be lost.)  Also, Soft Updates can cause
            temporary space shortages.</para>

          <para>When using Soft Updates, the kernel can take up to
            thirty seconds to actually write changes to the physical
            disk.  If you delete a large file, the file still resides
            on disk until the kernel actually performs the deletion.
            This can cause a very simple race condition.  Suppose you
            delete one large file and immediately create another large
            file.  The first large file is not yet actually removed
            from the physical disk, so the disk might not have enough
            room for the second large file.  You get an error that the
            partition does not have enough space, although you know
            perfectly well that you just released a large chunk of
            space!  When you try again mere seconds later, the file
            creation works as you expect.  This has left more than one
            user scratching his head and doubting his sanity, the
            FreeBSD filesystem, or both.</para>

          <para>If a system should crash after the kernel accepts a
            chunk of data for writing to disk, but before that data is
            actually written out, data could be lost or corrupted.
            This risk is extremely small, but generally manageable.
            Use of IDE write caching greatly increases this risk; it
            is strongly recommended that you disable IDE write caching
            when using Soft Updates.</para>

          <para>These issues affect all partitions using Soft Updates.
            So, what does this mean for the root partition?</para>

          <para>Vital information on the root partition changes very
            rarely.  Files such as <filename>/kernel</filename> and
            the contents of <filename>/etc</filename> only change
            during system maintenance, or when users change their
            passwords.  If the system crashed during the
            thirty-second window after such a change is made, it is
            possible that data could be lost.  This risk is negligible
            for most applications, but you should be aware that it
            exists.  If your system cannot tolerate this much risk,
            do not use Soft Updates on the root filesystem!</para>

          <para><filename>/</filename> is traditionally one of the
            smallest partitions.  By default, FreeBSD puts the
            <filename>/tmp</filename> directory on
            <filename>/</filename>.  If you have a busy
            <filename>/tmp</filename>, you might see intermittent
            space problems.  Symlinking <filename>/tmp</filename> to
            <filename>/var/tmp</filename> will solve this
            problem.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="inappropriate-ccd">
          <para>What is inappropriate about my ccd?</para>
        </question>

        <answer>
          <para>The symptom of this is:</para>

          <screen>&prompt.root; <userinput>ccdconfig -C</userinput>
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format</screen>

          <para>This usually happens when you are trying to concatenate
            the <literal>c</literal> partitions, which default to type
            <literal>unused</literal>. The ccd driver requires the
            underlying partition type to be FS_BSDFFS. Edit the disklabel
            of the disks you are trying to concatenate and change the types
            of partitions to <literal>4.2BSD</literal>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ccd-disklabel">
          <para>Why can I not edit the disklabel on my ccd?</para>
        </question>

        <answer>
          <para>The symptom of this is:</para>

          <screen>&prompt.root; <userinput>disklabel ccd0</userinput>
(it prints something sensible here, so let us try to edit it)
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label</screen>

          <para>This is because the disklabel returned by ccd is actually
            a <quote>fake</quote> one that is not really on the disk.
            You can solve this problem by writing it back explicitly,
            as in:</para>

          <screen>&prompt.root; <userinput>disklabel ccd0 &gt; /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -Rr ccd0 /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(this will work now)</screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mount-foreign-fs">
          <para>Can I mount other foreign filesystems under FreeBSD?</para>
        </question>

        <answer>
	  <para>FreeBSD supports a variety of other
	    filesystems.</para>

          <variablelist>
            <varlistentry>
              <term>Digital UNIX</term>

              <listitem>
                <para>UFS CDROMs can be mounted directly on FreeBSD.
                  Mounting disk partitions from Digital UNIX and other
                  systems that support UFS may be more complex, depending
                  on the details of the disk partitioning for the operating
                  system in question.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>&linux;</term>

              <listitem>
                <para>FreeBSD supports <literal>ext2fs</literal>
                  partitions.  See &man.mount.ext2fs.8; for more
                  information.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>&windowsnt;</term>

              <listitem>
                <para>FreeBSD includes a read-only NTFS driver.  For
		  more information, see &man.mount.ntfs.8;.
                </para>
              </listitem>
            </varlistentry>

	    <varlistentry>
	      <term>FAT</term>

	      <listitem>
		<para>FreeBSD includes a read-write FAT driver.  For
                  more information, see &man.mount.msdosfs.8;.</para>
		</listitem>
	      </varlistentry>
          </variablelist>

          <para>FreeBSD also supports network filesystems such as NFS
            (see &man.mount.nfs.8;), NetWare (see &man.mount.nwfs.8;),
            and Microsoft-style SMB filesystems (see
            &man.mount.smbfs.8;).</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mount-dos">
          <para>How do I mount a secondary DOS partition?</para>
        </question>

        <answer>

        <para>The secondary DOS partitions are found after ALL the
          primary partitions. For example, if you have an
          <quote>E</quote> partition as the second DOS partition on
          the second SCSI drive, you need to create the special files
          for <quote>slice 5</quote> in <filename>/dev</filename>,
          then mount <devicename>/dev/da1s5</devicename>:</para>

        <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV da1s5</userinput>
&prompt.root; <userinput>mount -t msdos /dev/da1s5 /dos/e</userinput></screen>

        <note>
	  <para>You can omit this step if you are running FreeBSD
	    5.0-RELEASE or newer with &man.devfs.5;
	    enabled.</para>
	</note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="crypto-filesystem">
          <para>&os; 有檔案加密系統嗎？</para>
        </question>

        <answer>

          <para>有啊！  FreeBSD 5.0 起內建 &man.gbde.8;，而 FreeBSD 6.0
            又加上 &man.geli.8;。  而較早期的版本，請多利用 <filename
            role="package">security/cfs</filename> port，謝謝。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="nt-bootloader">
          <para>How can I use the &windowsnt; loader to boot FreeBSD?</para>
        </question>

        <answer>
          <para>The general idea is that you copy the first sector of your
            native root FreeBSD partition into a file in the DOS/&windowsnt;
            partition. Assuming you name that file something like
            <filename>c:\bootsect.bsd</filename> (inspired by
            <filename>c:\bootsect.dos</filename>), you can then edit the
            <filename>c:\boot.ini</filename> file to come up with something
            like this:</para>

          <programlisting>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"</programlisting>

          <para>If FreeBSD is installed on the same disk as the &windowsnt; boot
            partition simply copy <filename>/boot/boot1</filename> to
            <filename>C:\BOOTSECT.BSD</filename>. However, if FreeBSD is
            installed on a different disk <filename>/boot/boot1</filename>
            will not work, <filename>/boot/boot0</filename> is needed.</para>

          <para><filename>/boot/boot0</filename> needs to be installed
            using sysinstall(&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>) by selecting the FreeBSD boot manager on
            the screen which asks if you wish to use a boot
            manager. This is because <filename>/boot/boot0</filename>
            has the partition table area filled with NULL characters
            but sysinstall copies the partition table before copying
            <filename>/boot/boot0</filename> to the MBR.</para>

            <warning>
              <para><emphasis>Do not simply copy <filename>/boot/boot0</filename>
                instead of <filename>/boot/boot1</filename>; you will
                overwrite your partition table and render your computer
                un-bootable!</emphasis></para>
            </warning>

          <para>When the FreeBSD boot manager runs it records the last
            OS booted by setting the active flag on the partition table
            entry for that OS and then writes the whole 512-bytes of itself
            back to the MBR so if you just copy
            <filename>/boot/boot0</filename> to
            <filename>C:\BOOTSECT.BSD</filename> then it writes an empty
            partition table, with the active flag set on one entry, to the
            MBR.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="lilo-bootloader">
          <para>How do I boot FreeBSD and &linux; from LILO?</para>
        </question>

        <answer>
          <para>If you have FreeBSD and &linux; on the same disk, just follow
            LILO's installation instructions for booting a non-&linux;
            operating system.  Very briefly, these are:</para>

          <para>Boot &linux;, and add the following lines to
            <filename>/etc/lilo.conf</filename>:</para>

            <programlisting>other=/dev/hda2
        table=/dev/hda
        label=FreeBSD</programlisting>

          <para>(the above assumes that your FreeBSD slice is known to
            &linux; as <devicename>/dev/hda2</devicename>; tailor to
            suit your setup).  Then, run <command>lilo</command> as
            <username>root</username> and you should be done.</para>

          <para>If FreeBSD resides on another disk, you need to add
            <literal>loader=/boot/chain.b</literal> to the LILO entry.
            For example:</para>

          <programlisting>other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=FreeBSD</programlisting>

          <para>In some cases you may need to specify the BIOS drive number
            to the FreeBSD boot loader to successfully boot off the second
            disk.  For example, if your FreeBSD SCSI disk is probed by BIOS
            as BIOS disk 1, at the FreeBSD boot loader prompt you need to
            specify:</para>

          <screen>Boot: <userinput>1:da(0,a)/kernel</userinput></screen>

          <para>You can configure
            &man.boot.8;
            to automatically do this for you at boot time.</para>

          <para>The <ulink
            url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html">
            &linux;+FreeBSD mini-HOWTO</ulink> is a good reference for
            FreeBSD and &linux; interoperability issues.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="booteasy-loader">
          <para>How do I boot FreeBSD and &linux; using BootEasy?</para>
        </question>

        <answer>
          <para>Install LILO at the start of your &linux; boot partition
            instead of in the Master Boot Record.   You can then boot LILO
            from BootEasy.</para>

          <para>If you are running &windows; 95 and &linux; this is recommended
            anyway, to make it simpler to get &linux; booting again if you
            should need to reinstall &windows; 95 (which is a Jealous
            Operating System, and will bear no other Operating Systems in
            the Master Boot Record).</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="changing-bootprompt">
          <para>How do I change the boot prompt from <literal>???</literal> to
            something more meaningful?</para>
        </question>

        <answer>
          <para>You can not do that with the standard boot manager without
            rewriting it. There are a number of other boot managers
            in the <filename>sysutils</filename> ports category that
            provide this functionality.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="removable-drives">
          <para>I have a new removable drive, how do I use it?</para>
        </question>

        <answer>

          <para>Whether it is a removable drive like a &iomegazip; or an EZ drive
            (or even a floppy, if you want to use it that way), or a new
            hard disk, once it is installed and recognized by the system,
            and you have your cartridge/floppy/whatever slotted in, things
            are pretty much the same for all devices.</para>

          <para>(this section is based on <ulink
            url="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html">
            Mark Mayo's ZIP FAQ</ulink>)</para>

          <para>If it is a ZIP drive or a floppy, you have already got a DOS
            filesystem on it, you can use a command like this:</para>

          <screen>&prompt.root; <userinput>mount -t msdos /dev/fd0c /floppy</userinput></screen>

          <para>if it is a floppy, or this:</para>

          <screen>&prompt.root; <userinput>mount -t msdos /dev/da2s4 /zip</userinput></screen>

          <para>for a ZIP disk with the factory configuration.</para>

          <para>For other disks, see how they are laid out using
            &man.fdisk.8; or
            &man.sysinstall.8;.</para>

          <para>The rest of the examples will be for a ZIP drive on da2,
            the third SCSI disk.</para>

          <para>Unless it is a floppy, or a removable you plan on sharing
            with other people, it is probably a better idea to stick a BSD
            filesystem on it. You will get long filename support, at least a
            2X improvement in performance, and a lot more stability. First,
            you need to redo the DOS-level partitions/filesystems. You can
            either use &man.fdisk.8; or
            <filename>sysinstall</filename>(&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>), or for a small drive
            that you do not want to bother with multiple operating system
            support on, just blow away the whole FAT partition table
            (slices) and just use the BSD partitioning:</para>

          <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda2 count=2</userinput>
&prompt.root; <userinput>disklabel -Brw da2 auto</userinput></screen>

          <para>You can use disklabel or
            <filename>sysinstall</filename> to create multiple BSD
            partitions. You will certainly want to do this if you are adding
            swap space on a fixed disk, but it is probably irrelevant on a
            removable drive like a ZIP.</para>

          <para>Finally, create a new filesystem, this one is on our ZIP
            drive using the whole disk:</para>

          <screen>&prompt.root; <userinput>newfs /dev/rda2c</userinput></screen>

          <para>and mount it:</para>

          <screen>&prompt.root; <userinput>mount /dev/da2c /zip</userinput></screen>

          <para>and it is probably a good idea to add a line like this
            to <filename>/etc/fstab</filename> (see &man.fstab.5;) so
            you can just type <command>mount /zip</command> in the
            future:</para>

          <programlisting>/dev/da2c /zip ffs rw,noauto 0 0</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mount-cd-superblock">
          <para>Why do I get <errorname>Incorrect super block</errorname> when
            mounting a CDROM?</para>
        </question>

        <answer>
          <para>You have to tell &man.mount.8; the type of the device
            that you want to mount.  This is described in the <ulink
            url="&url.books.handbook;/creating-cds.html"> Handbook section on
            optical media</ulink>, specifically the section <ulink
            url="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Using Data
            CDs</ulink>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cdrom-not-configured">
          <para>Why do I get <errorname>Device not
            configured</errorname> when mounting a CDROM?</para>
        </question>

        <answer>
          <para>This generally means that there is no CDROM in the
            CDROM drive, or the drive is not visible on the
            bus. Please see the <ulink
            url="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Using Data
            CDs</ulink> section of the Handbook for a detailed
            discussion of this issue.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cdrom-unicode-filenames">
          <para>Why do all non-English characters in filenames show up as
            <quote>?</quote> on my CDs when mounted in FreeBSD?</para>
        </question>

        <answer>
          <para>Your CDROM probably uses the <quote>Joliet</quote>
            extension for storing information about files and
            directories.  This is discussed in the Handbook chapter on
            <ulink url="&url.books.handbook;/creating-cds.html">creating and
            using CDROMs</ulink>, specifically the section on <ulink
            url="&url.books.handbook;/creating-cds.html#MOUNTING-CD">Using Data
            CDROMs</ulink>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="burncd-isofs">
          <para>I burned a CD under FreeBSD and now I can not read it
            under any other operating system. Why?</para>
        </question>

        <answer>
          <para>You most likely burned a raw file to your CD, rather
            than creating an ISO 9660 filesystem.  Take a look at the
            <ulink url="&url.books.handbook;/creating-cds.html">Handbook
            chapter on creating CDROMs</ulink>, particularly the
            section on <ulink
            url="&url.books.handbook;/creating-cds.html#RAWDATA-CD">burning raw
            data CDs</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="copy-cd">
          <para>How can I create an image of a data CD?</para>
        </question>

        <answer>
          <para>This is discussed in the Handbook section on <ulink
            url="&url.books.handbook;/creating-cds.html#IMAGING-CD">duplicating
            data CDs</ulink>. For more on working with CDROMs, see the
            <ulink url="&url.books.handbook;/creating-cds.html">Creating CDs
            Section</ulink> in the Storage chapter in the
            Handbook.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mount-audio-CD">
          <para>Why can I not <command>mount</command> an audio
          CD?</para>
         </question>

        <answer>
          <para>If you try to mount an audio CD, you will get an error
            like <errorname>cd9660: /dev/acd0c: Invalid
            argument</errorname>.  This is because
            <command>mount</command> only works on filesystems.  Audio
            CDs do not have filesystems; they just have data.  You
            need a program that reads audio CDs, such as the
            <filename role="package">audio/xmcd</filename> port.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="multi-session-CD">
          <para>How do I <command>mount</command> a multi-session CD?</para>
        </question>

        <answer>
          <para>By default, &man.mount.8; will attempt to mount the
            last data track (session) of a CD.  If you would like to
            load an earlier session, you must use the
            <option>-s</option> command line argument.  Please see
            &man.mount.cd9660.8; for specific examples.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="user-floppymount">
          <para>How do I let ordinary users mount floppies, CDROMs and
            other removable media?</para>
        </question>

        <answer>
          <para>Ordinary users can be permitted to mount devices. Here is
            how:</para>

          <procedure>
            <step>
              <para>As <username>root</username> set the sysctl variable
                <varname>vfs.usermount</varname> to
                <literal>1</literal>.</para>

              <screen>&prompt.root; <userinput>sysctl -w vfs.usermount=1</userinput></screen>
            </step>

            <step>
              <para>As <username>root</username> assign the appropriate
                permissions to the block device associated with the
                removable media.</para>

              <para>For example, to allow users to mount the first floppy
                drive, use:</para>

              <screen>&prompt.root; <userinput>chmod 666 /dev/fd0</userinput></screen>

              <para>To allow users in the group
                <groupname>operator</groupname> to mount the CDROM drive,
                use:</para>

              <screen>&prompt.root; <userinput>chgrp operator /dev/acd0c</userinput>
&prompt.root; <userinput>chmod 640 /dev/acd0c</userinput></screen>
            </step>

	    <step>
	      <para>If you are running &os; 5.X or later, you will need to alter
		<filename>/etc/devfs.conf</filename> to make these changes
		permanent across reboots.</para>

	      <para>As <username>root</username>, add the necessary lines to
		<filename>/etc/devfs.conf</filename>.  For example, to allow
		  users to mount the first floppy drive add:</para>

	      <programlisting># Allow all users to mount the floppy disk.
own       /dev/fd0	  root:operator
perm	  /dev/fd0	  0666</programlisting>

	      <para>To allow users in the group <groupname>operator</groupname>
		to mount the CD-ROM drive add:</para>

	      <programlisting># Allow members of the group operator to mount CD-ROMs.
own       /dev/acd0	  root:operator
perm	  /dev/acd0	  0660</programlisting>
	    </step>

            <step>
              <para>Finally, add the line
                <literal><varname>vfs.usermount</varname>=1</literal>
                to the file <filename>/etc/sysctl.conf</filename> so
                that it is reset at system boot time.</para>
            </step>
          </procedure>

          <para>All users can now mount the floppy
            <devicename>/dev/fd0</devicename> onto a directory that they
            own:</para>

          <screen>&prompt.user; <userinput>mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput>mount -t msdos /dev/fd0 ~/my-mount-point</userinput></screen>

          <para>Users in group <groupname>operator</groupname> can now
            mount the CDROM <devicename>/dev/acd0c</devicename> onto a
            directory that they own:</para>

          <screen>&prompt.user; <userinput>mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput>mount -t cd9660 /dev/acd0c ~/my-mount-point</userinput></screen>

          <para>Unmounting the device is simple:</para>

          <screen>&prompt.user; <userinput>umount ~/my-mount-point</userinput></screen>

          <para>Enabling <varname>vfs.usermount</varname>, however,
            has negative security implications.  A better way to
            access &ms-dos; formatted media is to use the
            <filename role="package">emulators/mtools</filename>
            package in the ports collection.</para>

	  <note>
	    <para>The device name used in the previous examples must be
	      changed according to your configuration.</para>
	  </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="du-vs-df">
          <para>The <command>du</command> and <command>df</command>
            commands show different amounts of disk space available.
            What is going on?</para>
        </question>

        <answer>
          <para>You need to understand what <command>du</command> and
            <command>df</command> really do.  <command>du</command>
            goes through the directory tree, measures how large each
            file is, and presents the totals.  <command>df</command>
            just asks the filesystem how much space it has left.  They
            seem to be the same thing, but a file without a directory
            entry will affect <command>df</command> but not
            <command>du</command>.</para>

          <para>When a program is using a file, and you delete the
            file, the file is not really removed from the filesystem
            until the program stops using it.  The file is immediately
            deleted from the directory listing, however.  You can see
            this easily enough with a program such as
            <command>more</command>.  Assume you have a file large
            enough that its presence affects the output of
            <command>du</command> and <command>df</command>.  (Since
            disks can be so large today, this might be a
            <emphasis>very</emphasis> large file!)  If you delete this
            file while using <command>more</command> on it,
            <command>more</command> does not immediately choke and
            complain that it cannot view the file.  The entry is
            simply removed from the directory so no other program or
            user can access it.  <command>du</command> shows that it
            is gone &mdash; it has walked the directory tree and the file
            is not listed.  <command>df</command> shows that it is
            still there, as the filesystem knows that
            <command>more</command> is still using that space.  Once
            you end the <command>more</command> session,
            <command>du</command> and <command>df</command> will
            agree.</para>

          <para>Note that Soft Updates can delay the freeing of disk
            space; you might need to wait up to 30 seconds for the
            change to be visible!</para>

          <para>This situation is common on web servers.  Many people
            set up a FreeBSD web server and forget to rotate the log
            files.  The access log fills up <filename>/var</filename>.
            The new administrator deletes the file, but the system
            still complains that the partition is full.  Stopping and
            restarting the web server program would free the file,
            allowing the system to release the disk space.  To prevent
            this from happening, set up &man.newsyslog.8;.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="add-swap-space">
          <para>How can I add more swap space?</para>
        </question>

        <answer>
          <para>In the <ulink
          url="&url.books.handbook;/config-tuning.html">Configuration and
          Tuning</ulink> section of the Handbook, you will find a
          <ulink
          url="&url.books.handbook;/adding-swap-space.html">section</ulink>
          describing how to do this.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="manufacturer-disk-size">
          <para>Why does &os; see my disk as smaller than the
            manufacturer says it is?</para>
        </question>

        <answer>
        <para>Disk manufacturers calculate gigabytes as a billion bytes
          each, whereas &os; calculates them as 1,073,741,824 bytes
          each. This explains why, for example, &os;'s boot messages
          will report a disk that supposedly has 80GB as holding
          76319MB.</para>
        <para>Also note that &os; will (by default)
          <link linkend="disk-more-than-full">reserve</link> 8% of the disk
          space.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="disk-more-than-full">
          <para>How is it possible for a partition to be more than 100%
            full?</para>
        </question>

        <answer>
	  <para>A portion of each UFS partition (8%, by default) is
	    reserved for use by the operating system and the
	    <username>root</username> user.
	    &man.df.1; does not count that space when
	    calculating the <literal>Capacity</literal> column, so it can
	    exceed 100%.  Also, you will notice that the
	    <literal>Blocks</literal> column is always greater than the
	    sum of the <literal>Used</literal> and
	    <literal>Avail</literal> columns, usually by a factor of
	    8%.</para>

	  <para>For more details, look up the <option>-m</option> option
	    in &man.tunefs.8;.</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>


  <chapter id="admin">
    <chapterinfo>
      <author>
	<firstname>Wei-Hon</firstname>
	<surname>Chen</surname>
	<affiliation>
	  <address><email>plasmaball@pchome.com.tw</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>系統管理</title>

    <qandaset>
      <qandaentry>
        <question id="startup-config-files">
          <para>系統起始設定檔在哪？</para>
        </question>

        <answer>

          <para>從 2.0.5R 到 2.2.1R，主要的設定檔是
	    <filename>/etc/sysconfig</filename>。所有的選項都被指定在這個檔，
	    而其他像 <filename>/etc/rc</filename> (參見 &man.rc.8;)
            和 <filename>/etc/netstart</filename> 只是引用它。</para>

          <para>觀察 <filename>/etc/sysconfig</filename> 這個檔並修正其值以
	    適合你的系統。這個檔用註解填滿以表示何處該放置什麼設定。</para>

          <para>在 post-2.2.1 以後及 3.0，<filename>/etc/sysconfig</filename>
            亦更名為一個更容易描述的檔名叫 &man.rc.conf.5; ，並且語法簡化了些。
            <filename>/etc/netstart</filename> 亦更名為
            <filename>/etc/rc.network</filename> 因此所有的檔案都可以用
            <command>cp /usr/src/etc/rc* /etc</command> 來拷貝。</para>

          <para>在 3.1 以及，<filename>/etc/rc.conf</filename> 被移到
	    <filename>/etc/defaults/rc.conf</filename>。
            <emphasis>千萬不要編輯這個檔！</emphasis> 如果
            <filename>/etc/defaults/rc.conf</filename> 內有想要更動的項目，
	    你應該將那一行的內容拷貝到 <filename>/etc/rc.conf</filename>，
	    然後再修改它。</para>

          <para>例如 FreeBSD 3.1 及以後的版本內，有一個 DNS 伺服器 named，
	    而你想要啟動它。你所需要作的事就是：</para>
          <screen>&prompt.root; <userinput>echo named_enable="YES" &gt;&gt; /etc/rc.conf</userinput></screen>

          <para>想要在 FreeBSD 3.1 及以後的版本中，啟動本地端服務的話，將
	    shell script 置於 <filename>/usr/local/etc/rc.d</filename> 目錄
	    下。這些 shell script 應該設定成可執行，並且檔名以 .sh 結束。
            在 FreeBSD 3.0 及更早的版本中，你應該直接編輯
            <filename>/etc/rc.local</filename> 檔。</para>

          <para><filename>/etc/rc.serial</filename>用來初始化序列埠
	    （像是鎖定埠的特性等）。</para>

          <para><filename>/etc/rc.i386</filename> 是 Intel 專用設定，
	    像是 iBCS2 模擬或是 PC 系統主控台設定。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="adding-users">
          <para>該如何簡單地新增帳號？</para>
        </question>

        <answer>
          <para>使用 &man.adduser.8; 指令。如果需要更複雜的使用方式，
	    請用 &man.pw.8; 這個指令。</para>

          <para>要再次移除使用者，使用 &man.rmuser.8; 指令。還有，
	    &man.pw.8; 也可以使用。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="root-not-found-cron-errors">
          <para>在改完 crontab 檔案後，為什麼老是收到這樣的訊息：
            <errorname>root: not found</errorname>？</para>
        </question>

        <answer>
          <para>通常都是因為編輯了系統的 crontab
	    (<filename>/etc/crontab</filename>) 然後就用 &man.crontab.1;
	    去安裝它：</para>

          <screen>&prompt.root; <userinput>crontab /etc/crontab</userinput></screen>

          <para>這樣作是不對的。系統的 crontab 和 &man.crontab.1;
            所更新的使用者的 crontab 格式並不一樣 (&man.crontab.5;
            說明文件針對差異處有詳細的說明)。</para>

          <para>如果你已經用這種方法，額外多出的 crontab 只就是
            <filename>/etc/crontab</filename> 的拷貝，只是格式是錯誤的。
            可用以下的命令刪除：</para>

          <screen>&prompt.root; <userinput>crontab -r</userinput></screen>

          <para>下次你編輯 <filename>/etc/crontab</filename> 檔案的時候，
            你不用作任何動作去通知 &man.cron.8; ，它自動會去偵測是否有更動。
          </para>

          <para>如果你想要每天、每週、或是每月固定執行某些動作一次，也許加個
            shell script 在 <filename>/usr/local/etc/periodic</filename>
            目錄下會更好，系統的 cron 會固定執行 &man.periodic.8; 命令，
            它可將你的程式和其它的系統週期性工作一起執行。</para>

          <para>這個錯誤的真正原因，是因為系統的 crontab 有一個額外的欄位，
            說明該命令要以什麼使用者身份執行。在 FreeBSD 的預設系統 crontab
            中，所有的項目都是 <username>root</username>。 當這個 crontab
            被當作是 <username>root</username> 的使用者 crontab (它和系統的
            crontab 是 <emphasis>不</emphasis> 一樣的)，&man.cron.8; 會以為
            <literal>root</literal> 字串是欲執行的命令的第一個字，但是實際上
            並沒有這樣的命令存在。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="su-wheel-group">
	  <para>為什麼我想要用 su 成為 <username>root</username> 時，會得到
            <errorname>you are not in the correct group to su root</errorname>
            的錯誤訊息？</para>
	</question>

	<answer>
	  <para>這是一個安全特性。想要利用 su 成為 <username>root</username>
            (或其它有 superuser 權限的帳號)，你一定要在
	    <groupname>wheel</groupname> 群組內。如果沒有這個特性的話，
	    任何人只要在系統裡有帳號，並且恰巧知道 <username>root</username>
	    的密碼，就可以取得 superuser 等級的權限以存取系統。有了這個特性，
	    這樣的情況就不會發生；如果使用者不在 <groupname>wheel</groupname>
	    群組內的話，&man.su.1; 會讓他們連試著鍵入密碼的機會都沒有。</para>

	  <para>要讓某人可以利用 su 成為 <username>root</username> 的話，
            只要把他們放入 <groupname>wheel</groupname> 群組內即可。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="rcconf-readonly">
          <para>我在 <filename>rc.conf</filename> 還是某個起動檔案裡犯了錯誤，
            因為檔案系統變成唯讀的，我無法去編輯它。我該怎麼辦？</para>
        </question>

        <answer>
          <para>當電腦問你 shell 完整路徑名時，只要按 <literal>ENTER
            </literal>，然後執行 <command>mount /</command> 以讀寫模式
            重新掛載根檔案系統。你也許需要執行 <command>mount -a -t ufs
            </command>，將你慣用的文字編輯器所在的檔案系統掛載上來。如果
            你慣用的文字編輯器在網路檔案系統上的話，你必須先手動將網路設定
            起來，以便將網路檔案系統掛載上來，或是使用本地端檔案系統上的
            編輯器，例如 &man.ed.1;。</para>

          <para>如果你想要使用像 &man.vi.1; 或是 &man.emacs.1; 等的全螢幕
            文字編輯器的話，你也需要執行
	    <command>export TERM=cons25 </command>，以便讓這些編輯器能夠從
	    &man.termcap.5; 資料庫裡讀取正確的資料。</para>

          <para>當你已經完成了這些步驟後，你可以照你平常修改文法錯誤的方式
            去編輯 <filename>/etc/rc.conf</filename> 檔案。在核心 (kernel)
            啟動時所顯示的錯誤訊息，能夠告訴你檔案中哪一行有錯誤。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="printer-setup">
          <para>為什麼我沒辦法設定我的印表機？</para>
        </question>

        <answer>
          <para>請參考一下 Handbook 中，有關列印的部份。它應該能夠解決
            你大部份的問題。請參考 <ulink url="../handbook/printing.html">
            Handbook 中的列印部份</ulink>。</para>

	  <para>有些印表機需要主機支援的驅動程式 (host-based driver) 才能
            執行任何列印功能。FreeBSD 本身並不支援這些所謂的
            <quote>WinPrinters</quote>。 如果你的印表機無法在 DOS 或
            Windows NT 4.0 下執行，那它大概就是一台 WinPrinter。你唯一能使用
            這樣的印表機的希望，就是試試 <filename role="package">
            print/pnm2ppa</filename> 支不支援它了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="keyboard-mappings">
          <para>我要怎麼樣修正我的系統所使用的鍵盤對映 (keyboard mapping)？
            </para>
        </question>

        <answer>
          <para>請參考 Handbook 中的 <ulink
            url="../handbook/using-localization.html">using localization
            </ulink> 章節，尤其是 <ulink
            url="../handbook/using-localization.html#SETTING-CONSOLE">console
            setup</ulink> 章節。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="pnp-resources">
          <para>為什麼我在系統啟動時，得到 <errorname>unknown: &lt;PNP0303&gt;
            can't assign resources</errorname> 的訊息？</para>
        </question>

        <answer>
	  <para>以下是從 &os.current; 通信論壇的一篇文章中節錄出來的。</para>

	  <blockquote>
	    <attribution>&a.wollman;, 2001 年四月 24 日</attribution>

	    <para><quote>無法指派資源 (can't assign resources)</quote> 訊息表示
              那些裝置是傳統的 ISA 裝置，而核心中已經編入不認得 PNP 的驅動程
	      式。這些裝置包括鍵盤控制器，可程式化岔斷控制晶片，還有幾個標準
	      設備。資源無法指派給這些裝置，是因為早已有驅動程式使用那些位址
	      了。</para>
	  </blockquote>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="user-quotas">
          <para>為什麼 user quotas 無法正常運作？</para>
        </question>

        <answer>

            <orderedlist>
              <listitem>
                <para>可能你 kernel 設定未加入 quotas 支援(預設是無)。如果是這樣子的話，
                  那麼請把下面這行加到 kernel 設定檔內並重新編譯、安裝：</para>
                  <programlisting>options QUOTA</programlisting>

                <para>細節部分，請參閱 Handbook 內的 <ulink url="&url.books.handbook;/quotas.html">
                quotas</ulink> 章節。</para>
              </listitem>

              <listitem>
                <para>請不要直接在 <filename>/</filename> 打開 quotas </para>
              </listitem>

              <listitem>
                <para>把 quotas 檔放在它必須強迫置入的檔案系統內，舉例：</para>

                <informaltable frame="none">
                  <tgroup cols="2">
                    <thead>
                      <row>
                        <entry>檔案系統</entry>
                        <entry>Quota 檔</entry>
                      </row>
                    </thead>

                    <tbody>
                      <row>
                        <entry><filename>/usr</filename></entry>
                        <entry><filename>/usr/admin/quotas</filename></entry>
                      </row>

                      <row>
                        <entry><filename>/home</filename></entry>
                        <entry><filename>/home/admin/quotas</filename></entry>
                      </row>

                      <row>
                        <entry>&hellip;</entry>
                        <entry>&hellip;</entry>
                      </row>
                    </tbody>
                  </tgroup>
                </informaltable>
              </listitem>
            </orderedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="sysv-ipc">
          <para>FreeBSD 支援 System V IPC 格式指令集？</para>
        </question>

        <answer>
          <para>是的，FreeBSD 支援 System V-style IPC。這包括共享記憶體，
	    訊息跟信號。你需要在你的 kernel 設定檔內加入下列幾行以啟動它們。</para>

          <programlisting>options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</programlisting>

            <note>
              <para>在  FreeBSD 3.2 以及之後的版本，這些選項已經是
                <emphasis>GENERIC</emphasis> 核心的一部份，也就是說它們已
		經編進了你的系統中。</para>
            </note>

          <para>重新編譯並安裝。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="uucpmail">
          <para>我該如何讓 sendmail 透過 UUCP 來遞送郵件？</para>
        </question>

        <answer>
          <para>跟隨 FreeBSD 套裝而來的 sendmail 設定是適合那些直接連上網際網路
            的站台。想透過 UUCP 交換郵件的站台必須另外安裝 sendmail 的設定檔案。
          </para>

          <para>手動修改 <filename>/etc/sendmail.cf</filename> 是絕對必要的。
            第 8 版的 sendmail 提供一個全新的入口以透過一些像 &man.m4.1;
            的處理就能產生設定檔，這事實上是一個高層概念等級的技巧性設定。
	    你應該可以在 <filename>/usr/src/usr.sbin/sendmail/cf</filename>
	    以下裡使用它：</para>

          <para>假如你不是用 full sources 方式安裝系統，那麼 sendmail
            設定項目可能已經分散成好幾個來源分布檔在等著你，假設你已經
            mount 光碟機，做以下動作：</para>

          <screen>&prompt.root; <userinput>cd /cdrom/src</userinput>
&prompt.root; <userinput>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</userinput></screen>

          <para>別驚慌，這只有數十萬個位元組的大小。在 <filename>cf</filename>
	    目錄裡的 <filename>README</filename> 可以提供一個 m4 設定法的基
	    本介紹。</para>

          <para>以 UUCP 遞送來說，建議你最好使用 <literal>mailertable</literal>
            特點。建構一個資料庫讓 sendmail 可以使用它自己的路徑決策。</para>

          <para>首先，你必須建立自己的 <filename>.mc</filename> 檔。
            <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename> 目錄是這些
	    檔案的家。查看一下，已經有好幾個範例檔，假設你已經命名自己的檔叫
            <filename>foo.mc</filename>，你要做的只是把它轉換成一個有效的
            <filename>sendmail.cf</filename>：</para>

          <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail/cf/cf</userinput>
&prompt.root; <userinput>make foo.cf</userinput>
&prompt.root; <userinput>cp foo.cf /etc/mail/sendmail.cf</userinput></screen>

          <para>一個典型的 <filename>.mc</filename> 檔看起來可能像這樣：</para>

          <programlisting>VERSIONID(`<replaceable>Your version number</replaceable>')
OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable')

define(`UUCP_RELAY', <replaceable>your.uucp.relay</replaceable>)
define(`UUCP_MAX_SIZE', 200000)
define(`confDONT_PROBE_INTERFACES')

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <replaceable>your.alias.host.name</replaceable>
Cw    <replaceable>youruucpnodename.UUCP</replaceable></programlisting>

          <para><literal>accept_unresolvable_domains</literal>，
            <literal>nocanonify</literal>， 和
	    <literal>confDONT_PROBE_INTERFACES</literal> 特性將避免任何在
	    遞送郵件時會用到 DNS 的機會。<literal>UUCP_RELAY</literal>
	    項目的出現理由很奇怪，就不要問為何了。簡單的放入一個網際網路
	    上可以處理 .UUCP 虛擬網域位址的主機名稱；通常，你只需要在這
	    裡填入你 ISP 的信件回覆處 (mail replay)。</para>

          <para>你已經做到這裡了，你還需要這個叫
	    <filename>/etc/mail/mailertable</filename>。如果你只有一個用
	    來傳遞所有郵件的對外通道的話，以下的檔案就足夠了：</para>

          <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
                              uucp-dom:<replaceable>your.uucp.relay</replaceable></programlisting>

          <para>另一個更複雜的例子看起來像這樣：</para>

          <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
                             uucp-dom:</programlisting>


          <para>如你所見，這是某個真實檔案裡的一部份。首三行處理網域定址信件
            不應該被送出到內定路徑，而由某些 UUCP 鄰居(UUCP neighbor)取代
            的特殊情形，這是為了 <quote>縮短</quote>遞送的路徑。下一行處理到
	    本地乙太網路網域的信件讓它可以使用 SMTP 來遞送。最後，UUCP 鄰居提到
            .UUCP 虛擬網域的記載，允許一個 <literal><replaceable>uucp-neighbor
            </replaceable>!<replaceable>recipient</replaceable></literal> 推翻
	    內定規則。最後一行則以一個單獨的句點做結束，以 UUCP 遞送到提供當
	    你全世界性郵件閘門的UUCP 鄰居。所有在 <literal>uucp-dom:</literal>
	    關鍵字裡的節點名稱必須都是有效的 UUCP 鄰居，你可以用
	    <literal>uuname</literal> 命令去確認。
          </para>

          <para>提醒你這個檔案在使用前必須被轉換成 DBM 資料庫檔案，最好在
            mailertable 最上面用註解寫出命令列來完成這個工作。當你每次更換你
            的 mailertable 後你總是需要執行這個命令。</para>

          <para>最後提示：如果你不確定某些特定的信件路徑可用，記得把
            <option>-bt</option> 選項加到 sendmail。這會將 sendmail 啟動在
            <emphasis>address test mode</emphasis>；只要按下
            <literal>0</literal>，接著輸入你希望測試的信件路徑位址。
            最後一行告訴你使用內部的信件代理程式，代理程式的會通知目的主機，
            以及(可能轉換的)位址。要離開此模式請按 Control-D。</para>

          <screen>&prompt.user; <userinput>sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<prompt>&gt;</prompt> <userinput>3,0 foo@example.com</userinput>
canonify           input: foo @ example . com
..
parse            returns: $# uucp-dom $@ <replaceable>your.uucp.relay</replaceable> $: foo &lt; @ example . com . &gt;
<prompt>&gt;</prompt> <userinput>^D</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ispmail">
          <para>當我用撥接連上網路時該怎麼設定信件遞送？</para>
        </question>

        <answer>
          <para>如果你已經有一個固定的 IP 數字，你不需要調整任何內定值。設好
            你要指定的網路名稱，其他的 sendmail 都會幫你做完。</para>

          <para>如果你拿到的是動態配置的 IP 數字而使用撥接 ppp 連接到網際網
	    路，你可能已經在你的 ISP 信件主機上有一個信箱。假設你的 ISP 網域
	    是 <hostid role="domainname">example.net</hostid>，你的使用者名
	    稱是 <username>user</username>。亦假設你稱自己的主機名稱是
            <hostid role="fqdn">bsd.home</hostid> 而你的 ISP 告訴你可以使用
            <hostid role="fqdn">relay.example.net</hostid> 當作信件回覆處。
          </para>

          <para>為了從你的信箱接收信件，你將需要安裝取信程式以便從信箱取回信件。
            <application>Fetchmail</application> 是一個不錯的選擇，因為它支
	    援許多不同的通訊協定，通常你的 ISP 會提供 POP3。如果你選擇使用
	    user-ppp，你可以在連線到網路成功後自動抓取你的信件，只要在
	    <filename>/etc/ppp/ppp.linkup</filename>裡面設定以下這項：</para>

          <programlisting>MYADDR:
  !bg su user -c fetchmail</programlisting>

          <para>假使你正使用 <application>sendmail</application> (如下所示)
	    傳送信件到非本地帳號，置入以下命令：</para>

          <programlisting>  !bg su user -c "sendmail -q"</programlisting>

          <para>在上面那項命令之後。這會強迫 <application>sendmail</application>
	    在連接上網路後馬上開始處理 mailqueue。</para>

          <para>我假設你在 <hostid role="fqdn">bsd.home</hostid> 機器上有一個
            <username>user</username> 的帳號。在 <hostid
	    role="fqdn">bsd.home</hostid> 機器上 <username>user</username>
	    的家目錄裡建立一個 <filename>.fetchmailrc</filename> 的檔案：</para>

          <programlisting>poll example.net protocol pop3 fetchall pass MySecret</programlisting>

          <para>無須贅言，這個檔除了 <username>user</username> 外不應該被任
	    何人讀取，因為它包含 <literal>MySecret</literal> 這個密碼。</para>

          <para>為了在寄信時有正確的抬頭 <literal>from:</literal>，你必須告訴
	    <application>sendmail</application> 使用
	    <literal>user@example.net</literal> 而非
	    <literal>user@bsd.home</literal>。你可能會希望告訴
            <application>sendmail</application> 從
            <hostid role="fqdn">relay.example.net</hostid> 送出所有信件，
            加快信件傳送。</para>

          <para>以下的 <filename>.mc</filename> 檔應能滿足你的要求：</para>

          <programlisting>VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl</programlisting>

          <para>如何轉換這個 <filename>.mc</filename> 檔案到
            <filename>sendmail.cf</filename> 檔的詳細細節，請參考上一節。
            另外，在更新 <filename>sendmail.cf</filename> 以後不要忘記重新啟動
            <application>sendmail</application>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="sendmail-alternative">
          <para>除了 Sendmail 外，還有哪些郵件伺服器可以使用呢？</para>
        </question>

        <answer>
          <para><ulink url="http://www.sendmail.org/">Sendmail</ulink>
            是 FreeBSD 預設使用的郵件伺服器，但是你還是可以很容易地以其它
            郵件伺服器 (例如，從 port 安裝的郵件伺服器) 取代之。</para>

          <para>port 裡有很多可供選擇的郵件伺服器，像
            <filename role="package">mail/exim</filename>、
            <filename role="package">mail/postfix</filename>、
            <filename role="package">mail/qmail</filename>、
            <filename role="package">mail/zmailer</filename> 等，
            就是幾個很受歡迎的選擇。</para>

          <para>多樣選擇是好事，而且大家有許多郵件伺服器可以使用也被認為是
            好事；所以請避免在通信論壇裡問像 <quote>Sendmail 有比 Qmail
            好嗎？</quote> 這樣的問題。如果你真的很想問的話，請先到通信論壇
            archive 裡找一下。每一個郵件伺服器的優點與缺點，以前大概就已經
            討論好幾次了。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="forgot-root-pw">
          <para>我忘了 <username>root</username> 密碼了！怎麼辦？</para>
        </question>

	<answer>
          <para>不要驚慌！只要重新啟動系統，在看到 Boot: 時輸入
            <userinput>boot -s</userinput> 即可進入單使用者模式
            (在 3.2-RELEASE 之前的版本請改用 <userinput>-s</userinput>)。
            在問要使用哪個 shell 時，按下 ENTER。你會看到一個 &prompt.root;
            的提示號，輸入 <command>mount -u /</command> 以重新掛上(mount)
            你的根檔案系統可供讀/寫。執行 <command>passwd root</command>
            以更換 <username>root</username> 密碼，然後執行 &man.exit.1;
	    繼續啟動程序。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="CAD-reboot">
          <para>我該怎麼讓 Control-Alt-Delete 不會重新啟動系統？</para>
        </question>

        <answer>
          <para>如果你是使用 FreeBSD 2.2.7-RELEASE 或之後版本的
            syscons(系統內定的主控台驅動程式)，把下列這行放到 kernel 設定檔內，
            然後重做一個新的核心：</para>

          <programlisting>options SC_DISABLE_REBOOT</programlisting>

          <para>若是使用 FreeBSD 2.2.5-RELEASE 或之後版本的 PCVT 主控台驅動
	    程式，則以下列選項代替：</para>

          <programlisting>options PCVT_CTRL_ALT_DEL</programlisting>

          <para>其他更早期的 FreeBSD 版本，請修改你正在使用的主控台鍵盤對應，
            並將所有 <literal>boot</literal> 關鍵字以 <literal>nop</literal>
            取代。內定的鍵盤對應是在
            <filename>/usr/share/syscons/keymaps/us.iso.kbd</filename>。
            你可能需要明白的吩咐 <filename>/etc/rc.conf</filename> 去讀取
            這個鍵盤對應以確保更動生效。當然如果你正在用適合你國籍的鍵盤對應，
            你應該編輯那一個。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dos-to-unix-txt">
          <para>我該怎麼把 DOS 文字檔案重新格式化成 UNIX 的？</para>
        </question>

        <answer>
          <para>只要使用這個 perl 命令：</para>

          <screen>&prompt.user; <userinput>perl -i.bak -npe 's/\r\n/\n/g' file ...</userinput></screen>

          <para>file 就是要處理的檔案。這個修改是在內部完成，原始的檔案會儲存成
            副檔名為 .bak 的檔案。</para>

          <para>或者你可以使用 &man.tr.1; 這個命令：</para>

          <screen>&prompt.user; <userinput>tr -d '\r' &lt; <replaceable>dos-text-file</replaceable> &gt; <replaceable>unix-file</replaceable></userinput></screen>

          <para><replaceable>dos-text-file</replaceable> 是包含 DOS 文字的
	    檔案，而 <replaceable>unix-text-file</replaceable> 則是包含轉換
	    的輸出結果。這比使用 perl 還要快上一點點。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="kill-by-name">
          <para>我該怎麼用名稱砍掉 process？</para>
        </question><answer>

          <para>使用 &man.killall.1; 。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="root-acl">
          <para>為何在 su 一直說我不在 <username>root</username> 的 ACL 裡？
            </para>
        </question>

        <answer>
          <para>這個錯誤是因為 Kerberos 分散認證系統。這個問題並不是很嚴重
            但是令人厭煩。你可以用 -K 選項去執行 su，或是像下個問題所描述的
            移除 Kerberos。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="uninstall-kerberos">
          <para>我該怎麼移除 Kerberos？</para>
        </question>

        <answer>
          <para>要從系統裡移除 Kerberos，重裝你正在執行的 release 版本的
	    bin distribution。如果你有 CDROM，你可以 mount cd(假設在 /cdrom)
	    並執行：</para>

          <screen>&prompt.root; <userinput>cd /cdrom/bin</userinput>
&prompt.root; <userinput>./install.sh</userinput></screen>

          <para>或者你也可以將 <filename>/etc/make.conf</filename> 裡的
            "MAKE_KERBEROS" 選項全都拿掉，然後再 build world.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="add-pty">
          <para>我該怎麼增加系統的虛擬終端機？</para>
        </question>

        <answer>
          <para>如果你有許多 telnet，ssh，X 或是 screen 使用者，你或許會用完
            虛擬終端機，這能教你怎麼加更多：</para>

            <procedure>
              <step>
                <para>建立並安裝一個新的 kernel 並且把這一行</para>

                <programlisting>pseudo-device pty 256</programlisting>

                <para>加入到設定檔裡。</para>
              </step>

              <step>
                <para>執行這個命令：</para>

                <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV pty{1,2,3,4,5,6,7}</userinput></screen>

                <para>會造出 256 個虛擬終端機的裝置節點。</para>

              </step>

              <step>
                <para>編輯 <filename>/etc/ttys</filename> 並加入符合 256
                  個終端機的行數。它們應該符合已經存在單項的格式，舉例來說，
                  它們看起來像：</para>

                <programlisting>ttyqc none network</programlisting>

                <para>字母設計的順序是
                  <literal>tty[pqrsPQRS][0-9a-v]</literal>，使用正規表示式。
                </para>
              </step>

              <step>
                <para>用新的 kernel 重新啟動電腦就可以了。</para>
              </step>
            </procedure>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="create-snd0">
          <para>/dev/snd0 這個裝置做不出來！</para>
        </question>

        <answer>
          <para>並沒 <devicename>snd</devicename> 這個裝置的存在。這個名字
            是用來當作各個組成 FreeBSD 聲音驅動程式組，諸如
            <devicename>mixer</devicename>，
	    <devicename>sequencer</devicename>，以及
            <devicename>dsp</devicename> 的簡稱。</para>

          <para>可以用以下的命令作出這些裝置：</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="reread-rc">
          <para>可以不用開機，重新讀取 <filename>/etc/rc.conf</filename>、
            再次啟動 <filename>/etc/rc</filename> 嗎?</para>
        </question>

        <answer>
          <para>先進入單人使用者模式，然後再回到多使用者模式。</para>

          <para>在主控台執行：</para>

          <screen>&prompt.root; <userinput>shutdown now</userinput>
(Note: without -r or -h)

&prompt.root; <userinput>return</userinput>
&prompt.root; <userinput>exit</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="release-candidate">
          <para>我想要把我的系統昇級到最新的 -STABLE，但是得到的是 -RC 或
            -PRERELEASE！怎麼了？</para>
        </question>

        <answer>
          <para>簡單地說：那只是名字而已。RC 的意思是 <quote>Release Candiate，
            發行候選版本</quote>，它表示新版本快要發行了。在 FreeBSD 中，
            -PRERELEASE 通常是發行前的程式碼凍結的代名詞。(有些發行版本中，
            -BETA 標籤跟 -PRERELEASE 是相同意思的。)</para>

          <para>詳細地說：FreeBSD 從兩個地方分支出它的發行版本。主版號、
            點零、release (例如 3.0-RELEASE 及 4.0-RELEASE) 的，是從發展過程
            開始時分支出來的，通常稱為 <link linkend="current">-CURRENT
            </link>。有副版號的版本 (例如 3.1-RELEASE 或 4.2-RELEASE)，是
            活躍的 <link linkend="stable">-STABLE</link> 分支中的發行版本
            快照。從 4.3-RELEASE 開始，每一個發行版本有它自己的分支，可為
            偏好極度保守的發展速度 (通常只會作安全方面的更新) 的人所用。</para>

          <para>準備要製作發行版本時，其所在的分支會經過一定的程序。有一個是
            程式碼凍結。當程式碼凍結開始時，分支名稱會更名，以反映它快要成為
            一個發行版本了。舉個例子，如果原來的分支叫 4.5-STABLE，它的名字
            會變成 4.6-PRERELEASE 以表示程式碼已凍結，並且額外的發行前測試
            將要開始了。臭蟲更正仍可回報，以成為發行版本的一部份。當程式碼
            有了可成為發行版本的雛形時，它的名字就會變成 4.6-RC，以表示發行
            版本快好了。進入 RC 階段後，只有找到的最有影響的臭蟲才會被修正。
            當發行版本 (本例中為 4.6-RELEASE) 產生後，發行版本會有自己的分支，
            原分支會被更名為 4.6-STABLE。</para>

          <para>想要得知更多有關版本號碼與各 CVS 分支的資訊，請參考
            <ulink url="../../articles/releng/article.html">Release
            Engineering</ulink> 一文。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="kernel-chflag-failure">
          <para>我試著要安裝一個新的核心，但是無法 chflags。我該怎麼解決？
          </para>
        </question>

        <answer>
          <para>簡單地說：你的 securelevel 可能大於零。直接重新開機到
            單人模式，再安裝核心。</para>

          <para>詳細地說：FreeBSD 在 securelevel 大於零情況下，不允許
            變更系統旗標 (system flags)。你可以用這個指令檢查你的
            securelevel：</para>

          <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

           <para>你沒有辦法降低 securelevel；你必須啟動系統到單人模式以
            安裝核心，或是修改 <filename>/etc/rc.conf</filename> 內的
            securelevel 再重新開機。請參考 &man.init.8; 說明文件，以取得
            更多有關 securelevel 的資訊，還有 <filename>/etc/defaults/rc.conf
            </filename> 和 &man.rc.conf.5; 說明文件，以取得更多有關 rc.conf
            的資訊。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="kernel-securelevel-time">
          <para>在我的系統上，我無法變更時間超過一秒以上的範圍！
            我該怎麼辦？</para>
        </question>

        <answer>
          <para>簡單地講：你系統的 securelevel 也許大於 1。直接重新開機至
            單人模式，然後再修改時間。</para>

          <para>詳細地說：在 securelevel 大於 1 的情況下，FreeBSD 不允許時間
            變動大於一秒。你可以用以下的命令來檢查目前的 securelevel：</para>

          <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

           <para>你無法降低 securelevel；你必須啟動電腦至單人模式下以修改時間，
             或是修改 <filename>/etc/rc.conf</filename> 再重新開機。請參考
             &man.init.8; 說明文件，以取得更多有關 securelevel 的資訊，還有
             <filename>/etc/defaults/rc.conf</filename> 和 &man.rc.conf.5;
             說明文件，以取得更多有關 rc.conf 的資訊。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="statd-mem-leak">
          <para>為什麼 <command>rpc.statd</command> 用了 256 megabytes
            的記憶體？</para>
        </question>

        <answer>
          <para>不，那不是 memory leak，而且它也不是真的用了 256 Mbyte
            的記憶體。它只是喜歡 (意思就是總會這樣作) 將一狗票的記憶體
            映謝到它自己的位址空間，以方便作事。就技術而言，這樣並沒有
            什麼不對；這樣只是會讓 &man.top.1; 和 &man.ps.1; 嚇一大跳而已。
          </para>

          <para>&man.rpc.statd.8; 會將它的狀態檔案 (位於 <filename>/var
            </filename>) 映射至它的位址空間裡；為了防止需要的時候再增大所
            導致的重新映射，它一次會使用相當大的大小。從程式碼來看的話就
            更明顯了，可以看到 &man.mmap.2; 的長度參數為 <literal>0x10000000
            </literal>，它是 IA32 架構上的十六分之一的定址空間，也就是
            256MB。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="unsetting-schg">
          <para>為什麼我沒辦法取消 <literal>schg</literal> 檔案旗標？</para>
        </question>

        <answer>
          <para>你正在一個提高了 securelevel (也就是大於 0) 的系統運作。
            降低 securelevel 再試試看。請參考 <link linkend="securelevel">
            FAQ 中對 securelevel 的說明</link> 和 &man.init.8; 說明文件。
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ssh-shosts">
	  <para>為什麼近來的新版 FreeBSD 預設無法利用 <filename>.shosts
            </filename> 完成 SSH 認證？</para>
	</question>

	<answer>
	  <para>為什麼近來新版 FreeBSD <filename>.shosts</filename> 認證預設
            為取消的原因，是因為 &man.ssh.1; 預設不安裝為 suid 成 <username>
            root</username>。要 <quote>修正</quote> 這點，你可以作下列的
            任何一件事：</para>

	  <itemizedlist>
	    <listitem>
	      <para>要一勞永逸解決，請將 <filename>/etc/make.conf</filename>
                裡的 <makevar>ENABLE_SUID_SSH</makevar> 設成 <literal>true
                </literal>，然後再重新 build ssh (或是執行 <command>make
                world</command>)。</para>
	    </listitem>

	    <listitem>
	      <para>只作一時的修正的話，可以 <username>root</username> 身份
                執行 <command>chmod 4755 /usr/bin/ssh</command> 將
                <filename>/usr/bin/ssh</filename> 設成 <literal>4555
                </literal>。然後將 <makevar>ENABLE_SUID_SSH= true</makevar>
                加入 <filename>/etc/make.conf</filename> 裡，這樣下次
                <command>make world</command> 執行就會生效了。</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="vnlru">
          <para>什麼是 <literal>vnlru</literal>?</para>
        </question>

        <answer>
          <para>當系統達到上限 <varname>kern.maxvnodes</varname> 時，
            <literal>vnlru</literal> 會清除並釋放 vnode。這個核心
            執行緒大部份的時間都沒事作，只有當你有很大的記憶體，而且
            正在存取上萬個小檔案時，才會被啟動。</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="x">
    <chapterinfo>
      <author>
	<firstname>Wei-Hon</firstname>
	<surname>Chen</surname>
	<affiliation>
	  <address><email>plasmaball@pchome.com.tw</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>X Window System 及 Virtual Consoles</title>

    <qandaset>
      <qandaentry>
        <question id="running-X">
          <para>我想要執行 X ，我該怎麼做？</para>
        </question>

        <answer>

          <para>最簡單的方法就是在安裝系統的時候一併安裝。</para>

          <para>然後看看 &man.xorgconfig.1; 的文件，這個程式可以
            幫您設定 &xorg; 相關設定，使它能夠正確運用您的顯示卡、滑鼠等週邊。此外，還可以用 &man.xorgcfg.1;
            的圖形介面來做相關設定。</para>

          <para>您或許也想試試看 Xaccel server。詳情請看 <link linkend="xig">Xi Graphics</link>
            這一段。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="running-X-securelevels">
          <para>我 <emphasis>試著</emphasis> 要執行 X, 但是當我鍵入
            <command>startx</command> 時，得到
            <errorname>KDENABIO failed (Operation not permitted)</errorname>
            錯誤。我該怎麼辦？</para>
        </question>

        <answer>
          <para>你的系統一定提高了 securelevel，對不對？在一個提高了
            securelevel 的系統上，是絕對無法起動 X 的。想知道為什麼，
            請參考 &man.init.8; 說明文件。</para>

          <para>所以這個問題變成：你還能怎麼辦。基本上你有兩種選擇：
            將你的 securelevel 設回零 (通常在 <filename>/etc/rc.conf
            </filename> 裡面設定)，或是在啟動時執行 &man.xdm.1; (在
            securelevel 被昇高前)。</para>

          <para>請參考 <xref linkend="xdm-boot"/> 以取得更多有關啟動時
            執行 &man.xdm.1; 的資訊。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="x-and-moused">
          <para>為什麼我不能在 X 裡使用滑鼠？</para>
        </question>

        <answer>
          <para>如果您用的是 syscons (內定的 console 驅動程式) 的話，您可以
            經由設定 FreeBSD 來讓它支援在每個 virtual console 使用滑鼠。為了
            避免和 X 產生衝突，syscons 使用了一個叫做
            <devicename>/dev/sysmouse</devicename> 的虛擬裝置。所有滑鼠產生的
            event 都會利用 moused 來寫到 sysmouse 這個裝置。如果您希望在一個
            或以上的 virtual console 上使用滑鼠，<emphasis>並且</emphasis>
            能夠使用 X 的話，請參考
            <xref linkend="moused" remap="another section"/> 並且設定好
            moused。</para>

          <para>然後編輯 <filename>/etc/XF86Config</filename> 這個檔案，
            並且確認你有以下這幾行的設定。</para>

          <programlisting>Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
....</programlisting>

          <para>以上的例子，適用於 XFree86 3.3.2 及其後的版本。用於更早的
            版本的，其 <emphasis>Protocol</emphasis> 應為
            <emphasis>MouseSystems</emphasis>。</para>

          <para>有些人比較喜歡在設定 X 的時候用
            <devicename>/dev/mouse</devicename> 這個裝置。如果您要讓它能夠
            正常工作的話，您就必須把 <devicename>/dev/mouse</devicename>
            連結到 <devicename>/dev/sysmouse</devicename> (請參考
            &man.sysmouse.4;):</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>rm -f mouse</userinput>
&prompt.root; <userinput>ln -s sysmouse mouse</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="x-and-wheel">
          <para>滑鼠的滾輪，能在 X 裡面使用嗎？</para>
        </question>

        <answer>
          <para>可以。不過需要設定 X client 端程式。 請參考 <ulink
            url="http://www.inria.fr/koala/colas/mouse-wheel-scroll/">
            Colas Nahaboo 的網頁
            (http://www.inria.fr/koala/colas/mouse-wheel-scroll/)
            </ulink>.</para>

          <para>如果你要使用 <application>imwheel</application> 程式，
            只要跟著下列步驟作即可。</para>

          <orderedlist>
            <listitem>
              <para>轉換滾輪 event
Translate the Wheel Events</para>

              <para><application>imwheel</application> 程式的運作原理，
                是將滑鼠的第四鍵與第五鍵轉換成按鍵 event。因為如此，所以
                你必須讓滑鼠驅動程式將滑輪事件轉換成第四鍵與第五鍵 event。
                有兩種方法可以達到目的，一是讓 &man.moused.8; 作轉換，二是
                讓 X 本身去作 event 轉換。</para>

              <orderedlist>
                <listitem>
                  <para>使用 &man.moused.8; 來轉換滾輪 Event</para>

                  <para>要讓 &man.moused.8; 來作 event 轉換，只要在
                    執行 &man.moused.8; 的命令列中加上 <option>-z 4</option>
                    即可。舉個例子，如果你一般都是以
                    <command>moused -p /dev/psm0</command> 來起動
                    &man.moused.8; 的話，只要改成 <command>moused -p
                    /dev/psm0 -z 4</command> 即可。如果你是在開機過程中利用
                    <filename>/etc/rc.conf</filename> 來起動 &man.moused.8;，
                    你可以在 <filename>/etc/rc.conf</filename> 中將
                    <varname>moused_flags</varname> 上加 <option>-z 4
                    </option> 即可。</para>

                  <para>你現在需要讓 X 知道你的滑鼠有五個按鍵，只要在
                    <filename>/etc/XF86Config</filename> 中的
                    <quote>Pointer</quote> 區塊中加上
                    <literal>Buttons 5</literal> 這一行即可。例如，
                    你可能在 <filename>/etc/XF86Config</filename> 中有
                    以下的 <quote>Pointer</quote> 區塊：</para>

                  <example>

                    <title>在 XFree86 3.3.x 系列的 XF86Config 設定檔的
                      <quote>Pointer</quote> 區塊中，以 moused 作轉換
                      的滾輪鼠的設定範例</title>

                    <programlisting>Section "Pointer"
   Protocol        "SysMouse"
   Device          "/dev/sysmouse"
   Buttons         5
EndSection</programlisting>
                  </example>

                  <example>
                    <title>在 XFree86 4.x 系列的 XF86Config 設定檔的
                      <quote>InputDevice</quote> 區塊中，以 X Server 作轉換
                      的滾輪鼠的設定範例</title>

                    <programlisting>Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/sysmouse"
   Option          "Buttons" "5"
EndSection</programlisting>
                  </example>

                  <example>
                    <title>在 <quote>.emacs</quote> 中，設定滾輪鼠的原生
                      頁面滾動支援範例</title>
                    <programlisting>;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</programlisting>
                  </example>

                </listitem>

                <listitem>
                  <para>利用你的 X Server 來作滾輪 Event 轉換</para>

                  <para>如果你沒有執行 &man.moused.8;，或是你不想利用
                    &man.moused.8; 去作滾輪 event 轉換，你可以改用
                    X server 來作這樣的 event 轉換。你得在 <filename>
                    /etc/XF86Config</filename> 檔案中作幾個更動。第一，
                    你要為你的滑鼠選擇適當的通訊協定。大多數的滾輪鼠都
                    使用 <quote>IntelliMouse</quote> 協定，不過 XFree86
                    也支援其它的通訊協定，例如羅技的 MouseMan+ 滑鼠所用的
                    <quote>MouseManPlusPS/2</quote>。當你選好之後，只要
                    加進一行 <quote>Pointer</quote> 區塊的 <varname>
                    Protocol</varname> 變數即可。</para>

                  <para>第二，你要告訴 X server 將捲動事件重新對映至滑鼠的
                    第四和第五鍵。這可以利用 <varname>ZAxisMapping</varname>
                    選項辦到。</para>

                  <para>舉個例子，如果你沒有使用 &man.moused.8;，而你有一個
                    IntelliMouse 安裝在 PS/2 滑鼠埠的話，你可以在
                    <filename>/etc/XF86Config</filename> 裡使用以下的設定。
                  </para>

                  <example>
                    <title>在 XF86Config 設定檔的 <quote>Pointer</quote>
                      區塊中，以 X Server 作轉換的滾輪鼠的設定範例</title>

                    <programlisting>Section "Pointer"
   Protocol        "IntelliMouse"
   Device          "/dev/psm0"
   ZAxisMapping    4 5
EndSection</programlisting>
                  </example>

                  <example>
                    <title>在 XFree86 4.x 系列的 XF86Config 設定檔的
                      <quote>InputDevice</quote> 區塊中，以 X Server 作轉換
                      的滾輪鼠的設定範例</title>

                    <programlisting>Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/psm0"
   Option          "ZAxisMapping" "4 5"
EndSection</programlisting>
                  </example>

                  <example>
                    <title>在 <quote>.emacs</quote> 中，設定滾輪鼠的原生
                      頁面滾動支援範例</title>
                    <programlisting>;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</programlisting>
                  </example>

                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>安裝 <application>imwheel</application></para>

              <para>接下來，從 Ports 裡安裝 <application>imwheel
                </application>。在 x11 類別裡可以找到它，它可以將
                滾輪 event 對映到鍵盤 event。舉個例子，它可以在你
                將滾輪往前推時，送出一個 <keycap>Page Up</keycap>
                到你的應用程式去。<application>Imwheel</application>
                利用一個設定檔，以便對應滾輪 event 至鍵盤 event，這樣
                它就可以在不同的應用程式中，送出不同的鍵盤按鍵。預設的
                <application>imwheel</application> 設定檔是在
                <filename>/usr/X11R6/etc/imwheelrc</filename>，如果你想
                編輯自訂的設定檔的話，可以將它複製到
                <filename>~/.imwheelrc</filename>，然後依你的需要修改它。
                設定檔的格式在 &man.imwheel.1; 裡面有詳細的說明。</para>
            </listitem>

            <listitem>
              <para>設定 <application>Emacs</application> 與
                <application>Imwheel</application> 協同工作
                (<emphasis>選擇性</emphasis>)</para>

              <para>如果你使用 <application>emacs</application> 或是
                <application>Xemacs</application> 的話，那你需要在你的
                <filename>~/.emacs</filename> 檔案裡加上一小段設定。
                <application>emacs</application> 請加上這一段：</para>

              <example>
                <title><application>Imwheel</application> 的
                <application>Emacs</application> 設定</title>

                <programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</programlisting>
              </example>

              <para><application>Xemacs</application> 則在
                <filename>~/.emacs</filename> 檔裡加上這一段：</para>

              <example>
                <title><application>Imwheel</application> 的
                <application>Xemacs</application> 設定</title>

                <programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>執行 <application>Imwheel</application></para>

              <para>安裝之後，你可以直接在 xterm 裡鍵入 <command>imwheel
                </command> 命令以起動它。它會以背景執行，並且馬上發揮效用。
                如果你確定要直接使用 <application>imwheel</application>，
                只要把它加進你自己的 <filename>.xinitrc</filename> 或
                <filename>.xsession</filename> 內檔案即可。你可以不管
                <application>imwheel</application> 所送出來有關 PID 檔案
                警告。那些警告只對 Linux 版的 <application>imwheel
                </application> 有效而已。</para>
            </listitem>
          </orderedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="window-menu-weird">
          <para>為什麼 X Window 的選單和對話框不能正常運作？</para>
        </question>

        <answer>
          <para>把 Num Lock 關掉試試。</para>

          <para>如果您的 Num Lock 在開機時的預設值是開著的話，您必須把下列
            這行放到 <filename>XF86Config</filename> 設定檔中的
            <literal>Keyboard</literal> 部份。</para>

          <programlisting># Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
    ServerNumLock</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="virtual-console">
          <para>什麼是 virtual console？我要怎麼做才能用多一點？</para>
        </question>

        <answer>
          <para>簡單來說，virtual console 就是可以讓您不必做太多複雜的設定
            如使用網路或執行 X ，而在同一臺機器上同時做好幾件事的方法。</para>

          <para>當啟動系統並顯示完所有開機訊息之後，您就會在螢幕上看到一個
             login 的提示符號。在這個時候您就可以輸入您的 login name 以及
             password ，然後就可以在第一個 virtual console 上開始工作了
             (或者開始玩！) 。</para>

          <para>在某些情況下，您可能會想要作其他的工作，例如說是看看您正在
            執行的程式的說明文件，或是當您在 FTP 傳輸的等待時間中看看您的
            郵件。您只需要按 Alt-F2 (按住 Alt 鍵不放，並按下 F2 鍵) ，然後
            您就會在第二個 <quote>virtual console</quote> 上看到一個 login
            提示符號！當您想要回到原來的工作時，請按 Alt-F1。</para>

          <para>FreeBSD 在安裝時的預設值是使用三個 virtual console
            (3.3-RELEASE 後為八個)，您可以用 Alt-F1，Alt-F2，以及 Alt-F3
            在它們之間做切換。</para>

          <para>如果您想要多一點 virtual console 的話，您只需要編輯
            <filename>/etc/ttys</filename> 這個檔 (請參考 &man.ttys.5;)，
            在 <quote>Virtual terminals</quote> 這個註解後面加入
            <devicename>ttyv4</devicename> 到 <devicename>ttyvc</devicename>
            的欄位：</para>

          <programlisting># Edit the existing entry for ttyv3 in /etc/ttys and change
# "off" to "on".
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</programlisting>

          <para>您想用幾個就設幾個。您設越多 virtual terminal ，它們就用掉
            越多系統資源；如果您只有不到 8MB 的記憶體的話，這影響就大了。
            您可能也會想把 <literal>secure</literal> 換成
            <literal>insecure</literal>。</para>

            <important>
              <para>如果您想要執行 X 的話，您 <emphasis>必須</emphasis>
                為它保留 (或關掉) 至少一個 virtual terminal 。這就是說，如果
                您想在按十二個 Alt 功能鍵時都有 login 提示符號，而且又在同一
                部電腦上也想執行 X 的話，那麼這真是太不幸了 - 您只能用十一個。
              </para>
            </important>

          <para>取消一個 console 最簡單的方法就是把它關掉。舉例來說，如果
            您像上面講的一樣設定了全部的 12 個 terminal 並且想要執行 X ，
            您必需把 virtual terminal 12 從：</para>

          <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  on  secure</programlisting>

          <para>設成：</para>

          <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>

          <para>如果您的鍵盤只有 10 個功能鍵的話，您就要改成這樣：</para>

<programlisting>ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>

          <para>(您也可以直接把這幾行砍掉。)</para>

          <para>一旦您改了 <filename>/etc/ttys</filename>，下一個步驟就是要
            確定您有足夠的 virtual terminal 裝置。最簡單的方法就是：</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vty12</userinput></screen>

          <para>再過來，想要啟動這些 virtual console 最簡單 (也是最乾淨)
            的做法就是重開機。然後，如果您不想重開機的話，您可以把 X Window
            關掉，然後用 <username>root</username> 的身份執行下列指令：</para>

          <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

          <para>當您執行這個命令前，您一定要完全把 X Window 關掉。如果
            您不這麼做的話，您的系統可能會在您執行 kill 命令後出現當掉或
            鎖死的情況。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="vty-from-x">
          <para>我要怎麼從 X 切換到 virtual console？</para>
        </question>

        <answer>
          <para>請用 <keycombo action="simul">
              <keycap>Ctrl</keycap>
              <keycap>Alt</keycap>
              <keycap>F<replaceable>n</replaceable></keycap>
            </keycombo> 以切回至 virtual console。
            <keycombo action="simul">
              <keycap>Ctrl</keycap>
              <keycap>Alt</keycap>
              <keycap>F1</keycap>
            </keycombo> 可以切回至第一個 virtual console。</para>

          <para>當你切回至文字 console 後，你就可以使用一般
            <keycombo action="simul">
              <keycap>Alt</keycap>
              <keycap>F<replaceable>n</replaceable></keycap>
            </keycombo> 按鍵組合，在各 console 之間切換。</para>

          <para>要回到 X 的話，你必須切回至執行 X 的 virtual console。
            如果你是從命令列裡起動 X 的話 (例如使用 <command>startx</command>
            指令)，那麼 X 會依附在下一個未使用的 virtual console，而不是它被
            起動的文字 console。如果你有八個使用中的 virtual terminal，那麼
            X 就會在第九個上執行，你就可以使用
            <keycombo action="simul">
              <keycap>Alt</keycap>
              <keycap>F9</keycap>
            </keycombo> 以返回至 X 中。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="xdm-boot">
          <para>我要怎麼做才能在開機時啟動 XDM？</para>
        </question><answer>

          <para>有兩種方法可以啟動 <ulink
            url="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">
            xdm</ulink>。一種方法是從 <filename>/etc/ttys</filename> 來啟動，
            可以參考 &man.ttys.5; 說明文件中的範例；另一種方法是在
            <filename>rc.local</filename> (請參考 &man.rc.8;) 執行 xdm，或是
            在 <filename>/usr/local/etc/rc.d</filename> 放一個
            <filename>X.sh</filename>。這兩種方法都是合法的，如果您試某一種
            方法無效的話，您可以試試另外一種。這兩種方法的結果是一樣的：X
            會顯示一個圖形化的 login: 提示。</para>

          <para>用 ttys 的方法的優點，在於指明了 X 在啟動時到底是用那個 vty，
            並且將 logout 時重新啟動 X server 的責任丟給 init。 rc.local
            的方法則是在當啟動 X 出了問題時，可以很輕鬆地把 xdm 殺掉來解決
            問題。</para>

          <para>如果是用 rc.local 的方法，在執行 <command>xdm</command>
            時您不能加任何參數（也就是跑成 daemon）。必須在 getty 執行後
            才能啟動 xdm，否則 getty 和 xdm 會互相衝突而鎖住 console。最好的
            方式是在 script 中加個 sleep，讓它暫停 10 秒鐘左右，接著才執行
             xdm。</para>

          <para>如果你是從 <filename>/etc/ttys</filename> 啟動
            <command>xdm</command>，<command>xdm</command> 與 &man.getty.8;
            仍有機會互相衝突。一個避免它的方法，就是在
            <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename> 檔案中加入
            <literal>vt</literal> 數字。</para>

          <programlisting>:0 local /usr/X11R6/bin/X vt4</programlisting>

          <para>上面的例子中，會指示 X server 在 <devicename>/dev/ttyv3
            </devicename> 中執行。請注意數字是差一的。X server 從一開始數
            vty，而 FreeBSD 核心則是從零開始數 vty 的。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="xconsole-failure">
          <para>為什麼當我執行 xconsole 時，發生了
            <errorname>Couldn't open console</errorname> 的錯誤？</para>
        </question>

        <answer>
          <para>如果你是用 <command>startx</command> 來啟動 <command>startx
            </command> 的話，<devicename>/dev/console</devicename> 的權限並
            <emphasis>不會</emphasis> 改變，結果就是 <command>xterm -C
            </command> 和 <command>xconsole</command> 這類的程式無法
            正常執行。</para>

          <para>這一切的問題，都是因為 console 的權限是採用系統預設值。
            在一個多使用者的系統裡，我們不希望每個使用者都可以直接寫入系統
            console 。如果使用者是從機器的 VTY 直接 login 的話，那麼
            &man.fbtab.5; 可以解決這類的問題。</para>

          <para>簡單地說，請確保 <filename>/etc/fbtab</filename> (請參考
            &man.fbtab.5;) 這個檔案中的這一行沒有被註解掉：</para>

          <programlisting>/dev/ttyv0 0600 /dev/console</programlisting>

          <para>這一行設定的存在可以確保從 <devicename>/dev/ttyv0</devicename>
            登入的使用者可以控制 console。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="xfree86-root">
          <para>以前我可以以一般使用者執行 XFree86，為什麼現在它說我一定要
            以 <username>root</username> 才能執行？</para>
        </question>

        <answer>
          <para>所有的 X server 都需要以 <username>root</username> 來執行，
            才能直接存取你的視訊硬體。舊版本的 XFree86 (&lt;= 3.3.6) 會自動
            將所附的 server 以利用 <username>root</username> 身份執行的方式
            安裝起來  (setuid 為 <username>root</username>)。由於 X server
            都是體積龐大又複雜的程式，顯而易見地，這是一個安全上的災難。
            因為這個原因，新版的 XFree86 就不將這些 server 以 setuid 為
            <username>root</username> 的方式安裝。</para>

          <para>很明顯地，我們完全無法接受將 X server 以
            <username>root</username> 的身份執行。起碼就安全上不是個好主意。
            有兩種方法可以以一般使用者的身份使用 X。第一是利用
            <command>xdm</command> 或是其它的 display manager (例如
            <command>kdm</command>)；第二是利用 <command>Xwrapper</command>。
          </para>

          <para><command>xdm</command> 是一個處理圖形界面登入的 daemon。
            它通常在開機時執行起來，而且負責對使用者作身份認證，以及起動
            使用者的工作環境；它可說是圖形環境下的 &man.getty.8; 與
            &man.login.1; 的對應程式。想得知更多有關 <command>xdm</command>
            的資訊，請參考 <ulink url="http://www.xfree86.org/support.html">
            XFree86 文件</ulink>，以及其 <link linkend="xdm-boot">FAQ
            項目</link>。</para>

          <para><command>Xwrapper</command> 是 X server 的包裝程式；它可以
            讓一般使用者可以手動起動 X server 的小工具，而還能維持一定的安全
            環境。它會檢查傳入的命令列參數，如果沒問題的話，就起動適當的
            X server。如果你因為某種理由而不想執行 display manager 的話，
            它是為你而設定的。如果你安裝了完整的 ports，你可以在
            <filename>/usr/ports/x11/wrapper</filename> 中找到它。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ps2-x">
          <para>我的 PS/2 滑鼠在 X 中有點不正常？</para>
        </question>

        <answer>
          <para>您的滑鼠和您的滑鼠驅動程式可能存在有不同步的現象。</para>

          <para>在 2.2.5 以及更早的系統裡，從 X 切到 virtual terminal 然後
            再切回來就可以使它們重新做同步的動作。如果這個問題常常發生的話，
            您可以在您的 kernel 設定檔中加入下面這個選項然後重新編譯：</para>

          <programlisting>options PSM_CHECKSYNC</programlisting>

          <para>如果您沒有建立 kernel 的經驗，請看
             <link linkend="make-kernel">自訂核心</link> 這一節。</para>

          <para>加上這個選項以後，滑鼠和滑鼠驅動程式間的同步問題應該就比較
            不會出現了。如果這個問題仍然存在的話，在移動滑鼠時按按滑鼠按鍵
            可以使滑鼠和滑鼠驅動程式重新做同步的動作。</para>

          <para>該注意的是這個選項並不是對每一個系統都有效，它可能會讓接在
             PS/2 滑鼠位置的 ALPS GlidePoint 裝置失去 <quote>tap</quote>
             這項功能。</para>

          <para>在 2.2.6 及其後的版本，同步的確認已經有了較好的解決辦法，
            而且這些都已經是 PS/2 滑鼠驅動程式的標準了。這個方法也可以在
            GlidePoint 上正常工作。 (因為確認的程式碼已經成為一個標準功能，
            所以在這些版本中我們不在提供 PSM_CHECKSYNC 的選項了。) 不過在
            極少數的案例中，這些驅動程式會誤報同步性錯誤，然後您就會看到
            這樣的核心訊息：</para>

          <programlisting>psmintr: out of sync (xxxx != yyyy)</programlisting>

          <para>然後您就會發現您的滑鼠不能正常運作了。</para>

          <para>如果您發生了這樣的狀況，您必須藉由把 PS/2 滑鼠驅動程式的 flag
            設成 0x100 來把同步確認的程式碼給取消掉。然後在開機提示符號時用
            <option>-c</option> 選項來進入 <emphasis>UserConfig</emphasis>：
          </para>

          <screen>boot: <userinput>-c</userinput></screen>

          <para>然後，在 <emphasis>UserConfig</emphasis> 命令列中鍵入：</para>

          <screen>UserConfig&gt; <userinput>flags psm0 0x100</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ps2-mousesystems">
          <para>我的 PS/2 滑鼠不能透過 MouseSystem 來運作？</para>
        </question>

        <answer>
          <para>有一些報告指出某些廠牌的 PS/2 滑鼠只能在
            <quote>高解析度</quote> 狀態下才能運作。如果不是的話，滑鼠游標
            會常常跑到螢幕的左上角去。</para>

          <para>非常不幸的，這個問題在 2.0.X 和 2.1.X 下是無解的。在 2.2
            到 2.2.5 版，您可以對 <filename>/sys/i386/isa/psm.c</filename>
            使用下列 patch 然後重建您的核心。如果您沒有建立 kernel 的經驗，
            請看 <link linkend="make-kernel">自訂核心</link> 這節。</para>

          <programlisting>@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
         log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
             unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);        /* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);                /* stream mode */</programlisting>

          <para>在 2.2.6 及以後的版本，在 PS/2 滑鼠驅動程式中設定 0x04 的
             flag 會把滑鼠設成高解析度模式。在開機提示符號時用
             <option>-c</option> 選項來進入 <emphasis>UserConfig</emphasis>：
          </para>

          <screen>boot: <userinput>-c</userinput></screen>

          <para>然後，在 <emphasis>UserConfig</emphasis> 的命令列中鍵入：
            </para>

          <screen>UserConfig&gt; <userinput>flags psm0 0x04</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>

          <para>前一節有提到另一個可能導致滑鼠問題的原因。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="imake-tmpl">
          <para>當我建立 X 程式時，<command>imake</command> 說它找不到
            <filename>Imake.tmpl</filename>。它在哪兒？</para>
        </question>

        <answer>

          <para><filename>Imake.tmpl</filename> 是 Imake 套件的一部份，Imake
            是標準的建立 X 程式的工具。 <filename>Imake.tmpl</filename>
            和其他數個 header file 一樣是建立 X 程式的必要檔案，您可以在
            X prog distribution 中找到它們。您可以用 sysinstall(&os; 5.2 之前版本則是 <command>/stand/sysinstall</command>)
             來安裝或是直接從 X distribution 中手動安裝。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="xfree86-version">
          <para>我在 build 一個 X 應用程式，它需要 XFree86 3.3.x，但是
            我已經安裝 XFree86 4.x 了。我該怎麼辦？</para>
        </question>

        <answer>
          <para>要告訴 port 在編譯程式時，使用 XFree86 4.x 函式庫，你可以
            在 <filename>/etc/make.conf</filename> 裡 (如果你沒有這個檔，
            請建立它) 加上下面這一行：</para>

	  <programlisting>XFREE86_VERSION=        4</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mouse-button-reverse">
          <para>我要怎麼做才能設定左撇子用的滑鼠？</para>
        </question>

        <answer>
          <para>在您的 <filename>.xinitrc</filename> 或是
            <filename>.xsession</filename> 中執行
            <literal>xmodmap -e "pointer = 3 2 1"</literal> 的指令。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="install-splash">
          <para>要如何安裝 splash 圖形顯示程式？那裡可以找得到呢？</para>
        </question>

        <answer>

          <para>就在發行 FreeBSD 3.1 之前，我們加進了在開機時顯示
            <quote>splash</quote> 圖形的新功能。目前用來顯示在螢幕上的檔案
            必須是 256 色的點矩陣圖形 (<filename>*.BMP</filename>) 或 ZSoft
            PCX(<filename>*.PCX</filename>) 的格式。除此之外，解析度也必須在
            320x200 以下，才能和標準 VGA 顯示卡搭配使用。如果您編譯 kernel
            時有加入 VESA 支援，那麼最大解析度可以到 1024x768。注意 VESA 的
            支援需要加入 <literal>VM86</literal> 這個 kernel 選項。VESA
            支援實際上可以在編譯 kernel 時加入 <literal>VESA</literal> 選項、
            或載入 VESA 的 kld module 來達成。</para>

          <para>您要修改控制 FreeBSD 開機步驟的設定檔，才能使用 splash
            顯示圖形的功能。設定檔在發行 FreeBSD 3.2 前有些更動，所以現在
            有兩個方法可以載入 splash 的功能：</para>

            <itemizedlist>
              <listitem>
                <para>FreeBSD 3.1</para>

                <para>先選出用來顯示在螢幕上的圖形，3.1 版只支援 Windows
                  的點矩陣格式。選好了您要的圖檔後，將它拷到 <filename>
                  /boot/splash.bmp</filename>。接著把下面幾行加入
                  <filename>/boot/loader.rc</filename> 中：</para>

                <programlisting>load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</programlisting>

              </listitem>

              <listitem>
                <para>FreeBSD 3.2+</para>

                <para>除了加入對 PCX 檔案的支援外，FreeBSD 3.2 也改進了
                  開機程序的設定方式。如果您願意的話，可以用上述 FreeBSD 3.1
                  的方法，將 <literal>splash_bmp</literal> 換成
                  <literal>splash_pcx</literal> 來載入 PCX 檔案即可。
                  如果想用新的設定方式，您的 <filename>/boot/loader.rc
                  </filename> 必須包括這幾行：</para>

                <programlisting>include /boot/loader.4th
start</programlisting>

                <para>還需要一個包含以下幾行的 <filename>/boot/loader.conf
                  </filename>：</para>

                <programlisting>splash_bmp_load="YES"
bitmap_load="YES"</programlisting>

                <para>這是假設您用 <filename>/boot/splash.bmp</filename>
                  來當作 splash 的螢幕顯示。如果想用 PCX 的檔案，把它拷成
                  <filename>/boot/splash.pcx</filename>，如上述做出
                  <filename>/boot/loader.rc</filename>，再將這幾行加到
                  <filename>/boot/loader.conf</filename> 中：</para>

                <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</programlisting>

              </listitem>
            </itemizedlist>

          <para>現在就只剩下 splash 用來顯示的圖檔，您可以在
            <ulink url="http://www.baldwin.cx/splash/">http://www.baldwin.cx/splash/</ulink> 找到各種樣品。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="windows-keys">
          <para>我能在 X 裡使用鍵盤上的 <trademark class="registered">Windows
            </trademark> 嗎？</para>
        </question>

        <answer>
          <para>可以。你所要作的，就是利用 &man.xmodmap.1; 去定義你想使用
            的功能。</para>

          <para>假設所有的 <quote><trademark class="registered">Windows</trademark></quote> 都是標準的，
            那它們的 keycode 分別為：</para>

          <itemizedlist>
            <listitem>
              <para>115 - <trademark class="registered">Windows</trademark> 鍵，
		在左手的 Ctrl 與 Alt 鍵之間</para>
            </listitem>

            <listitem>
              <para>116 - <trademark class="registered">Windows</trademark> 鍵，
		在 Alt-Gr 鍵右邊</para>
            </listitem>

            <listitem>
              <para>117 - 選單鍵，右手的 Ctrl 鍵左邊</para>
            </listitem>
          </itemizedlist>

          <para>要讓左邊的 <trademark class="registered">Windows</trademark>
            鍵印出一個逗點，試試這個：</para>

          <screen>&prompt.root; <userinput>xmodmap -e "keycode 115 = comma"</userinput></screen>

          <para>你可能要重跑你的 windows manager，才會有動作。</para>

          <para>要讓 <trademark class="registered">Windows</trademark> 鍵
            的對映在每次 X 起動時自動設定好，你可以在你的
            <filename>~/.xinitrc</filename> 裡加上 <command>xmodmap</command>，
            或是最好建立一個 <filename>~/.xmodmaprc</filename> 檔案，裡面
            每一行就是一個 <command>xmodmap</command> 的選項，然後在你的
            <filename>~/.xinitrc</filename> 裡加上：</para>


          <programlisting>xmodmap $HOME/.xmodmaprc</programlisting>

          <para>這一行。</para>

	  <para>例如，你想要將這三個鍵各對映到 F13、F14 和 F15。這讓你能
            在你的程式或是 window manager 內將其對應到便利的功能上，等一下
            我們會示範。</para>

          <para>把這些放進 <filename>~/.xmodmaprc</filename> 裡：</para>

          <programlisting>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</programlisting>

	  <para>假如你用 <command>fvwm2</command> 的話，你可以作這樣的對映，
            讓 F13 能夠讓游標所在的視窗縮成小圖示 (或是反過來)。F14 讓游標
            所在的視窗變成最上層的視窗，或是退到下層去 (如果它已經是最上層
            了的話)。F15 則將 Workplace (application) 選單叫出來，即使游標
            不在桌面上。當你沒有可見的桌面區域時，這個功能就相當地方便 (而且
            按鍵上的圖案和這個功能相吻合)。</para>

	  <para>以下的 <filename>~/.fvwmrc</filename> 設定可作出前述的功能。
          </para>

          <programlisting>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="x-3d-acceleration">
          <para>我要怎麼樣才能得到 OpenGL 的 3D 硬體加速功能？</para>
        </question>

        <answer>
          <para>3D 加速功能的有無，視你所使用的 XFree86 版本與顯示晶片
            的型號而定。如果你的是 NVIDIA 晶片的話，請去
            <ulink url="http://nvidia.netexplorer.org/">FreeBSD NVIDIA
            Driver Initiative </ulink> 網頁看看，那裡有在 XFree86-4 上使用
            NVIDIA 晶片的 3D 加速功能的討論。XFree86-4 上的其它顯示卡廠牌
            硬體加速功能的資訊， 包括 Matrox G200/G400, ATI Rage 128/Radeon,
            3dfx Voodoo 3, 4, 5, 以及 Banshee，可在 <ulink
            url="http://gladstone.uoregon.edu/~eanholt/dri/">XFree86-4
            Direct Rendering on FreeBSD</ulink> 網頁上找到。XFree 3.3 的
            使用者可以使用 Utah-GLX port，它可以在
            <filename role="package">graphics/utah-glx</filename> 找到。
            使用它可以在 Matrox Gx00, ATI Rage Pro, SiS 6326, i810,
            Savage, 以及舊的 NVIDIA 上得到有限的 OpenGL 加速。</para>
          </answer>
        </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="networking">
    <chapterinfo>
      <author>
	<firstname>Biing Jong</firstname>
	<surname>Lin</surname>
	<affiliation>
	  <address><email>bjlin@stic.gov.tw</email></address>
        </affiliation>
      </author>
    </chapterinfo>

    <title>Networking</title>

    <qandaset>
      <qandaentry>
        <question id="diskless-booting">
          <para>我應該到哪邊找有關無磁碟開機
	    <quote>diskless booting</quote> 的資料？</para>
          </question>

          <answer>
            <para><quote>Diskless booting</quote> 就是讓 FreeBSD 主機從網路
	      上開機，並且從網路上的 server 上讀取其他必要的檔案，而非由主機
	      的硬碟上取得這些檔案。詳細的資料可以參考 <ulink
	      url="../handbook/diskless.html"> FreeBSD 手冊的無磁碟開機篇
	      </ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="router">
          <para>FreeBSD 的主機可以當作某個網路上的路由器(router)嗎？</para>
        </question>

        <answer>
          <para>是的。請參考 FreeBSD 手冊的網路進階篇 <ulink
            url="../handbook/routing.html"> advanced
            networking</ulink>，尤其是路由與閘道器 <ulink
            url="../handbook/routing.html#DEDICATED-ROUTER">routing
            and gateways</ulink>的部分。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="win95-connection">
          <para>我可以透過 FreeBSD 將我的 Win95 機器連上 Internet 嗎？</para>
        </question>

        <answer>
          <para>基本上，會問這種問題的人在家裡至少有兩台電腦，一台跑 FreeBSD
            另外一台跑 Win95；這個想法是將 FreeBSD 主機連上 Internet，然後透
	    過這台 FreeBSD 主機，讓跑 Win95 的電腦能夠上網。這個問題算是前一
	    個問題的一個特例</para> <para>... 答案是：可以的！在 FreeBSD 3.x
	    版中，使用者模式(user-mode)的 &man.ppp.8; 包含了
	    <option>-nat</option> 選項。如果你在
	    <filename>/etc/rc.conf</filename> 使用<option>-nat</option>選項並
	    設定 <literal>gateway_enable</literal> 為 <emphasis>YES</emphasis>
	    ，以這種設定啟動 &man.ppp.8; ，並且正確的設定你的 Windows 主機的
	    話，這個做法應該是可以正常使用的。</para>

          <para>關於本主題更詳細的資料可以參考 Steve Sims 所撰寫的 <ulink
	    url="../ppp-primer/index.html"> Pedantic PPP Primer</ulink> 一文。
	    </para>

          <para>如果你使用的是核心模式 (kernel-mode) PPP，或者你有區域連線
	    (Ethernet connection) 可通達 Internet 的話，你將需要使用
	    &man.natd.8;。請查閱 FAQ 中關於 <link linkend="natd">natd</link>
	    的部分。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="slip-ppp-support">
          <para>FreeBSD 支援 SLIP 和 PPP 嗎？</para>
        </question>

        <answer>
          <para>是的。你可以查查 man pages 中關於 &man.slattach.8;，
            &man.sliplogin.8;，&man.ppp.8;，以及 &man.pppd.8; 的部分。
	    &man.ppp.8; 及 &man.pppd.8; 提供進出雙向連線的支援，另外
	    &man.sliplogin.8; 專門提供進入連線的支援，而 &man.slattach.8;
	    專門提供向外連線的支援。</para>

          <para>如果你需要更進一步的資料的話,請查閱 <ulink
	    url="../handbook/ppp-and-slip.html">FreeBSD 手冊中關於 PPP 與 SLIP
	    的說明</ulink>。</para>

          <para>如果你只能夠過 <quote>shell account</quote> 連線到 Internet
	    的話，你也許可以試試 <filename role="package">net/slirp</filename>
	    這個套件程式。這個套件程式可以提供你的電腦直接連上某些(限定的)服務
	    連線，如 ftp 及 http 等等。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="natd">
          <para>FreeBSD 支援 NAT 或 Masquerading 嗎？</para>
        </question>

        <answer>
          <para>如果你有一個近端的子網路(有一台以上的機器)，但是你的
	    Internet provider 卻只分配一個 IP number 給你(或者你只分配到一個
	    動態的 IP number)，你可以參考 &man.natd.8; 這個程式。 &man.natd.8;
	    讓你可以透過這一個 IP number 讓整個子網路的電腦都能連上 internet。
	    </para>

          <para>&man.ppp.8; 這個程式也提供類似的功能，如果你指定
	    <option>-nat</option> 選項。alias library (&man.libalias.3;)
	    在這兩個處理方式中都會被使用到。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="parallel-connect">
          <para>我如何將兩台 FreeBSD 主機用平行埠 (parallel line) 透過 PLIP
	    連線？</para>
        </question>

        <answer>
          <para>請參考手冊中關於 <ulink url="../handbook/plip.html">PLIP
            section</ulink> 的部分。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="create-dev-net">
          <para>我沒有辦法建立 <filename>/dev/ed0</filename> 這個 device，
	    為什麼？</para>
        </question>

        <answer>
          <para>因為不需要！在 Berkeley 網路架構中，只有 kernel 程式碼可以直
	    接存取網路界面卡。請參考 <filename>/etc/rc.network</filename> 這
	    個檔案和 manual pages 取得與其他不同網路程式。更進一步的資訊：如
	    果你覺得你完全搞混了的話，您應該找一本與其他 BSD 相關作業系統網路
	    管理有關書來參考；除了少數顯著的不同外，FreeBSD 的網路管理基本上和
	    SunOS 4.0 和 Ultrix 是一樣的。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ethernet-aliases">
          <para>我如何建立 Ethernet aliases？</para>
        </question>

	<answer>
	  <para>如果你的 alias 位址跟你目前網路介面的位址在同一個子網路下的
	    話，加入一個 <literal>netmask 0xffffffff</literal> 在你的
	    &man.ifconfig.8; command-line，範例如下：</para>
	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff</userinput></screen>
	  <para>不然的話，就如同加入一個新的網路位址一樣輸入你的網路位址與子
	    網路遮罩：</para>
	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="port-3c503">
          <para>我如何指定我的 3C503 使用其他不同的的 network port？</para>
        </question>

        <answer>
          <para>如果您想使用其他的 port，你必須在 &man.ifconfig.8; 的命令中
	    指定額外的參數。內定的 port 是 <literal>link0</literal>。要使用
	    AUI port 代替 BNC port 的話，改用 <literal>link2</literal>。這些
	    flags 應該改變ifconfig_* 的變數來指定， 你可以在
	    <filename>/etc/rc.conf</filename> 這個檔案裡面找到 (請參考
	    &man.rc.conf.5;)。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="nfs">
          <para>為什麼我在使用 FreeBSD 的 NFS 時出現問題？</para>
        </question>

        <answer>
          <para>我們用含蓄一點的說法，某些 PC 的網路卡比其他的好，這種狀況在
	    造成 NFS 這種對網路敏感的程式有時會出現問題。</para>

          <para>參考 <ulink url="../handbook/nfs.html">
	    the Handbook entry on NFS</ulink> 以獲得這個主題的更多資訊。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="nfs-linux">
          <para>為什麼我不能 NFS-mount Linux 的機器？</para>
        </question>

        <answer>
          <para>某些版本的 Linux NFS 程式碼只接受 privileged port 的
	    mount request；試用這行指令看看</para>

          <screen>&prompt.root; <userinput>mount -o -P linuxbox:/blah /mnt</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="nfs-sun">
          <para>為什麼我不能 NFS-mount Sun 的機器？</para>
        </question>

        <answer>
          <para>跑 SunOS 4.X 的 Sun 工作站只接受來自 privileged port 的
	    mount request；試用這行指令看看</para>

          <screen>&prompt.root; <userinput>mount -o -P sunbox:/blah /mnt</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="exports-errors">
          <para>為什麼 <command>mountd</command> 一直鬼叫說
            <errorname>can't change attributes</errorname> 而且我一直看到
            <errorname>bad exports list</errorname> 這個訊息在我的 FreeBSD NFS
            伺服器上？</para>
        </question>

        <answer>
          <para>這個問題最常發生的原因是在於不了解
	    <filename>/etc/exports</filename> 的正確格式。請詳讀
	    &man.exports.5; 以及手冊中關於 <ulink
            url="../handbook/nfs.html">NFS</ulink> 的部分，特別是<ulink
            url="../handbook/nfs.html#CONFIGURING-NFS">configuring
            NFS</ulink>這一段。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-nextstep">
          <para>為什麼我在使用 PPP 連線到 NeXTStep 機器時有問題？</para>
        </question>

        <answer>

          <para>把 TCP extensions 取消，這個設定在
	    <filename>/etc/rc.conf</filename> 裡面(參考 &man.rc.conf.5;) 把
	    以下這個值設成 NO：</para>

          <programlisting>tcp_extensions=NO</programlisting>

          <para>Xylogic 的 Annex 主機也有相同的問題，您要做相同的修改才能連
	    上這些主機。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ip-multicast">
          <para>我要怎樣才能把 IP multicast support 打開？</para>
        </question>

        <answer>
          <para>FreeBSD 2.0 以後的版本內定都有 支援 Multicast host 操作。如果
	    您想將您的主機設定成 multicast router 的話，您必須重新 compile 您
	    的 kernel，加入 <literal>MROUTING</literal> 的選項，並且執行
	    &man.mrouted.8; FreeBSD 2.2 及之後的版本會在開機時執行
	    &man.mrouted.8; 如果在 <filename>/etc/rc.conf</filename> 中
            <literal>mrouted_enable</literal> 設定為 <literal>"YES"</literal>
	    </para>

          <para>MBONE 的各種工具可以在他們 ports 下所屬叫做 <ulink
	    url="http://www.FreeBSD.org/ports/mbone.html">mbone</ulink> 目錄
	    中找到。如果您在找視訊會議的工具如 <command>vic</command> 以及
	    <command>vat</command>的話，到那邊找找吧！</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dec-pci-chipset">
          <para>哪些網路卡是使用 DEC PCI chipset？</para>
        </question><answer>

          <para>以下是 Glen Foster <email>gfoster@driver.nsta.org</email>
	    提供的清單：</para>

          <table>
            <title>Network cards based on the DEC PCI chipset</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Vendor</entry>
                  <entry>Model</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>ASUS</entry>
                  <entry>PCI-L101-TB</entry>
                </row>
                <row>
                  <entry>Accton</entry>
                  <entry>ENI1203</entry>
                </row>
                <row>
                  <entry>Cogent</entry>
                  <entry>EM960PCI</entry>
                </row>
                <row>
                  <entry>Compex</entry>
                  <entry>ENET32-PCI</entry>
                </row>
                <row>
                  <entry>D-Link</entry>
                  <entry>DE-530</entry>
                </row>
                <row>
                  <entry>Dayna</entry>
                  <entry>DP1203, DP2100</entry>
                </row>
                <row>
                  <entry>DEC</entry>
                  <entry>DE435, DE450</entry>
                </row>
                <row>
                  <entry>Danpex</entry>
                  <entry>EN-9400P3</entry>
                </row>
                <row>
                  <entry>JCIS</entry>
                  <entry>Condor JC1260</entry>
                </row>
                <row>
                  <entry>Linksys</entry>
                  <entry>EtherPCI</entry>
                </row>
                <row>
                  <entry>Mylex</entry>
                  <entry>LNP101</entry>
                </row>
                <row>
                  <entry>SMC</entry>
                  <entry>EtherPower 10/100 (Model 9332)</entry>
                </row>
                <row>
                  <entry>SMC</entry>
                  <entry>EtherPower (Model 8432)</entry>
                </row>
                <row>
                  <entry>TopWare</entry>
                  <entry>TE-3500P</entry>
                </row>
                <row>
                  <entry>Znyx (2.2.x)</entry>
                  <entry>ZX312, ZX314, ZX342, ZX345, ZX346, ZX348</entry>
                </row>
                <row>
                  <entry>Znyx (3.x)</entry>
                  <entry>ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442, ZX444,
                    ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="fqdn-hosts">
          <para>為什麼要用 FQDN 才能連到其他機器？</para>
        </question>

        <answer>
          <para>你也許會發現要連的機器其實是在另一個網域。舉個例子，假設你是在
	    foo.bar.edu 這個網域中，想要連到在一台叫 <hostid>mumble</hostid>
	    的主機，他在 <hostid role="domainname">example.org</hostid> 網域下，
	    你必須用 Fully-Qualified Domain Name <hostid
            role="fqdn">mumble.example.org</hostid>，而不是只用
            <hostid>mumble</hostid>。</para>

          <para>傳統的 BSD BIND resolver 允許用這種方式解出機器的位址，但是
	    FreeBSD 內附 <application>bind</application> (see &man.named.8;)
	    版本內定方式，則是除了你所在的網域以外，不支援其他非 FQDN 的縮寫。
	    所以如 <hostid>mumble</hostid> 必須在 <hostid
	    role="fqdn">mumble.foo.example.org</hostid>，否則就會從網域的最底
	    層開始找。</para>

          <para>這和先前的做法不同，也就是不用
            <hostid role="domainname">mumble.example.org</hostid>，和
            <hostid role="domainname">mumble.edu</hostid> 繼續搜尋。
            看一下 RFC 1535，裡面有提到為什麼之前的做法不好，甚至算是個安全
	    漏洞。</para>

          <para>這裡有個不錯的解法, 你可以加入一行</para>

          <programlisting>search foo.example.org example.org</programlisting>

          <para>instead of the previous</para>

          <programlisting>domain foo.example.org</programlisting>

          <para>在你的 <filename>/etc/resolv.conf</filename> 檔案中 (請參考
	    &man.resolv.conf.5;)。但是要確定搜尋順序不會違反 RFC 1535 所謂的
            <quote>boundary between local and public administration</quote>。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="network-permission-denied">
          <para>為什麼我在連線時一直出現
	    <errorname>Permission denied</errorname> 的錯誤訊息？</para>
        </question>

        <answer>
          <para> 如果在編譯 kernel 時加入 <literal>IPFIREWALL</literal> 選項，
            請注意 2.1.7R 內定是拒絕所有未經核准的網路封包(但在開發
	    2.1-STABLE 時改掉了)。</para>

          <para>I如果不小心弄錯了 firewall 的設定，你可以以
	    <username>root</username> 執行以下命令網路功能就會恢復正常：</para>

          <screen>&prompt.root; <userinput>ipfw add 65534 allow all from any to any</userinput></screen>

          <para>也可以在 <filename>/etc/rc.conf</filename> 加入
	    <literal>firewall_type="open"</literal> 的選項。</para>

          <para>如果想知道如何設定 FreeBSD firewall，請參考 <ulink
	    url="../handbook/firewalls.html">手冊中相關章節</ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ipfw-overhead">
          <para>IPFW 會造成多大的網路延遲？</para>
        </question>

        <answer>
          <para>請參考手冊中 <ulink
            url="../handbook/firewalls.html">Firewalls</ulink> 章節，特別是
	    <ulink url="../handbook/firewalls.html#IPFW-OVERHEAD">IPFW
            Overhead & Optimization</ulink> 這一段。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ipfw-fwd">
          <para>為什麼我的 <command>ipfw</command> <quote>fwd</quote>
	    redirect 規則將服務轉向其他機器時無法正常運作？</para>
        </question>

        <answer>
          <para>可能是你除了轉送封包以外還額外想進行位址轉譯
	    (network address translation, NAT)，<quote>fwd</quote> 規則所進
	    行的動作就如同字面所示；僅轉送封包，它並不會去修改封包中的資料。
            假設我們有如下的規則：</para>

          <screen>01000 fwd <replaceable>10.0.0.1</replaceable> from any to <replaceable>foo 21</replaceable></screen>

          <para>當一個通往特定目標位址 <replaceable>foo</replaceable> 的封包
	    送達主機時，根據這條規則，封包將被轉送至
	    <replaceable>10.0.0.1</replaceable>，但是它的目標位址卻仍然是
	    <replaceable>foo</replaceable>！封包的目標位址並
	    <emphasis>沒有</emphasis> 更改為
	    <replaceable>10.0.0.1</replaceable>。大部分的主機會將封包丟棄，
	    因為他們並不是這個目標位址。因此，使用 <quote>fwd</quote> 規則
	    時往往不如使用者所預期的那般順利。這種行為是系統特性，而非錯誤。
	    </para>

          <para>參考 <link linkend="service-redirect">關於服務轉向的常見問
	    答集</link>， &man.natd.8; 手冊，或者是使用 <ulink
	    url="../../../../ports/index.html">ports collection</ulink> 中許
	    多服務轉向的工具來正確的完成你想進行的工作。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="service-redirect">
          <para>要如何把對某台機器的網路服務要求(service request)轉向到另一台？
	    </para>
        </question>

        <answer>
          <para>在 ports 目錄的<quote>sysutils</quote>分類中有個叫
	    <literal>socket</literal> 的套件，可以幫你轉向 FTP 或其他類似的
	    網路服務。只要把該網路服務的命令改成呼叫 socket 即可，如下所示：
	    </para>

          <programlisting>ftp stream tcp nowait nobody /usr/local/bin/socket socket <replaceable>ftp.example.com</replaceable> <replaceable>ftp</replaceable></programlisting>

          <para>其中 <replaceable>ftp.example.com</replaceable> 與
            <replaceable>ftp</replaceable> 分別是被轉到的機器和 port 名稱。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bandwidth-mgr-tool">
          <para>那裡可以找到管理頻寬的工具？</para>
        </question>

        <answer>
          <para>FreeBSD 上有三套頻寬管理工具： &man.dummynet.4; 已經整合進入
	    FreeBSD 系統(更詳細的用途, &man.ipfw.4;); <ulink
	    url="http://www.csl.sony.co.jp/person/kjc/programs.html">ALTQ</ulink>
	    可以免費使用，<ulink
	    url="http://www.etinc.com/">Emerging Technologies</ulink>
	    推出的 Bandwidth Manager 則是商用軟體。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bpf-not-configured">
          <para>怎麼會跑出
	    <errorname>/dev/bpf0: device not configured</errorname>這個訊息？
	    </para>
        </question>

        <answer>
          <para>你執行了一個需要柏克萊封包過濾器 (Berkeley Packet Filter) 的
	    程式 (&man.bpf.4;)，但是你在 kernel 中沒有啟動它。把下面這一行加
	    入 kernel 設定檔中，編譯一個新的 kernel：</para>

          <programlisting>pseudo-device bpf        # Berkeley Packet Filter</programlisting>

          <para>在重新開機之後，還要做出 device node，在
	    <filename>/dev</filename> 下執行：</para>

          <screen>&prompt.root; <userinput>sh MAKEDEV bpf0</userinput></screen>

          <para>如果想要更進一步知道如何做出各種 device node，請參閱 <ulink
            url="../handbook/kernelconfig-nodes.html">Handbook 關於週邊節點的說明</ulink>
	    。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="mount-smb-share">
          <para>我要怎樣才能將 Windows 機器中的磁碟掛入系統, 就像 Linux 提供
	    的 smbmount 那樣？</para>
        </question>

        <answer>
          <para>使用 <application>SMBFS</application> 工具組。這套工具組中
            包含了一系列的 kernel 修改還有使用者的工具程式(userland programs)。
	    這些程式和資訊在 ports 收藏中
	    <filename role="package">net/smbfs</filename> 下可以找到。在
	    4.5-RELEASE 之後的版本則是系統中內建。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="icmp-response-bw-limit">
          <para>我在系統日誌中發現以下訊息：
	    <quote>icmp-response bandwidth limit 300/200 pps</quote>，這是
	    蝦米碗糕？</para>
        </question>

        <answer>
          <para>這是系統核心告訴你有某些活動引發它送出比它所認為應該送出更
	    多的 ICMP 或 TCP 重置訊息 (RST)。ICMP 回應訊息常常是因為有人嘗
	    試連接未被使用的 UDP 通訊埠。TCP 重置訊息則是有人嘗試連接未開
	    放 TCP 通訊埠造成的結果。以下這些活動可能就是造成這些訊息的原因：
	    </para>

          <itemizedlist>
            <listitem>
              <para>暴力法的服務組絕攻擊(DoS)方式
	        (相較於針對特殊弱點使用單一封包的攻擊方式)。</para>
            </listitem>

            <listitem>
              <para>大量的通訊埠掃描(相較於僅嘗試少數的常見服務通訊埠)。</para>
            </listitem>
          </itemizedlist>

          <para>出現的數字中第一個代表根據這些流量 kernel 應該送出的封包數，
            第二個數字則是 kernel 目前限制最大發送數。你可以利用 sysctl 修改
	    <varname>net.inet.icmp.icmplim</varname> 變數值來更改最大值。舉
	    例來說,如果希望修改限制為 <literal>300</literal> packets per
	    second：</para>

          <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim=300</userinput></screen>

          <para>如果你不想在系統紀錄中看到這些訊息，但是仍然希望保持回應的限
	    制的話，你可以利用 sysctl 修改
	    <varname>net.inet.icmp.icmplim_output</varname> 變數來取消這些訊
	    息：</para>

          <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim_output=0</userinput></screen>

          <para>最後，如果你想取消這些限制的話，你可以設定
	    <varname>net.inet.icmp.icmplim</varname> (如上例所示) 為
	    <literal>0</literal>。基於上述理由，我們不建議你取消這些限制。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="unknown-hw-addr-format">
          <para>這個錯誤訊息
	    <errorname>arp: unknown hardware address format</errorname>
	    是什麼意思？</para>
        </question>

        <answer>
          <para>這代表你的區域網路連線上有一些設備使用 FreeBSD 看不懂的 MAC
	    格式。這通常是代表有人在你的區域網路上進行實驗，最常見的就是
	    cable modem 的連線。這訊息無害，而且應該不至於影響到 FreeBSD 主
	    機的效能。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cvsup-missing-libs">
          <para>我剛剛裝好 CVSup 套件，但是在嘗試執行時發生了錯誤，要怎麼辦？
	    </para>
        </question>

        <answer>
          <para>首先，看看錯誤的訊息是否如下：</para>

          <programlisting>/usr/libexec/ld-elf.so.1: Shared object "libXaw.so.6" not found</programlisting>

          <para>這種錯誤訊息代表你主機上安裝的
	    <filename role="package">net/cvsup</filename> 沒有包含
	    <application>XFree86</application> 套件。如果你想要使用
	    <application>CVSup</application> 內建的圖形介面
	    <acronym>GUI</acronym> 的話，你需要安裝
	    <application>XFree86</application>。此外，如果你只想以命令列方
	    式使用 <application>CVSup</application> 的話，你應該先移除之前
	    安裝的套件。並安裝
	    <filename role="package">net/cvsup-without-gui</filename> 這套
	    軟體。在 FreeBSD 手冊中 <ulink
	    url="http://www.freebsd.org/handbook/cvsup.html">CVSup</ulink>
	    段落中有更詳細的說明。</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="security">
    <chapterinfo>
      <author>
	<firstname>Biing Jong</firstname>
	<surname>Lin</surname>
	<affiliation>
	  <address><email>bjlin@stic.gov.tw</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>系統安全篇</title>
    <qandaset>
      <qandaentry>
        <question id="sandbox">
          <para>什麼是 sandbox？</para>
        </question><answer>

          <para><quote>Sandbox</quote> 是系統安全用的術語，有兩個意義：</para>

            <itemizedlist>
              <listitem>

                <para>放在某些虛擬防護牆裡的執行程序，這些防護牆是用來阻止
                  某些人侵入這道程序，進而出入於更大的系統中。</para>

                <para>這道程序可以完全在防護牆裡 <quote>動作</quote>。也就
		  是說，它所執行的任何程式不可能會滲透到牆的外面。所以如果
		  您對它有安全上的顧慮，並不需要特別去監聽它的一舉一動，反
		  正它只能在牆內活動。</para>

                <para>舉例來說，可以用 userid 來做這道防護牆，這正是 security
                  和 named 說明文件中的定義。</para>

                <para>現在就用 <literal>ntalk</literal> 這個服務作說明（見
                  /etc/inetd.conf）。這個服務以前的 userid 是
                  <username>root</username>，現在執行時則是用
                  <username>tty</username>。<username>tty</username>
                  這個使用者就是一個 sandbox，如果有人能夠順利用 ntalk
                  侵入系統，現在他就算進得來也只能用這個 userid。</para>
              </listitem>

              <listitem>
                <para>放在某個模擬機器裡的程式，這比上述來得更嚴密。基本上
                  這表示能侵入該程式的人相信他能再進入所屬的機器，但事實上
                  只會進入模擬出來的機器，無法進一步修改任何真實的資料。</para>

                <para>達到這個目的最常用的方法，就是在某個子目錄下做出模擬的
                  環境，然後用 chroot 執行該程式，這樣該程式的根目錄便是這個
                  子目錄，而非系統真正的根目錄。</para>

                <para>另一個常見作法是將某個檔案系統 mount 成唯讀，但在它
                  上面另外製造出程式以為可以寫入的檔案系統。這個程式會相信
                  它可以對其他檔案讀寫，但只有它看不到這個唯讀效應 - 系統
                  執行的一般程式都看得到。</para>

                <para>我們試圖將這類 sandbox 盡量透明化，讓使用者或侵入者
                  無法看到他是否在某個 sandbox 裡面。</para>
              </listitem>
            </itemizedlist>

          <para>UNIX 實作兩種 sandbox，一個在程式層面，另一個則是由 userid
            來達成。</para>

          <para>每個 UNIX 執行程序會用防火牆將它和所有其他程序隔開，某個程序
            不可以隨意修改其他程序位址的資料。這和 Windows 中，程式可以輕易
            修改其他位址資料，結果導致當機的情形大不相同。</para>

          <para>每個 UNIX 程序都屬於某個特定的 userid。如果該 userid 不是
            <username>root</username>，就會將它和其他使用者的程序隔開。
            Userid 同時也用於硬碟資料的存取權上。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="securelevel">
          <para>什麼是 securelevel?</para>
        </question>

        <answer>
          <para>securelevel 是核心中所實作的一個安全機制。基本上當
            securelevel 是正值時，核心會限制某些工作；即使是 superuser
            (也就是 <username>root</username>) 也無法完成那些工作。在撰寫
            本文時，securelevel 機制在一般的限制外，還能夠限制以下的功能：
          </para>

          <itemizedlist>
            <listitem>
              <para>清除某些特定的檔案旗標，例如 <literal>schg</literal>
                (系統唯讀標旗, the system immutable flag)</para>
            </listitem>

            <listitem>
              <para>經由 <devicename>/dev/mem</devicename> 與
                <devicename>/dev/kmem</devicename>， 將資料寫入至核心記憶體中
              </para>
            </listitem>

            <listitem>
              <para>載入核心模組</para>
            </listitem>

            <listitem>
              <para>更動 &man.ipfirewall.4; 規則。</para>
            </listitem>
          </itemizedlist>

          <para>想要檢查在某個運作中的系統的 securelevel 狀態，只要執行以下
            命令即可：</para>

          <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

          <para>輸出的結果會包含一個 &man.sysctl.8; 變數名稱 (在這個例子中，
            它是 <varname>kern.securelevel</varname>) 以及一個數字。後者即是
            目前的 securelevel 值。如果它是一個正值 (也就是大於 0)，表示至少
            有一些 securelevel 的保護機制已經開啟了。</para>

          <para>你沒有辦法降低一個運作中的系統的 securelevel；如果可以的話，
            就失去了這個機制的意義了。如果你要作一些需要 securelevel 為
            非正值才可以的動作的話 (例如 <maketarget>installworld</maketarget>
            或更動日期)，你需要修改 <filename>/etc/rc.conf</filename> 內的
            securelevel 設定 (找找 <varname>kern_securelevel</varname> 和
            <varname>kern_securelevel_enable</varname> 變數)，然後重新開機。
          </para>

          <para>想要知道更多有關於 securelevel 與各個不同等級影響的細節，
            請參考 &man.init.8; 說明文件。</para>

            <warning>
              <para>securelevel 可不是萬靈丹；它有許多已知的缺陷，往往造成
                一種安全的假象。</para>

              <para>它一個最大的問題，就是要讓這個功能完全有效的話，在
                securelevel 發揮作用前的啟動過程中，所有使用到的檔案都
                必須被保護起來。如果一個攻擊者在 securelevel 有效前 (由於
                有些系統在啟動中所作的事情，無法在較高的 securelevel 中
                正常運作，所以這會在啟動過程中後期才會運作)，能讓他們的程式
                被執行的話，securelevel 的保護就完全無效了。保護啟動程序
                中所有的檔案在技術上是可行的，但是如果真的這樣作的話，系統
                維護將會變成一場夢魘。即使只是修改一個設定檔，也必須將整個
                系統關閉，至少也得到單人模式。</para>

              <para>除了這點，還有許多其它的東西都在通信論壇上討論，尤其是
	        freebsd-security。請到 <ulink
		url="../../../../search/index.html">這裡</ulink> 搜尋以前的
                討論。有些人希望 securelevel 能夠儘快消失，由另一個更優秀的
                機制取代，不過機會有點渺茫。</para>

              <para>風險自行承擔。</para>
            </warning>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="extra-named-port">
	  <para>BIND (<command>named</command>) 除了在通訊埠 53 以外也在
	    其他高編號通訊埠 (high-numbered port) 聆聽 (Listen)。
	    這是怎麼回事？</para>
	</question>

	<answer>
	  <para>FreeBSD 3.0 後的版本使用一個特殊的 BIND 版本，這個版本會使
	    用隨機的高編號通訊埠來回應外部的查詢。如果你因為要適合防火牆的
	    設定或是單純的想讓自己看來舒服一點而想用 53 通訊埠回應外部查詢，
	    那麼你可以嘗試更改以下檔案相關內容
	    <filename>/etc/namedb/named.conf</filename>：</para>

	  <programlisting>options {
        query-source address * port 53;
};</programlisting>

	  <para>你也可以將 <literal>*</literal> 更改為特定 IP address，
	    藉以加強控制條件。</para>

	  <para>順便恭喜你。能夠讀取你系統上的 &man.sockstat.1; 報告並且注意
	    不正常狀況是一件好事！</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="sendmail-port-587">
          <para>Sendmail 除了在標準的通訊埠 25 外也在通訊埠 587 聆聽！這是怎
	    麼回事？</para>
        </question>

        <answer>
          <para>較新版本的 Sendmail 支援 mail submission 這項功能，並且使
	    用通訊埠 587。這項功能還沒有被廣泛支援但是支援的數目正在增長
	    中。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="toor-account">
          <para>我發現了這個 UID 0 <username>toor</username> 帳號，這是什麼
	    碗糕？我被黑掉了嗎？</para>
        </question>

        <answer>
          <para>放心。<username>toor</username> 是一個
            <quote>alternative</quote> 管理者帳號 (toor 是 root 的轉向拼法)。
	    以往是跟隨 &man.bash.1; 安裝而建制的，後來則成為系統內定建制的一
	    個帳號。這個帳號將伴隨一個非標準的 shell 測試使用， 讓你不需要去
	    更改到 <username>root</username> 的內建 shell。因為這些其他的 shell
	    並沒有跟隨系統預設值安裝 (舉例來說，某些由 ports 安裝的
	    shell package)，而被內定安裝在 <filename>/usr/local/bin</filename>
	    目錄下，有可能存在不同的檔案系統中。 倘若 <username>root</username>
	    的 shell 被放在 <filename>/usr/local/bin</filename>，且
	    <filename>/usr</filename> (或是其他包含著
	    <filename>/usr/local/bin</filename> 這個子目錄的檔案系統)
            因為某些原因並沒有被正常的 mount 起來的話，<username>root</username>
            將無法正常的登入系統進行維修 (雖然說你重開機成單人模式就會問你要
	    載入哪個 shell)。</para>

          <para>有些人使用 <username>toor</username> 帳號進行每日的
            <username>root</username> 維護工作，如此可以使用非標準的
	    shell，而 <username>root</username> 可以保留標準 shell，
	    以因應單一使用者模式 (single user mode) 或緊急狀況處理。
	    依照系統內定值，你將無法使用 <username>toor</username> 登入，
	    因為這個帳號尚未更改密碼設定。因此你如果你想啟動這個帳號，你需要
	    使用 <username>root</username> 登入系統並且修改
	    <username>toor</username> 的密碼。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="suidperl">
          <para>為什麼 <command>suidperl</command> 無法正常運作？</para>
        </question>

        <answer>
          <para>因為某些安全的考，<command>suidperl</command> 內定的安裝
            並沒有設定 suid bit。系統管理者可以依照以下命令啟動 suid 設定。
	    </para>

	    <screen>&prompt.root; <userinput>chmod u+s /usr/bin/suidperl</userinput></screen>

          <para>如果你想要在由 source 升級時 <command>suidperl</command> 內定
	    啟動 suid 功能的話，編輯 <filename>/etc/make.conf</filename> 加入
            <varname>ENABLE_SUIDPERL=true</varname> 然後執行
            <command>make buildworld</command>。</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="ppp">
    <title>PPP</title>

    <qandaset>
      <qandaentry>
        <question id="userppp">
          <para>I cannot make &man.ppp.8; work.  What am I doing wrong?</para>
        </question>

        <answer>
          <para>You should first read the
            &man.ppp.8;
            man page and the <ulink
            url="../handbook/ppp-and-slip.html#USERPPP">
            PPP section of the handbook</ulink>.  Enable logging with
            the command</para>

          <programlisting>set log Phase Chat Connect Carrier lcp ipcp ccp command</programlisting>

          <para>This command may be typed at the
            &man.ppp.8; command prompt or it may be
            entered in the <filename>/etc/ppp/ppp.conf</filename>
            configuration file (the start of the
            <literal>default</literal> section is the best
            place to put it).  Make sure that
            <filename>/etc/syslog.conf</filename> (see &man.syslog.conf.5;) contains the lines</para>

          <programlisting>!ppp
*.*        /var/log/ppp.log</programlisting>

          <para>and that the file <filename>/var/log/ppp.log</filename>
            exists.  You can now find out a lot about what is going on
            from the log file.  Do not worry if it does not all make sense.
            If you need to get help from someone, it may make sense to
            them.</para>

          <para>If your version of &man.ppp.8; does not understand the
            <command>set log</command> command, you should download the
            <ulink url="http://people.FreeBSD.org/~brian/">
            latest version</ulink>. It will build on FreeBSD version
            2.1.5 and higher.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-hangs">
          <para>Why does &man.ppp.8; hang when I run it?</para>
        </question>

        <answer>
          <para>This is usually because your hostname will not resolve.
            The best way to fix this is to make sure that
            <filename>/etc/hosts</filename> is consulted by your
            resolver first by editing <filename>/etc/host.conf</filename>
            and putting the <literal>hosts</literal> line first.  Then,
            simply put an entry in <filename>/etc/hosts</filename> for
            your local machine.  If you have no local network, change your
            <hostid>localhost</hostid> line:</para>

          <programlisting>127.0.0.1        foo.bar.com foo localhost</programlisting>

          <para>Otherwise, simply add another entry for your host.
            Consult the relevant man pages for more details.</para>

          <para>You should be able to successfully
            <command>ping -c1 `hostname`</command> when you are done.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-nodial-auto">
          <para>Why will &man.ppp.8; not dial in <literal>-auto</literal>
            mode?</para>
        </question>

        <answer>
          <para>First, check that you have got a default route.  By running
            <command>netstat -rn</command> (see &man.netstat.1;), you should see two entries like this:</para>

          <programlisting>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</programlisting>

          <para>This is assuming that you have used the addresses from the
            handbook, the man page or from the ppp.conf.sample file.
            If you do not have a default route, it may be because you are
            running an old version of &man.ppp.8;
            that does not understand the word <literal>HISADDR</literal>
            in the ppp.conf file.  If your version of
            &man.ppp.8; is from before FreeBSD
            2.2.5, change the</para>

          <programlisting>add 0 0 HISADDR</programlisting>

          <para>line to one saying</para>


          <programlisting>add 0 0 10.0.0.2</programlisting>

          <para>Another reason for the default route line being missing
            is that you have mistakenly set up a default router in your
            <filename>/etc/rc.conf</filename> (see &man.rc.conf.5;) file (this file was called
            <filename>/etc/sysconfig</filename> prior to release 2.2.2),
            and you have omitted the line saying</para>

          <programlisting>delete ALL</programlisting>

          <para>from <filename>ppp.conf</filename>.  If this is the case,
            go back to the <ulink
            url="../handbook/ppp-and-slip.html#USERPPP-FINAL">
            Final system configuration</ulink> section of the
            handbook.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="no-route-to-host">
          <para>What does <errorname>No route to host</errorname> mean?</para>
        </question>

        <answer>
          <para>This error is usually due to a missing</para>

          <programlisting>MYADDR:
  delete ALL
  add 0 0 HISADDR</programlisting>

          <para>section in your <filename>/etc/ppp/ppp.linkup</filename>
            file.  This is only necessary if you have a dynamic IP address
            or do not know the address of your gateway.  If you are using
            interactive mode, you can type the following after entering
            <literal>packet mode</literal> (packet mode is
            indicated by the capitalized <acronym>PPP</acronym> in the
            prompt):</para>

         <programlisting>delete ALL
add 0 0 HISADDR</programlisting>

          <para>Refer to the <ulink
            url="../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP">
            PPP and Dynamic IP addresses</ulink> section of the handbook
            for further details.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="connection-threeminutedrop">
          <para>Why does my connection drop after about 3 minutes?</para>
        </question>

        <answer>
          <para>The default PPP timeout is 3 minutes.  This can be
            adjusted with the line</para>

          <programlisting>set timeout <replaceable>NNN</replaceable></programlisting>

          <para>where <replaceable>NNN</replaceable> is the number of
            seconds of inactivity before the connection is closed.  If
            <replaceable>NNN</replaceable> is zero, the connection is never
            closed due to a timeout. It is possible to put this command in
            the <filename>ppp.conf</filename> file, or to type it at the
            prompt in interactive mode. It is also possible to adjust it on
            the fly while the line is active by connecting to
            <application>ppp</application>s server socket using
            &man.telnet.1; or &man.pppctl.8;.
            Refer to the
            &man.ppp.8; man
            page for further details.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-drop-heavy-load">
          <para>Why does my connection drop under heavy load?</para>
        </question>

        <answer>
          <para>If you have Link Quality Reporting (LQR) configured,
            it is possible that too many LQR packets are lost between
            your machine and the peer.  Ppp deduces that the line must
            therefore be bad, and disconnects.  Prior to FreeBSD version
            2.2.5, LQR was enabled by default.  It is now disabled by
            default. LQR can be disabled with the line</para>

          <programlisting>disable lqr</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-drop-random">
          <para>Why does my connection drop after a random amount of
            time?</para>
        </question>

        <answer>
          <para>Sometimes, on a noisy phone line or even on a line with
            call waiting enabled, your modem may hang up because it
            thinks (incorrectly) that it lost carrier.</para>

          <para>There is a setting on most modems for determining how
            tolerant it should be to temporary losses of carrier.  On a
            USR Sportster for example, this is measured by the S10
            register in tenths of a second.  To make your modem more
            forgiving, you could add the following send-expect sequence
            to your dial string:</para>

          <programlisting>set dial "...... ATS10=10 OK ......"</programlisting>

          <para>Refer to your modem manual for details.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-hangs-random">
          <para>Why does my connection hang after a random amount of
            time?</para>
        </question><answer>

          <para>Many people experience hung connections with no apparent
            explanation.  The first thing to establish is which side of
            the link is hung.</para>

          <para>If you are using an external modem, you can simply try
            using &man.ping.8; to see if the
            <acronym>TD</acronym> light is flashing when you transmit data.
            If it flashes (and the <acronym>RD</acronym> light does not),
            the problem is with the remote end. If <acronym>TD</acronym>
            does not flash, the problem is local. With an internal modem,
            you will need to use the <literal>set server</literal> command in
            your <filename>ppp.conf</filename> file. When the hang occurs,
            connect to &man.ppp.8; using &man.pppctl.8;. If your network connection
            suddenly revives (PPP was revived due to the activity on the
            diagnostic socket) or if you cannot connect (assuming the
            <literal>set socket</literal> command succeeded at startup
            time), the problem is local. If you can connect and things are
            still hung, enable local async logging with <literal>set log
            local async</literal> and use &man.ping.8; from
            another window or terminal to make use of the link. The async
            logging will show you the data being transmitted and received
            on the link. If data is going out and not coming back, the
            problem is remote.</para>

          <para>Having established whether the problem is local or remote,
            you now have two possibilities:</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-remote-not-responding">
          <para>The remote end is not responding.  What can I do?</para>
        </question>

        <answer>
          <para>There is very little you can do about this.  Most ISPs
            will refuse to help if you are not running a Microsoft OS.
            You can <literal>enable lqr</literal> in your
            <filename>ppp.conf</filename> file, allowing &man.ppp.8; to detect
            the remote failure and hang up, but this detection is
            relatively slow and therefore not that useful.  You may want to
            avoid telling your ISP that you are running user-PPP...</para>

          <para>First, try disabling all local compression by adding the
            following to your configuration:</para>

          <programlisting>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</programlisting>

          <para>Then reconnect to ensure that this makes no difference.
            If things improve or if the problem is solved completely,
            determine which setting makes the difference through trial
            and error.  This will provide good ammunition when you contact
            your ISP (although it may make it apparent that you are not
            running a Microsoft product).</para>

          <para>Before contacting your ISP, enable async logging locally
            and wait until the connection hangs again.  This may use up
            quite a bit of disk space.  The last data read from the port
            may be of interest.  It is usually ascii data, and may even
            describe the problem
            (<quote>Memory fault, core dumped</quote>?).</para>

          <para>If your ISP is helpful, they should be able to enable
            logging on their end, then when the next link drop occurs,
            they may be able to tell you why their side is having a
            problem.  Feel free to send the details to &a.brian;, or
            even to ask your ISP to contact me directly.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-hung">
          <para>&man.ppp.8; has hung.  What can I do?</para>
        </question>

        <answer>
          <para>Your best bet here is to rebuild &man.ppp.8; by adding
            <literal>CFLAGS+=-g</literal> and <literal>STRIP=</literal>
            to the end of the Makefile, then doing a
            <command>make clean &amp;&amp; make &amp;&amp; make
            install</command>.  When &man.ppp.8; hangs, find the &man.ppp.8; process id
            with <command>ps ajxww | fgrep ppp</command> and run
            <command>gdb ppp <replaceable>PID</replaceable></command>.
            From the gdb prompt, you can then use <command>bt</command>
            to get a stack trace.</para>

          <para>Send the results to <email>brian@Awfulhak.org</email>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-loginok-thennothing">
          <para>Why does nothing happen after the <quote>Login OK!</quote>
            message?</para>
        </question>

        <answer>
          <para>Prior to FreeBSD version 2.2.5, once the link was
            established, &man.ppp.8;
            would wait for the peer to initiate the Line Control Protocol
            (LCP).  Many ISPs will not initiate negotiations and expect
            the client to do so.  To force
            &man.ppp.8; to initiate the LCP, use the
            following line:</para>

          <programlisting>set openmode active</programlisting>

            <note>
              <para>It usually does no
            harm if both sides initiate negotiation, so openmode is now
            active by default.  However, the next section explains when
            it <emphasis>does</emphasis> do some harm.</para>
            </note>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-same-magic">
          <para>I keep seeing errors about magic being the same.  What does
            it mean?</para>
        </question>

        <answer>
          <para>Occasionally, just after connecting, you may see messages
            in the log that say <quote>magic is the same</quote>.
            Sometimes, these messages are harmless, and sometimes one side
            or the other exits.  Most PPP implementations cannot survive
            this problem, and even if the link seems to come up, you will see
            repeated configure requests and configure acknowledgments in
            the log file until &man.ppp.8; eventually gives up and closes the
            connection.</para>

          <para>This normally happens on server machines with slow disks
            that are spawning a getty on the port, and executing &man.ppp.8; from
            a login script or program after login.  I have also heard reports
            of it happening consistently when using slirp.  The reason is
            that in the time taken between &man.getty.8; exiting and &man.ppp.8; starting,
            the client-side &man.ppp.8; starts sending Line Control Protocol (LCP)
            packets.  Because ECHO is still switched on for the port on
            the server, the client &man.ppp.8; sees these packets
            <quote>reflect</quote> back.</para>

          <para>One part of the LCP negotiation is to establish a magic
            number for each side of the link so that
            <quote>reflections</quote> can be detected. The protocol says
            that when the peer tries to negotiate the same magic number, a
            NAK should be sent and a new magic number should be chosen.
            During the period that the server port has ECHO turned on, the
            client &man.ppp.8; sends LCP packets, sees the same magic in the
            reflected packet and NAKs it. It also sees the NAK reflect
            (which also means &man.ppp.8; must change its magic). This produces a
            potentially enormous number of magic number changes, all of
            which are happily piling into the server's tty buffer. As soon
            as &man.ppp.8; starts on the server, it is flooded with magic number
            changes and almost immediately decides it has tried enough to
            negotiate LCP and gives up. Meanwhile, the client, who no
            longer sees the reflections, becomes happy just in time to see
            a hangup from the server.</para>

          <para>This can be avoided by allowing the peer to start
            negotiating with the following line in your ppp.conf
            file:</para>

          <programlisting>set openmode passive</programlisting>

          <para>This tells &man.ppp.8; to wait for the server to initiate LCP
            negotiations.  Some servers however may never initiate
            negotiations.  If this is the case, you can do something
            like:</para>

          <programlisting>set openmode active 3</programlisting>

          <para>This tells &man.ppp.8; to be passive for 3 seconds, and then to
            start sending LCP requests.  If the peer starts sending
            requests during this period, &man.ppp.8; will immediately respond
            rather than waiting for the full 3 second period.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-lcp-constant">
          <para>LCP negotiations continue until the connection is
            closed.  What is wrong?</para>
        </question>

        <answer>
          <para>There is currently an implementation mis-feature in
            &man.ppp.8; where it does not associate
            LCP, CCP &amp; IPCP responses with their original requests. As
            a result, if one PPP
            implementation is more than 6 seconds slower than the other
            side, the other side will send two additional LCP configuration
            requests. This is fatal.</para>

          <para>Consider two implementations,
            <hostid>A</hostid> and
            <hostid>B</hostid>. <hostid>A</hostid> starts
            sending LCP requests immediately after connecting and
            <hostid>B</hostid> takes 7 seconds to start. When
            <hostid>B</hostid> starts, <hostid>A</hostid>
            has sent 3 LCP REQs. We are assuming the line has ECHO switched
            off, otherwise we would see magic number problems as described in
            the previous section. <hostid>B</hostid> sends a
            REQ, then an ACK to the first of
            <hostid>A</hostid>'s REQs. This results in
            <hostid>A</hostid> entering the <acronym>OPENED</acronym>
            state and sending and ACK (the first) back to
            <hostid>B</hostid>. In the meantime,
            <hostid>B</hostid> sends back two more ACKs in response to
            the two additional REQs sent by <hostid>A</hostid>
            before <hostid>B</hostid> started up.
            <hostid>B</hostid> then receives the first ACK from
            <hostid>A</hostid> and enters the
            <acronym>OPENED</acronym> state.
            <hostid>A</hostid> receives the second ACK from
            <hostid>B</hostid> and goes back to the
            <acronym>REQ-SENT</acronym> state, sending another (forth) REQ
            as per the RFC. It then receives the third ACK and enters the
            <acronym>OPENED</acronym> state. In the meantime,
            <hostid>B</hostid> receives the forth REQ from
            <hostid>A</hostid>, resulting in it reverting to the
            <acronym>ACK-SENT</acronym> state and sending
            another (second) REQ and (forth) ACK as per the RFC.
            <hostid>A</hostid> gets the REQ, goes into
            <acronym>REQ-SENT</acronym> and sends another REQ. It
            immediately receives the following ACK and enters
            <acronym>OPENED</acronym>.</para>

          <para>This goes on until one side figures out that they are
            getting nowhere and gives up.</para>

          <para>The best way to avoid this is to configure one side to be
            <literal>passive</literal> - that is, make one side
            wait for the other to start negotiating.  This can be done
            with the</para>

          <programlisting>set openmode passive</programlisting>

          <para>command.  Care should be taken with this option.  You
            should also use the</para>

          <programlisting>set stopped N</programlisting>

          <para>command to limit the amount of time that
            &man.ppp.8; waits for the peer to begin
            negotiations.  Alternatively, the</para>

          <programlisting>set openmode active N</programlisting>

          <para>command (where <replaceable>N</replaceable> is the
            number of seconds to wait before starting negotiations) can be
            used.  Check the manual page for details.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-lockups">
          <para>Why does &man.ppp.8; lock up shortly after connection?</para>
        </question>

        <answer>
          <para>Prior to version 2.2.5 of FreeBSD, it was possible that
            your link was disabled shortly after connection due to
            &man.ppp.8; mis-handling Predictor1
            compression negotiation. This would only happen if both sides
            tried to negotiate different Compression Control Protocols
            (CCP). This problem is now corrected, but if you are still
            running an old version of &man.ppp.8;
            the problem can be circumvented with the line</para>

          <programlisting>disable pred1</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-shell-test-lockup">
          <para>Why does &man.ppp.8; lock up when I shell out to test it?</para>
        </question>

        <answer>
          <para>When you execute the <command>shell</command> or
            <command>!</command> command, &man.ppp.8; executes a
            shell (or if you have passed any arguments,
            &man.ppp.8; will execute those arguments). Ppp will
            wait for the command to complete before continuing. If you
            attempt to use the PPP link while running the command, the link
            will appear to have frozen. This is because
            &man.ppp.8; is waiting for the command to
            complete.</para>

          <para>If you wish to execute commands like this, use the
            <command>!bg</command> command instead.  This will execute
            the given command in the background, and &man.ppp.8; can continue to
            service the link.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-nullmodem">
          <para>Why does &man.ppp.8; over a null-modem cable never exit?</para>
        </question>

        <answer>
          <para>There is no way for &man.ppp.8; to
            automatically determine that a direct connection has been
            dropped.  This is due to the lines that are used in a
            null-modem serial cable.  When using this sort of connection,
            LQR should always be enabled with the line</para>

          <programlisting>enable lqr</programlisting>

          <para>LQR is accepted by default if negotiated by the peer.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-auto-noreasondial">
          <para>Why does &man.ppp.8; dial for no reason in -auto mode?</para>
        </question><answer>

          <para>If &man.ppp.8; is dialing
            unexpectedly, you must determine the cause, and set up Dial
            filters (dfilters) to prevent such dialing.</para>

          <para>To determine the cause, use the following line:</para>

          <programlisting>set log +tcp/ip</programlisting>

          <para>This will log all traffic through the connection.  The
            next time the line comes up unexpectedly, you will see the
            reason logged with a convenient timestamp next to it.</para>

          <para>You can now disable dialing under these circumstances.
            Usually, this sort of problem arises due to DNS lookups.  To
            prevent DNS lookups from establishing a connection (this will
            <emphasis>not</emphasis> prevent
            &man.ppp.8; from passing the packets
            through an established connection), use the following:</para>

          <programlisting>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</programlisting>

          <para>This is not always suitable, as it will effectively break
            your demand-dial capabilities - most programs will need a DNS
            lookup before doing any other network related things.</para>

          <para>In the DNS case, you should try to determine what is
            actually trying to resolve a host name.  A lot of the time,
            &man.sendmail.8; is the culprit.  You should make sure that
            you tell sendmail not to do any DNS lookups in its
            configuration file.  See the section on
            <link linkend="ispmail">Mail Configuration</link> for details
            on how to create your own configuration file and what should
            go into it.  You may also want to add the following line to
            your <filename>.mc</filename> file:</para>

          <programlisting>define(`confDELIVERY_MODE', `d')dnl</programlisting>

          <para>This will make sendmail queue everything until the queue
            is run (usually, sendmail is invoked with
            <option>-bd -q30m</option>, telling it to run the queue every
            30 minutes) or until a <command>sendmail -q</command> is done
            (perhaps from your ppp.linkup file).</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ccp-errors">
          <para>What do these CCP errors mean?</para>
        </question>

        <answer>
          <para>I keep seeing the following errors in my log file:</para>

          <programlisting>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</programlisting>

          <para>This is because &man.ppp.8; is trying to negotiate Predictor1
            compression, and the peer does not want to negotiate any
            compression at all.  The messages are harmless, but if you
            wish to remove them, you can disable Predictor1 compression
            locally too:</para>

          <programlisting>disable pred1</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-lockup-ioerrors">
          <para>Why does &man.ppp.8; lock up during file transfers with IO
            errors?</para>
        </question>

        <answer>
          <para>Under FreeBSD 2.2.2 and before, there was a bug in the
            tun driver that prevents incoming packets of a size larger
            than the tun interface's MTU size.  Receipt of a packet
            greater than the MTU size results in an IO error being logged
            via syslogd.</para>

          <para>The PPP specification says that an MRU of 1500 should
            <emphasis>always</emphasis> be accepted as a minimum,
            despite any LCP negotiations, therefore it is possible that
            should you decrease the MTU to less than 1500, your ISP will
            transmit packets of 1500 regardless, and you will tickle this
            non-feature - locking up your link.</para>

          <para>The problem can be circumvented by never setting an MTU of
            less than 1500 under FreeBSD 2.2.2 or before.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-connectionspeed">
          <para>Why does &man.ppp.8; not log my connection speed?</para>
        </question>

        <answer>

          <para>In order to log all lines of your modem
            <quote>conversation</quote>, you must enable the
            following:</para>

          <programlisting>set log +connect</programlisting>

          <para>This will make &man.ppp.8; log
            everything up until the last requested <quote>expect</quote>
            string.</para>

          <para>If you wish to see your connect speed and are using PAP
            or CHAP (and therefore do not have anything to
            <quote>chat</quote> after the CONNECT in the dial script - no
            <literal>set login</literal> script), you must make sure that
            you instruct &man.ppp.8; to <quote>expect</quote> the whole CONNECT
            line, something like this:</para>

          <programlisting>set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</programlisting>

          <para>Here, we get our CONNECT, send nothing, then expect a
            line-feed, forcing &man.ppp.8; to read
            the whole CONNECT response.</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-ignores-backslash">
          <para>Why does &man.ppp.8; ignore the <literal>\</literal> character
            in my chat script?</para>
        </question><answer>

          <para>Ppp parses each line in your config files so that it can
            interpret strings such as
            <literal>set phone "123 456 789"</literal> correctly (and
            realize that the number is actually only
            <emphasis>one</emphasis> argument. In order to specify a
            <literal>&quot;</literal> character, you must escape it
            using a backslash (<literal>\</literal>).</para>

          <para>When the chat interpreter parses each argument, it
            re-interprets the argument in order to find any special
            escape sequences such as <literal>\P</literal> or
            <literal>\T</literal> (see the man page).  As a result of this
            double-parsing, you must remember to use the correct number of
            escapes.</para>

          <para>If you wish to actually send a <literal>\</literal>
            character to (say) your modem, you would need something
            like:</para>

          <programlisting>set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</programlisting>

          <para>resulting in the following sequence:</para>

          <programlisting>ATZ
OK
AT\X
OK</programlisting>

          <para>or</para>

          <programlisting>set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"</programlisting>

          <para>resulting in the following sequence:</para>

          <programlisting>ATZ
OK
ATDT1234567</programlisting>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-segfault-nocore">
          <para>Why does &man.ppp.8; get a seg-fault, but I see no
            <filename>ppp.core</filename> file?</para>
        </question>

        <answer>
          <para>Ppp (or any other program for that matter) should never
            dump core.  Because &man.ppp.8; runs with an effective user id of 0,
            the operating system will not write &man.ppp.8;'s core image to disk
            before terminating it.  If, however &man.ppp.8;
            is actually terminating due to a
            segmentation violation or some other signal that normally
            causes core to be dumped, <emphasis>and</emphasis>
            you are sure you are using the latest version (see the start of
            this section), then you should do the following:</para>

          <screen>&prompt.user; <userinput>tar xfz ppp-*.src.tar.gz</userinput>
&prompt.user; <userinput>cd ppp*/ppp</userinput>
&prompt.user; <userinput>echo STRIP= &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>echo CFLAGS+=-g &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>make clean all</userinput>
&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>chmod 555 /usr/sbin/ppp</userinput></screen>

          <para>You will now have a debuggable version of &man.ppp.8; installed.
            You will have to be <username>root</username> to run &man.ppp.8; as all of its privileges
            have been revoked.  When you start &man.ppp.8;, take a careful note
            of what your current directory was at the time.</para>

          <para>Now, if and when &man.ppp.8; receives the segmentation violation,
            it will dump a core file called <filename>ppp.core</filename>.  You should then do
            the following:</para>

          <screen>&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>gdb /usr/sbin/ppp ppp.core</userinput>
<prompt>(gdb)</prompt> <userinput>bt</userinput>
.....
<prompt>(gdb)</prompt> <userinput>f 0</userinput>
....
<prompt>(gdb)</prompt> <userinput>i args</userinput>
....
<prompt>(gdb)</prompt> <userinput>l</userinput>
.....</screen>

          <para>All of this information should be given alongside your
            question, making it possible to diagnose the problem.</para>

          <para>If you are familiar with gdb, you may wish to find out some
            other bits and pieces such as what actually caused the dump and
            the addresses &amp; values of the relevant variables.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-autodialprocess-noconnect">
          <para>Why does the process that forces a dial in auto mode never
            connect?</para>
        </question>

        <answer>
          <para>This was a known problem with
            &man.ppp.8; set up to negotiate a
            dynamic local IP number with the peer in auto mode.  It is
            fixed in the latest version - search the man page for
            <literal>iface</literal>.</para>

          <para>The problem was that when that initial program calls
            &man.connect.2;, the IP number of the tun interface is assigned
            to the socket endpoint. The kernel creates the first outgoing
            packet and writes it to the tun device.
            &man.ppp.8; then reads the packet and
            establishes a connection. If, as a result of
            &man.ppp.8;'s dynamic IP assignment, the
            interface address is changed, the original socket endpoint will
            be invalid. Any subsequent packets sent to the peer will
            usually be dropped. Even if they are not, any responses will
            not route back to the originating machine as the IP number is
            no longer owned by that machine.</para>

          <para>There are several theoretical ways to approach this
            problem. It would be nicest if the peer would re-assign the
            same IP number if possible <literal>:-)</literal>
            The current version of &man.ppp.8; does
            this, but most other implementations do not.</para>

          <para>The easiest method from our side would be to never change
            the tun interface IP number, but instead to change all outgoing
            packets so that the source IP number is changed from the
            interface IP to the negotiated IP on the fly. This is
            essentially what the <literal>iface-alias</literal> option in
            the latest version of &man.ppp.8; is
            doing (with the help of
            &man.libalias.3; and &man.ppp.8;'s <option>-nat</option> switch) -
            it is maintaining all previous interface addresses and NATing
            them to the last negotiated address.</para>

          <para>Another alternative (and probably the most reliable) would
            be to implement a system call that changes all bound sockets
            from one IP to another.  &man.ppp.8; would
            use this call to modify the sockets of all existing programs
            when a new IP number is negotiated. The same system call could
            be used by dhcp clients when they are forced to re-bind() their
            sockets.</para>

          <para>Yet another possibility is to allow an interface to be
            brought up without an IP number. Outgoing packets would be
            given an IP number of 255.255.255.255 up until the first
            SIOCAIFADDR ioctl is done. This would result in fully binding
            the socket. It would be up to &man.ppp.8;
            to change the source IP number, but only if it is set to
            255.255.255.255, and only the IP number and IP checksum would
            need to change. This, however is a bit of a hack as the kernel
            would be sending bad packets to an improperly configured
            interface, on the assumption that some other mechanism is
            capable of fixing things retrospectively.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ppp-nat-games">
          <para>Why do most games not work with the -nat switch?</para>
        </question>

        <answer>
          <para>The reason games and the like do not work when libalias
            is in use is that the machine on the outside will try to open a
            connection or send (unsolicited) UDP packets to the machine on
            the inside. The NAT software does not know that it should send
            these packets to the interior machine.</para>

          <para>To make things work, make sure that the only thing
            running is the software that you are having problems with, then
            either run tcpdump on the tun interface of the gateway or
            enable &man.ppp.8; tcp/ip logging (<literal>set log +tcp/ip</literal>)
            on the gateway.</para>

          <para>When you start the offending software, you should see
            packets passing through the gateway machine. When something
            comes back from the outside, it will be dropped (that is the
            problem). Note the port number of these packets then shut down
            the offending software. Do this a few times to see if the port
            numbers are consistent. If they are, then the following line in
            the relevant section of <filename>/etc/ppp/ppp.conf</filename> will make the
            software functional:</para>

          <programlisting>nat port <replaceable>proto</replaceable> <replaceable>internalmachine</replaceable>:<replaceable>port</replaceable> <replaceable>port</replaceable></programlisting>

          <para>where <replaceable>proto</replaceable> is either
            <literal>tcp</literal> or <literal>udp</literal>,
            <replaceable>internalmachine</replaceable> is the machine that
            you want the packets to be sent to and
            <replaceable>port</replaceable> is the destination port number
            of the packets.</para>

          <para>You will not be able to use the software on other machines
            without changing the above command, and running the software
            on two internal machines at the same time is out of the question
            - after all, the outside world is seeing your entire internal
            network as being just a single machine.</para>

          <para>If the port numbers are not consistent, there are three
            more options:</para>

          <orderedlist>
            <listitem>
          <para>Submit support in
            libalias. Examples of <quote>special cases</quote> can be found
            in <filename>/usr/src/lib/libalias/alias_*.c</filename>
            (<filename>alias_ftp.c</filename> is a good prototype). This
            usually involves reading certain recognised outgoing packets,
            identifying the instruction that tells the outside machine to
            initiate a connection back to the internal machine on a
            specific (random) port and setting up a <quote>route</quote> in
            the alias table so that the subsequent packets know where to
            go.</para>

          <para>This is the most difficult solution, but it is the best
            and will make the software work with multiple machines.</para>
            </listitem>

            <listitem>
              <para>Use a proxy.  The
            application may support socks5 for example, or (as in the
            <quote>cvsup</quote> case) may have a <quote>passive</quote>
            option that avoids ever requesting that the peer open
            connections back to the local machine.</para>
            </listitem>

            <listitem>
          <para>Redirect everything to
            the internal machine using <literal>nat addr</literal>.  This
            is the sledge-hammer approach.</para>
            </listitem>
          </orderedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="useful-port-numbers">
          <para>Has anybody made a list of useful port numbers?</para>
        </question><answer>

          <para>Not yet, but this is intended to grow into such a list
            (if any interest is shown).  In each example,
            <replaceable>internal</replaceable> should be replaced with
            the IP number of the machine playing the game.</para>

          <itemizedlist>
            <listitem>
              <para><application>Asheron's Call</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>
                :65000 65000</literal></para>

              <para>Manually change the port number within the game to
                65000. If you have got a number of machines that you wish
                to play on assign a unique port number for each (i.e.
                65001, 65002, etc) and add a <literal>nat port</literal>
                line for each one.</para>
            </listitem>

            <listitem>
              <para><application>Half Life</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:27005
                27015</literal></para>
            </listitem>

            <listitem>
              <para><application>PCAnywhere 8.0</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:5632
                5632</literal></para>

              <para><literal>nat port tcp
                <replaceable>internal</replaceable>:5631
                5631</literal></para>
            </listitem>

            <listitem>
              <para><application>Quake</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:6112
                6112</literal></para>

              <para>Alternatively, you may want to take a look at <ulink
                url="http://www.battle.net/support/proxy/">
                www.battle.net</ulink> for Quake proxy support.</para>
            </listitem>

            <listitem>
              <para><application>Quake 2</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:27901
                27910</literal></para>
              <para><literal>nat port udp
                <replaceable>internal</replaceable>:60021
                60021</literal></para>
              <para><literal>nat port udp
                <replaceable>internal</replaceable>:60040
                60040</literal></para>
            </listitem>

            <listitem>
              <para><application>Red Alert</application></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:8675
                8675</literal></para>

              <para><literal>nat port udp
                <replaceable>internal</replaceable>:5009
                5009</literal></para>
            </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="fcs-errors">
          <para>What are FCS errors?</para>
        </question>

        <answer>
          <para>FCS stands for <literal>F</literal>rame
            <literal>C</literal>heck
            <literal>S</literal>equence.  Each PPP packet
            has a checksum attached to ensure that the data being
            received is the data being sent.  If the FCS of an incoming
            packet is incorrect, the packet is dropped and the HDLC FCS
            count is increased.  The HDLC error values can be displayed
            using the <literal>show hdlc</literal> command.</para>

          <para>If your link is bad (or if your serial driver is dropping
            packets), you will see the occasional FCS error.  This is not
            usually worth worrying about although it does slow down the
            compression protocols substantially.  If you have an external
            modem, make sure your cable is properly shielded from
            interference - this may eradicate the problem.</para>

          <para>If your link freezes as soon as you have connected and you
            see a large number of FCS errors, this may be because your link
            is not 8 bit clean. Make sure your modem is not using software
            flow control (XON/XOFF). If your datalink
            <emphasis>must</emphasis> use software flow control, use the
            command <literal>set accmap 0x000a0000</literal> to tell
            &man.ppp.8; to escape the <literal>^Q</literal> and
            <literal>^S</literal> characters.</para>

          <para>Another reason for seeing too many FCS errors may be that
            the remote end has stopped talking <acronym>PPP</acronym>. You
            may want to enable <literal>async</literal> logging at this
            point to determine if the incoming data is actually a login or
            shell prompt. If you have a shell prompt at the remote end,
            it is possible to terminate &man.ppp.8; without dropping the line by
            using the <literal>close lcp</literal> command (a following
            <literal>term</literal> command will reconnect you to the shell
            on the remote machine.</para>

          <para>If nothing in your log file indicates why the link might
            have been terminated, you should ask the remote administrator
            (your ISP?) why the session was terminated.</para>
        </answer>
      </qandaentry>

      <qandaentry id="PPPoEwithNAT">
        <question id="macos-win98-pppoe-freeze">
          <para>Why do MacOS and Windows 98 connections freeze when
            running PPPoE on the gateway?</para>
        </question>

        <answer>
          <para>Thanks to Michael Wozniak
            <email>mwozniak@netcom.ca</email> for figuring this out and
            Dan Flemming <email>danflemming@mac.com</email> for the Mac
            solution:</para>

          <para>This is due to what is called a <quote>Black Hole</quote>
            router.  MacOS and Windows 98 (and maybe other Microsoft OSs)
            send TCP packets with a requested segment size too big to fit
            into a PPPoE frame (MTU is 1500 by default for Ethernet)
            <emphasis>and</emphasis> have the <quote>do not
            fragment</quote> bit set (default of TCP) and the Telco router
            is not sending ICMP <quote>must fragment</quote> back to the
            www site you are trying to load.  (Alternatively, the router is
            sending the ICMP packet correctly, but the firewall at the www
            site is dropping it.)  When the www server is sending
            you frames that do not fit into the PPPoE pipe the Telco router
            drops them on the floor and your page does not load (some
            pages/graphics do as they are smaller than a MSS.) This seems
            to be the default of most Telco PPPoE configurations (if only
            they knew how to program a router... sigh...)</para>

          <para>One fix is to use regedit on your 95/98 boxes to add the
            following registry entry...</para>

          <programlisting>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</programlisting>

          <para>It should be a string with a value <quote>1436</quote>, as
            some ADSL routers are reported to be unable to deal with packets
            larger than this.  This registry key has been changed to
            <literal>Tcpip\Parameters\Interfaces\<replaceable>ID for adapter</replaceable>\MTU</literal>
            in Windows 2000 and becomes a DWORD.</para>

          <para>Refer to the Microsoft Knowledge Base documents <ulink
            url="http://support.microsoft.com/support/kb/articles/Q158/4/74.asp">Q158474
            - Windows TCPIP Registry Entries</ulink> and <ulink
            url="http://support.microsoft.com/support/kb/articles/Q120/6/42.asp">Q120642
            - TCPIP & NBT Configuration Parameters for Windows
            NT</ulink> for more information on changing Windows MTU to
            work with a NAT router.</para>

          <para>Another regedit possibility under Windows 2000 is to
            set the
            <literal>Tcpip\Parameters\Interfaces\<replaceable>ID for
            adapter</replaceable>\EnablePMTUBHDetect</literal> DWORD
            to 1 as mentioned in the Microsoft document 120642
            mentioned above.</para>

          <para>Unfortunately, MacOS does not provide an interface for
            changing TCP/IP settings. However, there is commercial software
            available, such as OTAdvancedTuner (OT for OpenTransport, the
            MacOS TCP/IP stack) by <ulink
            url="http://www.softworks.com/">Sustainable Softworks</ulink>,
            that will allow users to customize TCP/IP settings. MacOS NAT
            users should select <literal>ip_interface_MTU</literal> from
            the drop-down menu, enter <literal>1450</literal> instead of
            <literal>1500</literal> in the box, click the box next to
            <literal>Save as Auto Configure</literal>, and click
            <literal>Make Active</literal>.</para>

          <para>The latest version of &man.ppp.8;
            (2.3 or greater) has an <command>enable tcpmssfixup</command>
            command that will automatically adjust the MSS to an appropriate
            value.  This facility is enabled by default.  If you are stuck
            with an older version of &man.ppp.8;, you
            may want to look at the <application>tcpmssd</application>
            port.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="desperation">
          <para>None of this helps - I am desperate!  What can I do?</para>
        </question>

        <answer>
          <para>If all else fails, send as much information as you can,
            including your config files, how you are starting
            &man.ppp.8;, the relevant parts of your
            log file and the output of the <command>netstat -rn</command>
            command (before and after connecting) to the &a.questions; or
            the <ulink url="news:comp.unix.bsd.freebsd.misc">
            comp.unix.bsd.freebsd.misc</ulink> news group, and someone
            should point you in the right direction.</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="serial">
    <title>Serial Communications</title>

    <para>This section answers common questions about serial
      communications with FreeBSD.  PPP and SLIP are covered in the
      <xref linkend="networking" remap="Networking"/> section.</para>


    <qandaset>
      <qandaentry>
        <question id="found-serial">
          <para>How do I tell if FreeBSD found my serial ports?</para>
        </question>

        <answer>
          <para>As the FreeBSD kernel boots, it will probe for the serial
            ports in your system for which the kernel was configured.
            You can either watch your system closely for the messages it
            prints or run the command</para>

          <screen>&prompt.user; <userinput>dmesg | grep sio</userinput></screen>

          <para>after your system is up and running.</para>

          <para>Here is some example output from the above command:</para>

          <programlisting>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A</programlisting>

          <para>This shows two serial ports.  The first is on irq 4, is
            using port address <literal>0x3f8</literal>, and has a
            16550A-type UART chip.  The second uses the same kind of chip
            but is on irq 3 and is at port address <literal>0x2f8</literal>.
            Internal modem cards are treated just like serial ports---except
            that they always have a modem <quote>attached</quote> to the
            port.</para>

          <para>The <filename>GENERIC</filename> kernel includes support
            for two serial ports using the same irq and port address
            settings in the above example.  If these settings are not
            right for your system, or if you have added modem cards or have
            more serial ports than your kernel is configured for, just
            reconfigure your kernel.  See section
            <link linkend="make-kernel">about building a kernel</link> for
            more details.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="found-modem">
          <para>How do I tell if FreeBSD found my modem cards?</para>
        </question>

        <answer>
          <para>Refer to the answer to the previous question.</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-tty0X">
          <para>I just upgraded to 2.0.5 and my
            <devicename>tty0<replaceable>X</replaceable></devicename>
            are missing!  How do I solve this problem?</para>
        </question>

        <answer>
          <para>Do not worry, they have been merged with the
            <devicename>ttyd<replaceable>X</replaceable></devicename> devices. You will have to change
            any old configuration files you have, though.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="access-serial-ports">
          <para>How do I access the serial ports on FreeBSD?</para>
        </question>

        <answer>
          <para>The third serial port,
            <devicename>sio2</devicename>
            (see &man.sio.4;, known as COM3 in DOS), is on <devicename>/dev/cuaa2</devicename>
            for dial-out devices, and on <devicename>/dev/ttyd2</devicename>
            for dial-in devices.  What is the difference between these two
            classes of devices?</para>

          <para>You use <devicename>ttyd<replaceable>X</replaceable></devicename> for dial-ins.  When
            opening <devicename>/dev/ttyd<replaceable>X</replaceable></devicename> in blocking mode, a
            process will wait for the corresponding
            <devicename>cuaa<replaceable>X</replaceable></devicename> device to become inactive, and then
            wait for the carrier detect line to go active.  When you open
            the <devicename>cuaa<replaceable>X</replaceable></devicename> device, it makes sure the serial
            port is not already in use by the <devicename>ttyd<replaceable>X</replaceable></devicename>
            device. If the port is available, it <quote>steals</quote> it
            from the <devicename>ttyd<replaceable>X</replaceable></devicename> device. Also, the
            <devicename>cuaa<replaceable>X</replaceable></devicename> device does not care about carrier
            detect. With this scheme and an auto-answer modem, you can have
            remote users log in and you can still dial out with the same
            modem and the system will take care of all the
            conflicts.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="enable-multiport-serial">
          <para>How do I enable support for a multiport serial
            card?</para>
        </question>

        <answer>
          <para>Again, the section on kernel configuration provides
            information about configuring your kernel. For a multiport
            serial card, place an &man.sio.4; line
            for each serial port on the card in the kernel configuration
            file. But place the irq and vector specifiers on only one of
            the entries. All of the ports on the card should share one irq.
            For consistency, use the last serial port to specify the irq.
            Also, specify the <literal>COM_MULTIPORT</literal>
            option.</para>

          <para>The following example is for an AST 4-port serial card on
            irq 7:</para>

          <programlisting>options "COM_MULTIPORT"
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr</programlisting>

          <para>The flags indicate that the master port has minor number 7
            (<literal>0x700</literal>), diagnostics enabled during probe
            (<literal>0x080</literal>), and all the ports share an irq
            (<literal>0x001</literal>).</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="multiport-serial-share-irq">
          <para>Can FreeBSD handle multiport serial cards sharing
            irqs?</para>
        </question>

        <answer>
          <para>Not yet. You will have to use a different irq for each
            card.</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="default-serial-params">
          <para>Can I set the default serial parameters for a
            port?</para>
        </question>

        <answer>
          <para>The <devicename>ttyd<replaceable>X</replaceable></devicename> (or
            <devicename>cuaa<replaceable>X</replaceable></devicename>) device is the regular device
            you will want to open for your applications.  When a process
            opens the device, it will have a default set of terminal I/O
            settings. You can see these settings with the command</para>

          <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

          <para>When you change the settings to this device, the settings
            are in effect until the device is closed.  When it is reopened,
            it goes back to the default set.  To make changes to the
            default set, you can open and adjust the settings of the
            <quote>initial state</quote> device. For example, to turn on
            <acronym>CLOCAL</acronym> mode, 8 bits, and
            <acronym>XON/XOFF</acronym> flow control by default for
            ttyd5, do:</para>

          <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

          <para>A good place to do this is in
            <filename>/etc/rc.serial</filename>. Now, an application will
            have these settings by default when it opens
            <filename>ttyd5</filename>.  It can still change these settings
            to its liking, though.</para>

          <para>You can also prevent certain settings from being changed
            by an application by making adjustments to the
            <quote>lock state</quote> device.  For example, to lock the
            speed of <devicename>ttyd5</devicename> to 57600 bps, do</para>

          <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

          <para>Now, an application that opens <devicename>ttyd5</devicename>
            and tries to change the speed of the port will be stuck with
          57600 bps.</para>

          <para>Naturally, you should make the initial state and lock state
            devices writable only by <username>root</username>. The
            &man.MAKEDEV.8;
            script does <emphasis>NOT</emphasis> do this when it creates the
            device entries.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="enable-dialup">
          <para>How can I enable dialup logins on my modem?</para>
        </question>

        <answer>
          <para>So you want to become an Internet service provider, eh?
            First, you will need one or more modems that can auto-answer.
            Your modem will need to assert carrier-detect when it detects a
            carrier and not assert it all the time. It will need to hang up
            the phone and reset itself when the data terminal ready
            (<acronym>DTR</acronym>) line goes from on to off. It should
            probably use <filename>RTS/CTS</filename> flow control or no
            local flow control at all. Finally, it must use a constant
            speed between the computer and itself, but (to be nice to your
            callers) it should negotiate a speed between itself and the
            remote modem.</para>

          <para>For many Hayes command-set--compatible modems, this
            command will make these settings and store them in
            nonvolatile memory:</para>

          <programlisting>AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W</programlisting>

          <para>See the section <link linkend="direct-at">on sending AT
            commands</link> below for information on how to make these
            settings without resorting to an MS-DOS terminal program.</para>

          <para>Next, make an entry in
            <filename>/etc/ttys</filename> (see &man.ttys.5;) for the modem.  This file lists all the ports
            on which the operating system will await logins.  Add a line
            that looks something like this:</para>

          <programlisting>ttyd1 "/usr/libexec/getty std.57600" dialup on insecure</programlisting>

          <para>This line indicates that the second serial port
            (<devicename>/dev/ttyd1</devicename>) has a modem connected
            running at 57600 bps and no parity
            (<literal>std.57600</literal>, which comes from the file
            <filename>/etc/gettytab</filename>, see &man.gettytab.5;).
            The terminal type for this port is <literal>dialup</literal>.
            The port is <literal>on</literal> and is
            <literal>insecure</literal>---meaning <username>root</username>
	    logins on the port are not allowed. For dialin ports like this one,
	    use the <devicename>ttyd<replaceable>X</replaceable></devicename>
	    entry.</para>

          <para>It is common practice to use <literal>dialup</literal> as
            the terminal type. Many users set up in their <filename>.profile</filename> or
            <filename>.login</filename> files a prompt for the actual terminal type if the
            starting type is dialup. The example shows the port as
            insecure. To become <username>root</username> on this port, you
	    have to login as a regular user, then &man.su.1; to become
            <username>root</username>. If you use <literal>secure</literal>
            then <username>root</username> can login in directly.</para>

          <para>After making modifications to
            <filename>/etc/ttys</filename>, you need to send a hangup or
            <acronym>HUP</acronym> signal to the
            &man.init.8; process:</para>

          <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

          <para>This forces the &man.init.8; process to reread
            <filename>/etc/ttys</filename>.  The init process will then start getty
            processes on all <literal>on</literal> ports.  You can find
            out if logins are available for your port by typing</para>

          <screen>&prompt.user; <userinput>ps -ax | grep '[t]tyd1'</userinput></screen>

          <para>You should see something like:</para>

          <programlisting>747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dumb-terminal">
          <para>How can I connect a dumb terminal to my FreeBSD
            box?</para>
        </question>

        <answer>
          <para>If you are using another computer as a terminal into your
            FreeBSD system, get a null modem cable to go between the two
            serial ports.  If you are using an actual terminal, see its
            accompanying instructions.</para>

          <para>Then, modify
            <filename>/etc/ttys</filename> (see &man.ttys.5;), like above.  For example, if you are
            hooking up a WYSE-50 terminal to the fifth serial port,
            use an entry like this:</para>

          <programlisting>ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure</programlisting>

          <para>This example shows that the port on
            <devicename>/dev/ttyd4</devicename> has a wyse50 terminal
            connected at 38400 bps with no parity
            (<literal>std.38400</literal> from
            <filename>/etc/gettytab</filename>, see &man.gettytab.5;) and <username>root</username> logins are
            allowed (<literal>secure</literal>).</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cannot-tip">
          <para>Why can I not run <command>tip</command> or
            <command>cu</command>?</para>
        </question>

        <answer>
          <para>On your system, the programs &man.tip.1;
            and &man.cu.1;
            are probably executable only by
            <username>uucp</username>
            and group <groupname>dialer</groupname>.  You can use the group
            <groupname>dialer</groupname> to control who has access to your
            modem or remote systems.  Just add yourself to group
            dialer.</para>

          <para>Alternatively, you can let everyone on your system
            run &man.tip.1; and &man.cu.1; by
            typing:</para>

          <screen>&prompt.root; <userinput>chmod 4511 /usr/bin/cu</userinput>
&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="hayes-unsupported">
          <para>My stock Hayes modem is not supported---what
            can I do?</para>
        </question>

        <answer>
          <para>Actually, the man page for &man.tip.1; is
            out of date.  There is a generic Hayes dialer already built in.
            Just use <literal>at=hayes</literal> in your
            <filename>/etc/remote</filename> (see &man.remote.5;) file.</para>

          <para>The Hayes driver is not smart enough to recognize some of
            the advanced features of newer modems---messages like
            <literal>BUSY</literal>, <literal>NO DIALTONE</literal>, or
            <literal>CONNECT 115200</literal> will just confuse it. You
            should turn those messages off when you use &man.tip.1;
            (using <literal>ATX0&amp;W</literal>).</para>

          <para>Also, the dial timeout for &man.tip.1; is 60
            seconds.  Your modem should use something less, or else tip
            will think there is a communication problem.  Try
            <literal>ATS7=45&amp;W</literal>.</para>

          <para>Actually, as shipped &man.tip.1; does not yet
            support it fully. The solution is to edit the file
            <filename>tipconf.h</filename> in the directory
            <filename>/usr/src/usr.bin/tip/tip</filename>.  Obviously you
            need the source distribution to do this.</para>

          <para>Edit the line <literal>#define HAYES 0</literal>
            to <literal>#define HAYES 1</literal>. Then
            <command>make</command> and <command>make install</command>.
            Everything works nicely after that.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="direct-at">
          <para>How am I expected to enter these AT commands?</para>
        </question>

        <answer>
          <para>Make what is called a <quote>direct</quote> entry in your
            <filename>/etc/remote</filename> file (see &man.remote.5;).  For example, if your modem is hooked
            up to the first serial port, <devicename>/dev/cuaa0</devicename>,
            then put in the following line:</para>

          <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

          <para>Use the highest bps rate your modem supports in the br
            capability.  Then, type
            <command>tip <devicename>cuaa0</devicename></command> (see &man.tip.1;)
            and you will be connected to your modem.</para>

          <para>If there is no <devicename>/dev/cuaa0</devicename> on your
            system, do this:</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV cuaa0</userinput></screen>

          <para>Or use cu as <username>root</username> with the following command:</para>

          <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

          <para>with <replaceable>line</replaceable> being the serial port (e.g.
            <devicename>/dev/cuaa0</devicename>) and <replaceable>speed</replaceable> being the speed
            (e.g.<literal>57600</literal>).  When you are done entering
            the AT commands hit <literal>~.</literal> to exit.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="gt-failure">
          <para>Why does the <literal>&lt;@&gt;</literal> sign for the pn
            capability not work?</para></question><answer>

          <para>The <literal>&lt;@&gt;</literal> sign in the phone number
            capability tells tip to look in
            <filename>/etc/phones</filename> for a phone number.  But the
            <literal>&lt;@&gt;</literal> sign is also a special character
            in capability files like <filename>/etc/remote</filename>.
            Escape it with a backslash:</para>

          <programlisting>pn=\@</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dial-command-line">
          <para>How can I dial a phone number on the command
            line?</para>
        </question><answer>

          <para>Put what is called a <quote>generic</quote> entry in your
            <filename>/etc/remote</filename> file (see &man.remote.5;).  For example:</para>

          <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

          <para>Then you can do something like <command>tip -115200
            5551234</command>.  If you prefer &man.cu.1;
            over
            &man.tip.1;, use a generic cu entry:</para>

          <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

          <para>and type <command>cu 5551234 -s 115200</command>.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="set-bps">
          <para>Do I have to type in the bps rate every time I do
            that?</para>
        </question><answer>

          <para>Put in an entry for <literal>tip1200</literal> or
            <literal>cu1200</literal>, but go ahead and use whatever bps
            rate is appropriate with the br capability.
            &man.tip.1;
            thinks a good default is 1200 bps which is why it looks for
            a <literal>tip1200</literal> entry. You do not have to use 1200
            bps, though.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="terminal-server">
          <para>How can I more easily access a number of hosts through a
            terminal server?</para>
        </question>

        <answer>
          <para>Rather than waiting until you are connected and typing
            <literal>CONNECT <replaceable>host</replaceable></literal>
            each time, use tip's <literal>cm</literal> capability. For
            example, these entries in
            <filename>/etc/remote</filename> (see &man.remote.5;):</para>

          <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

          <para>will let you type <command>tip pain</command> or
            <command>tip muffin</command> to connect to the hosts
            <hostid>pain</hostid> or <hostid>muffin</hostid>; and
            <command>tip deep13</command> to get to the terminal
            server.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="tip-multiline">
          <para>Can tip try more than one line for each site?</para>
        </question>

        <answer>
          <para>This is often a problem where a university has several
            modem lines and several thousand students trying to use
            them...</para>

          <para>Make an entry for your university in
            <filename>/etc/remote</filename> (see &man.remote.5;) and use <literal>&lt;\@&gt;</literal> for
            the <literal>pn</literal> capability:</para>

          <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

          <para>Then, list the phone numbers for the university in
            <filename>/etc/phones</filename> (see &man.phones.5;):</para>

          <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

          <para>&man.tip.1;
            will try each one in the listed order, then give
            up.  If you want to keep retrying, run &man.tip.1;
            in a while loop.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="multi-controlp">
          <para>Why do I have to hit CTRL+P twice to send CTRL+P
            once?</para>
        </question>

        <answer>
          <para>CTRL+P is the default <quote>force</quote> character,
            used to tell &man.tip.1;
            that the next character is literal data.  You can set the
            force character to any other character with the
            <literal>~s</literal> escape, which means <quote>set a
            variable</quote>.</para>

          <para>Type <literal>~sforce=<replaceable>single-char
            </replaceable></literal> followed by a newline.
            <replaceable>single-char</replaceable> is any single character.
            If you leave out <replaceable>single-char</replaceable>,
            then the force character is the nul character, which you can
            get by typing CTRL+2 or CTRL+SPACE.  A pretty good value for
            <replaceable>single-char</replaceable> is SHIFT+CTRL+6, which
            I have seen only used on some terminal servers.</para>

          <para>You can have the force character be whatever you want by
            specifying the following in your
            <filename>$HOME/.tiprc</filename> file:</para>

          <programlisting>force=<replaceable>single-char</replaceable></programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="uppercase">
          <para>Why is everything I type suddenly in UPPER CASE?</para>
        </question>

        <answer>
          <para>You must have pressed CTRL+A, &man.tip.1;
            <quote>raise character</quote>, specially
            designed for people with broken caps-lock keys. Use
            <literal>~s</literal> as above and set the variable
            <quote>raisechar</quote> to something reasonable.  In fact,
            you can set it to the same as the force character, if you
            never expect to use either of these features.</para>

          <para>Here is a sample .tiprc file perfect for Emacs users who
            need to type CTRL+2 and CTRL+A a lot:</para>

          <programlisting>force=^^
raisechar=^^</programlisting>

<para>The ^^ is SHIFT+CTRL+6.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="tip-filetransfer">
          <para>How can I do file transfers with
            <command>tip</command>?</para>
        </question>

        <answer>
          <para>If you are talking to another Unix system, you can send
            and receive files with <literal>~p</literal> (put) and
            <literal>~t</literal> (take).  These commands run
            &man.cat.1; and
            &man.echo.1; on the remote system to accept and send files.
            The syntax is:</para>

          <programlisting>~p &lt;local-file&gt; [&lt;remote-file&gt;]
~t &lt;remote-file&gt; [&lt;local-file&gt;]</programlisting>

          <para>There is no error checking, so you probably should use
            another protocol, like zmodem.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="zmodem-tip">
          <para>How can I run zmodem with
            <application>tip</application>?</para>
        </question>

        <answer>
          <para>First, install one of the zmodem programs from the
            ports collection (such as one of the two from the comms
            category, <application>lrzsz</application> or
            <application>rzsz</application>.</para>

          <para>To receive files, start the sending program on the
            remote end.  Then, press enter and type
            <literal>~C rz</literal> (or <literal>~C lrz</literal> if you
            installed <application>lrzsz</application>) to begin
            receiving them locally.</para>

          <para>To send files, start the receiving program on the remote
            end.  Then, press enter and type
            <literal>~C sz <replaceable>files</replaceable></literal>
            (or <literal>~C lsz <replaceable>files</replaceable></literal>)
            to send them to the remote system.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="cannot-find-serial">
          <para>Why does FreeBSD not find my serial ports, even
            when the settings are correct?</para>
        </question>

        <answer>
          <para>Motherboards and cards with Acer UARTs do not probe
            properly under the FreeBSD sio probe.  Obtain a patch from
            <ulink url="http://www.lemis.com/serial-port-patch.html">
            www.lemis.com</ulink> to fix your problem.</para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="misc">
    <title>其它各式各樣的問題</title>

    <qandaset>
      <qandaentry>
        <question id="more-swap">
          <para>為甚麼 FreeBSD 用的置換(swap)空間比 Linux 多？</para>
        </question>

        <answer>
          <para>FreeBSD僅是看起來置換空間(swap)用的比Linux多而已。在事實上，
            並不然。主要的差異是在於，FreeBSD積極的將閒置無用的主記憶體內容
            推入置換空間(swap)中，以使得主記憶體可以更為有效率的被使用。而
            Linux的策略是將置換空間(swap)用來作為解決記憶體問題的最終手段。
            較頻繁的使用置換空間(swap)。是一種更有效率的使用主記憶體的手段。
	    </para>

          <para>註：當一方面FreeBSD積極的使用置換空間(swap)的同時，你必需注
            意到，FreeBSD並不會任意的將所有的東西都推入置換空間(swap)中。如此，
            你才不會在一夜宿醉起床後發現，整個系統都被倒進了置換空間(swap)之中。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="top-freemem">
          <para>即使我只有運行少數程式，為什麼 <command>top</command> 顯示出
	    來的剩餘記憶體還是很少？</para>
        </question>

        <answer>
          <para>簡單的答案是，所有未使用到的閒置記憶體都是被浪費的記憶體，
            任何未被你的程式所利用到的記憶體將被核心(kernel)用來當
            作磁碟快取(disk cache)。而這種記憶體被 &man.top.1; 標記為
            <literal>閒置的(Inact)</literal>，<literal>快取(Cache)</literal>，
            以及 <literal>緩衝區(Buf)</literal>，並負責在各個不同的位置負責
            暫存資料。被暫存(cached)的資料代表系統不需要去存取較慢的磁碟裝置
            就可以得到資料，如此，可以提升系統的效能。總而言之，&man.top.1;
            顯示出較少的 <literal>閒置(Free)</literal> 記憶體是好的，只要顯示
            出來的值不是 <literal>非常</literal> 的低。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="aout-elf">
          <para>為甚麼要用(甚麼是) a.out 和 ELF 執行檔格式？</para>
        </question>

        <answer>
          <para>要了解為什麼Freebsd使用 <filename>ELF</filename> 格式，你有必
	    要先認識一下三種在目前 Unix 系統中最被廣泛應用到的執行檔格式：
	    </para>

            <note>
              <para>在 FreeBSD 3.x 之前，FreeBSD 使用 a.out 格式。</para>
            </note>

            <itemizedlist>
              <listitem>
                <para>&man.a.out.5;</para>

                <para>這是最早，同是也是 <quote>最典型</quote> 的Unix目的檔
		  格式。這種格式的檔案使用一種短且緊密的檔頭，同時，伴隨著一
		  個魔術數字用來辨識格式。(參考 &man.a.out.5; 有更多詳細的說
		  明)。它包含有三個節區： .text .data 及 .bss 加上一個符號表
                  及字串表。</para>
              </listitem>

              <listitem>
                <para><acronym>COFF</acronym></para>

                <para>SVR3目的檔格式。檔頭包含了一個節區表，所以可以具備比
                      .text .data .bss 還多的節區。</para>
              </listitem>

              <listitem>
                <para><acronym>ELF</acronym></para>

                <para>ELF為 <acronym>COFF</acronym> 格式的後繼者，主要的特徵為
                  可以具有複數節區段，並可以使用32-bits或是64-bits的數值。
                  主要的缺點為： <acronym>ELF</acronym> 格式是在每個系統中只
                  會有一種 ABI 的假設為前題被設計出來的。但是，在事實上，這個
                  假設錯的離譜。因為，縱使在商用的 SYSV 世界裡，也至少有 SVR4，
                  Solaris 和 SCO 三種 ABI。</para>

                <para>譯註：ABI(Application Binary Interface)。如果一定要翻譯，
                 就叫它 <emphasis>應用程式二進位介面</emphasis> 好了。 ABI被發
		 展出來的用意，是為了促使在相同CPU所發展出來的應用程式，能夠
		 在不同的系統上，作到二元檔(Binary Code)相容。比方說，
                 <acronym>Sun</acronym> 所提出的 <acronym>Solaris ABI</acronym>
		 ，保證執行檔能夠在相同 CPU 的 Solaris 系統上執行，另一個例子是
                 Windows 系統。同屬於 Intel x86 版本的執行檔能夠自由的在Windows
                 9x/me及Windows NT/2k/XP之間執行。</para>

                <para>FreeBSD提供一個公用程式將程式所需的ABI資訊烙上，藉此試著
		  去解決這個問題。請參考 &man.brandelf.1; 以取得更多資訊。i
		  </para>
              </listitem>
            </itemizedlist>

          <para>FreeBSD 來自 <quote>傳統</quote> 的陣營。在傳統上，FreeBSD都
	    使用 &man.a.out.5; 格式，這樣的技術在好幾代的 BSD 都被證明是可靠的。
            雖然，在FreeBSD上可以建立以及正確的執行原生 <acronym>ELF</acronym>
            格式檔案(包含核心)。然而, FreeBSD在一開始反對將預設格式轉換為 ELF，
            為什麼呢？當Linux開始痛苦的轉換至 <acronym>ELF</acronym> 格式時，
            並非是為了要逃離 <filename>a.out</filename> 格式。相反的，這是因
	    為之前 Linux的共享函式庫(shared libraries)採用以跳躍表格
	    (jump-table)為基礎的技術去設計。這是一種讓發展者感到困擾，且非常
	    難以使用，不具足夠彈性的方法。既然，已經存在的
	    <acronym>ELF</acronym> 工具提供了共享函式庫(shared libraries)的解
	    決方案，而且，那看起來是個 <quote>前衛的方法</quote>，因此，所需
	    的轉換代價就可接受因而轉換。</para>

          <para>在FreeBSD的狀況中，我們的共享函式庫(shared libraries)機制和
            <application>SunOS</application> 的型式非常相近，且易於使用。然而，
            從 3.0 開始，FreeBSD 正式將 <acronym>ELF</acronym> 改為預設格式。
            雖然，<filename>a.out</filename> 格式依舊如以往般的好，但是，我們
	    編譯工具的撰寫者，GNU 的成員，他們中止了對
	    <filename>a.out</filename> 格式的支援與維護。在這種狀況下，迫使
	    我們必須自行維護另一份版本的 compiler 和 linker，也使得我們無法
	    從最新的 GNU 發展成果中獲得好處。此外，對 ISO-C++ 的需求，尤其是
	    建構子(constructors)和解構子(destructors)，也帶動未來版本中對
	    <acronym>ELF</acronym> 的原生支援。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="binary-formats">
          <para>是的, 但是, 為什麼會有這麼多不同格式的執行檔存在呢?</para>
        </question>

        <answer>
          <para>在黑暗而遙遠的過去，僅有簡陋的硬體存在。而因為硬體簡陋，當然也
            只能執行小而簡單的系統。a.out 格式是基於那個時代所需要，而被創造
	    出來的(例如像PDP-11)。在這之後，許多人試著將 Unix 移植到其他平台
	    時，他們也保留了 a.out 格式的執行檔。因為，這對早期的 Motorola 68k，
	    VAXen 之類的系統已經足夠使用了。</para>

          <para>然而，人並不會滿足於現狀。一些聰明的硬體工程師想到了，如果能
	    讓軟體多處理一些事，那 CPU 的電晶體數就能少一點，並且跑得更快。要
	    在這種新式的硬體上工作(現在稱為RISC)，<filename>a.out</filename>
	    這種格式就不合適了。基於這樣的現實所需，更多的執行檔格式被發展出
	    來，以提供比簡單且受到許多限制的 <filename>a.out</filename> 格式
	    更好的效能。比方像是 <acronym>COFF</acronym>，
	    <acronym>ECOFF</acronym>，已及一些較不為人所周知的格式紛紛被創造
	    出來。但是，這些格式都已達到各自的極限，直到有一天
	    <acronym>ELF</acronym> 的出現。</para>

          <para>此外，當程式的體積越來越大，而磁碟空間和主記憶體相對來說都較
	    小時，共享函式庫(shared libraries)的觀念被發展出來了。在這同時，
	    虛擬記憶體系統(VM System)也變得越來越精巧。當每一種進步都在
	    <filename>a.out</filename>格式上被發展出來時，它的可用性也同時變
	    得越來越低。另外，人們還希望程式能在執行期間動態載入，或是將已經
	    執行過且沒有用的初始化程式碼丟棄，藉以節省更多的記憶。程式語言在
	    這個時期也便得更精巧，人們也希望在 main 之前自動的執行更多的東西。
	    因此，許多繁雜且另人嘆為觀止的技巧被用在 <filename>a.out</filename>
            格式上去解決這些問題。但是，由於 <filename>a.out</filename> 格式
	    先天的限制，要解決這些問題必需付出更多的代價及時間成本，並讓程式
	    的複雜度大為提升。而 <acronym>ELF</acronym> 格式可以一舉解決這一
	    切問題。但是，要將整個系統從根本轉換過去，將會有不短的陣痛期，因
	    此， <acronym>ELF</acronym>格式將會有一陣子與
	    <filename>a.out</filename> 並存。</para>

          <para>然而，隨著時間的過去，FreeBSD的 build tools 演化成平行的兩個
	    支線(尤其是組譯器和載入器)。FreeBSD這條路加進了共享函式庫
	    (shared libraries)並修正了一些錯誤。而原來發展這些程式的 GNU 成員
	    則為了因應現況，重寫了這些程式，以更簡單的方式對跨平台編譯
	    (building cross compilers)，以及多種格式
	    (plugging in different formats) 作出了支援。許多人想作出以 FreeBSD
	    為目的平台的跨平台編譯器。但不幸的是，FreeBSD 的 as 和 ld 不能作
	    這項工作。新的 GNU 工具程式加入了跨平台編譯 (Cross Compiler)，
            <acronym>ELF</acronym>格式支援，共享函式庫(shared libraries)，
            C++ 的擴充... 等等。此外，許多廠商以 <acronym>ELF</acronym> 格式
	    發行其產品，如果這些東西能在 FreeBSD 上執行的話當然是最好的。既然，
	    能夠執行 <acronym>ELF</acronym> 格式的執行檔了，為什麼還須要
	    <filename>a.out</filename> 呢？它已經是一匹垂垂老矣的馬了，在竭力
	    盡忠的奉獻這麼多年之後，該是讓它在牧場肥沃的草地上好好休息的時候
	    了。</para>

          <para><acronym>ELF</acronym> 格式比 a.out 具有更良好的展現能力，並
	    且在底層系統中具有更多的可擴展性。<acronym>ELF</acronym> 工具程式
	    更容易被維護，且提供跨平台編譯的支援，這一點對很多人來說是很重要
	    的。<acronym>ELF</acronym> 格式可能比 a.out 慢一點，但是其差異非
	    常難測量出來。這兩者間還有許多細節上的不同，比方說分頁對應的方式，
	    程式碼初始化的方法...等等。這些並不是很重要，但是，兩者就是不同。
	    以後，GENERIC 核心(kernel)將會移除對 <filename>a.out</filename>
            格式。當不在有執行傳統 <filename>a.out</filename> 程式的須要時，
	    將會從核心(kernel)中移除。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="chmod-symlinks">
          <para>為甚麼chmod不會改變符號連結(symlink)的存取權限？</para>
        </question>

        <answer>
          <para>Symlinks 本身並沒有存取權限，同時，在預設的狀況下，
	    &man.chmod.1; 將不會跟隨著 symlinks 去改便目標檔案的存取權限。因此，
	    如果你有一個檔案 <filename>foo</filename>，同時，有一個 symlink
	    <filename>bar</filename> 指向這個檔案，以下這個命令將永遠會成功
	    的被執行。</para>

          <screen>&prompt.user; <userinput>chmod g-w bar</userinput></screen>

          <para>然而，在 <filename>foo</filename> 上的存取權限將不會被改
	    變。</para>

          <para>你必需使用 <option>-H</option> 或是將 <option>-L</option>
	    與 <option>-R</option> 選項一起使用，參考 &man.chmod.1; 以及
	    &man.symlink.7; 以取得更多的資訊。</para>

            <warning>
              <para>使用選項 <option>-R</option> 會讓 &man.chmod.1; 以
	        <acronym>遞迴(RECURSIVE)</acronym> 的方式工作。當你把
		&man.chmod.1; 用在目錄或是連結到目錄的符號連結時更要小心。
                如果你要改變一個符號連結參考到的目錄之存取權限 &man.chmod.1; ，
		且注意不要加上任何選項，並且在 symlink 的結尾加上斜線
		(<filename>/</filename>)。舉例來說，如果
		<filename>foo</filename> 連結到目錄 <filename>bar</filename>，
		而你要更改 <filename>foo</filename> (實際上是
		<filename>bar</filename>)，那就使用：</para>

              <screen>&prompt.user; <userinput>chmod 555 foo/</userinput></screen>

              <para>結尾的斜線會使得 &man.chmod.1; 改變
	        <filename>foo</filename> 所指向的目錄 <filename>bar</filename>
		的權限。</para>
            </warning>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="login-8char">
          <para>為什麼在 FreeBSD 2.2.x 及更早的版本中，登入名稱(login names)
	    被限制在八個字元以下呢？</para>
        </question>

        <answer>
          <para>你可能認為修改 <literal>UT_NAMESIZE</literal> 後在重新編譯整個
            系統是很容易的事。而且在這之後，每件事都可以運作的很好。不幸的是，
	    有許多的程式和工具(包含系統工具)把數字寫死在程式裡頭(並非總是
	    <literal>8</literal> 或 <literal>9</literal>，有時可能是古怪的
            <literal>15</literal> 或 <literal>20</literal>)。這不僅僅是會將
	    你的系統記錄檔弄壞而已(來自於變動長度和固定長度記錄的差異)，同時
	    也會破壞 Sun 的 NIS Client 的運作。同時，和其他的Unix系統之間也
	    有可能會產生未知的問題。</para>

          <para>在FreeBSD 3.0 及之後的版本，帳號的最大長度增加到16個字元，
	    同時，那些將長度寫死的程式也被找出來並作了適當的修正。正因為影響
	    系統的範圍很廣，所以直到3.0版之後才算大致修正完成。</para>

          <para>如果你有自信在出問題的時後能自行解決，你可以利用下面的方法讓
	    較早期的版本支援較長的帳號。首先，修改
	    <filename>/usr/include/utmp.h</filename> 中的UT_NAMESIZE。
            然後，你必須把 <filename>/usr/include/sys/param.h</filename>
	    中的 MAXLOGNAME 改成跟 UT_NAMESIZE 相同。最後，如果你是從原始程
	    式建立系統, 別忘了 /usr/include 每次都會被更新。
	    修改 /usr/src/.. 中適當的檔案。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dos-binaries">
          <para>我能在FreeBSD下執行DOS程式嗎？</para>
        </question>

        <answer>
          <para>是的，自3.0版起你可以使用BSDI的
	    <application>doscmd</application> DOS 模擬器，如果你對這個東西
	    有興趣，或是想加入發展行列，請寄一封電子郵件到 &a.emulation; 。
	    </para>

          <para>對於3.0之前的系統，在 ports 中有一套軟體可以模儗 8088，並提
	    供足夠的BIOS中斷服務以執行DOS文字模式的程式，這套軟體叫做
	    <application>pcemu</application>，同時，運行它須要
	    X Windows(由XFree86提供)。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="translation">
          <para>如果要把FreeBSD文件翻譯成我的母語，我需要作什麼？</para>
        </question>

        <answer>
          <para>參閱FreeBSD文件中的 <ulink
	    url="../fdp-primer/translations.html">翻譯常見問答</ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="freebsd-mail-bounces">
	  <para>為什麼我寄到 FreeBSD.org 相關地址的電子郵件都被退回了呢？</para>
        </question>

        <answer>
	  <para>FreeBSD.org 的郵件系統對於進來的郵件採取嚴格的檢查，並且退回
	    所有設定不正確，或是潛在的垃圾郵件。你的郵件被退回可能是因為下列
	    原因所引起：</para>

	  <itemizedlist>
	    <listitem>
              <para>這封電子郵件來自已知的垃圾郵件區域或是IP中。</para>

              <para>FreeBSD郵件伺服器將拒絕接收已知的垃圾郵件來源的電子郵件。
	        如果提供你網路服務的公司或是網域中有產生過垃圾郵件或是有垃圾
		郵件轉播站，請你換一個服務提供者，或是乾脆放棄。</para>
            </listitem>

            <listitem>
              <para>電子郵件的本文僅有HTML。</para>

              <para>郵件應該已純文字格式發送，請設定你的電子郵件軟體送出純文
	        字格式。</para>
            </listitem>

            <listitem>
              <para>FreeBSD的郵件處理程式無法由IP反查送件主機的IP。</para>

              <para>設置 DNS 反查是接受一台主機郵件的一個標準要求，請為您的郵件
	        主機設置 DNS 反查。許多提供家庭網路服務 (DSL，cable，dialup 等)
		的公司並不提供這樣的服務。在這種情況下，請透過網路服務提供者的
		郵件伺服器送出您的電子郵件。</para>
            </listitem>

	    <listitem>
	      <para>在 SMTP 使用 EHLO/HELO 命令時所給予的 hostname 無法被解析到
	        一個 IP 位置。</para>

	      <para>在郵件被接受以前，一個充分合格，且可被解析的主機名稱在
	        SMTP 協定的對談中是必要的。如果你沒有在 DNS 伺服器中登記你
		的主機名稱，請透過網路服務提供者的郵件伺服器送出您的電子郵
		件。</para>
	    </listitem>

	    <listitem>
	      <para>你的訊息中夾帶著一個 message ID 以 <quote>localhost</quote>
	        字串結束。</para>

	      <para>某些郵件軟體產生某些不正確的 message ID，這將不被接受。
	        你必需更改設定讓你的郵件軟體產生正確的 message ID，如果這無
		法解決，考慮說服你的郵件軟體作者更新程式以處理這個問題。</para>
	    </listitem>
          </itemizedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="free-account">
          <para>我可以在哪裡找到一個免費的FreeBSD帳號？</para>
        </question>

        <answer>
          <para>FreeBSD的伺服器本身不提供任何對外的服務，其他的單位中，
            有人提供開放的 Unix 系統服務。其中有些可能要收取些許費用。</para>

          <para><ulink url="http://www.arbornet.org/">Arbornet, Inc</ulink>，
	    也被稱為 M-Net，自 1983 年起就開始提供 Unix 系統服務。一開始，
	    他們使用 Altos 並執行 System III。他們在 1991 年轉換系統成為
	    BSD/OS。在 2000 年六月，他們再度更換成為 FreeBSD。M-Net 能讓使
            用者透過 SSH 及 telnet 連線到主機，並提供完整的 FreeBSD 軟體以
	    供使用。然而，M-Net 作為一個非盈利組織運行，存取權只限於成員和
	    贊助者，M-Net 也提供 BBS 系統和網路聊天服務。</para>

          <para><ulink url="http://www.grex.org/">Grex</ulink> 提供了非常
            類似 M-Net 的服務，包括了 BBS 系統和網路聊天。然而，機器是使用
            Sun 4M，並執行 SunOS。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="sup-define">
          <para>什麼是 <command>sup</command>，我該如何使用它？</para>
        </question>

        <answer>
          <para><ulink url="http://www.FreeBSD.org/cgi/ports.cgi?^sup">
            SUP</ulink> 的意思是 Software Update Protocol，由 CMU 發展，
            用來維持整個發展的同步。我們利用它保持遠端的站台和原始站台之間
            的同步工作。</para>

          <para>然而，SUP 在頻寬的使用上並不太友善，同時，目前也不再使用了。
            目前建議維持原始碼同步更新的方法是
	    <ulink url="../handbook/synching.html#CVSUP">CVSup</ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="daemon-name">
          <para>這個可愛的小紅人叫作什麼？</para>
        </question>

        <answer>
          <para>似乎，他並沒有一個正式的名字，姑且就稱其為
	    <quote>BSD 小惡魔</quote> 吧。如果你執意要使用一個名字。那就叫他
	    <quote>小動物(beastie)</quote> 吧。註：<quote>beastie</quote>
	    在讀音上跟 <quote>BSD</quote> 很接近。</para>

          <para>你可以在BSD小惡魔的 <ulink
	    url="http://www.mckusick.com/beastie/index.html">主頁</ulink>
	    上取得更多的資訊。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="use-beastie">
          <para>我能使用 BSD 小惡魔圖案嗎？</para>
        </question>

        <answer>
          <para>也許吧，我也不確定。BSD小惡魔圖案的版權是屬於馬歇爾蘇格蘭教會的
	    Marshall Kirk McKusick 所擁有。你可以試著去查看網頁<ulink
            url="http://www.mckusick.com/beastie/mainpage/copyright.html">關於BSD小惡魔肖像</ulink>
	    以取得更詳細的使用細節。</para>

          <para>總而言之，如果你純粹為了自己想要鑑賞，那麼，你可以自由的使用肖像。如果你是個人使用，只要情況適當，應該都會被許可。
	    如果你想在商業上使用，則你必需聯繫蘇格蘭教會的 Kirk McKusick 以取得許可。
	    如果你需要更進一步詳細的資訊，請參考 <ulink
	    url="http://www.mckusick.com/beastie/index.html">BSD小惡魔的首頁</ulink>。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="daemon-images">
          <para>你有任何的 BSD 小惡魔圖案可以讓我使用嗎？</para>
        </question>

        <answer>
          <para>你可以在 <filename>/usr/share/examples/BSD_daemon/</filename> 找到 Xfig 及 eps 兩種格式的圖檔。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="glossary">
	  <para>我在文件、郵遞論壇上，常會看到一些縮寫字、技術字彙，這些可以去哪邊查呢？</para>
        </question>

        <answer>
          <para>請參閱 <ulink
	     url="&url.books.handbook;/freebsd-glossary.html">
	     &os; 字彙表</ulink>。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bikeshed-painting">
          <para>為什麼我該在意腳踏車車棚的顏色？</para>
        </question>

        <answer>
          <para>最短最短的答案是：『不用在意』。稍微長一點的答案是：『雖然你有能力自己去建造一座腳踏車車棚，但是，
            這不代表因為你不喜歡現在這個車棚的顏色，就要中止他的建築。』這個比喻的意思是，
            你不需要去爭論每一個細項特徵，只因為你有辦法去作它。
            某些人的評論是：『雜音的程度，與變化的複雜性是成反比』。</para>

          <para>更長且較完整的答案是，在經過長時間爭論關於是否該將 &man.sleep.1;
            的秒參數移除，&a.phk;發表了一篇長論 <quote><ulink
            url="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">
            在青翠草地上的腳踏車車棚(任何顏色的)...</ulink></quote>。以下，僅摘要該則文章部分內容：</para>

          <blockquote>
            <attribution>&a.phk; on freebsd-hackers, October
              2, 1999</attribution>

            <para><quote>什麼是關於這個腳踏車車棚?</quote> 部分的人這樣的詢問我。</para>

            <para>這是一個非常長遠的故事，否則就是一個古老的故事。但是事實上，
              這個故事非常的短。C·諾斯科特·帕金森(C. Northcote Parkinson) 在 1960
              年代初期寫了一本書，書名為 <quote>Parkinson's Law(中文書名：升官有道－暴露上司心態之帕金森定律)</quote>
              ，這本書包含了很多具有卓見的動態管理學。</para>

            <para>[引述一點在這本書上的評論]</para>

            <para>在這個被捲入腳踏車車棚案的特殊例子，主要的要素是核能發電場，我想，這足以說明這本書的年齡。</para>

            <para>帕金森展示了該如何在董事會中贏得贊同去建造一座數百萬或甚至十億美元的核能發電場，
	      但是，如果你想要去建造一座腳踏車車棚，你將會被糾纏在無窮無盡的討論之中。</para>

            <para>他(帕金森)並解釋，這是因為一個核能發電場是這樣的廣闊，這樣的昂貴，並且這樣的複雜，
	      以至於人們無法掌握它，而並非嘗試，他們急切的希望有人能夠幫他們處理並解決所有瑣碎的細項。
	      Richard P. Feynmann 給了一些有趣，且非常一針見血的論點，在他的書提到了 Los Alamos 的例子。</para>

            <para>另一方面，任何人都能自己在週末組裝一座腳踏車車棚出來，並且仍有閒聊可以觀賞電視及玩遊戲。
	      因此，無論你作了多麼完善的準備，也不管你提出的方案是多麼的妥當，某些人仍將抓住機會跑出來告訴你，
	      他正在作同樣的事，正在付出努力，他就在 <emphasis>這裡</emphasis>。</para>

            <para>在丹麥，我們稱這個叫作『虎死留皮』(setting your fingerprint)。這關係到你個人的驕傲和聲望，
	      這關係到你是否可以指著某地後對著別人說：『這裡! 這是 <emphasis>我</emphasis> 作的。』
	      這是政治人物很重要的一個特徵。但是，時機是大多數人民所賦與的。想想那些留在水泥地上的腳印吧。</para>
          </blockquote>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="funnies">
    <chapterinfo>
      <author>
	<firstname>Edward</firstname>
	<surname>Chuang</surname>
	<affiliation>
	  <address><email>edwardc@firebird.org.tw</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>FreeBSD 冷笑話集</title>

    <qandaset>
      <qandaentry>
        <question id="very-very-cool">
          <para>How cool is FreeBSD？</para>
        </question>

        <answer>
          <para>問：有人做過 FreeBSD 執行時的溫度測試嗎？ 我知道 Linux
	    比 DOS 涼，但沒聽人提過 FreeBSD，似乎很熱。</para>

          <para>答：沒有，但是在味覺上有做過無數次測試。我們矇上自願受試者的
	    眼睛，事先再給他們服用 250 毫克的 LSD-25 迷幻藥。35% 的受試者說
	    FreeBSD 嘗起來像橘子，而 Linux 則是紫色的榛樹果實。據我所知，沒
	    有一組提到溫度上特別的差異。後來發現，有太多受試者在測試時夢遊走
	    出房間影響到數據，最後只得放棄整個調查。我想大部份的受試者現在在
	    Apple 工作，繼 Drag and Drop 之後，研究全新的 <quote>Scratch and
	    Sniff</quote> 圖形界面。It's a funny old business we're in！</para>

          <para>不開玩笑了，FreeBSD 和 Linux 都使用 <acronym>HLT</acronym>
	    (halt) 指令，可在系統閒置時降低電力的使用也減少了熱的產生。如果有設定 APM(Automatic Power Management)
	    ，FreeBSD 也可以讓 CPU 進入省電模式。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="letmeoutofhere">
          <para>誰在我的記憶體插槽中沙沙作響？？</para>
        </question>

        <answer>
          <para>問：FreeBSD 編譯核心時有做甚麼 <quote>奇特</quote> 的事
	    讓記憶體沙沙作響嗎？當編譯時(還有開機時確認軟碟後的短暫時間)，
	    也種似乎來自記憶體插槽的奇怪聲音。</para>

          <para>答：是的！在 BSD 的文件中你會常常看到 <quote>背後靈</quote>，
	    大部份的人都不知道那是一種實際存在的精神體 --- 掌控著你的電腦。
	    你聽到的聲音是這些背後靈以高音口哨在溝通怎樣做許多的系統管理工
	    作。</para>

          <para>如果這些聲音很困擾你，來自 DOS 的
	    <command>fdisk /mbr</command> 就能擺脫，但如果有相反的效果
	    也不要驚訝。事實上，如果在儀式中聽到 Bill Gates 恐怖的聲音從內
	    建的喇叭傳來，馬上逃而且不要回頭！ 從 BSD 背後靈不平衡的影響中
	    解放，DOS 和 Windows 背後靈通常都能重新控制整台機器並對你的靈
	    魂詛咒。如果有選擇，我想我寧願習慣奇怪的聲音。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="changing-lightbulbs">
          <para>要幾個 FreeBSD hacker 才能換掉一個電燈泡？</para>
        </question>

        <answer>
          <para>一千一百七十二個：</para>

          <para>二十三個在 -current 上抱怨看不到光了；</para>

          <para>四個宣稱這是設定上的問題，所以像這樣的 email 應該放在
	    -questions；</para>

          <para>三個 submit PR，其中一個送錯到 doc 下，並且內容只
	    有”這裡好暗”；</para>

          <para>一個 commit 尚未測試的電燈泡，造成不能 buildworld，
	    五分鐘後他把原來的燈泡換回來；</para>

          <para>八個煽起 flame war，責怪送出 PR 的人沒有包括 patch；</para>

          <para>五個埋怨 buildworld 爛掉了；</para>

          <para>三十一個說 buildworld 可以用，不能用的人一定是 cvsup 的
	    時機不對；</para>

          <para>一個把換成新燈泡的 patch 丟到 -hackers 上；</para>

          <para>一個說他三年前就做出了 patch，但送到 -current 後卻被忽略掉，
	    所以他對整個 PR 系統有很不好的印象。此外，他也認為拿出的新燈泡無
	    法反光；</para>

          <para>三十七個咆哮說電燈泡不屬於基本系統的一部份，所以 committer
	    不能不先諮詢整個 Community 的意見就這樣做下去。還有，-core
	    到底和這件事有什麼關係？！</para>

          <para>兩百人抱怨換燈泡之後，腳踏車棚的顏色變得好奇怪；</para>

          <para>三個指出，用來換燈泡的 patch 不符合 &man.style.9; 的規定；</para>

          <para>十七個埋怨拿出來的新燈泡為什麼是用 GPL；</para>

          <para>五百八十六人陷入一場 flame war，在 GPL、BSD、MIT、NPL
	    各個 license 和 FSF 某位不具名創辦人士個人衛生之間，比較彼此
	    的優勢；</para>

          <para>七個將這一串討論的不同部份分別移到 -chat 和 -advocacy；</para>

          <para>就算提出的新燈泡比舊的暗，還是有一個把它 commit 進來；</para>

          <para>兩個換回原先的燈泡，並且留下極為憤怒的 commit 訊息。他們認為
	    與其讓 FreeBSD 用暗燈泡，還不如乾脆待在黑暗中算了；</para>

          <para>四十六人對取消不用暗燈泡這件事大聲疾呼，要求 -core
	    立刻提出澄清；</para>

          <para>十一個要求換成小一點的電燈泡，以便未來 FreeBSD 如果移植到
	    電子雞上後會更為方便；</para>

          <para>七十三人抱怨 -hackers 和 -chat 上的 SNR，藉 unsubscribe
	    來表示抗議；</para>

          <para>十三個送出”unsubscribe”、”我要如何 unsubscribe”或”拜託把
	    我從 list 名單中刪掉”，信的最後面則是一般由 majordomo 加上去
	    的 footer；</para>

          <para>當每個人忙於彼此叫罵時，有個傢伙趁沒人注意，把可以用的燈泡偷
	    偷換上去；</para>

          <para>三十一個指出如果用 TenDRA 編譯新的燈泡，會比舊的來得亮
	    0.364%（雖然燈泡會被編譯成正六面體），所以 FreeBSD 內定的編譯器
	    應該是 TenDRA，而不是 EGCS；</para>

          <para>有個人說新燈泡缺乏美感；</para>

          <para>九個人（包括原先送 PR 的人）問”什麼是 MFC？”；</para>

          <para>五十七個抱怨自從換了燈泡後，兩個星期都沒有光出現。</para>

          <para><emphasis>&a.nik; 補注：</emphasis></para>

          <para><emphasis>剛看到時，我快笑翻了。</emphasis></para>

          <para><emphasis>然後想到，”等一下，不是應該還有一個要將這些記在
	    list 上嗎？”</emphasis></para>

          <para><emphasis>接著終於了解我的使命 :-)</emphasis></para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dev-null">
          <para>寫入 <filename>/dev/null</filename> 的資料跑到哪裡去了？</para>
        </question>
        <answer>
          <para>在 CPU 中有一種特別的資料散熱器，利用排出散熱片/風扇組合時，
	    轉換成熱能．這就是為什麼 CPU 冷卻日趨重要的原因；當人們使用更快
	    的處理器時，他們變成不在乎有越來越多他們的資料都送進了
	    <filename>/dev/null</filename> ，而使的他們的 CPU 過熱．
	    如果你刪除了 <filename>/dev/null</filename> (那將會有效的關閉
	    CPU 的資料散熱器) 你的 CPU 也許會降低工作溫度，但是你的系統將
	    會很快的像是罹患了便秘伴隨著所有超出的資料開始變成行為不正常。
	    如果你有快速的網路連線，你可以利用讀取
	    <filename>/dev/random</filename> 並將他隨意傳送至各處，
	    來降低你 CPU 的溫度；然而你將陷入使你網路連線或
	    <filename>/</filename> 有過熱的風險或是惹惱你的 ISP，
	    大部分的資料最終將會在他們的設備上轉換成熱，不過他們通常都擁有
	    好的散熱，所以如果你做的不太過分，應該是沒什麼大不了的。</para>

	  <para><emphasis>Paul Robinson 補充：</emphasis></para>

	  <para>中文版 FAQ 注：以下短文屬於美式幽默，恐翻譯後造成語焉不詳，
	    語意不通的情形，故保留原汁原味讓讀者自行品嚐。</para>

	  <para>There are other methods. As every good sysadmin knows,
            it is part of standard practise to send data to the screen
            of interesting variety to keep all the pixies that make up
            your picture happy. Screen pixies (commonly mis-typed or
            re-named as 'pixels') are categorised by the type of hat
            they wear (red, green or blue) and will hide or appear
            (thereby showing the colour of their hat) whenever they
            receive a little piece of food. Video cards turn data into
            pixie-food, and then send them to the pixies - the more
            expensive the card, the better the food, so the better
            behaved the pixies are. They also need constant simulation
            - this is why screen savers exist.</para>

          <para>To take your suggestions further, you could just throw
            the random data to console, thereby letting the pixies
            consume it. This causes no heat to be produced at all,
            keeps the pixies happy and gets rid of your data quite
            quickly, even if it does make things look a bit messy on
            your screen.</para>

          <para>Incidentally, as an ex-admin of a large ISP who
            experienced many problems attempting to maintain a stable
            temperature in a server room, I would strongly discourage
            people sending the data they do not want out to the
            network. The fairies who do the packet switching and
            routing get annoyed by it as well.</para>
	</answer>
      </qandaentry>


      <qandaentry>
        <question id="pttlz">
          <para>1993 年就有『make world』了？</para>
        </question>

        <answer>
	  <para>問：根據 jkh 的 <ulink
	      url="http://www.freebsd.org/cgi/cvsweb.cgi/src/Makefile.diff?r1=1.5;r2=1.6;f=h">
	    這份 commit</ulink>，應該是 Aug 13 22:47:28 1994 UTC
	    之後才會有 make world，怎麼會有在那之前會有呢？</para>

	  <para>答：根據 pttlz.bbs@ptt.cc (工蟻) 於 Apr  7 17:09:47 2008 CST 自稱：
	    『make world 是我古早 (15 年前) 時玩 freebsd 時用的』，所以 1993 年就有
	    pttlz 的『make world』存在了，請注意人家可是自稱『15 年前』的長輩，
	    請勿對長輩權威挑戰，謝謝！</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="advanced">
    <chapterinfo>
      <author>
	<firstname>En-Ran</firstname>
	<surname>Zhou</surname>
	<affiliation>
	  <address><email>zhouer@tfcis.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>進階主題</title>

    <qandaset>
      <qandaentry>
        <question id="learn-advanced">
          <para>如何能學習更多有關 FreeBSD 內部的東西？</para>
        </question>

        <answer>
          <para>目前市面上還沒有探討作業系統內部的書是專為 FreeBSD 而寫
	    的。然而，許多一般的 UNIX 知識都可以直接應用在 FreeBSD 上。附
	    加一點，仍然有相關的書是專為 BSD 所寫的。</para>

          <para>請參考 Handbook 的<ulink
	    url="../handbook/bibliography-osinternals.html">作業系統內部之參考書目</ulink>
	    。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="how-to-contribute">
	  <para>如何能為 FreeBSD 出一份力？</para>
	</question>

	<answer>
	  <para>請參考這篇文章 <ulink
	    url="../../articles/contributing/article.html">Contributing
	    to FreeBSD</ulink> 來提供您的建議。如果您能幫忙那就更歡迎了！</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="define-snap-release">
          <para>SNAP 和 RELEASE 是什麼？</para>
        </question>

        <answer>
          <para>目前有三個活躍/半活躍的分支在 FreeBSD 的 <ulink
	    url="http://www.FreeBSD.org/cgi/cvsweb.cgi">CVS Repository</ulink>
	    (古早分支已經幾乎沒在更新了，因為通常只有三個活躍的發展分支)：
	    </para>

            <itemizedlist>
              <listitem>
                <para><literal>RELENG_5</literal> 即
                  <emphasis>5-STABLE</emphasis></para>
              </listitem>

              <listitem>
                <para><literal>RELENG_6</literal> 即
                  <emphasis>6-STABLE</emphasis></para>
              </listitem>

              <listitem>
                <para><literal>HEAD</literal> 即
                  <emphasis>-CURRENT</emphasis> 也就是目前的
                  <emphasis>7.X-CURRENT</emphasis></para>
              </listitem>
            </itemizedlist>

          <para>與上面其他兩個分支相比，其實 <literal>HEAD</literal> 並不是真正
	    的 branch tag，它只是個 symbolic constant，代表 <quote><emphasis>current
	    (尚未分支的發展中版本)</emphasis></quote>，通常我們會簡寫為 <quote>-CURRENT</quote>。</para>

          <para>就現在而言，<quote>-CURRENT</quote> 就是指 7.X 的發展；
            而 <literal>5-STABLE</literal> 分支(<symbol>RELENG_5</symbol>)是在 2004 年 10 月從
            <quote>-CURRENT</quote> fork 出來的；
            <literal>6-STABLE</literal> 分支(<symbol>RELENG_6</symbol>)是在 2005 年 11 月從
            <quote>-CURRENT</quote> fork 出來的。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="custrel">
          <para>要怎麼作出自己的 release？</para>
        </question>

        <answer>
          <para>請參照 <ulink
            url="../../articles/releng/article.html">Release 工程</ulink>
	    文章說明。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="makeworld-clobbers">
          <para>為何 <command>make world</command> 會把原來裝的 binary 檔都換掉了？</para>
        </question>

        <answer>
          <para>沒錯，就是這樣子。如名字所示，<command>make world</command>
	    會重新編譯系統內建的每個 binary 檔，這樣在結束時就可確定有個一致且乾淨的環境(所以要花上好一段時間)。</para>

          <para>在執行 <command>make world</command> 或
	    <command>make install</command> 時，如果有設
	    <literal>DESTDIR</literal> 這個環境變數，新產生的 binary 將會裝在
	    <literal>${DESTDIR}</literal> 下同樣的目錄樹中。但在某些修改
	    shared library 和重建 binary 的無特定情況下，這樣做可能會使
	    <command>make world</command> 失敗。</para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="cvsup-round-robin">
	  <para>Why isn't cvsup.FreeBSD.org a round robin DNS entry to
	  share the load amongst the various CVSup servers?</para>
	</question>

	<answer>
	  <para>While CVSup mirrors update from the master CVSup
	    server hourly, this update might happen at any time during
	    the hour.  This means that some servers have newer code
	    than others, even though all servers have code that is
	    less than an hour old.  If <hostid role="fqdn">cvsup.FreeBSD.org</hostid> was a round
	    robin DNS entry that simply redirected users to a random
	    CVSup server, running CVSup twice in a row could download
	    code older than the code already on the system.</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="bus-speed-defaulted">
          <para>在系統開機時，出現 <quote>(bus speed defaulted)</quote>。</para>
        </question>

        <answer>

          <para>Adaptec 1542 SCSI 卡允許使用者用軟體調整匯流排的存取速度。
	    早期的 1542 驅動程式試圖將它設成可用的最快速度，但後來發現在一
	    些機器上不能用，所以現在要在 kernel 設定中加
	    <symbol>TUNE_1542</symbol> 這個選項來啟動這個功能。在支援的機器
	    上用這個選項會使硬碟存取更快，但在不支援的機器上有可能會毀掉資料。
	    </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ctm">
          <para>在網路頻寬有限的情況下，我也可以跟上 current 的發展嗎？</para>
        </question>

        <answer>
          <para>是的，藉著 <ulink url="../handbook/synching.html#CTM">CTM
	  </ulink> 您就可以<literal>不用</literal>下載全部的程式碼。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="split-240k">
          <para>是怎麼把發行版本中的檔案切成一個個 240k 的小檔案的？</para>
        </question>

        <answer>
          <para>以 BSD 為基礎的較新系統有個 <option>-b</option> 選項
	  可以把檔案以任意數目 byte 切開。</para>

          <para>這裡是 <filename>/usr/src/Makefile</filename> 中的一個
	  例子：</para>

          <programlisting>bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="submitting-kernel-extensions">
          <para>我在 kernel 中加了新功能，我要把它寄給誰？</para>
        </question>

        <answer>
          <para>請參考 <ulink
	    url="../../articles/contributing/article.html">Contributing
            to FreeBSD</ulink> 中的文章，以了解要如何提供您的程式碼。</para>

          <para>同時也謝謝您的關心！</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="pnp-initialize">
          <para>ISA 的隨插即用卡是如何偵測及初始化的？</para>
        </question>

        <answer>
          <para>由 Frank Durda IV 所寫：
            <email>uhclem@nemesis.lonestar.org</email></para>

          <para>簡單的說，當主機發出是否有 PnP 卡的詢問訊號時，所有的 PnP 卡
	    會在幾個固定的 I/O port 作回應。所以當偵測 PnP 的程式開始時，它
	    會先問有沒有 PnP 卡在，接著所有 PnP 卡會在它讀的 port 以自己的
	    型號 # 作回答，這樣偵測程式就會得到一個 wired-OR <quote>yes</quote>
	    的數字，其中至少會有一個 bit 是打開的。然後偵測程式會要求型號
	    (由 Microsoft/Intel指定)小於 X 的卡<quote>離線</quote>。再去看是
	    否還有卡回答同樣的詢問，如果得到 <literal>0</literal>，就表示沒
	    有型號大於 X 的卡。 現在程式會問是否有型號小於 <literal>X</literal>
	    的卡，如果有的話，程式再要型號大於 X-(limit/4) 的卡離線，然後重覆
	    上面的動作。用重複這種類似 semi-binary search 的方法，在某範圍內
	    找個幾次後，測程式最後會在機器中區分出所有的 PnP 卡，搜尋次數也
	    遠低於一個個找的 2^64 次。</para>

          <para>一張卡的 ID 由兩個 32-bit(所以上面是 2&circ;64) + 8bit 偵錯碼
	    組成，第一個 32 bits 是用來區分各家廠商的。這些廠商從來沒有出來澄
	    清過，但看來應假設同一家出的不同種類的卡的廠商 ID 有可能不同。用
	    32 bits 只來表示不同廠商的想法實在有點過頭了。</para>

          <para>第二個 32 bits 則是型號 #、乙太網路位址、或一些使這張卡獨特的
	    資料。除非第一個 32 bits 不同，否則廠商不可能作出第二個 32 bit 相
	    同的兩張卡。所以在一台機器中可以有同樣的好幾張卡，然而他們整個
	    64 bits 還是會都不一樣。</para>

          <para>這兩個 32 bit 絕對不可以全為零，這才能使得最開始 binary search
	    中的 wired-OR 會得到一個非零數字。</para>

          <para>一旦系統區分出所有卡的 ID，接著會經由同樣的 I/O port 一個個重
	    新啟動每張卡，接著找出已知介面卡所需的資源、有哪些中斷可以使用等
	    等。所有卡都會被掃描一次，來收集這些資料。</para>

          <para>這些資訊接著和硬碟上的 ECU 檔案、或 MLB BIOS 裡的資料結合在一
	    起，通常是綜合 ECU 和 MLB 裡的 BIOS PnP 資料，這些週邊並不支援真正
	    的 PnP，然而偵測程式在檢查 BIOS 和 ECU 資料後，它可以避免 PnP 週邊
	    和那些偵測不到的相衝突。</para>

          <para>接著再度拜訪這些 PnP 週邊，這次會把可用的 I/O、DMA、IRQ 和記憶
	    體映射的位址都指定給它們。這些週邊就會出現在所指定的地方，直到下一
	    次重新開機為止，不過也沒有人說不能把它們隨時移來移去。</para>

          <para>上面有相當多的簡化，但你應該已經了解大致的過程。</para>

          <para>Microsoft 把表示印表機狀態的幾個主要 port 拿來作 PnP，他們的
	    邏輯是沒有一張卡會在這些地方解碼作相反的 I/O cycles。但是我找到
	    一款早期仍在評估 PnP 提案時的 IBM 原廠 printer board，它的確去解
	    對這些狀態 port 的寫入資料，但是 MS <quote>說了就算</quote>。所以
	    它們的確有對印表機狀態 port 寫入，還有讀取該位址 +
	    <literal>0x800</literal>、和另一個在 <literal>0x200</literal> 及
	    <literal>0x3ff</literal> 之間的 port。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="major-numbers">
          <para>我為某設備寫了驅動程式，能不能給它一個 major number？</para>
        </question>

        <answer>
          <para>這要看你是否打算將這個驅動程式公開使用，如果是的話，請把它的
	    原始碼送一份給我們，還有 <filename>files.i386</filename> 修改的
	    部份、kernel 設定檔樣本、以及用來產生設備檔的 &man.MAKEDEV.8;。
	    如果你不打算公開、或因為版權問題而不能公開的話，我們有特地保留
	    character major number 32 和 block major number 8 給這方面的使用，
	    直接用這兩個就好了。不論如何，我們都會很感激你能在 &a.hackers;
	    發表驅動程式的消息。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="alternate-directory-layout">
          <para>關於更動目錄放置的原則？</para>
        </question>

        <answer>
          <para>在回答關於更動目錄放置的原則方面，我在 1983 年寫好目前的作法
	    後就沒有再改變過，這種方式是針對原先的 FFS 檔案系統，後來也沒有
	    對它作任何更動。它在避免 cylinder group 被填滿這方面做得相當成功，
	    但是就像有些人已經注意到，它和 find 就配合得不大好。大部份的檔案
	    系統是由那些用 depth first search(aka ftw) 產生的 archive 製造出
	    來，解出來的目錄 inode 會橫跨好幾個 cylinder group，如果以後要做
	    depth first search 的話，這是最糟糕的情況之一。如果我們知道總共
	    會產生多少目錄的話，解法是在做任何存取/寫入動作之前，在每個
	    cylinder group 上先造出(所有目錄數/cylinder greoup 的數目)這麼多
	    的目錄。很明顯的，我們必須要有根據地去猜這 個數字，就算一個像 10
	    的很小固定數目也會使效率以級數成長。區分 restore (即解開上述的
	    archive) 和一般檔案操作的方法可以是(現在用的演算法可能要更敏感)：
	    如果一些目錄(最多 10 個)都在 10 秒內產 生的話，那麼就把這些目錄
	    聚集在同一個 cylinder group。不管怎樣， 我的經驗指出這是一個已經
	    充份實驗過的部份。</para>

          <para>Kirk McKusick, September 1998</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="kernel-panic-troubleshooting">
          <para>如何在 kernel panics 時得到最多的資訊？</para>
        </question>

        <answer>
          <para><emphasis>[這節是從 &a.wpaul; 在 &os.current; <link
	    linkend="mailing">mailing list</link> 上發表的信中節錄，
	    &a.des; 修正了打字錯誤、再加上括弧裡的注解。]</emphasis></para>

          <programlisting>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: Ben Rosengart
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org</programlisting>

          <para><emphasis>[Ben 發表了下面的 panic 訊息]</emphasis></para>

          <programlisting>&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</programlisting>

          <para>當你看到像這樣的訊息時，只把它拷一份送上來是不夠的。我在上面
	    特地標明的 instruction pointer 值相當重要，不幸的是它會因設定而
	    不同。換句話說，這個值會跟你用的 kernel image 檔而變動。如果是用
	    某個 snapshot 版本的 GENERIC kernel，也許其他人可以追蹤到出問題
	    的函式，但如果你是用自訂的 kernel，那麼只有
	    <emphasis>你</emphasis>才能告訴我們問題出在那裡。</para>

          <para>要做的事包括這些：</para>

            <procedure>
              <step>
                <para>把 instruction pointer 的值記下來。注意在前面的
		  <literal>0x8:</literal> 在這個情況中並不重要，我們要的是
		  <literal>0xf0xxxxxx</literal>。</para>
              </step>

              <step>
                <para>當系統重新開機後，執行這道命令：

                  <screen>&prompt.user; <userinput>nm -n /(造成 panic 的 kernel 檔案) | grep f0xxxxxx</userinput></screen>

		  其中 <literal>f0xxxxxx</literal> 就是記下來的
		  instruction pointer 值。有可能不會剛好找到完整的這個字串，
		  這是因為 kernel symbol table 裡的各個 symbol 只是函式的進
		  入點，但 instruction pointer 所指的位址有可能是在函式內的
		  某一處，而不一定在開頭。所以如果找不到整個字串，那麼把
		  instruction pointer 值的最後一個數字拿掉，再試一次：

                  <screen>&prompt.user; <userinput>nm -n /(造成 panic 的 kernel 檔案) | grep f0xxxxx</userinput></screen>

                  如果這樣也找不到，那就把另一個數字去掉再找，一直重複到找到
		  為止， 結果是一串可能造成 panic 的函式列表。這樣比直接找到
		  出問題的函式來得差，但至少好過什麼都沒有。</para>

              </step>
            </procedure>

          <para>我常常看到人們顯示一大片 panic 訊息，但很少看到有人花一點時間
	    把 instruction pointer 和 kernel symbol table 中的函式比較一下。
	    </para>

          <para>要追蹤出造成 panic 原因的最好方法是先做出 crash dump，然後用
	    &man.gdb.1; 在上面做 stack trace。</para>

          <para>不管是那一種，我通常是用這個方法：</para>

            <procedure>
              <step>
                <para>寫好 kernel 設定檔。如果你需要用 kernel debugger，在設
		  定檔中加上 <literal>options DDB</literal> 這個選項。
		  (當我懷疑有出現無窮迴圈時，通常會用這個來設定中斷點。)
		  </para>
              </step>

              <step>
                <para>用 <command>config -g
		  <replaceable>KERNELCONFIG</replaceable></command>
		  做出用來編譯的目錄。</para>
              </step>

              <step>
                <para><command>cd /sys/compile/
                  <replaceable>KERNELCONFIG</replaceable>; make
                  </command></para>
              </step>

              <step>
                <para>等待 kernel 編譯結束。</para>
              </step>

              <step>
                <para><command>make install</command></para>
              </step>

              <step>
                <para>重新開機</para>
              </step>
            </procedure>

          <para>&man.make.1; 將會製造出兩個 kernel。<filename>kernel</filename>
	    還有 <filename>kernel.debug</filename>。
	    <filename>kernel</filename> 將會被安裝到
	    <filename>/kernel</filename>，而 <filename>kernel.debug</filename>
	    可用來給 &man.gdb.1; 當作 debugging symbols 的來源。</para>

          <para>要確定能抓到 crash dump，先編輯
	    <filename>/etc/rc.conf</filename> 將 <literal>dumpdev</literal> 指
	    到 swap 分割區。這樣 &man.rc.8; 會用 &man.dumpon.8; 來啟動
	    crash dump，你也可以手動執行 &man.dumpon.8; 在 panic 之後，
	    crash dump 可以用 &man.savecore.8; 存起來；如果
	    <filename>/etc/rc.conf</filename> 裡有設 <literal>dumpdev</literal>
	    那麼重新開機後 &man.rc.8; 會自動執行 &man.savecore.8; 把
	    crash dump 存在 <filename>/var/crash</filename>。</para>

            <note>
              <para>FreeBSD 的 crash dump 通常和機器裡的實際記憶體一樣大，就
	        像如果有 64MB 記憶體，crash dump 大小就是 64MB。所以要確定
		<filename>/var/crash</filename> 下有足夠的空間，或是可以手
		動執行 &man.savecore.8; 把 crash dump 放到另一個空間較夠的
		目錄下。另一種也許可以限制 crash dump 的方法，是在 kernel
		設定檔中用 <literal>options MAXMEM=(foo)</literal>，將 kernel
		可用的記憶體限制在合理的大小。舉例來說，如果你有 128MB 的記憶
		體，但是可以限制 kernel 只能用 16MB 的記憶體，這樣 crash dump
		就是 16MB 而不是 128MB 了。</para>
            </note>

          <para>一旦發現有了 crash dump，就可以用 &man.gdb.1; 來做
	    stack trace ，如下所示：</para>

          <screen>&prompt.user; <userinput>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</userinput>
<prompt>(gdb)</prompt> <userinput>where</userinput></screen>

          <para>要注意可能會出現好幾個螢幕的可用資訊，你可以用 &man.script.1;
	    把所有輸出都存起來。用包括所有 debug symbol 的 kernel 來除錯，這
	    樣應該可以直接顯示 panic 是發生在那一行。通常是由下往上讀
	    stack strace，這樣才能一個個追蹤出有哪些動作引到 crash。也可以用
	    &man.gdb.1; 把各種變數或結構的內容印出來，以檢查系統 crash 時的
	    實際狀態。</para>

          <para>好啦，如果你有第二台電腦而且有夠瘋狂，可以將 &man.gdb.1; 設定
	    成遠端除錯。這樣你可以在一台機器中用 &man.gdb.1; 去除錯另一台裡的
	    kernel，可以執行的包括設定中斷點、在 kernel 原始碼中一步步執行等
	    等，就像在一般使用者程式上除錯一樣。由於沒有什麼機會為除錯而設置
	    兩台並鄰電腦，所以我還沒有這樣玩過。</para>

          <para><emphasis>[Bill 補充："我忘了提到一點：如果你有啟動 DDB 而
	    kernel 也已經進入除錯器，可以在 DDB 命令列下打 'panic'，強迫產生
	    panic (還有 crash dump)。也有可能在 panic 階段時再進入除錯器，
	    如果這樣的話，輸入 'continue'，接著它就會完成 crash dump。" -ed]
	    </emphasis></para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="dlsym-failure">
          <para>為什麼 dlsym() 不能操作 ELF 執行檔？</para>
        </question>

        <answer>
          <para>在 ELF 一系列的工具中，內定是不會讓 dynamic linker 看到執行
	    檔裡定義了哪些 symbol。所以 <function>dlsym()</function> 沒有辦
	    法用藉由呼叫 <function>dlopen(NULL, flags)</function> 取得的
	    handle，用它去搜尋有那些 symbol 一定會失敗。</para>

          <para>如果你想要用 <function>dlsym()</function> 找出某個 process
	    的主執行檔中有哪些 symbol，則要在 link 時對 ELF linker (&man.ld.1;)
	    加上 <option>-export-dynamic</option> 這個參數。</para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="change-kernel-address-space">
          <para>我要如何增加或減少 kernel 能定址的空間？</para>
        </question>

        <answer>
          <para>預設值是，FreeBSD 3.x 的 kernel 可以定址的空間是 256 MB 而
	    FreeBSD 4.x 可以到 1 GB。如果是網路負荷相當重的伺服器
	    (例如大型 FTP 或 HTTP 伺服器)，你也許會發現 256 MB 可能不大夠。
	    </para>

          <para>所以，要如何增加定址空間呢？要從兩方面著手。首先首先告訴
	    kernel 本身要保留較大空間給自己。其次，既然是在定址空間的最上
	    面載入 kernel，所以還要調低載入的位址，才不會和前面定址的範圍
	    重疊。</para>

          <para>增加 <filename>src/sys/i386/include/pmap.h</filename> 裡的
	    <literal>NKPDE</literal> 就可以達成第一個目標。1 GB 的定址空間會
	    像這樣：</para>

          <programlisting>#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</programlisting>

          <para>要算出 <literal>NKPDE</literal> 的正確值，將想要的空間大小
	    (以 megabyte 為單位)除以 4，接著單 CPU 機器減 1，
	    雙 CPU 則是減 2。</para>

          <para>要解決第二個問題，必須自行算出 kernel 被載入的位址：求出
	    0x100100000 減掉定址空間大小的值(以 byte 為單位)，如 1 GB 大小就是
	    0xc0100000。把<filename>src/sys/i386/conf/Makefile.i386</filename>
	    裡的 <symbol>LOAD_ADDRESS</symbol> 設成這個值﹔接著在
	    <filename>src/sys/i386/conf/kernel.script</filename> 中，將
	    section 列表最前面的 location counter 設成相同的值，如下：</para>

          <programlisting>OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</programlisting>

          <para>然後重新編譯您的 kernel。您可能會在執行 &man.ps.1;、&man.top.1;
	    這類的程式時碰到問題﹔<command>make world</command> 應該就可以解決
	    (或把改過的 <filename>pmap.h</filename> 複製到
	    <filename>/usr/include/vm/</filename> 下，再手動編譯
	    <filename>libkvm</filename>，&man.ps.1; 還有 &man.top.1;)。</para>

          <para>注意：kernel 所能定址的空間大小必須是 4 megabytes 的倍數。
	    </para>

          <para>[&a.dg; 補充：<emphasis>我認為 kernel 定址空間大小應該要是 2
	    的乘冪，但不大確定這一點。舊的啟動程式會動到
	    high order address bits，記得它假設至少有 256 MB。]</emphasis>
	    </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="acknowledgments">
    <chapterinfo>
      <author>
	<firstname>Vanilla</firstname>
	<surname>Shu</surname>
	<affiliation>
	  <address><email>vanilla@FreeBSD.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>感謝</title>

    <blockquote>
       <attribution>FreeBSD Core Team</attribution>

       <para>假如您在這份 FAQ 中找到錯誤的地方，或是您想增加些甚麼，
         請寫封信到 &a.faq; 。我們非常感謝您的建議，
	 因為您的建議讓這份文件變得更好！</para>
    </blockquote>

      <variablelist>
        <varlistentry>
          <term>&a.jkh;</term>
            <listitem>
              <para>不停的更新過時的 FAQ</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>&a.dwhite;</term>

            <listitem>
              <para>經常在 freebsd-questions 上回答問題</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>&a.joerg;</term>

            <listitem>
              <para>經常在 Usenet 上回答問題</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>&a.wollman;</term>

            <listitem>
              <para>Networking and formatting</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Jim Lowe</term>

            <listitem>
              <para>Multicast information</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>&a.pds;</term>

            <listitem>
              <para>FreeBSD FAQ 這份文件的打字苦工</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>The FreeBSD Team</term>

            <listitem>
              <para>Kvetching, moaning, submitting data</para>

            </listitem>
          </varlistentry>
        </variablelist>

    <para>對於那些曾經對這份 FAQ 提供幫助，而我們沒提到的人們，
      我們由衷的感謝您！</para>
  </chapter>


  <chapter id="ports">
    <chapterinfo>
      <author>
	<firstname>Yi-Feng</firstname>
	<surname>Tzeng</surname>
	<affiliation>
	  <address><email>yftzeng@iis.sinica.edu.tw</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>Ports and Packages 常見問題</title>

    <qandaset>
      <qandaentry>
        <question id="make-fetch">
	  <para>如何只抓取 tarball？</para>
	</question>

	<answer>
	  <para>如果只希望抓取 tarball 下來的話，僅需輸入以下指令即可：
	    <screen>&prompt.root; <userinput>make fetch</userinput></screen>
	    如果是要抓取單一的 port，以
	    <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

	  <para>那麼，預設會將 <filename role="package">editors/joe</filename>
	    的 tarball 下載至 <filename>/usr/ports/distfiles</filename>
	    目錄下。</para>

	  <para>如果是希望抓取安裝此 ports 所有相關相依 ports 的 tarball，以
	    <filename role="package">systuils/portupgrade</filename> 為例的話，
	    則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/systuils/portupgrade</userinput>
&prompt.root; <userinput>make fetch-recursive</userinput></screen>

	  <para>預設會將此 port 與所有需要的其他 port 的 tarball，下載至
	    <filename>/usr/ports/distfiles</filename> 目錄下。</para>

	  <para>如果是希望抓取全部所有 ports 的 tarball ，則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

	  <para>則會所將全部所有 ports 的 tarball 下載至
	    <filename>/usr/ports/distfiles</filename> 目錄下。</para>

	  <para>如果是希望抓取 ftp 分類下所有 ports 的 tarball ，則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp</userinput>
&prompt.root; <userinput>make fetch-recursive</userinput></screen>

	  <para>則會所將 ftp 分類下所有 ports 的 tarball 都下載至
	    <filename>/usr/ports/distfiles</filename> 目錄下。</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="make-extract">
	  <para>如何僅做到解開 tarball的步驟？</para>
	</question>

	<answer>
	  <para>有時候習慣自己 patch 原始碼的時候，會很常用到這個功能。以
	    <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput>
&prompt.root; <userinput>make extract</userinput></screen>

	  <para>會將 tarball解開至
	    <filename>/usr/ports/editors/joe/work</filename> 目錄下。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-patch">
	  <para>如何僅做到解開 tarball 並補上官方提供的 patch ？</para>
	</question>

	<answer>
	  <para>此法與 <link linkend="make-extract">make extract</link>
	    的方法有一些類似，不同於是先補上官方提供的 patch，再行 patch
	    自己的修正。  有時候習慣自己 patch 原始碼的時候，
	    則這個方式正好符合您的需求。
	    以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make patch</userinput></screen>

	  <para>會將 tarball解開至 <filename>/usr/ports/editors/joe/work</filename> 目錄下
	    ，並補上官方提供的 patch。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-install">
	  <para>如何安裝一個新的 port？</para>
	</question>

	<answer>
	  <para>如果系統上未安裝此軟體，則可以選擇安裝一個新的 port。
	    以 <filename role="package">editors/joe</filename> 為例的話，則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make install</userinput></screen>

	  <para>如此會在系統上安裝一個新的 joe 軟體。
	    如果需要在安裝完成後，一併清除編輯時期所留下來的暫存目錄，則可配合 <userinput>make clean</userinput> 的方法一起使用，如：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean</userinput></screen>

	  <para>如果想要一次清掉所有 ports 產生的暫存資料，則只要回到 ports 的根目錄執行即可：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-package">
	  <para>如何安裝一個新的 port，並打包(package)起來？</para>
	</question>

	<answer>
	  <para>將安裝完成的軟體打包起來，有許多便利性：包括在叢集系統中，可供其它機器使用，
	    或將未來此軟體出問題可重新利用此 package 重新快速安裝。
	    以 <filename role="package">editors/joe</filename> 為例的話，則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make package</userinput></screen>

	  <para>如此會在系統上安裝一個新的 joe 軟體，並將此軟體打包(package)起來。
	    package 預設會在 <filename>/usr/ports/editors/joe</filename> 目錄下，如果希望集中管理的話，建議做如下的步驟：</para>

	  <screen>&prompt.root; <userinput>mkdir -p /usr/ports/packages</userinput></screen>

	  <para>以後打包的 packages 都會存放在此目錄下，並且系統會自動做分類，以方便管理。
	    如果需要在安裝完成後，一併清除編輯時期所留下來的暫存目錄，則可配合 make clean 一起使用，如：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make package clean</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-depend-package">
	  <para>如何打包一個 port，並將其所有相依的 ports 也打包起來？</para>
	</question>

	<answer>
	  <para>因為 <link linkend="make-package">make package</link> 只有打包單一套件，
	    中間依賴的 ports 並沒有一起打包，這會出現一個常遇到的問題：
	    就是如果一個 port 需要依賴其它的 ports，那麼必須將其它 ports 也一起打包，否則安裝 packages 會有相依性的問題。
	    以 <filename role="package">sysutils/portupgrade</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/portupgrade</userinput></screen>
	  <screen>&prompt.root; <userinput>make DEPENDS_TARGET=package package</userinput></screen>

	  <para>如此會對所有 portupgrade 所相依賴的 ports 都一併打包，也包括自己本身。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-create">
	  <para>如何對一個已經安裝的 port 打包？</para>
	</question>

	<answer>
	  <para>如果安裝好一個套件，事前並未打包，事後想打包的話，則：
	    以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /var/db/pkg</userinput></screen>
	  <screen>&prompt.root; <userinput>pkg_create -b joe-{版本號}</userinput></screen>

	  <para>會將已安裝的 port 打包起來，放在 <filename>/var/db/pkg</filename> 目錄下。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-clean">
	  <para>如何清理 ports 編輯期間所產生的暫存資料？</para>
	</question>

	<answer>
	  <para>在安裝 port 的時候，會有編譯期間所需要的工作目錄(work)，因此通常安裝好一個套件後，會清除此暫存目錄，以節省硬碟空間。
	    以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean</userinput></screen>

	  <para>如果是希望清除所有 ports 的暫存目錄，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean</userinput></screen>

	  <para>如果是希望清除所有 ftp 分類的暫存目錄，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-distclean">
	  <para>如何清理 ports 編輯期間所產生的暫存資料，以及 tarball 檔？</para>
	</question>

	<answer>
	  <para>在 <link linkend="make-clean">make clean</link> 僅只是清除編輯期間所需要的工作目錄(work)，並沒有將編譯
	    ports 時一併下載的 tarball 刪除(相對應之 tarball 預設會存放在 <filename>/usr/ports/distfiles</filename>)
	    如果想把 tarball 一併清除的話，以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make distclean</userinput></screen>

	  <para><userinput>make distclean</userinput> 的步驟包含了 <userinput>make clean</userinput>
	    的功能，也就是說除了會刪除 tarball 外，還會一併清除編譯時的暫存 work 目錄。</para>

	  <para>如果是希望清除所有 ports 的暫存 work 目錄及 tarball，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make distclean</userinput></screen>

	  <para>而如果是希望清除所有 ftp 分類的 work 目錄及 tarball，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp</userinput></screen>
	  <screen>&prompt.root; <userinput>make distclean</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-depends-list">
	  <para>如何在安裝 ports 前查詢所依賴的相關套件？</para>
	</question>

	<answer>
	  <para>在安裝 ports 前，可以查詢所依賴的相關套件。
	    以 <filename role="package">mail/p5-Mail-SpamAssassin</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/mail/p5-Mail-SpamAssassin</userinput></screen>
	  <screen>&prompt.root; <userinput>make all-depends-list</userinput></screen>
	  <para><userinput>make all-depends-list</userinput> 顯示此套件所有相依的套件。</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/mail/p5-Mail-SpamAssassin</userinput></screen>
	  <screen>&prompt.root; <userinput>make pretty-print-build-depends-list</userinput></screen>
	  <para><userinput>make all-depends-list</userinput> 顯示此套件在編譯期間所需要的套件。</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/mail/p5-Mail-SpamAssassin</userinput></screen>
	  <screen>&prompt.root; <userinput>make pretty-print-run-depends-list</userinput></screen>
	  <para><userinput>make all-depends-list</userinput> 顯示此套件要執行時所需要的套件。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-deinstall">
	  <para>如何移除已安裝的 ports？</para>
	</question>

	<answer>
	  <para>以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make deinstall</userinput></screen>

	  <para>或是使用 <userinput>pkg_delete</userinput>：</para>
	  <screen>&prompt.root; <userinput>pkg_delete joe-{version}</userinput></screen>

	  <para>有時候套件之間的相依性會導致無法直接移除，如果要強制移除的話，則：</para>
	  <screen>&prompt.root; <userinput>pkg_delete -f joe-{version}</userinput></screen>
	  <para>但請注意：很有可能會導致其它相依到這軟體的套件執行起來出現問題。</para>
	  <para>至於二者的差別，請參考 <link linkend="deinstall-vs-pkg-delete">make deinstall 與 pkg_delete 有什麼不同</link></para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-deinstall-depends">
	  <para>如何一併移除所相依的 ports？</para>
	</question>

	<answer>
	  <para>以 <filename role="package">sysutils/portupgrade</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/portupgrade</userinput></screen>
	  <screen>&prompt.root; <userinput>make deinstall-depends</userinput></screen>

	  <para>執行此步驟前，請注意是否會移除其他套件也有共同相依的部分。建議先參考
	    <link linkend="make-depends-list">make-depends-list</link> 的方法來檢查。</para>

          <para>或是使用</para>
	  <screen><userinput>pkg_delete</userinput></screen>
	  <para>這樣若仍有相依該套件的話，會先警告而不會移除。除非有另外加了 -f 參數來強制移除。</para>
	  <screen>&prompt.root; <userinput>pkg_delete -r portupgrade-{version}</userinput></screen>
	  <para>至於二者的差別，請參考 <link linkend="deinstall-vs-pkg-delete">make deinstall 與 pkg_delete 有什麼不同</link></para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-reinstall">
	  <para>如何重新安裝已安裝過的 ports？</para>
	</question>

	<answer>
	  <para>重新安裝的前提是：之前有安裝過或目前已安裝。以 <filename role="package">editors/joe</filename> 為例：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make deinstall clean install</userinput></screen>

	  <para>或是</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make reinstall</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-search">
	  <para>如何以關鍵字搜尋 ports？</para>
	</question>

	<answer>
	  <para>如果要從全部的 ports collection 中找尋與關鍵字 "ldap" 有關的 ports，則：</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make search key=ldap</userinput></screen>

	  <para>如果只要從與 ftp 相關的 ports 下找尋與關鍵字 "ldap" 有關的 ports，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp</userinput></screen>
	  <screen>&prompt.root; <userinput>make search key=ldap</userinput></screen>

	  <para>還有另一個用法，方法只是將 key 換成 name。如果已經知道要搜尋 ports 的名稱，或只想找名稱相關的關鍵字 "ldap"， 則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make search name=ldap</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="upgrade-ports">
	  <para>如何升級已安裝的 ports？</para>
	</question>

	<answer>
	  <para>如果已經安裝套件，事後欲升級的話，必須先移除舊版的 port。以 <filename role="package">editors/joe</filename> 為例：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make clean reinstall</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-info">
	  <para>如何查詢目前系統安裝了哪些套件？</para>
	</question>

	<answer>
	  <para>查詢目前系統已安裝的全部套件：</para>

	  <screen>&prompt.root; <userinput>pkg_info</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-info-grep">
	  <para>如何查詢目前系統有沒有安裝這個關鍵字的套件？</para>
	</question>

	<answer>
	  <para>假設要找的關鍵字是 joe 的話：</para>
	  <screen>&prompt.root; <userinput>pkg_info | grep joe</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-info-W">
	  <para>如何查詢某個檔案是屬於哪些套件？</para>
	</question>

	<answer>
	  <para>如果想查詢 <filename>/usr/local/bin/joe</filename> 是屬於哪個套件的話，則：</para>
	  <screen>&prompt.root; <userinput>pkg_info -W /usr/local/bin/joe</userinput></screen>
	  <para>如果沒有回傳任何資訊的話，代表著這個檔案是由 FreeBSD 內建的。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-info-L">
	  <para>如何查詢某個套件安裝了哪些檔案？</para>
	</question>

	<answer>
	  <para>如果想查詢目前系統所安裝的 <filename role="package">joe</filename> 包含了哪些檔案，則：</para>
	  <screen>&prompt.root; <userinput>pkg_info -L /var/db/pkg/joe-{version}</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="reinstall-upgrade">
	  <para>如何安裝舊版的 ports？</para>
	</question>

	<answer>
	  <para>有時候會因為相依性，或是新版有問題，而會想裝舊版本的套件。
	    這裡介紹的方法是利用 CVS 的好處，回歸到以前舊版本存在的日子，以安裝舊版本的套件。</para>

	  <para>首先，若我們要回復到某一個套件的版本時，需要去查詢 FreeBSD ports CVS repository。
	    最常見的就是 <ulink url="http://www.freshports.org/">Freshports</ulink> 網站、 FreeBSD 的
	    <ulink url="http://lists.freebsd.org/pipermail/cvs-all/">Mailing FreeBSD cvs</ulink> 或是 FreeBSD
	    <ulink url="http://www.freebsd.org/cgi/cvsweb.cgi/ports/">ports cvsweb</ulink>。</para>

	  <para>查到該套件版本所依存的日子後，就修改 CVS tag。一般預設 ports 的 CVS tag 會寫在 <filename>/usr/share/examples/cvsup/ports-supfile</filename>
	    ，如要回溯到 2002/10/05 號的話，則：</para>
	  <screen>&prompt.root; <userinput>vi /usr/share/examples/cvsup/ports-supfile</userinput></screen>
	  <screen>*default date=2002.10.05.00.00.00  #將 date 改成當日</screen>

	  <para>然後按照一般 CVSup 或 csup 的時候一樣，執行 CVSup 或 csup (make update)，此時的
	  ports collections 就會回到當時的情形，那麼該套件的舊版也會出現在 ports collections 中，只要安裝即可。</para>

	  <para>如果僅是想回溯某部份的 ports，則必須加上額外的資訊，如僅希望把 <filename role="package">lang/perl5.8</filename> 回溯，
	  而我們得知此屬於 lang 中的一支，則：</para>
	  <screen>&prompt.root; <userinput>vi /usr/share/examples/cvsup/ports-supfile</userinput></screen>
	  <screen>#ports-all #將 ports-all 標示起來</screen>
	  <screen>ports-lang #加入這行</screen>
	  <para>最後，執行 CVSup 或 csup ，並安裝即可。目前若希望單獨回溯單一的 port，則比較麻煩。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="upgrade-ports-mk">
	  <para>如何更新 ports Mk？</para>
	</question>

	<answer>
	  <para>Mk (<filename>/usr/ports/Mk</filename>) 是編譯 ports 時所參考的設定，有時若發生 ports collections 太新，而導致 Mk 的內容不符，此時就是應該更新 Mk 的時候了。</para>
	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
	<screen>&prompt.root; <userinput>make update</userinput></screen>
	<screen>&prompt.root; <userinput>cd /usr/src/share/mk</userinput></screen>
	<screen>&prompt.root; <userinput>make install</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-use-sed-inplace">
	  <para>如何解決安裝 ports 時出現 sed -i 的錯誤？</para>
	</question>

	<answer>
		<para>因為 BSD style 的 sed ，也就是 BSD 本身自有的 sed ，與一些 ports 編譯期間所執行的 sed 不一致，所以會導致一些語法錯誤。此時先安裝 sed_inplace (<filename role="package">textproc/sed_inplace</filename>)，然後再安裝原本無法安裝的 ports：</para>
	  <screen>&prompt.root; <userinput>make -DUSE_REINPLACE install</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-version">
	  <para>如何列出所有可以升級的 ports？</para>
	</question>

	<answer>
	  <para>ports collection 的更新速度很快，在每次更新 ports collections 後，往往會出現比目前現
		在安裝的套件還新的版本，可以令系統自行整理並提供可升級套件的列表：</para>
	  <screen>&prompt.root; <userinput>pkg_version -c</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="grep-defined-makefile">
	  <para>如何得知 ports 所提供的編譯參數？</para>
	</question>

	<answer>
	  <para>所有的 ports collections 中所提供的編譯參數都會在對應的 Makefile 檔案內詳述，
		  如 <filename role="package">sysutils/portupgrade</filename> 的話，則是位在 <filename>/usr/ports/sysutils/portupgrade/Makefile</filename>
		檔案下。</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/portupgrade</userinput></screen>
	  <screen>&prompt.root; <userinput>make -DNOPORTDOCS install</userinput></screen>

	  <para>那麼安裝此 ports 時，會將 NOPORTDOCS 所對應的相關參數指定進去。</para>
	  <para>有時候設定較人性化的 ports 會在安裝前提供參數供選擇，但是其實大部份的 ports 都沒有提
		  供，因此必須自行去搜尋可編譯的參數，在此我提供的方式如下：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/portupgrade</userinput></screen>
	  <screen>&prompt.root; <userinput>grep defined Makefile</userinput></screen>

	  <para>如此幾乎可以知道所有提供的可編譯參數，雖然有時會多出其它的資料，不會這個確實是一個不
		  錯可參考的方式。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-configure-args">
	  <para>如何手動加入編譯 ports 的參數？</para>
	</question>

	<answer>
	  <para>在 <link linkend="grep-defined-makefile">前面所述</link> 的方法，是 ports collections 有提供的前提之下，有時候並不是所有該軟體所支援的參數都會收納在 ports collections 中，因此有時候會需要手動加入編譯的參數。</para>
	  <para>如 ftp/pure-ftpd 中，如果不想把 inetd 的支援編入的選項，並沒有被 ports collections 所納入，因此必須手動加上這個編譯參數，如下：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp/pure-ftpd</userinput></screen>
	  <screen>&prompt.root; <userinput>make CONFIGURE_ARGS+="--without-inetd" install</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-prefix">
	  <para>如何指定 ports 的安裝路徑？</para>
	</question>

	<answer>
	  <para>預設 ports collecions 已安排安裝的路徑 (<filename>/usr/local/</filename>)，如果不想將套件安裝在預設路徑的話，可以手動指定安裝路徑。以 <filename role="package">editors/joe</filename> 為例，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/editors/joe</userinput></screen>
	  <screen>&prompt.root; <userinput>make PREFIX=/usr install</userinput></screen>
	  <para>那麼 joe 就會將檔案對應在 /usr 目錄下，而不是預設的 /usr/local 目錄下。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="force-pkg-register">
	  <para>安裝 ports 出現 FORCE_PKG_REGISTER 的錯誤訊息</para>
	</question>

	<answer>
	  <para>請參考 Ohaha 的 <ulink url="http://ohaha.ks.edu.tw/faq-0003.htm">FAQ</ulink>。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="shared-object-not-found">
	  <para>安裝 ports 出現 Shared object libintl.so.X not found 的錯誤訊息</para>
	</question>

	<answer>
	  <para>請參考 Ohaha 的 <ulink url="http://ohaha.ks.edu.tw/faq-0004.htm">FAQ</ulink>。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-add">
	  <para>如何安裝 packages？</para>
	</question>

	<answer>
	  <para>目前 FreeBSD 的 packages 是由 .tgz 所打包。如果想安裝一個 packages ，可使用 pkg_add，如安裝一個 joe 的 tgz：</para>
	  <screen>&prompt.root; <userinput>pkg_add joe-{version}.tgz</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-add-force">
	  <para>如何強制安裝 packages？</para>
	</question>

	<answer>
	  <para>由於有些 packages 會有與其他 packages 相依性的關係，所以必須先行安裝那些 packages 才
能正常安裝。</para>
	  <para>如果須要強制安裝 packages ，可以不須安裝那些有相依性 packages ，但要注意的是強制安裝
的結果可能會導致執行或運作的不正常。強制安裝 packages 的指令如下，如強制安裝一個 joe 的 tgz：</para>
	  <screen>&prompt.root; <userinput>pkg_add -f joe-{version}.tgz</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-info-r">
	  <para>如何查詢 packages 與其他 packages 之間的相依性？</para>
	</question>

	<answer>
	  <para>由於有些 packages 會有與其他 packages 相依性的關係，所以必須先行安裝那些 packages 才
能正常安裝。</para>
	  <para>查詢 packages 與其他 packages 之間的相依性的指令如下，如查詢與 portupgrade 相依的其他 packages：</para>
	  <screen>&prompt.root; <userinput>pkg_info -r portupgrade-{version}.tgz</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="pkg-add-r">
	  <para>如何安裝遠端的 packages？</para>
	</question>

	<answer>
	  <para>有兩種設定方式，首先是 PACKAGEROOT，如：</para>
	  <screen>&prompt.root; <userinput>setenv PACKAGEROOT ftp://ftp.tw.freebsd.org</userinput></screen>

	  <para>另一種方式是設定 PACKAGESITE，好處是若該站台的 packages 倉儲並不是符合官方的設定或你
想自己指定一個路徑。</para>
	  <para>以 ftp.tw.freebsd.org i386 的 current pakcages 為例：</para>
	  <screen>&prompt.root; <userinput>setenv PACKAGESITE ftp://ftp.tw.freebsd.org/pub/FreeBSD/ports/i386/packages-current/Latest/</userinput></screen>

	  <para>兩種方式選擇其中一種皆可，接下來的步驟都一樣。</para>
	  <para>往後要安裝 packages 的時候，如 portupgrade 的話，則：</para>
	  <screen>&prompt.root; <userinput>pkg_add -r portupgrade</userinput></screen>

	  <para>則系統會自動於 ftp.tw.freebsd.org 抓取所有與 portupgrade 相依的 packages 並安裝。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-index">
	  <para>如何更新 INDEX 對照表？</para>
	</question>

	<answer>
	  <para>4.x 的 INDEX 位於 <filename>/usr/ports/INDEX</filename>，5.x 位於 <filename>/usr/ports/INDEX-5</filename>，以此類推。</para>
	  <para>INDEX 是對照 ports 所有相依等資訊的對照表，若長期未更新的話，會導致 ports 對照失敗。
官方有定期更新 INDEX，如果想自行更新的話，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make index</userinput></screen>

	  <para>如果想直接下載官方最新的 INDEX，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make fetchindex</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="make-readmes">
	  <para>如何更新 INDEX HTML？</para>
	</question>

	<answer>
	  <para>FreeBSD 提供了用網頁的方式來觀看 ports collection，即可使用 lynx, w3m, links 或其它可瀏覽網頁的程式來查閱。製作全部 ports collection 的方式如下：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports</userinput></screen>
	  <screen>&prompt.root; <userinput>make readmes</userinput></screen>

	  <para>如果是僅須要做目前目錄下的資訊，或單一更新某一分類下的資訊，如 /usr/ports/ftp 的話，則：</para>
	  <screen>&prompt.root; <userinput>cd /usr/ports/ftp</userinput></screen>
	  <screen>&prompt.root; <userinput>make readme</userinput></screen>
	  <para>則僅會更新 /usr/ports/ftp 這個目錄的資訊，其上與其下的目錄皆不會更動到。執行成功後，會在相對應的目錄下產生 README.html 的檔案。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="sup-refuse">
	  <para>如何針對某些 ports 不做 ports update？</para>
	</question>

	<answer>
	  <para>若 ports 底下的某些分類完全用不到，則可以在 ports update 時，不做更新，以節省網路頻寬與時間。只要修改 <filename>/usr/sup/refuse</filename> 這個檔。</para>
	  <screen>&prompt.root; <userinput>ports/french</userinput></screen>
	  <screen>&prompt.root; <userinput>ports/german</userinput></screen>
	  <screen>&prompt.root; <userinput>ports/lang/perl5.8</userinput></screen>
	  <para>則上列目錄將不會更新。</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="deinstall-vs-pkg-delete">
	  <para>make deinstall 與 pkg_delete 有什麼不同？</para>
	</question>

	<answer>
	  <para>簡單來說，make deinstall 會移除該 port，並且不會參照其相依的相關套件。</para>
	  <para>pkg_delete 在移除該 port 前，會參照其相依的相關套件，並且 pkg_delete 有支援 wild card ，如要移除所有 p 開頭的 ports，則：</para>
	  <screen>&prompt.root; <userinput>cd /var/db/pkg</userinput></screen>
	  <screen>&prompt.root; <userinput>pkg_delete p*</userinput></screen>

	  <para>要注意的是，如果使用 make deinstall，則最好確定系統目前所安裝的版本，與 ports collection 中顯示的版本符合，否則有可能會出現非預期性錯誤；而 pkg_delete 是因為直接
刪除系統中所安裝的版本，所以沒有此問題。</para>
	  <para>因此，換句話說，當系統所安裝的版本符合 ports collections 中的版本，則可以使用 make deinstall 或 pkg_delete，否則的話最好用 pkg_delete。</para>
	</answer>
      </qandaentry>

    </qandaset>
  </chapter>

  &bibliography;
</book>
