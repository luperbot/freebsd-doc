<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>3.3. Permisos</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Manual de FreeBSD" /><link rel="up" href="basics.html" title="Capítulo 3. Conceptos básicos de Unix" /><link rel="prev" href="consoles.html" title="3.2. Consolas virtuales y terminales" /><link rel="next" href="dirstructure.html" title="3.4. Estructura de directorios" /><link rel="copyright" href="legalnotice.html" title="Aviso Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. Permisos</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="consoles.html">Anterior</a> </td><th width="60%" align="center">Capítulo 3. Conceptos básicos de Unix</th><td width="20%" align="right"> <a accesskey="n" href="dirstructure.html">Siguiente</a></td></tr></table><hr /></div><div class="sect1"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="permissions"></a>3.3. Permisos</h2></div></div></div><a id="idp69120080" class="indexterm"></a><p>FreeBSD, cuya raíz histórica es el <span class="trademark">UNIX</span>® BSD,
      se fundamenta en varios conceptos clave de UNIX. El primero y
      más importante es que FreeBSD es un sistema operativo
      multi-usuario.  El sistema puede gestionar múltiples usuarios
      trabajando simultáneamente y en tareas que no guarden relación
      entre sí.  El sistema se encarga de compartir y administrar
      peticiones de dispositivos de hardware, periféricos, memoria y
      tiempo de CPU de manera equitativa para cada usuario.</p><p>Debido a que el sistema es capaz de soportar múltiples
      usuarios, todo lo que el sistema administra tiene un conjunto de
      permisos que usa para decidir quién puede leer, escribir y
      ejecutar un recurso.  Estos permisos se guardan como octetos
      divididos en tres partes: una para el propietario del fichero, otra
      para el grupo al que el fichero pertenece, y otra para todos los
      demás grupos y usuarios.  Veamos una
      representación numérica de esto:</p><a id="idp69122000" class="indexterm"></a><a id="idp69122512" class="indexterm"></a><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Valor</th><th>Permiso</th><th>Listado de directorio</th></tr></thead><tbody><tr><td>0</td><td>No leer, no escribir, no ejecutar</td><td><code class="literal">---</code></td></tr><tr><td>1</td><td>No leer, no escribir, ejecutar</td><td><code class="literal">--x</code></td></tr><tr><td>2</td><td>No leer, escribir, no ejecutar</td><td><code class="literal">-w-</code></td></tr><tr><td>3</td><td>No leer, escribir, ejecutar</td><td><code class="literal">-wx</code></td></tr><tr><td>4</td><td>Leer, no escribir, no ejecutar</td><td><code class="literal">r--</code></td></tr><tr><td>5</td><td>Leer, no escribir, ejecutar</td><td><code class="literal">r-x</code></td></tr><tr><td>6</td><td>Leer, escribir, no ejecutar</td><td><code class="literal">rw-</code></td></tr><tr><td>7</td><td>Leer, escribir, ejecutar</td><td><code class="literal">rwx</code></td></tr></tbody></table></div><a id="idp69152592" class="indexterm"></a><a id="idp69153488" class="indexterm"></a><p>Puede utilizar el parámetro de línea de órdenes
      <code class="option">-l</code> de <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> para ver un listado
      largo que incluya una columna con información acerca
      de los permisos de fichero para el propietario, grupo y
      los demás.  Por ejemplo, un <code class="command">ls -l</code> en
      un directorio puede mostrar algo como esto:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>ls -l</code></strong>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 mifichero
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otrofichero
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</pre><p>Aquí está como se divide la primera columna
      de <code class="command">ls -l</code>:</p><pre class="screen">-rw-r--r--</pre><p>El primer caracter (más a la izquierda) indica si
      este fichero es un fichero regular, un directorio, un
      dispositivo especial de caracter, un socket o cualquier otro
      dispositivo especial pseudo-ficheroa . En este caso, el
      <code class="literal">-</code> un fichero regular.  Los siguientes tres
      caracteres, <code class="literal">rw-</code> en este ejemplo, dan los permisos
      para el propietario del fichero.  Los siguientes tres caracteres,
      <code class="literal">r--</code>, dan los permisos para el grupo al que
      el fichero pertenece.  Los últimos tres caracteres,
      <code class="literal">r--</code>, dan los permisos para el resto del
      mundo.  Un guión indica que el permiso está desactivado.
      En el caso de este fichero, los permisos están
      asignados de tal manera que el propietario puede leer y escribir
      en el fichero, el grupo puede leer el fichero, y el resto del
      mundo sólo puede leer el fichero.  De acuerdo con la tabla
      de arriba, los permisos para este fichero serían
      <code class="literal">644</code>,
      donde cada dígito representa las tres partes de los
      permisos del fichero.</p><p>Todo ésto está muy bien, pero ?cómo
      controla el sistema los permisos de los dispositivos? FreeBSD en
      realidad trata la mayoría de los dispositivos hardware como un
      fichero que los programas pueden abrir, leer y en los que pueden
      escribir datos como si de cualquier otro fichero se tratara.  Estos
      ficheros especiales de dispositivo se encuentran en el directorio
      <code class="filename">/dev</code>.</p><p>Los directorios también son tratados como ficheros.  Tienen
      permisos de lectura, escritura y ejecución.  El bit de
      ejecución en un directorio tiene un significado
      ligeramente distinto que para los ficheros.  Cuando un directorio
      está marcado como ejecutable significa que se puede mirar dentro,
      se puede hacer un «cd» (cambiar directorio) a él.
      Esto también significa que dentro del directorio es posible
      acceder a ficheros cuyos nombres son conocidos (sujeto, claro está,
      a los permisos de los ficheros mismos).</p><p>En particular, para poder realizar un listado de directorio,
      el permiso de lectura debe ser activado en el directorio,
      mientras que para borrar un fichero del que se conoce el
      nombre es necesario tener permisos de escritura <span class="emphasis"><em>y</em></span>
      ejecución en el directorio que contiene el fichero.</p><p>Existen más permisos, pero se usan principalmente en
      circunstancias especiales como los binarios ejecutables de tipo setuid
      y los los directorios de tipo «sticky».  Si desea más
      información acerca de los permisos de ficheros y cómo
      establecerlos, consulte <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a>.
      </p><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp69168080"></a>3.3.1. Permisos simbólicos</h3></div><div><span class="authorgroup">Escrito por <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Tom</span> <span class="surname">Rhodes</span></span>. </span></div></div></div><a id="idp69170640" class="indexterm"></a><p>Los permisos simbólicos, también conocidos como
        expresiones simbólicas, utilizan caracteres en lugar de valores
        octales para asignar permisos a ficheros o directorios.  Las expresiones
        simbólicas utilizan la sintaxis de (quién) (acción)
        (permisos) mediante los siguientes valores:</p><div class="informaltable"><table width="100%" border="0"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Opción</th><th>Letra</th><th>Representa</th></tr></thead><tbody><tr><td>(quién)</td><td>u</td><td>Usuario</td></tr><tr><td>(quién)</td><td>g</td><td>Grupo propietario</td></tr><tr><td>(quién)</td><td>o</td><td>Otro</td></tr><tr><td>(quién)</td><td>a</td><td>Todos («todo el mundo»)</td></tr><tr><td>(acción)</td><td>+</td><td>Añadir permisos</td></tr><tr><td>(acción)</td><td>-</td><td>Quitar permisos</td></tr><tr><td>(acción)</td><td>=</td><td>Activar permisos explícitamente</td></tr><tr><td>(permisos)</td><td>r</td><td>Lectura</td></tr><tr><td>(permisos)</td><td>w</td><td>Escritura</td></tr><tr><td>(permisos)</td><td>x</td><td>Ejecución</td></tr><tr><td>(permisos)</td><td>t</td><td>Bit Sticky («pegajoso»)</td></tr><tr><td>(permisos)</td><td>s</td><td>Activar UID o GID</td></tr></tbody></table></div><p>Estos valores se aplican con <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chmod&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chmod</span>(1)</span></a>
      de la misma manera que los anteriores, pero con letras.  Por
      ejemplo, podría usar la siguiente orden para
      bloquear a otros usuarios el acceso a <em class="replaceable"><code>FICHERO</code></em>:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>chmod go= FICHERO</code></strong></pre><p>Puede usarse una lista separada por comas cuando
      se quiera aplicar más de un conjunto de cambios a un fichero.
      Por ejemplo la siguiente orden eliminará los permisos de
      escritura de grupo y «mundo» a
      <em class="replaceable"><code>FICHERO</code></em>, y añade permisos de
      ejecución para todos:</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>chmod go-w,a+x FILE</code></strong></pre></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp69202640"></a>3.3.2. Banderas de fichero en FreeBSD</h3></div><div><span class="authorgroup">Escrito por <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Tom</span> <span class="surname">Rhodes</span></span>. </span></div></div></div><p>Además de los permisos de fichero previamente
        expuestos, FreeBSD permite el uso de «banderas de
        fichero». Estas banderas añaden un nivel de seguridad
        y control adicional a los ficheros, pero no a los directorios.</p><p>Las banderas de fichero añaden un nivel adicional
        de control sobre los ficheros ayudando a asegurar que en algunos
        casos ni siquiera <code class="systemitem">root</code> pueda eliminar
        o alterar ficheros.</p><p>Las banderas de fichero se modifican mediante
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chflags&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chflags</span>(1)</span></a>, gracias a una interfaz muy sencilla. Por ejemplo,
        para habilitar la bandera imborrable de sistema en
        <code class="filename">fichero1</code>, escriba lo siguiente:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chflags sunlink fichero1</code></strong></pre><p>Y para dehabilitar la bandera imborrable de sistema,
        simplemente escriba la orden previa con «no»
        antes de <code class="option">sunlink</code>. Observe:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chflags nosunlink fichero1</code></strong></pre><p>Para ver las banderas de este fichero, utilice
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=ls&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">ls</span>(1)</span></a> con las opciones <code class="option">-lo</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ls -lo fichero1
	</code></strong></pre><p>La salida debería ser como esta:</p><pre class="programlisting">-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 fichero1</pre><p>Varias banderas solo pueden ser añadidas o retiradas
        de ficheros por el usuario <code class="systemitem">root</code>. En
        otros casos, el propietario del fichero puede activar estas
        banderas. Se recomienda que para más información
        la persona encargada de la administración del sistema
        consulte las  páginas de manual <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chflags&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">chflags</span>(1)</span></a> y
        <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=chflags&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">chflags</span>(2)</span></a>.</p></div><div class="sect2"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp69228880"></a>3.3.3. Los permisos <code class="literal">setuid</code>,
        <code class="literal">setgid</code> y <code class="literal">sticky</code></h3></div><div><span class="authorgroup">Escrito por <span xmlns="http://www.w3.org/1999/xhtml" class="author"><span class="firstname">Tom</span> <span class="surname">Rhodes</span></span>. </span></div></div></div><p>Además de los permisos que se han explicado hay
        más, hay tres tipos más que todos los administradores
	deberían conocer.  Son los permisos
	<code class="literal">setuid</code>,
	<code class="literal">setgid</code> y <code class="literal">sticky</code>.</p><p>Estos permisos juegan un papel clave en ciertas operaciones
        <span class="trademark">UNIX</span>® puesto que facilitan funcionalidades que no se suelen
	permitir a los usuarios normales.  Para comprenderlas
	totalmente hay que comprender la diferencia entre el ID real
	del usuario y el ID efectivo.</p><p>El ID del usuario real es el
        <acronym class="acronym">UID</acronym> que arranca (y el propietario) del
	proceso.   El <acronym class="acronym">UID</acronym> efectivo es el ID bajo
	el que se ejecuta el proceso.  Veamos un ejemplo; el programa
	<a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=passwd&amp;sektion=1"><span class="citerefentry"><span class="refentrytitle">passwd</span>(1)</span></a> se ejecuta con el ID real del usuario puesto que
	el usuario está cambiando su contraseña.  Pero para
	poder manipular la base de datos de contraseñas debe
	ejecutarse con el ID efectivo del usuario
	<code class="systemitem">root</code>.  De este modo es posible que los usuarios
	cambien su contraseña sin llegar a ver un error de
	<span class="errorname">Permission Denied</span> (permiso denegado).</p><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">La opción <code class="literal">nosuid</code> de <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>
	  hace que estos binarios den errores silenciosos, es decir,
	  fallarán pero el usuario no recibirá ningún
	  mensaje de error por ello.  Esta opción no funciona
	  siempre, pues, según la página man de
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=mount&amp;sektion=8"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>, un «wrapper»
	  <code class="literal">nosuid</code> puede sortear esta limitación.</p></div><p>El permiso setuid puede asignarse colocando un número
         cuatro (4) antes de los permisos.  Se ve mejor con un ejemplo:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 4755 ejemplosuid.sh</code></strong></pre><p>Los permisos de
	<code class="filename">ejemplosuid.sh</code>
	deberían ser así:</p><pre class="programlisting">-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 ejemplosuid.sh</pre><p>Fíjese atentamente en la
	<code class="literal">s</code> que ha aparecido en los permisos
	del fichero, en la parte de los permisos del propietario;
	esa <code class="literal">s</code> está en donde estaría
	el bit de ejecución.  Gracias a esto el funcionamiento
	de aplicaciones que necesitan permisos elevados, como
	<code class="command">passwd</code>, pueden funcionar.</p><p>Si quiere ver un ejemplo con sus propios ojos abra dos
        terminales.  En una arranque un proceso (ejecute)
	<code class="command">passwd</code> con un usuario normal.  Mientras la
	aplicación espera a que le de una nueva contraseña
	busque la información de usuario del proceso
	<code class="command">passwd</code> en la tabla de procesos.</p><p>En la terminal A:</p><pre class="screen">Changing local password for trhodes
Old Password:</pre><p>En la terminal B:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ps aux | grep passwd</code></strong></pre><pre class="screen">trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</pre><p>Tal y como se ha dicho, un usuario normal puede ejecutar
        <code class="command">passwd</code>, pero en realidad está
	utilizando el <acronym class="acronym">UID</acronym> efectivo de
	<code class="systemitem">root</code>.</p><p>El permiso <code class="literal">setgid</code> actúa del mismo
        modo que el <code class="literal">setuid</code>, pero afecta a los permisos
	del grupo.  Cuando una aplicación funciona con esta
	configuración lo hace con los permisos del grupo al
	que pertenece el fichero, no los del usuario que ha
	arrancado el proceso.</p><p>Si quiere utilizar el permiso <code class="literal">setgid</code>
        debe situar un núnmero dos (2) al principio de los
	permisos que vaya a asignar mediante
	<code class="command">chmod</code>.</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 2755 ejemplosuid.sh</code></strong></pre><p>La nueva configuración tiene un aspecto muy
        similar a la que tenía antes, pero observe que la
	<code class="literal">s</code> de antes está ahora en el campo
	de los permisos de grupo:</p><pre class="screen">-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 ejemplosuid.sh</pre><div xmlns="" class="note"><h3 class="admontitle">Nota: </h3><p xmlns="http://www.w3.org/1999/xhtml">En ambos ejemplos, incluso si el «script»
	  en cuestión es ejecutable, no se va a ejecutar
	  con un
	  <acronym class="acronym">EUID</acronym> distinto o un ID efectivo de
	  usuario porque los «scripts» de shell no
	  pueden acceder a la llama del sistema
	  <a class="citerefentry" href="http://www.FreeBSD.org/cgi/man.cgi?query=setuid&amp;sektion=2"><span class="citerefentry"><span class="refentrytitle">setuid</span>(2)</span></a>.</p></div><p>Los dos permisos que acabamos de mostrar
	los bits de permisos (<code class="literal">setuid</code>
	y <code class="literal">setgid</code>) pueden reducir el nivel
	de seguridad haciendo que se escalen los permisos.
	Pero hay un tercer bit especial de permisos que puede
	ser de mucha ayuda para reforzar la seguridad del
	sistema:
	el <code class="literal">sticky bit</code>.</p><p>El <code class="literal">sticky bit</code>( que podríamos
        traducir como «bit pegajoso») aplicado a un
	directorio hace que solamente el propietario de un fichero
	pueda borrarlo.  Esto evita el borrado de ficheros ajenos
	en directorios públicos como
	<code class="filename">/tmp</code>.  Si quiere
	usarlo coloque un uno (1) antes de los permisos. Veamos
	un ejemplo:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>chmod 1777 /tmp</code></strong></pre><p>Para ver el <code class="literal">;sticky bit</code> en acción usamos
	<code class="command">ls</code>:</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>ls -al / | grep tmp</code></strong></pre><pre class="screen">drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</pre><p>El <code class="literal">sticky bit</code> es la letra
	<code class="literal">t</code> al final de los permisos.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="consoles.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="basics.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="dirstructure.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. Consolas virtuales y terminales </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> 3.4. Estructura de directorios</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Puede descargar éste y muchos otros documentos desde
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Si tiene dudas sobre FreeBSD consulte la
    <a href="http://www.FreeBSD.org/docs.html">documentación</a> antes de escribir a la lista
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Envíe sus preguntas sobre la documentación a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>