<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>Capítulo 11. PPP</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Preguntas más frecuentes de FreeBSD 4.X, 5.X y 6.X" /><link rel="up" href="index.html" title="Preguntas más frecuentes de FreeBSD 4.X, 5.X y 6.X" /><link rel="prev" href="networking.html" title="Capítulo 10. Networking" /><link rel="next" href="serial.html" title="Capítulo 12. Comunicaciones serie" /><link rel="copyright" href="legalnotice.html" title="Aviso Legal" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Capítulo 11. PPP</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="networking.html">Anterior</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="serial.html">Siguiente</a></td></tr></table><hr /></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="ppp"></a>Capítulo 11. PPP</h1></div></div></div><div class="qandaset"><a id="idp68212816"></a><dl><dt>11.1. <a href="ppp.html#idp68213072">El ppp no funciona. ?Qué estoy haciendo mal?</a></dt><dt>11.2. <a href="ppp.html#idp68221392">Ppp se bloquea al ejecutarlo</a></dt><dt>11.3. <a href="ppp.html#idp68235856">PPP no quiere marcar en modo -auto</a></dt><dt>11.4. <a href="ppp.html#idp68245328">?Qué significa "No route to host"?</a></dt><dt>11.5. <a href="ppp.html#idp68251216">Mi conexión se corta pasados 3 minutos</a></dt><dt>11.6. <a href="ppp.html#idp68261712">Mi conexión se corta en situaciones de carga</a></dt><dt>11.7. <a href="ppp.html#idp68264400">Mi conexión se corta en periodos aleatorios</a></dt><dt>11.8. <a href="ppp.html#idp68267856">No ocurre nada después del mensaje Login OK</a></dt><dt>11.9. <a href="ppp.html#idp68280656">Sigo teniendo errores sobre el parámetro magic</a></dt><dt>11.10. <a href="ppp.html#idp68318928">Las negociaciones LCP continuan hasta que se cierra la conexión</a></dt><dt>11.11. <a href="ppp.html#idp68341712">Ppp se bloquea al conectar</a></dt><dt>11.12. <a href="ppp.html#idp68349136">Ppp se bloqua al abrir un shell de test</a></dt><dt>11.13. <a href="ppp.html#idp68366928">Ppp sobre un cable null-modem no funciona</a></dt><dt>11.14. <a href="ppp.html#idp68370512">?Por que llama sin motivo el ppp en modo -auto?</a></dt><dt>11.15. <a href="ppp.html#idp68379216">?Qué significan estos errores CCP?</a></dt><dt>11.16. <a href="ppp.html#idp68383056">PPP se cuelga durante transferencia de archivos con errores I/OP</a></dt><dt>11.17. <a href="ppp.html#idp68390480">?Por que ppp no loguea la velocidad de la conexión?</a></dt><dt>11.18. <a href="ppp.html#idp68400592">Ppp ignora el carácter `\' en mi chat script</a></dt><dt>11.19. <a href="ppp.html#idp68408144">Ppp produce un seg-fault, pero no veo el archivo
        ppp.core</a></dt><dt>11.20. <a href="ppp.html#idp68413008">El proceso que fuerza una llamada en modo auto nunca funciona</a></dt><dt>11.21. <a href="ppp.html#idp68420944">?Porqué muchos juegos no funcionan con el
        parámetro -alias?</a></dt><dt>11.22. <a href="ppp.html#idp68432464">?Ha hecho alguien una lista de puertos útiles?</a></dt><dt>11.23. <a href="ppp.html#idp68453712">?Qué son los errores FCS?</a></dt><dt>11.24. <a href="ppp.html#idp68462160">Nada de esto me ayuda - Estoy desesperado !</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%" /><col /></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="idp68213072"></a><a id="userppp"></a><p><strong>11.1.</strong></p></td><td align="left" valign="top"><p>El ppp no funciona. ?Qué estoy haciendo mal?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Primero deberías leer el
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ppp" target="_top">man de ppp</a> y
        la <a class="link" href="../../handbook/ppp-and-slip.html#USERPPP" target="_top">sección de
        PPP del handbook</a>. Activa los logs con el comando</p><p>
        </p><div class="literallayout"><p><br />
          set log Phase Chat Connect Carrier lcp ipcp ccp command<br />
        </p></div><p>
        </p><p>Este comando debería ser tecleado en el prompt del
        <span class="emphasis"><em>ppp</em></span> o incluirse en el archivo de
        configuración <code class="filename">/etc/ppp/ppp.conf</code>
        (al inicio de la sección <span class="emphasis"><em>default</em></span> es el mejor lugar).
        Asegurate que el archivo
        url="http://www.FreeBSD.org/cgi/man.cgi?syslog.conf"
        name="/etc/syslog.conf"&gt; contiene las siguientes líneas:</p><p>
        </p><div class="literallayout"><p>        !ppp<br />
        *.*              /var/log/ppp.log<br />
        </p></div><p>
        </p><p>y que el archivo <code class="filename">/var/log/ppp.log</code> existe. Puedes
        encontrar mucha información sobre lo que está pasando en las
        conexiones con el archivo de log.</p><p>Si tu versión de ppp no entiende el comando "set log"
        deberías bajarte la
        <a class="link" href="http://www.FreeBSD.org/~brian/" target="_top">última versión</a>.
        Esta compilará sin problemas en FreeBSD 2.1.5 y superiores.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68221392"></a><a id="idp68221648"></a><p><strong>11.2.</strong></p></td><td align="left" valign="top"><p>Ppp se bloquea al ejecutarlo</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Esto ocurre normalmente por que no se puede resolver el nombre
        de la máquina. La mejor manera de solucionar este problema
        es asegurarse que el sistema use en primer lugar el archivo
        <code class="filename">/etc/hosts</code> para hacer la resolución de
        nombres. Para ello, basta con editar el archivo
        <code class="filename">/etc/host.conf</code> y poner la línea
        <span class="emphasis"><em>hosts</em></span> en primer lugar. A
        continuación, simplemente hay que añadir una
        línea para la máquina local en el archivo
        <code class="filename">/etc/hosts</code>. Si no existe una red local, modificar
        la línea <span class="emphasis"><em>localhost</em></span>:</p><p>
        </p><div class="literallayout"><p>127.0.0.1	foo.bar.com foo localhost<br />
        </p></div><p>
        </p><p>Añadir otra línea para la máquina local.
        Consultar las páginas man relevantes para más detalles.</p><p>Ahora se debería poder ejecutar el siguiente mandato de
        forma satisfactoria <code class="command">ping -c1 `hostname`</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68235856"></a><a id="idp68236112"></a><p><strong>11.3.</strong></p></td><td align="left" valign="top"><p>PPP no quiere marcar en modo -auto</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Primero, asegúrate de tener una ruta por defecto. Ejecutando
        el comando url="http://www.FreeBSD.org/cgi/man.cgi?netstat"&gt;
        name="netstat -rn"&gt; deberías ver dos entradas como estas:</p><p>
        </p><div class="literallayout"><p><br />
Destination        Gateway            Flags     Refs     Use     Netif Expire<br />
default            10.0.0.2           UGSc        0        0      tun0<br />
10.0.0.2           10.0.0.1           UH          0        0      tun0<br />
        </p></div><p>
        </p><p>Esto es asumiendo que hayas usado las direcciones del manual,
        la página man o del archivo de ejemplo ppp.conf.sample. Si no
        tienes una ruta por defecto, puede ser por que estés usando una
        versión antigua de <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ppp" target="_top">ppp</a>
        que no entiende la palabra <acronym class="acronym">HISADDR</acronym> en el archivo ppp.conf. Si
        tu versión de <span class="emphasis"><em>ppp</em></span> es de antes de FreeBSD 2.2.5,
        cambia la línea</p><p>
        </p><div class="literallayout"><p>          add 0 0 HISADDR<br />
        </p></div><p>
        </p><p>por otra diciendo</p><p>
        </p><div class="literallayout"><p>          add 0 0 10.0.0.2<br />
        </p></div><p>
        </p><p>Otra razón para la inexistencia de la ruta por defecto es que
        sin darte cuenta hayas creado un default router en el archivo
        /etc/rc.conf (anteriormente llamado <code class="filename">/etc/sysconfig</code>) y
        hayas omitido la línea</p><p>
        </p><div class="literallayout"><p>          delete ALL<br />
        </p></div><p>
        </p><p>en el archivo <code class="filename">ppp.conf</code>.  Si es este el caso vuelve a la
        sección
        <a class="link" href="../../handbook/ppp-and-slip.html#USERPPP-FINAL.html" target="_top">configuración final del sistema</a>
        en el handbook.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68245328"></a><a id="idp68245584"></a><p><strong>11.4.</strong></p></td><td align="left" valign="top"><p>?Qué significa "No route to host"?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Este error se debe normalmente a la falta de la sección</p><p>
        </p><div class="literallayout"><p><br />
            MYADDR:<br />
            delete ALL<br />
            add 0 0 HISADDR<br />
        </p></div><p>
        </p><p>en el archivo <code class="filename">/etc/ppp/ppp.linkup</code>. Esto es solo
        necesario si tienes una direccion IP dinámica o no sabes la
        dirección de tu gateway. Si estás usando el modo
        interactivo, puedes teclear lo siguiente despues de entrar en
        <span class="emphasis"><em>packet mode</em></span>:</p><p>
        </p><div class="literallayout"><p><br />
          delete ALL<br />
          add 0 0 HISADDR<br />
        </p></div><p>
        </p><p>Pásate por la sección
        <a class="link" href="../../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP" target="_top">PPP y direcciones IP dinámicas</a>
        del handbook para más información.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68251216"></a><a id="idp68251472"></a><p><strong>11.5.</strong></p></td><td align="left" valign="top"><p>Mi conexión se corta pasados 3 minutos</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>El timeout de ppp por defecto es de 3 minutos. Se puede ajustar
        con la línea:</p><p>
        </p><div class="literallayout"><p>          set timeout NNN<br />
        </p></div><p>
        </p><p>Donde <acronym class="acronym">NNN</acronym> es el número de segundos de inactividad antes
        de cerrar la conexión. Si <acronym class="acronym">NNN</acronym> es 0, la conexión no
        se cerrará nunca por timeout. Es posible poner este comando en
        el archivo <code class="filename">ppp.conf</code>, o teclearla en el prompt del modo
        interactivo. También es posible ajustarla en cualquier momento mientras la
        conexión esté activa conectando al socket del servidor
        <span class="emphasis"><em>ppp</em></span> usando
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?telnet" target="_top">telnet</a>
        o <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?pppctl" target="_top">pppctl</a>. Leete el man de
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ppp" target="_top">ppp</a>
        para más detalles.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68261712"></a><a id="idp68261968"></a><p><strong>11.6.</strong></p></td><td align="left" valign="top"><p>Mi conexión se corta en situaciones de carga</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Si tienes la opción Link Quality Reporting (LQR) configurada
        es posible que demasiados paquetes LQR se pierdan entre tu
        máquina y el remoto. PPP deduce que la línea es mala y
        corta la conexión. En versiones anteriores a la 2.2.5 de
        FreeBSD, LQR estaba activado por defecto. Ahora está desactivado
        por defecto. LQR puede ser activado con la línea</p><p>
        </p><div class="literallayout"><p>          disable lqr<br />
        </p></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68264400"></a><a id="idp68264656"></a><p><strong>11.7.</strong></p></td><td align="left" valign="top"><p>Mi conexión se corta en periodos aleatorios</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Algunas veces, en líneas telefónicas de baja calidad
        o con mucho ruido, o líneas con la opción de llamada en
        espera activada, el módem corta la conexión por que
        piensa (erróneamente) que ha perdido la portadora.</p><p>Hay una opción en muchos modems para determiar la tolerancia
        a pérdidas temporales de portadora. En un USR Sportster por
        ejemplo, esta es medida por el registro S10 en décimas de
        segundo. Para hacer que tu módem sea más resistente,
        puedes añadir la siguiente secuencia "send-expect" a la cadena
        de llamada:</p><p>
        </p><div class="literallayout"><p>          set dial "...... ATS10=10 OK ......"<br />
        </p></div><p>
        </p><p>Mira en el manual de tu módem para más detalles.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68267856"></a><a id="idp68268112"></a><p><strong>11.8.</strong></p></td><td align="left" valign="top"><p>No ocurre nada después del mensaje Login OK</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>En versiones anteriores a FreeBSD 2.2.5, una vez estaba la
        conexión establecida,
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ppp" target="_top">ppp</a> espera a
        que el remoto inicie la negociación LCP
        (Line Control Protocol). Muchos proveedores de Internet no
        iniciarán la negociación esperando que sea el cliente el
        que lo haga. Para forzar al <span class="emphasis"><em>ppp</em></span> a iniciar el LCP, usa la
        siguiente línea:</p><p>
        </p><div class="literallayout"><p>          set openmode active<br />
        </p></div><p>
        </p><p><span class="emphasis"><em>Nota:</em></span> Normalmente no hay problemas si las dos partes
        inician la negocioacion LCP, ya que el modo abierto (open mode)
        está activo por defecto. De todas maneras, la siguiente
        sección explica cuando pueden haber problemas.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68280656"></a><a id="idp68280912"></a><p><strong>11.9.</strong></p></td><td align="left" valign="top"><p>Sigo teniendo errores sobre el parámetro magic</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ocasionalmente, justo después de la conexión, puedes
        ver mensajes en el log referentes a "magic number is the same".
        Algunas veces, estos mensajes son inofensivos, y otras veces
        uno de los dos extremos finaliza la conexión. Algunas
        implementaciones de ppp no pueden solucionar este problema, y,
        aunque parezca que la conexión está establecida,
        verás repetidas peticiones y aceptaciones de
        configuración en el archivo de log hasta que una de las dos
        partes cierra la conexión.</p><p>Esto ocurre normalmente en servidores con disco lentos que
        tienen problemas para gestionar eficientemente los puertos
        serie. También existen informes de problemas en conexiones
        mediante slip. La razón es que en el tiempo que tarda el
        servidor en salir del getty y ejecutar el ppp, el cliente
        manda los paquetes de inicio LCP. Al estar el ECHO todavía
        activo en el puerto del servidor, el cliente ppp lo único que
        ve son sus propios paquetes "reflejados" por el servidor.</p><p>Una parte de la negociación LCP es establecer un número
        mágico para cada una de los dos extremos de las conexiones para
        que los "reflejos" puedan ser detectados. El protocolo dice que
        cuando el remoto intenta negociar el mismo "magic number", se debe
        enviar un NAK para seleccionar un nuevo "magic number". Durante el
        periodo de tiempo que el servidor tiene el ECHO activado en el
        puerto, el cliente ppp envía paquetes LCP, ve que el mismo
        "magic" vuelve en el paquete reflejado y lo da como no válido
        (envia NAK).
        Este todavía ve el paquete reflajado con NAK (lo que significa
        que el ppp debe cambiar su "magic"). Esto produce un enorme
        número de cambios de "magic number" que son introducidos en el
        buffer tty del servidor. Tan pronto como el ppp arranca en el servidor,
        es bombardeado con cambios de "magic numbers" e inmediatamente decide
        que ya ha realizado el número suficiente de negociaciones LCP y
        corta la conexión. Mientras tanto, el cliente, que ya no ve los
        paquetes reflejados, recibe sin problemas la desconexión del
        servidor y también cierra la conexión.</p><p>Esto puede ser resuelto permitiendo que el remoto inicie la
        negociación, poniendo la siguiente línea en el archivo
        ppp.conf:</p><p>
        </p><div class="literallayout"><p>          set openmode passive<br />
        </p></div><p>
        </p><p>Esto indica al ppp que espere a que el servidor comience la
        negociación LCP. Es posible que algunos servidores nunca inicien
        la negociación. Si este es el caso, puedes hacer algo como:</p><p>
        </p><div class="literallayout"><p>          set openmode active 3<br />
        </p></div><p>
        </p><p>Esto le indica al ppp que sea pasivo durante 3 segundos, y
        despues comience a enviar peticiones LCP. Si el remoto envía
        peticiones durante este periodo, ppp responderá inmediatamente
        sin esperar los 3 segundos establecidos.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68318928"></a><a id="idp68319184"></a><p><strong>11.10.</strong></p></td><td align="left" valign="top"><p>Las negociaciones LCP continuan hasta que se cierra la conexión</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Existe actualmente un problema de implementación en
        <span class="emphasis"><em>ppp</em></span> en la que no asocia las respuestas LCP, CCP
        &amp; IPCP con sus peticiones originales. Como resultado, si una implementación
        <span class="emphasis"><em>ppp</em></span> es más lenta durante 6 segundos que la remota, la remota
        enviará dos peticiones de configuración LCP adicionales.
        Esto es fatal.</p><p>Considera dos implementaciones, <span class="emphasis"><em>A</em></span> y
        <span class="emphasis"><em>B</em></span>. <span class="emphasis"><em>A</em></span> empieza
        a enviar peticiones LCP inmediatamente después de conectar y
        <span class="emphasis"><em>B</em></span> tarda 7 segundos en arrancar. Cuando
        <span class="emphasis"><em>B</em></span> arranca, <span class="emphasis"><em>A</em></span> ha
        enviado 3 peticiones LCP. Estamos asumiendo que la línea tiene el
        ECHO desactivado, si no, veriamos los problemas de "magic number"
        descritos en el apartado anterior. <span class="emphasis"><em>B</em></span> envía un REQ, y a
        continuación envía un ACK al primer REQ de <span class="emphasis"><em>A</em></span>. Esto
        resulta en que <span class="emphasis"><em>A</em></span> entra en modo <acronym class="acronym">OPENED</acronym>
        y envía un ACK (el primero) a <span class="emphasis"><em>B</em></span>. Mientras,
        <span class="emphasis"><em>B</em></span> devuelve dos ACKs más en respuesta a los dos REQs
        adicionales enviados por <span class="emphasis"><em>A</em></span> antes de que
        <span class="emphasis"><em>B</em></span> arrancase .<span class="emphasis"><em>B</em></span> recibe
        el primer ACK de <span class="emphasis"><em>A</em></span> y entra en modo
        <acronym class="acronym">OPENED</acronym>. <span class="emphasis"><em>A</em></span> recibe el segundo ACK
        de <span class="emphasis"><em>B</em></span> y vuelve al estado
        <span class="emphasis"><em>REQ-SENT</em></span>, enviando otro (el cuarto) REQ. Entonces recibe el
        tercer ACK y entra en modo <acronym class="acronym">OPENED</acronym>. Mientras,
        <span class="emphasis"><em>B</em></span> recibe el cuarto REQ de <span class="emphasis"><em>A</em></span>,
        produciendo que vuelva de nuevo al estado <span class="emphasis"><em>ACK-SENT</em></span> y
        enviando otro (el segundo) REQ y (cuarto) ACK. <span class="emphasis"><em>A</em></span>
        recibe el REQ, entra en modo <span class="emphasis"><em>REQ-SENT</em></span> y envía otro REQ.
        Inmediatamente recibe el siguiente ACK y entra en <acronym class="acronym">OPENED</acronym>.</p><p>Esto pasa hasta que una de las partes piensa que ya ha realizado
        suficientes reintentos y corta la conexión.</p><p>La mejor manera de evitar esto es configurar una de las partes
        de manera <span class="emphasis"><em>pasiva</em></span> - que es, hacer que una de las partes espere
        a que la otra comience la negociación. Esto puede realizarse
        con el comando:</p><p>
        </p><div class="literallayout"><p><br />
          set openmode passive<br />
        </p></div><p>
        </p><p>Se debe tener cuidado con esta opción. También se puede
        usar:</p><p>
        </p><div class="literallayout"><p><br />
        set stopped N<br />
        </p></div><p>
        </p><p>para limitar el número de veces que <span class="emphasis"><em>ppp</em></span>
        espera a que el remoto comience la negociación. Alternativamente, puedes user
        el comando:</p><p>
        </p><div class="literallayout"><p><br />
          set openmode active N<br />
        </p></div><p>
        </p><p>donde <span class="emphasis"><em>N</em></span> es el número de segundos que
        espera antes de empezar la negociación. Mira en el manual para más
        detalles.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68341712"></a><a id="idp68341968"></a><p><strong>11.11.</strong></p></td><td align="left" valign="top"><p>Ppp se bloquea al conectar</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Antes de la versión 2.2.5 era posible que la conexión
        se corte nada más iniciarse debido a un problema en la
        negociación de compresión Predictor1. Esto solo pasa si
        las dos partes intentan negociar con diferentes protocolos de control
        de compresión (CCP). Este problema ya está corregido, pero
        si estás usando una versión antigua de
        <span class="emphasis"><em>ppp</em></span>, el problema puede solucionarse
        con la línea</p><p>
        </p><div class="literallayout"><p><br />
          disable pred1<br />
        </p></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68349136"></a><a id="idp68349392"></a><p><strong>11.12.</strong></p></td><td align="left" valign="top"><p>Ppp se bloqua al abrir un shell de test</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Cuando ejecutas el comando <span class="emphasis"><em>shell</em></span> o
        <span class="emphasis"><em>!</em></span>, <span class="emphasis"><em>ppp</em></span> ejecuta
        un shell (o si has pasado argumentos, <span class="emphasis"><em>ppp</em></span> ejecutará esos
        argumentos). Ppp esperará a que se complete el comando antes de
        continuar. Si intentas usar la conexión ppp mientras se ejecuta
        el comando, parecerá que la conexión se ha colgado. Esto
        es por que <span class="emphasis"><em>ppp</em></span> está esperando a que se complete la
        ejecución del comando.</p><p>Si quieres ejecutar comandos como este, usa el comando
        <span class="emphasis"><em>!bg</em></span> en su lugar. Esto ejecutará el comando
        en background, y ppp continúa sin problemas con la conexión.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68366928"></a><a id="idp68367184"></a><p><strong>11.13.</strong></p></td><td align="left" valign="top"><p>Ppp sobre un cable null-modem no funciona</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>No hay manera que <span class="emphasis"><em>ppp</em></span> detecte
        automáticamente que una conexión directa se ha cortado. Es debido
        a las líneas que se usan en un cable serie null-modem. Cuando usamos este tipo de
        conexión, LQR debería estar siempre activada con el
        comando</p><p>
        </p><div class="literallayout"><p>          enable lqr<br />
        </p></div><p>
        </p><p>LQR es aceptado por defecto si es negociado por el remoto.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68370512"></a><a id="idp68370768"></a><p><strong>11.14.</strong></p></td><td align="left" valign="top"><p>?Por que llama sin motivo el ppp en modo -auto?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Si <span class="emphasis"><em>ppp</em></span> llama inesperadamente, debes determinar la causa, y
        poner filtros (dfilters) para prevenir esas llamadas.</p><p>Para determinar la causa, usa la siguiente línea:</p><p>
        </p><div class="literallayout"><p>          set log +tcp/ip<br />
        </p></div><p>
        </p><p>Esto guardara todo el tráfico que pase a través de la
        conexión.
        La próxima vez que se realice una llamada no deseada,
        podrás ver la causa convenientemente guardada.</p><p>Ahora puedes desactivar las llamadas producidas por esa causa.
        Usualmente, este tipo de problemas se debe a consultas de DNS. Para
        prevenir que las consultas de DNS puedan establecer conexiones usa
        la siguiente línea (esto no hará que los paquetes de DNS
        queden parados cuando la conexión está establecida):</p><p>
        </p><div class="literallayout"><p>          set dfilter 1 deny udp src eq 53<br />
          set dfilter 2 deny udp dst eq 53<br />
          set dfilter 3 permit 0/0 0/0<br />
        </p></div><p>
        </p><p>Esto no siempre es aconsejable, ya que puede afectar a la
        capacidad de realizar conexiones bajo demanda - muchos programas
        necesitan hacer una consulta al DNS antes de poder realizar
        cualquier operación.</p><p>En el caso del DNS, deberías determinar que es lo que
        está intentando realizar esas consultas de DNS. Muchas veces,
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?sendmail" target="_top">sendmail</a>
        es el culpable. Debes asegurarte configurar el
        sendmail de manera que no realice ninguna consulta al DNS. Mira la
        sección <a class="link" href="admin.html#ispmail" title="8.19.">Configuracion de correo</a> para
        tener más detalles acerca de como crear una archivo propio de
        configuración de sendmail. También deberías
        añadir la siguiente línea en tu archivo <code class="filename">.mc</code>:</p><p>
        </p><div class="literallayout"><p>          define(`confDELIVERY_MODE', `d')dnl<br />
        </p></div><p>
        </p><p>Esto hara que sendmail encole todo el correo hasta que no se
        procese la cola (usualmente, sendmail es invocado con
        "-bd -q30m", indicandole que procese la cola cada 30 minutos) o
        hasta que se ejecuta el comando "sendmail -q" (por ejemplo, desde
        el archivo ppp.linup).</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68379216"></a><a id="idp68379472"></a><p><strong>11.15.</strong></p></td><td align="left" valign="top"><p>?Qué significan estos errores CCP?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Sigo viendo los siguientes errores en el archivo de log:</p><p>
        </p><div class="literallayout"><p>          CCP: CcpSendConfigReq<br />
          CCP: Received Terminate Ack (1) state = Req-Sent (6)<br />
        </p></div><p>
        </p><p>Esto es porque ppp está intentando negociar compresión
        Predictor1, y el remoto no quiere negociar ningún tipo de
        compresión. Estos mensajes son sin importancia, pero si quieres
        eliminarlos, puedes desactivar la compresión Predictor1
        localmente:</p><p>
        </p><div class="literallayout"><p>          disable pred1<br />
        </p></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68383056"></a><a id="idp68387536"></a><p><strong>11.16.</strong></p></td><td align="left" valign="top"><p>PPP se cuelga durante transferencia de archivos con errores I/OP</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>En la versión FreeBSD 2.2.2 y anteriores, había un
        problema en el driver tun que no permitía paquetes entrantes con
        un tamaño mayor que el MTU del interface. La recepción de
        un paquete mayor que el MTU resulta en un error IO que es logueado
        vía syslogd.</p><p>La especificación PPP dice que un MRU de 1500
        <span class="emphasis"><em>siempre</em></span>
        debería ser aceptada como mínimo, a pesar de lo que se
        negocie mediante LCP, de todas maneras, es posible que hayas disminuido
        el MTU por debajo de 1500 y tu proveedor te esté enviando
        paquetes de 1500, haciendo que tu conexión se bloquee.</p><p>El problema puede solucionarse haciendo que el tamaño del
        MTU nunca sea inferior a 1500 bajo FreeBSD 2.2.2 y anteriores.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68390480"></a><a id="idp68390736"></a><p><strong>11.17.</strong></p></td><td align="left" valign="top"><p>?Por que ppp no loguea la velocidad de la conexión?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Para loguear todas las líneas de "conversación" de tu
        módem, debes activar la siguiente opción:</p><p>
        </p><div class="literallayout"><p>          set log +connect<br />
        </p></div><p>
        </p><p>Esto hará que
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?ppp" target="_top">ppp</a>
        loguee todo hasta la última cadena "expect" pedida.</p><p>Si quieres ver la velocidad de tu conexión y usas PAP o CHAP
        (y por lo tanto no tienes nada que "chatear" después del CONNECT
        en el script de marcado), debes estar seguro de indicarle al ppp que
        espera la línea "CONNECT con algo como esto:</p><p>
        </p><div class="literallayout"><p>          set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"<br />
        </p></div><p>
        </p><p>Aquí, tenemos nuestro CONNECT, enviamos nada, y esperamos un
        salto de línea, forzando al <span class="emphasis"><em>ppp</em></span> que lea
        la respuesta del CONNECT.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68400592"></a><a id="idp68400848"></a><p><strong>11.18.</strong></p></td><td align="left" valign="top"><p>Ppp ignora el carácter `\' en mi chat script</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>PPP lee cada línea de los archivos de configuración
        para poder interpretar cadenas como <span class="emphasis"><em>set phone "123 456 789"</em></span>
        correctamente.
        Para especificar un carácter ``"'', debes usar la contrabarra
        (``\'').</p><p>Cuando el intérprete lee cada argumento, reinterpreta el
        argumento para buscar alguna secuencia especial de escape como ``\P''
        o ``\T''.
        Como resultado de esta doble lectura, recuerda que has de usar el
        número correcto de escapes (contrabarras).</p><p>Si quieres enviar un caracter ``\'' a tu módem, necesitas
        hacer algo como:</p><p>
        </p><div class="literallayout"><p>          set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"<br />
        </p></div><p>
        </p><p>resultando en la siguiente secuencia:</p><p>
        </p><div class="literallayout"><p>          ATZ<br />
          OK<br />
          AT\X<br />
          OK<br />
        </p></div><p>
        </p><p>o</p><p>
        </p><div class="literallayout"><p>          set phone 1234567<br />
          set dial "\"\" ATZ OK ATDT\\T"<br />
        </p></div><p>
        </p><p>resultando en la siguiente secuencia:</p><p>
        </p><div class="literallayout"><p>          ATZ<br />
          OK<br />
          ATDT1234567<br />
        </p></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68408144"></a><a id="idp68408400"></a><p><strong>11.19.</strong></p></td><td align="left" valign="top"><p>Ppp produce un seg-fault, pero no veo el archivo
        <code class="filename">ppp.core</code></p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Ppp (o cualquier otro programa de este tipo), nunca deberían
        hacer un core dump. Por que ppp funciona con un id de usuario 0,
        el sistema operativo no escribirá la imagen del core en disco.
        Si ppp termina con errores de "segmentation violation" o cualquier
        otra señal que normalmente causa un core dumped, y quieres poder
        hacer un debug de ese core, asegúrate de usar la última
        versión de ppp, y haz lo siguiente:</p><p>
        </p><div class="literallayout"><p>          $ tar xfz ppp-*.src.tar.gz<br />
          $ cd ppp*/ppp<br />
          $ echo STRIP= &gt;&gt;Makefile<br />
          $ echo CFLAGS+=-g &gt;&gt;Makefile<br />
          $ make clean all<br />
          $ su<br />
          # make install<br />
          # chmod 555 /usr/sbin/ppp<br />
        </p></div><p>
        </p><p>Ahora tendrás instalada una versión "debuggable" de
        ppp. Tendrás que ser root para poder ejecutar ppp ya que todos
        sus privilegios han sido revocados. Cuando arranques ppp, acuerdate del
        directorio en el que te encuentras.</p><p>Ahora, cuando ppp recibe una violación de segmentación
        , creará un archivo core llamado ppp.core. A continuación
        , deberías hacer lo siguiente:</p><p>
        </p><div class="literallayout"><p>          $ su<br />
          # gdb /usr/sbin/ppp ppp.core<br />
          (gdb) bt<br />
          .....<br />
          (gdb) f 0<br />
          .....<br />
          (gdb) i args<br />
          .....<br />
          (gdb) l<br />
          .....<br />
        </p></div><p>
        </p><p>Toda esta información puede hacer posible diagnosticar el
        problema. Si estás familiarizado con gdb, puedes encontrar otras
        pistas como que causó el dump y las direcciones y valores de las
        variables más relevantes.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68413008"></a><a id="idp68413264"></a><p><strong>11.20.</strong></p></td><td align="left" valign="top"><p>El proceso que fuerza una llamada en modo auto nunca funciona</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Este es un problema conocido cuando <span class="emphasis"><em>ppp</em></span>
        está configurado para negociar una IP dinámica local con el
        remoto. Este problema ha sido solucionado en la última versión -
        busca en el man la palabra <span class="emphasis"><em>iface</em></span>.</p><p>El problema era que cuando el programa inicial llama a
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?connect" target="_top">connect(2)</a>,
        el IP del interface tun es asignado al punto
        final del socket. El kernel crea el primer paquete saliente y
        establece la conexión. Si, como resultado de la
        asignación dinámica de IP, la dirección del
        interface es cambiada, el punto final del socket original será
        invalido. Los siguientes paquetes enviados al remoto normalmente
        serán descartados. Aun si no lo son, cualquier respuesta no
        será enrutada hacia la máquina de origen por que la
        dirección IP de la máquina de origen ha cambiado.</p><p>Hay varias maneras teóricas de solucionar este problema. Lo
        mejor sería que el remoto reasignase la misma IP si fuese
        posible <span class="emphasis"><em>:-)</em></span> La versión actual de
        <span class="emphasis"><em>ppp</em></span> hace esto,
        pero otras muchas implementaciones no.</p><p>El método más sencillo desde nuestra parte,
        sería no cambiar nunca la IP del interface tun, pero por el
        contrario, cambiar todos los paquetes salientes de manera que la ip de
        origen es cambiada del IP del interface a la IP negociada,
        instantaneamente.
        Esto es, esencialmente, lo que hacen
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?libalias" target="_top">libalias(3)</a>
        y el parámetro <code class="option">-alias</code> de ppp.</p><p>Otra alternativa (y probablemente la más eficaz) es implementar
        una llamada al sistema que cambie todos los sockets de una IP a
        otra. <span class="emphasis"><em>Ppp</em></span> debería usar esta llamada para modificar los
        sockets de todos los programas existentes cuando una nueva
        dirección IP es negociada. La misma llamada de sistema
        podría ser usada para clientes dhcp cuando son forzados
        a rehacer sus sockets.</p><p>Una tercera opción es permitir que un interface se active sin
        IP. Los paquetes salientes tendrían un IP de 255.255.255.255
        hasta que el primer SIOCAIFADDR ioctl este hecho. Esto
        permitiría que ppp cambiase el IP de origen, pero solo si el
        socket es 255.255.255.255 y solo el IP y el checksum necesitan cambiar. Esto, de
        todas maneras, requiere tocar el kernel para que puede enviar
        paquetes incorrectos a un interface mal configurado.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68420944"></a><a id="idp68421200"></a><p><strong>11.21.</strong></p></td><td align="left" valign="top"><p>?Porqué muchos juegos no funcionan con el
        parámetro -alias?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>La razón por la que muchos de los juegos no funcionan es
        por que la máquina externa intentará abrir una
        conexión o enviar paquetes UDP (no solicitados) a la
        máquina interna. El software "alias" no sabe que esos paquetes
        debrín enviarse a la máquina interna.</p><p>Para que las cosas funcionen, asegúrate que la única
        cosa que está funcionando es el software con el que tienes
        problemas, entonces ejecuta tcpdump en el interface tun del
        gateway o ejecuta el log tcp/ip del ppp ("set log +tcp/ip" en el
        gateway.</p><p>Cuando arrancas el software que no funciona, deberís ver
        paquetes que pasan a través del gateway. Cuando algo
        vuelve del exterior, será rechazado (ese es el problema).
        Apunta el número de puerto de esos paquetes y cierra el
        software que no funciona. Haz esto varias veces para comprobar si
        el número de puerto se repite. Si es así, la siguiente
        línea en el archivo de configuración del ppp
        /etc/ppp/ppp.conf hará que las cosas funcionen:</p><p>
        </p><div class="literallayout"><p>         alias port proto internalmachine:port port<br />
       </p></div><p>
        </p><p>donde "proto" puede ser "tcp" o "udp", "internalmachine" es la
        máquina a la que quieres que los paquetes sean enviados y
        "port" es el número de puerto de destino de los paquetes.</p><p>No podrás usar ese software en otras máquinas sin
        modificar el comando anterior, y ejecutar el software
        simultaneamente en dos máquinas internas no será
        posible - después de todo, el mundo exterior está
        viendo a toda tu red como una sola máquina.</p><p>Si los números de puertos no se repiten, hay tres opciones
        más:</p><p><span class="emphasis"><em>1)</em></span> Desarrollar el soporte en libalias. Ejemplos de estos
        "casos especiales" los puedes encontrar en
        /usr/src/lib/libalias/alias_*.c (alias_ftp.c es un buén
        prototipo). Esto usualmente supone leer ciertos paquetes salientes
        conocidos, identificando la instrucción que le indica a la
        máquina exterior que inicie una conexión con la
        máquina interna en un puerto específico (aleatorio)
        y configurar un "ruta" en la tabla de alias para que los paquetes
        siguientes sepan donde ir.</p><p>Esta es la solución más difícil, pero es la
        mejor y hará que el software funcione con múltiples
        máquinas.</p><p><span class="emphasis"><em>2)</em></span> Usar un proxy. La aplicación debe soportar
        socks5 por ejemplo, o (como en el caso del "cvsup") debería
        tener una opción "pasiva" que evita que el remoto intente abrir
        conexiones con la maquina local.</p><p><span class="emphasis"><em>3)</em></span> Redireccionar todo el tráfico
        a la máquina interna usando "alias addr". Esta es la solución más
        sencilla.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68432464"></a><a id="idp68432720"></a><p><strong>11.22.</strong></p></td><td align="left" valign="top"><p>?Ha hecho alguien una lista de puertos útiles?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Todavía no, pero se podría hacer, si hay
        interés. En cada ejemplo, <span class="emphasis"><em>internal</em></span> debe ser
        reemplazado por la dirección IP de la máquina que
        va a estar jugando.</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Quake</em></span>
            </p><p><span class="emphasis"><em>alias port udp internal:6112 6112</em></span></p><p>Alternativamente, quizás estés interesado en
            mirar en el
            <a class="link" href="http://www.battle.net/support/proxy/" target="_top">www.battle.net</a>soporte
            de Quake a través de proxy"&gt;.</p></li></ul></div><p>
        </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Quake 2</em></span></p><p><span class="emphasis"><em>alias port udp internal:27901 27910</em></span></p></li></ul></div><p>
        </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Red Alert</em></span></p><p><span class="emphasis"><em>alias port udp internal:8675 8675</em></span></p><p><span class="emphasis"><em>alias port udp internal:5009 5009</em></span></p></li></ul></div><p>
        </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Half Life</em></span></p><p><span class="emphasis"><em>alias port udp internal:27005 27015</em></span></p></li></ul></div><p>
        </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>PCAnywhere 8.0</em></span></p><p><span class="emphasis"><em>alias port udp internal:5632 5632</em></span></p><p><span class="emphasis"><em>alias port tcp internal:5631 5631</em></span></p></li></ul></div><p>
        </p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68453712"></a><a id="idp68453968"></a><p><strong>11.23.</strong></p></td><td align="left" valign="top"><p>?Qué son los errores FCS?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>FCS significa <span class="emphasis"><em>F</em></span>rame
        <span class="emphasis"><em>C</em></span>heck <span class="emphasis"><em>S</em></span>equence.
        Cada paquete ppp tiene un checksum añadido para asegurar que los datos
        que se reciben son los datos que han sido enviados. Si el FCS de un
        paquete entrante es incorrecto, el paquete es rechazado y se
        incremente el contador HDLC FCS. Los valores de error HDLC se
        pueden visualizar usando el comando <span class="emphasis"><em>show hdlc</em></span>.</p><p>Si tu conexión es mala (o si tu driver serie está
        rechazando paquetes), verás errores FCS ocasionales. En general
        no tienes porque preocuparte de ellos. Si tienes un módem
        externo, asegúrate que el cable está correctamente
        aislado de interferencias - esto debería erradicar el problema.</p><p>Si tu conexión se corta tan pronto como has conectado y ves
        gran cantidad de errores FCS, puede ser por que ti conexión no
        es de 8 bits. Asegúrate de que tu módem no está
        usando control de flujo (XON/XOFF) por software. Si tu conexión
        de datos <span class="emphasis"><em>debe</em></span> usar control de flujo por software, usa el
        comando <code class="literal">set accmap 0x000a0000</code> para indicar al
        <span class="emphasis"><em>ppp</em></span> que "escape" los carácteres ^Q y ^S.</p><p>Otra razón para ver muchos errores FCS puede ser que el
        remoto haya dejado de "hablar" <acronym class="acronym">PPP</acronym>. Deberís activar el
        log asíncrono para determinar si los datos entrantes son de
        un login o un prompt de shell. Si tienes un prompt de shell en el
        extremo de la conexión, es posible terminar el ppp sin
        cortar la conexión usando el comando <span class="emphasis"><em>close clp</em></span> (usando
        el comando <span class="emphasis"><em>term</em></span> podrás conectar de nuevo con el shell
        de la máquina remota.</p><p>Si no hay nada en el log que indique por que se ha terminado la
        conexión, deberís preguntar al administrador del
        sistema remoto porqué ha terminado la sesión.</p></td></tr><tr class="question"><td align="left" valign="top"><a id="idp68462160"></a><a id="idp68462416"></a><p><strong>11.24.</strong></p></td><td align="left" valign="top"><p>Nada de esto me ayuda - Estoy desesperado !</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Si todo falla, envía toda la información que puedas,
        incluyendo los archivos de configuración, como arrancas el ppp,
        las partes relevantes del archivo de log y la salida del comando
        <a class="link" href="http://www.FreeBSD.org/cgi/man.cgi?netstat" target="_top">netstat -rn</a>
        (antes y despues de la conexión) a la lista de distribución
        <a class="link" href="mailto:FreeBSD-questions@FreeBSD.org" target="_top">FreeBSD-questions@FreeBSD.org</a>,
        a la lista de
        <a class="link" href="mailto:FreeBSD@es.FreeBSD.org" target="_top">FreeBSD en castellano</a> o
        al grupo de news
        <a class="link" href="news:comp.unix.bsd.FreeBSD.misc" target="_top">comp.unix.bsd.FreeBSD.misc</a>
        y alguien te ayudará a solucionar los problemas.</p></td></tr></tbody></table></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="networking.html">Anterior</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="serial.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Capítulo 10. Networking </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Capítulo 12. Comunicaciones serie</td></tr></table></div><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Puede descargar éste y muchos otros documentos desde
    <a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/</a></small></p><p xmlns="http://www.w3.org/TR/xhtml1/transitional" align="center"><small>Si tiene dudas sobre FreeBSD consulte la
    <a href="http://www.FreeBSD.org/docs.html">documentación</a> antes de escribir a la lista
    &lt;<a href="mailto:questions@FreeBSD.org">questions@FreeBSD.org</a>&gt;.<br></br>
    Envíe sus preguntas sobre la documentación a
    &lt;<a href="mailto:doc@FreeBSD.org">doc@FreeBSD.org</a>&gt;.</small></p></body></html>