<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><title>PMake &#8212; A Tutorial</title><link rel="stylesheet" type="text/css" href="docbook.css" /><link rev="made" href="mailto:doc@FreeBSD.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><script xmlns="" type="text/javascript" src="/layout/js/google.js"></script></head><body><div xml:lang="en" class="book" lang="en"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="idp60644304"></a>PMake &#8212; A Tutorial</h1></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="author"><h3 class="author"><span class="firstname">Adam</span> <span class="surname">de Boor</span></h3></div></div><div>Revision: <a href="https://svnweb.freebsd.org/changeset/doc/"><span class="svnref"></span></a></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 1988-1989 Adam de Boor</p></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 1989 Berkeley Softworks</p></div><div><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 1988-1989, 1993 The Regents of the University of California.</p></div><div><div xmlns="http://www.w3.org/1999/xhtml" class="legalnotice"><a id="legalnotice"></a><p>All rights reserved.</p><p>This code is derived from software contributed to Berkeley
    by Adam de Boor.</p><p>Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.</p></li><li class="listitem"><p>Redistributions in binary form must reproduce the above
	copyright notice, this list of conditions and the following
	disclaimer in the documentation and/or other materials provided
	with the distribution.</p></li><li class="listitem"><p>All advertising materials mentioning features or use of this
	software must display the following acknowledgement: This product
	includes software developed by the University of California,
	Berkeley and its contributors.</p></li><li class="listitem"><p>Neither the name of the University nor the names of its
	contributors may be used to endorse or promote products derived
	from this software without specific prior written
	permission.</p></li></ol></div><div xmlns="" class="important"><h3 class="admontitle">Important: </h3><p xmlns="http://www.w3.org/1999/xhtml">THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
      BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
      CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
      SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
      INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
      CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
      ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
      THE POSSIBILITY OF SUCH DAMAGE.</p></div></div></div></div><div class="docformatnavi">
      [
      <a href="index.html">Split HTML</a>
      /
      
	  Single HTML
	
      ]
    </div><hr /></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="chapter"><a href="#intro">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#basics">2. The Basics of PMake</a></span></dt><dd><dl><dt><span class="section"><a href="#deplines">2.1. Dependency Lines</a></span></dt><dt><span class="section"><a href="#shellcmds">2.2. Shell Commands</a></span></dt><dt><span class="section"><a href="#variables">2.3. Variables</a></span></dt><dt><span class="section"><a href="#comments">2.4. Comments</a></span></dt><dt><span class="section"><a href="#parellelism">2.5. Parallelism</a></span></dt><dt><span class="section"><a href="#writeanddebug">2.6. Writing and Debugging a Makefile</a></span></dt><dt><span class="section"><a href="#invoking">2.7. Invoking PMake</a></span></dt><dt><span class="section"><a href="#summary">2.8. Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#shortcuts">3. Short-cuts and Other Nice Things</a></span></dt><dd><dl><dt><span class="section"><a href="#rules">3.1. Transformation Rules</a></span></dt><dt><span class="section"><a href="#including">3.2. Including Other Makefiles</a></span></dt><dt><span class="section"><a href="#savingcmds">3.3. Saving Commands</a></span></dt><dt><span class="section"><a href="#targetattr">3.4. Target Attributes</a></span></dt><dt><span class="section"><a href="#specialtargets">3.5. Special Targets</a></span></dt><dt><span class="section"><a href="#modyvarex">3.6. Modifying Variable Expansion</a></span></dt><dt><span class="section"><a href="#moreexercises">3.7. More Exercises</a></span></dt></dl></dd><dt><span class="chapter"><a href="#gods">4. PMake for Gods</a></span></dt><dd><dl><dt><span class="section"><a href="#searchpaths">4.1. Search Paths</a></span></dt><dt><span class="section"><a href="#archivesandlibraries">4.2. Archives and Libraries</a></span></dt><dt><span class="section"><a href="#condition">4.3. On the Condition...</a></span></dt><dt><span class="section"><a href="#ashell">4.4. A Shell is a Shell is a Shell</a></span></dt><dt><span class="section"><a href="#compatibility">4.5. Compatibility</a></span></dt><dt><span class="section"><a href="#defcon3">4.6. DEFCON 3 &#8211; Variable Expansion</a></span></dt><dt><span class="section"><a href="#defcon2">4.7. DEFCON 2 &#8211; The Number of the Beast</a></span></dt><dt><span class="section"><a href="#defcon1">4.8. DEFCON 1 &#8211; Imitation is the Not the Highest Form of
      Flattery</a></span></dt><dt><span class="section"><a href="#theway">4.9. The Way Things Work</a></span></dt></dl></dd><dt><span class="chapter"><a href="#answers">5. Answers to Exercises</a></span></dt><dt><span class="glossary"><a href="#glossary">Glossary of Jargon</a></span></dt></dl></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="intro"></a>Chapter 1. Introduction</h1></div></div></div><p><span class="application">PMake</span> is a program for creating other
    programs, or anything else you can think of for it to do.  The basic idea
    behind <span class="application">PMake</span> is that, for any given system, be
    it a program or a document or whatever, there will be some files that
    depend on the state of other files (on when they were last modified).
    <span class="application">PMake</span> takes these dependencies, which you must
    specify, and uses them to build whatever it is you want it to
    build.</p><p><span class="application">PMake</span> is almost fully-compatible with
    <span class="application">Make</span>, with which you may already be familiar.
    <span class="application">PMake</span>'s most important feature is its ability
    to run several different jobs at once, making the creation of systems
    considerably faster.  It also has a great deal more functionality than
    <span class="application">Make</span>.</p><p>This tutorial is divided into three main sections corresponding to
    basic, intermediate and advanced <span class="application">PMake</span> usage.
    If you already know <span class="application">Make</span> well, you will only
    need to skim <a class="xref" href="#basics" title="Chapter 2. The Basics of PMake">Chapter 2, <em>The Basics of PMake</em></a> (there are some aspects of
    <span class="application">PMake</span> that I consider basic to its use that did
    not exist in <span class="application">Make</span>).
    Things in <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a> make life much easier, while those in
    <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a> are strictly for those who know what they are doing.
    <a class="xref" href="#glossary" title="Glossary of Jargon">Glossary of Jargon</a> has definitions for the jargon I use and
    <a class="xref" href="#answers" title="Chapter 5. Answers to Exercises">Chapter 5, <em>Answers to Exercises</em></a> contains possible solutions to the problems
    presented throughout the tutorial.</p></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="basics"></a>Chapter 2. The Basics of PMake</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="section"><a href="#deplines">2.1. Dependency Lines</a></span></dt><dt><span class="section"><a href="#shellcmds">2.2. Shell Commands</a></span></dt><dt><span class="section"><a href="#variables">2.3. Variables</a></span></dt><dt><span class="section"><a href="#comments">2.4. Comments</a></span></dt><dt><span class="section"><a href="#parellelism">2.5. Parallelism</a></span></dt><dt><span class="section"><a href="#writeanddebug">2.6. Writing and Debugging a Makefile</a></span></dt><dt><span class="section"><a href="#invoking">2.7. Invoking PMake</a></span></dt><dt><span class="section"><a href="#summary">2.8. Summary</a></span></dt></dl></div><p><span class="application">PMake</span> takes as input a file that
    tells which files depend on which other files to be complete and
    what to do about files that are <span class="quote">&#8220;<span class="quote">out-of-date</span>&#8221;</span>.
    This file is known as a <span class="quote">&#8220;<span class="quote">makefile</span>&#8221;</span> and is usually
    kept in the top-most directory of the system to be built.
    While you can call the makefile anything you want,
    <span class="application">PMake</span> will look for
    <code class="filename">Makefile</code> and <code class="filename">makefile</code>
    (in that order) in the current directory if you do not tell it
    otherwise.  To specify a different makefile, use the
    <code class="option">-f</code> flag, e.g.</p><pre class="screen"><code class="prompt">%</code> <strong class="userinput"><code>pmake -f <em class="replaceable"><code>program.mk</code></em></code></strong></pre><p>A makefile has four different types of lines in it:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>File dependency specifications</p></li><li class="listitem"><p>Creation commands</p></li><li class="listitem"><p>Variable assignments</p></li><li class="listitem"><p>Comments, include statements and conditional directives</p></li></ul></div><p>Any line may be continued over multiple lines by ending it
    with a backslash.  The backslash, following newline and any
    initial whitespace on the following line are compressed into a
    single space before the input line is examined by
    <span class="application">PMake</span>.</p><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="deplines"></a>2.1. Dependency Lines</h2></div></div></div><p>As mentioned in the introduction, in any system, there are
      dependencies between the files that make up the system.
      For instance, in a program made up of several C source files and
      one header file, the C files will need to be re-compiled should
      the header file be changed.  For a document of several chapters
      and one macro file, the chapters will need to be reprocessed if
      any of the macros changes.  These are dependencies and are
      specified by means of dependency lines in the makefile.</p><p>On a dependency line, there are targets and sources,
      separated by a one- or two-character operator.  The targets
      <span class="quote">&#8220;<span class="quote">depend</span>&#8221;</span> on the sources and are usually created
      from them.  Any number of targets and sources may be specified
      on a dependency line.  All the targets in the line are made to
      depend on all the sources.  Targets and sources need not be
      actual files, but every source must be either an actual file or
      another target in the makefile.  If you run out of room, use a
      backslash at the end of the line to continue onto the next
      one.</p><p>Any file may be a target and any file may be a source, but
      the relationship between the two (or however many) is determined
      by the <span class="quote">&#8220;<span class="quote">operator</span>&#8221;</span> that separates them.  Three types
      of operators exist: one specifies that the datedness of a target
      is determined by the state of its sources, while another
      specifies other files (the sources) that need to be dealt with
      before the target can be re-created.  The third operator is very
      similar to the first, with the additional condition that the
      target is out-of-date if it has no sources.  These operations
      are represented by the colon, the exclamation point and the
      double-colon, respectively, and are mutually exclusive.
      Their exact semantics are as follows:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="literal">:</code></td><td valign="top">If a colon is used, a target on the line is
	      considered to be <span class="quote">&#8220;<span class="quote">out-of-date</span>&#8221;</span> (and in need
	      of creation) if any of the sources has been modified
	      more recently than the target, or the target does not
	      exist.  Under this operation, steps will be taken to
	      re-create the target only if it is found to be
	      out-of-date by using these two rules.</td></tr><tr valign="top"><td valign="top"><code class="literal">!</code></td><td valign="top">If an exclamation point is used, the target will
	      always be re-created, but this will not happen until all
	      of its sources have been examined and re-created, if
	      necessary.</td></tr><tr valign="top"><td valign="top"><code class="literal">::</code></td><td valign="top">If a double-colon is used, a target is
	      <span class="quote">&#8220;<span class="quote">out-of-date</span>&#8221;</span> if any of the sources has
	      been modified more recently than the target, or the
	      target does not exist, or the target has no sources.
	      If the target is out-of-date according to these rules,
	      it will be re-created.  This operator also does
	      something else to the targets, but I will go into that
	      in the next section
	      (see <a class="xref" href="#shellcmds" title="2.2. Shell Commands">Shell Commands</a>).</td></tr></tbody></table></div><p>Enough words, now for an example.  Take that C program I
      mentioned earlier.  Say there are three C files
      (<code class="filename">a.c</code>, <code class="filename">b.c</code> and
      <code class="filename">c.c</code>) each of which includes the file
      <code class="filename">defs.h</code>.  The dependencies between the files
      could then be expressed as follows:</p><pre class="programlisting">program         : a.o b.o c.o

a.o b.o c.o     : defs.h

a.o             : a.c

b.o             : b.c

c.o             : c.c</pre><p>You may be wondering at this point, where
      <code class="filename">a.o</code>, <code class="filename">b.o</code> and
      <code class="filename">c.o</code> came in and why they depend on
      <code class="filename">defs.h</code> and the C files do not.
      The reason is quite simple: <code class="buildtarget">program</code>
      cannot be made by linking together <code class="filename">.c</code>
      files&#8212;it must be made from <code class="filename">.o</code> files.
      Likewise, if you change <code class="filename">defs.h</code>, it is not
      the <code class="filename">.c</code> files that need to be re-created,
      it is the <code class="filename">.o</code> files.  If you think of
      dependencies in these terms&#8212;which files (targets) need to
      be created from which files (sources)&#8212;you should have no
      problems.</p><p>An important thing to notice about the above example, is
      that all the <code class="filename">.o</code> files appear as targets on
      more than one line.  This is perfectly all right: the target is
      made to depend on all the sources mentioned on all the
      dependency lines.  For example, <code class="filename">a.o</code> depends
      on both <code class="filename">defs.h</code> and <code class="filename">a.c</code>.</p><p>The order of the dependency lines in the makefile is
      important: the first target on the first dependency line in the
      makefile will be the one that gets made if you do not say
      otherwise.  That is why program comes first in the example
      makefile, above.</p><p>Both targets and sources may contain the standard C-Shell wildcard
      characters (<code class="literal">{</code>, <code class="literal">}</code>,
      <code class="literal">*</code>, <code class="literal">?</code>, <code class="literal">[</code>, and
      <code class="literal">]</code>), but the non-curly-brace ones may only appear in
      the final component (the file portion) of the target or source.
      The characters mean the following things:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="literal">{}</code></td><td valign="top">These enclose a comma-separated list of options and
	      cause the pattern to be expanded once for each element
	      of the list.  Each expansion contains a different
	      element.  For example,
	      <code class="filename">src/{whiffle,beep,fish}.c</code> expands
	      to the three words <code class="filename">src/whiffle.c</code>,
	      <code class="filename">src/beep.c</code>, and
	      <code class="filename">src/fish.c</code>.  These braces may be
	      nested and, unlike the other wildcard characters, the
	      resulting words need not be actual files.  All other
	      wildcard characters are expanded using the files that
	      exist when <span class="application">PMake</span> is
	      started.</td></tr><tr valign="top"><td valign="top"><code class="literal">*</code></td><td valign="top">This matches zero or more characters of any sort.
	      <code class="filename">src/*.c</code> will expand to the same
	      three words as above as long as src contains those three
	      files  (and  no other files that end in
	      <code class="filename">.c</code>).&gt;</td></tr><tr valign="top"><td valign="top"><code class="literal">?</code></td><td valign="top">Matches any single character.</td></tr><tr valign="top"><td valign="top"><code class="literal">[]</code></td><td valign="top">This is known as a character class and contains
	      either a list of single characters, or a series of
	      character ranges (<code class="literal">a-z</code>, for example
	      means all characters between <code class="literal">a</code> and
	      <code class="literal">z</code>), or both.  It matches any single
	      character contained in the list.  For example,
	      <code class="literal">[A-Za-z]</code> will match all letters,
	      while <code class="literal">[0123456789]</code> will match all
	      numbers.</td></tr></tbody></table></div></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="shellcmds"></a>2.2. Shell Commands</h2></div></div></div><p><span class="quote">&#8220;<span class="quote">Is not that nice,</span>&#8221;</span> you say to yourself,
      <span class="quote">&#8220;<span class="quote">but how are files actually ``re-created'', as he likes to
	spell it?</span>&#8221;</span>
      The re-creation is accomplished by commands you place in the
      makefile.  These commands are passed to the Bourne shell (better
      known as <code class="filename">/bin/sh</code>) to be executed and are
      expected to do what is necessary to update the target file
      (<span class="application">PMake</span> does not actually check to see
      if the target was created.  It just assumes it is there).</p><p>Shell commands in a makefile look a lot like shell commands
      you would type at a terminal, with one important exception: each
      command in a makefile must be preceded by at least one
      tab.</p><p>Each target has associated with it a shell script made up of
      one or more of these shell commands.  The creation script for a
      target should immediately follow the dependency line for that
      target.  While any given target may appear on more than one
      dependency line, only one of these dependency lines  may be
      followed  by a creation script, unless the <code class="literal">::</code>
      operator was used on the dependency line.</p><p>If the double-colon was used, each dependency line for the
      target may be followed by a shell script.  That script will only
      be executed if the target on the associated dependency line is
      out-of-date with respect to the sources on that line, according
      to the rules I gave earlier.  I'll give you a good example of
      this later on.</p><p>To expand on the earlier makefile, you might add commands
      as follows:</p><pre class="programlisting">program         : a.o b.o c.o
        cc a.o b.o c.o -o program

a.o b.o c.o     : defs.h
a.o             : a.c
       cc -c a.c

b.o             : b.c
       cc -c b.c

c.o             : c.c
       cc -c c.c</pre><p>Something you should remember when writing a makefile is,
      the commands will be executed if the target on the dependency
      line is out-of-date, not the sources.  In this example, the
      command <code class="command">cc -c a.c</code> will be executed if
      <code class="filename">a.o</code> is out-of-date.  Because of the
      <code class="literal">:</code> operator, this means that should
      <code class="filename">a.c</code> or <code class="filename">defs.h</code> have
      been modified more recently than <code class="filename">a.o</code>, the
      command will be executed (<code class="filename">a.o</code> will be
      considered out-of-date).</p><p>Remember how I said the only difference between a makefile
      shell command and a regular shell command was the leading tab?
      I lied.  There is another way in which makefile commands differ
      from regular ones.  The first two characters after the initial
      whitespace are treated specially.  If they are any combination
      of <code class="filename">@</code> and <code class="literal">-</code>, they cause
      <span class="application">PMake</span> to do different things.</p><p>In most cases, shell commands are printed before they are
      actually executed.  This is to keep you informed of what is
      going on.  If an <code class="literal">@</code> appears, however, this
      echoing is suppressed.  In the case of an echo command,
      say</p><pre class="programlisting">echo Linking index</pre><p>it would be rather silly to see</p><pre class="screen">echo Linking index
Linking index</pre><p>so <span class="application">PMake</span> allows you to place an
      <code class="literal">@</code> before the command to prevent the command
      from being printed:</p><pre class="programlisting">@echo Linking index</pre><p>The other special character is the <code class="literal">-</code>.
      In case you did not know, shell commands finish with a certain
      <span class="quote">&#8220;<span class="quote">exit status</span>&#8221;</span>.  This status is made available by
      the operating system to whatever program invoked the command.
      Normally this status will be <code class="literal">0</code> if everything
      went ok and non-zero if something went wrong.  For this reason,
      <span class="application">PMake</span> will consider an error to have
      occurred if one of the shells it invokes returns a non-zero
      status.  When it detects an error,
      <span class="application">PMake</span>'s usual action is to abort
      whatever it is doing and exit with a non-zero status itself (any
      other targets that were being created will continue being made,
      but nothing new will be started.
      <span class="application">PMake</span> will exit after the last job
      finishes).  This behavior can be altered, however, by placing a
      <code class="literal">-</code> at the front of a command
      (e.g. <code class="command">-mv index index.old</code>), certain
      command-line arguments, or doing other things, to be detailed
      later.  In such a case, the non-zero status is simply ignored
      and <span class="application">PMake</span> keeps chugging
      along.</p><p>Because all the commands are given to a single shell to
      execute, such things as setting shell variables, changing
      directories, etc., last beyond the command in which they are
      found.  This also allows shell compound commands (like for
      loops) to be entered in a natural manner.  Since this could
      cause problems for some makefiles that depend on each command
      being executed by a single shell,
      <span class="application">PMake</span> has a <code class="option">-B</code> flag
      (it stands for backwards-compatible) that forces each command to
      be given to a separate shell.  It also does several other
      things, all of which I discourage since they are now
      old-fashioned.</p><p>A target's shell script is fed to the shell on its (the
      shell's) input stream. This means that any commands, such as
      <span class="application">ci</span> that need to get input from the
      terminal will not work right &#8211; they will get the shell's
      input, something they probably will not find to their liking.
      A simple way around this is to give a command like this:</p><pre class="screen"><code class="command">ci $(SRCS) &lt; /dev/tty</code></pre><p>This would force the program's input to come from the
      terminal.  If you cannot do this for some reason, your only
      other alternative is to use <span class="application">PMake</span> in
      its fullest compatibility mode.
      See <span class="quote">&#8220;<span class="quote">Compatibility</span>&#8221;</span> in <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a>.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="variables"></a>2.3. Variables</h2></div></div></div><p><span class="application">PMake</span>, like
      <span class="application">Make</span> before it, has the ability to
      save text in variables to be recalled later at your convenience.
      Variables in <span class="application">PMake</span> are used much like
      variables in the shell and, by tradition, consist of all
      upper-case letters (you do not have to use all upper-case
      letters.  In fact there is nothing to stop you from calling a
      variable <code class="literal">@^&amp;$%$</code>.  Just tradition).  Variables
      are assigned-to using lines of the form:</p><pre class="programlisting">VARIABLE = value</pre><p>appended-to by:</p><pre class="programlisting">VARIABLE += value</pre><p>conditionally assigned-to (if the variable is not already
      defined) by:</p><pre class="programlisting">VARIABLE ?= value</pre><p>and assigned-to with expansion (i.e. the value is expanded
      (see below) before being assigned to the variable&#8212;useful
      for placing a value at the beginning of a variable, or other
      things) by:</p><pre class="programlisting">VARIABLE := value</pre><p>Any whitespace before value is stripped off.  When
      appending, a space is placed between the old value and the stuff
      being appended.</p><p>The final way a variable may be assigned to is using:</p><pre class="programlisting">VARIABLE != shell-command</pre><p>In this case, shell-command has all its variables expanded
      (see below) and is passed off to a shell to execute.  The output
      of the shell is then placed in the variable.  Any newlines
      (other than the final one) are replaced by spaces before the
      assignment is made.  This is typically used to find the current
      directory via a line like:</p><pre class="programlisting">CWD             != pwd</pre><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">This is intended to be used to execute commands that
	produce small amounts of output
	(e.g. <span class="application">pwd</span>).
	The implementation is less than intelligent and will likely
	freeze if you execute something that produces thousands of
	bytes of output (8 Kb is the limit on many <span class="trademark">UNIX</span>® systems).
	The value of a variable may be retrieved by enclosing the
	variable name in parentheses or curly braces and preceding the
	whole thing with a dollar sign.</p></div><p>For example, to set the variable <code class="envar">CFLAGS</code> to
      the string <code class="literal">-I/sprite/src/lib/libc -O,</code> you
      would place a line:</p><pre class="programlisting">CFLAGS = -I/sprite/src/lib/libc -O</pre><p>in the makefile and use the word
      <code class="literal">$(CFLAGS)</code> wherever you would like the string
      <code class="literal">-I/sprite/src/lib/libc -O</code> to appear.  This is
      called variable expansion.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">Unlike <span class="application">Make</span>,
	<span class="application">PMake</span> will not expand a variable
	unless it knows the variable exists.  E.g. if you have a
	<code class="literal">${i}</code> in a shell command and you have not
	assigned a value to the variable <code class="varname">i</code> (the
	empty string is considered a value, by the way), where
	<span class="application">Make</span> would have substituted the
	empty string, <span class="application">PMake</span> will leave the
	<code class="literal">${i}</code> alone.
	To keep <span class="application">PMake</span> from substituting for
	a variable it knows, precede the dollar sign with another
	dollar sign (e.g. to pass <code class="literal">${HOME}</code> to
	the shell, use <code class="literal">$${HOME}</code>).  This causes
	<span class="application">PMake</span>, in effect, to expand the
	<code class="literal">$</code> macro, which expands to a single
	<code class="literal">$</code>.</p></div><p>For compatibility, <span class="application">Make</span>'s style
      of variable expansion will be used if you invoke
      <span class="application">PMake</span> with any of the compatibility
      flags (<code class="option">-V</code>, <code class="option">-B</code> or
      <code class="option">-M</code>.  The <code class="option">-V</code> flag alters just
      the variable expansion).  There are two different times at which
      variable expansion occurs: when parsing a dependency line, the
      expansion occurs immediately upon reading the line.  If any
      variable used on a dependency line is undefined,
      <span class="application">PMake</span> will print a message and exit.
      Variables in shell commands are expanded when the command is
      executed.  Variables used inside another variable are expanded
      whenever the outer variable is expanded (the expansion of an
      inner variable has no effect on the outer variable.  For
      example, if the outer variable is used on a dependency line and
      in a shell command, and the inner variable changes value between
      when the dependency line is read and the shell command is
      executed, two different values will be substituted for the outer
      variable).</p><p>Variables come in four flavors, though they are all expanded
      the same and all look about the same.  They are (in order of
      expanding scope):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Local variables.</p></li><li class="listitem"><p>Command-line variables.</p></li><li class="listitem"><p>Global variables.</p></li><li class="listitem"><p>Environment variables.</p></li></ul></div><p>The classification of variables does not matter much, except
      that the classes are searched from the top (local) to the bottom
      (environment) when looking up a variable.  The first one found
      wins.</p><div class="section"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="localvariables"></a>2.3.1. Local Variables</h3></div></div></div><p>Each target can have as many as seven local variables.
	These are variables that are only <span class="quote">&#8220;<span class="quote">visible</span>&#8221;</span>
	within that target's shell script and contain such things as
	the target's name, all of its sources (from all its dependency
	lines), those sources that were out-of-date, etc.  Four local
	variables are defined for all targets.  They are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">.TARGET</code></span></dt><dd><p>The name of the target.</p></dd><dt><span class="term"><code class="varname">.OODATE</code></span></dt><dd><p>The list of the sources for the target that were
	      considered out-of-date.  The order in the list is not
	      guaranteed to be the same as the order in which the
	      dependencies were given.</p></dd><dt><span class="term"><code class="varname">.ALLSRC</code></span></dt><dd><p>The list of all sources for this target in the order
	      in which they were given.</p></dd><dt><span class="term"><code class="varname">.PREFIX</code></span></dt><dd><p>The target without its suffix and without any
	      leading path.  E.g. for the target
	      <code class="filename">../../lib/compat/fsRead.c</code>, this
	      variable would contain <code class="literal">fsRead</code>.</p></dd></dl></div><p>Three other local variables are set only for certain
	targets under special circumstances.  These are the
	<code class="varname">.IMPSRC,</code> <code class="varname">.ARCHIVE,</code> and
	<code class="varname">.MEMBER</code> variables.  When they are set and
	how they are used is described later.</p><p>Four of these variables may be used in sources as well as
	in shell scripts.  These are <code class="varname">.TARGET</code>,
	<code class="varname">.PREFIX</code>, <code class="varname">.ARCHIVE</code> and
	<code class="varname">.MEMBER</code>.  The variables in the sources are
	expanded once for each target on the dependency line,
	providing what is known as a <span class="quote">&#8220;<span class="quote">dynamic source,</span>&#8221;</span>
	allowing  you to specify several dependency lines at once.
	For example:</p><pre class="programlisting">$(OBJS)         : $(.PREFIX).c</pre><p>will create a dependency between each object file and its
	corresponding C source file.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="cmdvars"></a>2.3.2. Command-line Variables</h3></div></div></div><p>Command-line variables are set when
	<span class="application">PMake</span> is first invoked by giving a
	variable assignment as one of the arguments.
	For example:</p><pre class="screen">pmake "CFLAGS = -I/sprite/src/lib/libc -O"</pre><p>would make <code class="envar">CFLAGS</code> be a command-line
	variable with the given value.  Any assignments to
	<code class="envar">CFLAGS</code> in the makefile will have no effect,
	because once it is set, there is (almost) nothing you can do
	to change a command-line variable (the search order, you see).
	Command-line variables may be set using any of the four
	assignment operators, though only <code class="literal">=</code> and
	<code class="literal">?=</code> behave as you would expect them to,
	mostly because assignments to command-line variables are
	performed before the makefile is read, thus the values set in
	the makefile are unavailable at the time.
	<code class="literal">+=</code> is the same as <code class="literal">=</code>,
	because the old value of the variable is sought only in the
	scope in which the assignment is taking place (for reasons of
	efficiency that I will not get into here).  <code class="literal">:=</code>
	and <code class="literal">?=</code> will work if the  only variables
	used are in the environment.  <code class="literal">!=</code> is sort of
	pointless to use from the command line, since the same effect
	can no doubt be accomplished using the shell's own command
	substitution mechanisms (backquotes and all that).</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="globalvariables"></a>2.3.3. Global Variables</h3></div></div></div><p>Global variables are those set or appended-to in the
	makefile.  There are two classes of global variables: those
	you set and those <span class="application">PMake</span> sets.
	As I said before, the ones you set can have any name you want
	them to have, except they may not contain a colon or an
	exclamation point.
	The variables <span class="application">PMake</span> sets (almost)
	always begin with a period and always contain upper-case
	letters, only.  The variables are as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">.PMAKE</code></span></dt><dd><p>The name by which <span class="application">PMake</span>
	      was invoked is stored in this variable.  For
	      compatibility, the name is also stored in the
	      <code class="varname">MAKE</code> variable.</p></dd><dt><span class="term"><code class="varname">.MAKEFLAGS</code></span></dt><dd><p>All the relevant flags with which
	      <span class="application">PMake</span> was invoked.
	      This does not include such things as <code class="option">-f</code>
	      or variable assignments. Again for compatibility, this
	      value is stored in the <code class="varname">MFLAGS</code>
	      variable as well.</p></dd></dl></div><p>Two other variables, <code class="varname">.INCLUDES</code> and
	<code class="varname">.LIBS,</code> are covered in the section on
	special targets in <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a>.</p><p>Global variables may be deleted using lines of the
	form:</p><pre class="programlisting">#undef variable</pre><p>The <code class="literal">#</code> must be the first character on
	the line.  Note that this may only be done on global
	variables.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="envvars"></a>2.3.4. Environment Variables</h3></div></div></div><p>Environment variables are passed by the shell that invoked
	<span class="application">PMake</span> and are given by
	<span class="application">PMake</span> to each shell it invokes.
	They are expanded like any other variable, but they cannot be
	altered in any way.</p><p>One special environment variable, <code class="envar">PMAKE</code>, is
	examined by <span class="application">PMake</span> for command-line
	flags, variable assignments, etc., it should always use.  This
	variable is examined before the actual arguments to
	<span class="application">PMake</span> are.  In addition, all flags
	given to <span class="application">PMake</span>, either through the
	<code class="envar">PMAKE</code> variable or on the command line, are
	placed in this environment variable and exported to each shell
	<span class="application">PMake</span> executes.  Thus recursive
	invocations of <span class="application">PMake</span> automatically
	receive the same flags as the top-most one.</p><p>Using all these variables, you can compress the sample
	makefile even more:</p><pre class="programlisting">OBJS            = a.o b.o c.o

program         : $(OBJS)
        cc $(.ALLSRC) -o $(.TARGET)

$(OBJS)         : defs.h

a.o             : a.c
        cc -c a.c

b.o             : b.c
        cc -c b.c

c.o             : c.c
        cc -c c.c</pre></div></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="comments"></a>2.4. Comments</h2></div></div></div><p>Comments in a makefile start with a <code class="literal">#</code>
      character and extend to the end of the line.  They may appear
      anywhere you want them, except in a shell command (though the
      shell will treat it as a comment, too).  If, for some reason,
      you need to use the <code class="literal">#</code> in a variable or on a
      dependency line, put a backslash in front of it.
      <span class="application">PMake</span> will compress the two into a
      single <code class="literal">#</code>.</p><div xmlns="" class="note"><h3 class="admontitle">Note: </h3><p xmlns="http://www.w3.org/1999/xhtml">This is not true if <span class="application">PMake</span> is
	operating in full-compatibility mode).</p></div></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="parellelism"></a>2.5. Parallelism</h2></div></div></div><p><span class="application">PMake</span> was specifically designed
      to re-create several targets at once, when possible. You do not
      have to do anything special to cause this to happen (unless
      <span class="application">PMake</span> was configured to not act in
      parallel, in which case you will have to make use of the
      <code class="option">-L</code> and <code class="option">-J</code> flags (see below)),
      but you do have to be careful at times.</p><p>There are several problems you are likely to encounter.  One
      is that some makefiles (and programs) are written in such a way
      that it is impossible for two targets to be made at once.  The
      program <span class="application">xstr</span>, for example, always
      modifies the files <code class="filename">strings</code> and
      <code class="filename">x.c</code>.  There is no way to change it.  Thus
      you cannot run two of them at once without something being
      trashed.  Similarly, if you have commands in the makefile that
      always send output to the same file, you will not be able to
      make more than one target at once unless you change the file you
      use.  You can, for instance, add a <code class="literal">$$$$</code> to
      the end of the file name to tack on the process ID of the shell
      executing the command (each <code class="literal">$$</code> expands to a
      single <code class="literal">$</code>, thus giving you the shell variable
      <code class="literal">$$</code>).  Since only one shell is used for all
      the commands, you will get the same file name for each command
      in the script.</p><p>The other problem comes from improperly-specified
      dependencies that worked in <span class="application">Make</span>
      because of its sequential, depth-first way of examining them.
      While I do not want to go into depth on how
      <span class="application">PMake</span> works (look in <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a> if you are interested), I will warn you that
      files in two different levels of the dependency tree may be
      examined in a different order in
      <span class="application">PMake</span> than they were in
      <span class="application">Make</span>.
      For example, given the makefile:</p><pre class="programlisting">a               :

b c b           : d</pre><p><span class="application">PMake</span> will examine the targets in
      the order <code class="buildtarget">c</code>,
      <code class="buildtarget">d</code>, <code class="buildtarget">b</code>,
      <code class="buildtarget">a</code>.  If the makefile's author expected
      <span class="application">PMake</span> to abort before making
      <code class="buildtarget">c</code> if an error occurred while making
      <code class="buildtarget">b</code>, or if <code class="buildtarget">b</code>
      needed to exist before <code class="buildtarget">c</code> was made,
      (s)he will be sorely disappointed.  The dependencies are
      incomplete, since in both these cases,
      <code class="buildtarget">c</code> would depend on
      <code class="buildtarget">b</code>.  So watch out.</p><p>Another problem you may face is that, while
      <span class="application">PMake</span> is set up to handle the output
      from multiple jobs in a graceful fashion, the same is not so for
      input.  It has no way to regulate input to different jobs, so if
      you use the redirection from <code class="filename">/dev/tty</code> I
      mentioned earlier, you must be careful not to run two of the
      jobs at once.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="writeanddebug"></a>2.6. Writing and Debugging a Makefile</h2></div></div></div><p>Now you know most of what is in a
      <code class="filename">Makefile</code>, what do you do next?  There are
      two choices: use one of the uncommonly-available makefile
      generators or write your own makefile (I leave out the third
      choice of ignoring <span class="application">PMake</span> and doing
      everything by hand as being beyond the bounds of common
      sense).</p><p>When faced with the writing of a makefile, it is usually
      best to start from first principles: just what are you trying to
      do?  What do you want the makefile finally to produce?  To begin
      with a somewhat traditional example, let's say you need to write
      a makefile to create a program, <code class="command">expr</code>, that
      takes standard infix expressions and converts them to prefix
      form (for no readily apparent reason).  You have got three
      source files, in C, that make up the program:
      <code class="filename">main.c</code>, <code class="filename">parse.c</code>, and
      <code class="filename">output.c</code>.  Harking back to my pithy advice
      about dependency lines, you write the first line of the
      file:</p><pre class="programlisting">expr            : main.o parse.o output.o</pre><p>because you remember <code class="filename">expr</code> is made from
      <code class="filename">.o</code> files, not <code class="filename">.c</code>
      files.  Similarly for the <code class="filename">.o</code> files you
      produce the lines:</p><pre class="programlisting">main.o          : main.c

parse.o         : parse.c

output.o        : output.c

main.o parse.o output.o : defs.h</pre><p>Great.  You have now got the dependencies specified.  What
      you need now is commands.  These commands, remember, must
      produce the target on the dependency line, usually by using the
      sources you have listed.  You remember about local variables?
      Good, so it should come to you as no surprise when you
      write:</p><pre class="programlisting">expr            : main.o parse.o output.o
	cc -o $(.TARGET) $(.ALLSRC)</pre><p>Why use the variables?  If your program grows to produce
      postfix expressions too (which, of course, requires a name
      change or two), it is one fewer place you have to change the
      file. You cannot do this for the object files, however, because
      they depend on their corresponding source files and
      <code class="filename">defs.h</code>, thus if you said:</p><pre class="programlisting">cc -c $(.ALLSRC)</pre><p>you will get (for <code class="filename">main.o</code>):</p><pre class="programlisting">cc -c main.c defs.h</pre><p>which is wrong.  So you round out the makefile with these
      lines:</p><pre class="programlisting">main.o          : main.c
	cc -c main.c

parse.o         : parse.c
	cc -c parse.c

output.o        : output.c
	cc -c output.c</pre><p>The makefile is now complete and will, in fact, create the
      program you want it to without unnecessary compilations or
      excessive typing on your part.  There are two things wrong with
      it, however (aside from it being altogether too long, something
      I will address in <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a>):</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The string <code class="literal">main.o parse.o output.o</code> is
	  repeated twice, necessitating two changes when you add
	  postfix (you were planning on that, were not you?).  This is
	  in direct violation of de Boor's First Rule of writing
	  makefiles:</p><p>Anything that needs to be written more than once should
	  be placed in a variable.  I cannot emphasize this enough as
	  being very important to the maintenance of a makefile and
	  its program.</p></li><li class="listitem"><p>There is no way to alter the way compilations are
	  performed short of editing the makefile and making the
	  change in all places.  This is evil and violates de Boor's
	  Second Rule, which follows directly from the first:</p><p>Any flags or programs used inside a makefile should be
	  placed in a variable so they may be changed, temporarily or
	  permanently, with the greatest ease.</p></li></ol></div><p>The makefile should more properly read:</p><pre class="programlisting">OBJS            = main.o parse.o output.o

expr            : $(OBJS)
	$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)

main.o          : main.c
	$(CC) $(CFLAGS) -c main.c

parse.o         : parse.c
	$(CC) $(CFLAGS) -c parse.c

output.o        : output.c
	$(CC) $(CFLAGS) -c output.c

$(OBJS)         : defs.h</pre><p>Alternatively, if you like the idea of dynamic sources
      mentioned in <a class="xref" href="#localvariables" title="2.3.1. Local Variables">Section 2.3.1, &#8220;Local Variables&#8221;</a>, you could write it
      like this:</p><pre class="programlisting">OBJS            = main.o parse.o output.o

expr            : $(OBJS)
	$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)

$(OBJS)         : $(.PREFIX).c defs.h
	$(CC) $(CFLAGS) -c $(.PREFIX).c</pre><p>These two rules and examples lead to de Boor's First
      Corollary:
      <span class="emphasis"><em>Variables are your friends</em></span>.</p><p>Once you have written the makefile comes the
      sometimes-difficult task of making sure the darn thing works.
      Your most helpful tool to make sure the makefile is at least
      syntactically correct is the <code class="option">-n</code> flag, which
      allows you to see if <span class="application">PMake</span> will choke
      on the makefile.  The second thing the <code class="option">-n</code> flag
      lets you do is see what <span class="application">PMake</span> would
      do without it actually doing it, thus you can make sure the
      right commands would be executed were you to give
      <span class="application">PMake</span> its head.</p><p>When you find your makefile is not behaving as you hoped,
      the first question that comes to mind (after <span class="quote">&#8220;<span class="quote">What time is
      it, anyway?</span>&#8221;</span>) is <span class="quote">&#8220;<span class="quote">Why not?</span>&#8221;</span> In answering
      this, two flags will serve you well: <code class="literal">-d m</code> and
      <span class="quote">&#8220;<span class="quote">-p 2</span>&#8221;</span>.
      The first causes <span class="application">PMake</span> to tell you as
      it examines each target in the makefile and indicate why it is
      deciding whatever it is deciding.  You can then use the
      information printed for other targets to see where you went
      wrong.  The <span class="quote">&#8220;<span class="quote">-p 2</span>&#8221;</span> flag makes
      <span class="application">PMake</span> print out its internal state
      when it is done, allowing you to see that you forgot to make
      that one chapter depend on that file of macros you just got a
      new version of.  The output from <span class="quote">&#8220;<span class="quote">-p 2</span>&#8221;</span> is intended
      to resemble closely a real makefile, but with additional
      information provided and with variables expanded in those
      commands <span class="application">PMake</span> actually printed or
      executed.</p><p>Something to be especially careful about is circular
      dependencies.  For example:</p><pre class="programlisting">a         : b

b         : c d

d         : a</pre><p>In this case,
      because of how <span class="application">PMake</span> works,
      <code class="buildtarget">c</code> is the only thing
      <span class="application">PMake</span> will examine, because
      <code class="buildtarget">d</code> and <code class="buildtarget">a</code> will
      effectively fall off the edge of the universe, making it
      impossible to examine <code class="buildtarget">b</code> (or them, for
      that matter).  <span class="application">PMake</span> will tell you
      (if run in its normal mode) all the targets involved in any
      cycle it looked at (i.e. if you have two cycles in the
      graph (naughty, naughty), but only try to make a target in one
      of them, <span class="application">PMake</span> will only tell you
      about that one.  You will have to try to make the other to find
      the second cycle).  When run as <span class="application">Make</span>,
      it will only print the first target in the cycle.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="invoking"></a>2.7. Invoking PMake</h2></div></div></div><p><span class="application">PMake</span> comes with a wide variety
      of flags to choose from.  They may appear in any order,
      interspersed with command-line variable assignments and targets
      to create.  The flags are as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-d <em class="replaceable"><code>what</code></em></code></span></dt><dd><p>This causes <span class="application">PMake</span> to spew
	    out debugging information that may prove useful to you.
	    If you cannot figure out why
	    <span class="application">PMake</span> is doing what it is
	    doing, you might try using this flag.
	    The <em class="replaceable"><code>what</code></em> parameter is a string
	    of single characters that tell
	    <span class="application">PMake</span> what aspects you are
	    interested in.  Most of what I describe will make little
	    sense to you, unless you have dealt with
	    <span class="application">Make</span> before.  Just remember
	    where this table is and come back to it as you read on.
	    The characters and the information they produce are as
	    follows:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="literal">a</code></td><td valign="top">Archive searching and caching.</td></tr><tr valign="top"><td valign="top"><code class="literal">c</code></td><td valign="top">Conditional evaluation.</td></tr><tr valign="top"><td valign="top"><code class="literal">d</code></td><td valign="top">The searching and caching of
		    directories.</td></tr><tr valign="top"><td valign="top"><code class="literal">j</code></td><td valign="top">Various snippets of information related to
		    the running of the multiple shells.  Not
		    particularly interesting.</td></tr><tr valign="top"><td valign="top"><code class="literal">m</code></td><td valign="top">The making of each target: what target is
		    being examined; when it was last modified; whether
		    it is out-of-date; etc.</td></tr><tr valign="top"><td valign="top"><code class="literal">p</code></td><td valign="top">Makefile parsing.</td></tr><tr valign="top"><td valign="top"><code class="literal">r</code></td><td valign="top">Remote execution.</td></tr><tr valign="top"><td valign="top"><code class="literal">s</code></td><td valign="top">The application of suffix-transformation
		    rules.  (See <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a>.)</td></tr><tr valign="top"><td valign="top"><code class="literal">t</code></td><td valign="top">The maintenance of the list of targets.</td></tr><tr valign="top"><td valign="top"><code class="literal">v</code></td><td valign="top">Variable assignment.</td></tr></tbody></table></div><p>Of these all, the <code class="literal">m</code> and
	    <code class="literal">s</code> letters will be most useful to you.
	    If the <code class="option">-d</code> is the final argument or the
	    argument from which it would get these key letters (see
	    below for a note about which argument would be used)
	    begins with a &#8211;, all of these debugging flags will
	    be set, resulting in massive amounts of output.</p></dd><dt><span class="term"><code class="option">-f</code> makefile</span></dt><dd><p>Specify a makefile to read different from the standard
	  makefiles (<code class="filename">Makefile</code> or
	  <code class="filename">makefile</code>).
	  If makefile is <code class="literal">-</code>,
	  <span class="application">PMake</span> uses the standard input.
	  This is useful for making quick and dirty makefiles.</p></dd><dt><span class="term"><code class="option">-h</code></span></dt><dd><p>Prints out a summary of the various flags
	    <span class="application">PMake</span> accepts.
	    It can also be used to find out what level of concurrency was
	    compiled into the version of <span class="application">PMake</span> you
	    are using (look at <code class="literal">-J</code> and
	    <code class="literal">-L</code>) and various other information on how
	    <span class="application">PMake</span> was configured.</p></dd><dt><span class="term"><code class="option">-i</code></span></dt><dd><p>If you give this flag, <span class="application">PMake</span> will
	    ignore non-zero status returned by any of its shells.  It is like
	    placing a <code class="literal">-</code> before all the commands in the
	    makefile.</p></dd><dt><span class="term"><code class="option">-k</code></span></dt><dd><p>This is similar to <code class="option">-i</code> in that it allows
	    <span class="application">PMake</span> to continue when it sees an
	    error, but unlike <code class="option">-i</code>, where
	    <span class="application">PMake</span> continues blithely as if nothing
	    went wrong, <code class="option">-k</code> causes it to recognize the error
	    and only continue work on those things that do not depend on the
	    target, either directly or indirectly (through depending on
	    something that depends on it), whose creation returned the error.
	    The <code class="option">k</code> is for <span class="quote">&#8220;<span class="quote">keep going</span>&#8221;</span>.</p></dd><dt><span class="term"><code class="option">-l</code></span></dt><dd><p><span class="application">PMake</span> has the ability to lock a
	    directory against other people executing it in the same directory
	    (by means of a file called <code class="filename">LOCK.make</code> that it
	    creates and checks for in the directory).  This is a Good Thing
	    because two people doing the same thing in the same place can be
	    disastrous for the final product (too many cooks and all that).
	    Whether this locking is the default is up to your system
	    administrator.  If locking is on, <code class="option">-l</code> will turn it
	    off, and vice versa.
	    Note that this locking will not prevent you from invoking
	    <span class="application">PMake</span> twice in the same place&#8211;if
	    you own the lock file, <span class="application">PMake</span> will warn
	    you about it but continue to execute.</p></dd><dt><span class="term"><code class="option">-m <em class="replaceable"><code>directory</code></em></code></span></dt><dd><p>Tells <span class="application">PMake</span> another place to search
	    for included makefiles via the
	    &lt;<em class="replaceable"><code>filename</code></em>&gt; style.
	    Several <code class="filename">-m</code> options can be given to form a
	    search path.  If this construct is used the default system
	    makefile search path is completely overridden.</p></dd><dt><span class="term"><code class="option">-n</code></span></dt><dd><p>This flag tells <span class="application">PMake</span> not to
	    execute the commands needed to update the out-of-date targets in
	    the makefile.  Rather, <span class="application">PMake</span> will
	    simply print the commands it would have executed and exit.
	    This is particularly useful for checking the correctness of a
	    makefile.  If <span class="application">PMake</span> does not do what
	    you expect it to, it is a good chance the makefile is wrong.</p></dd><dt><span class="term"><code class="option">-p number</code></span></dt><dd><p>This causes <span class="application">PMake</span> to print its
	    input in a reasonable form, though not necessarily one that would
	    make immediate sense to anyone but me.  The number is a bitwise OR
	    of 1 and 2, where 1 means it should print the input before doing
	    any processing and 2 says it should print it after everything has
	    been re-created.
	    Thus <code class="option">-p 3</code> would print it twice-a-once before
	    processing and once after (you might find the difference between
	    the two interesting).  This is mostly useful to me, but you may
	    find it informative in some bizarre circumstances.</p></dd><dt><span class="term"><code class="option">-q</code></span></dt><dd><p>If you give <span class="application">PMake</span> this flag, it
	    will not try to re-create anything.  It will just see if anything
	    is out-of-date and exit non-zero if so.</p></dd><dt><span class="term"><code class="option">-r</code></span></dt><dd><p>When <span class="application">PMake</span> starts up, it reads a
	    default makefile that tells it what sort of system it is on and
	    gives it some idea of what to do if you do not tell it anything.
	    I will tell you about it in <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a>.
	    If you give this flag, <span class="application">PMake</span> will not
	    read the default makefile.</p></dd><dt><span class="term"><code class="option">-s</code></span></dt><dd><p>This causes <span class="application">PMake</span> to not print
	    commands before they are executed.  It is the equivalent of
	    putting an <span class="quote">&#8220;<span class="quote">@</span>&#8221;</span> before every command in the
	    makefile.</p></dd><dt><span class="term"><code class="option">-t</code></span></dt><dd><p>Rather than try to re-create a target,
	    <span class="application">PMake</span> will simply <span class="quote">&#8220;<span class="quote">touch</span>&#8221;</span>
	    it so as to make it appear up-to-date.
	    If the target did not exist before, it will when
	    <span class="application">PMake</span> finishes, but if the target did
	    exist, it will appear to have been updated.</p></dd><dt><span class="term"><code class="option">-v</code></span></dt><dd><p>Targets can still be created in parallel, however.
	    This is the mode <span class="application">PMake</span> will enter
	    if it is invoked either as <code class="command">smake</code> or
	    <code class="command">vmake</code>.</p></dd><dt><span class="term"><code class="option">-x</code></span></dt><dd><p>This tells <span class="application">PMake</span> it is OK to export
	    jobs to other machines, if they are available.  It is used when
	    running in Make mode, as exporting in this mode tends to make
	    things run slower than if the commands were just executed
	    locally.</p></dd><dt><span class="term"><code class="option">-B</code></span></dt><dd><p>Forces <span class="application">PMake</span> to be as
	    backwards-compatible with <span class="application">Make</span> as
	    possible while still being itself.  This includes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Executing one shell per shell command</p></li><li class="listitem"><p>Expanding anything that looks even vaguely like a
		variable, with the empty string replacing any variable
		<span class="application">PMake</span> does not know.</p></li><li class="listitem"><p>Refusing to allow you to escape a <code class="literal">#</code>
		with a backslash.</p></li><li class="listitem"><p>Permitting undefined variables on dependency lines and
		conditionals (see below).  Normally this causes
		<span class="application">PMake</span> to abort.</p></li></ul></div></dd><dt><span class="term"><code class="option">-C</code></span></dt><dd><p>This nullifies any and all compatibility mode flags you may
	    have given or implied up to the time the <code class="option">-C</code> is
	    encountered.  It is useful mostly in a makefile that you wrote for
	    <span class="application">PMake</span> to avoid bad things happening
	    when someone runs <span class="application">PMake</span> as
	    <span class="application">make</span> or has things set in the
	    environment that tell it to be compatible.
	    <code class="option">-C</code> is not placed in the <code class="envar">PMAKE</code>
	    environment variable or the <code class="varname">.MAKEFLAGS</code> or
	    <code class="envar">MFLAGS</code> global variables.</p></dd><dt><span class="term"><code class="option">-D <em class="replaceable"><code>variable</code></em></code></span></dt><dd><p>Allows you to define a variable to have <span class="quote">&#8220;<span class="quote">1</span>&#8221;</span> as
	    its value.  The variable is a global variable, not a command-line
	    variable.  This is useful mostly for people who are used to the C
	    compiler arguments and those using conditionals, which I will get
	    into in <a class="xref" href="#condition" title="4.3. On the Condition...">Section 4.3, &#8220;On the Condition...&#8221;</a>.</p></dd><dt><span class="term"><code class="option">-I <em class="replaceable"><code>directory</code></em></code></span></dt><dd><p>Tells <span class="application">PMake</span> another place to search
	    for included makefiles.  Yet another thing to be explained in
	    <a class="xref" href="#shortcuts" title="Chapter 3. Short-cuts and Other Nice Things">Chapter 3, <em>Short-cuts and Other Nice Things</em></a> (<a class="xref" href="#including" title="3.2. Including Other Makefiles">Section 3.2, &#8220;Including Other Makefiles&#8221;</a>, to be
	    precise).</p></dd><dt><span class="term"><code class="option">-J <em class="replaceable"><code>number</code></em></code></span></dt><dd><p>Gives the absolute maximum number of targets to create at once
	    on both local and remote machines.</p></dd><dt><span class="term"><code class="option">-L <em class="replaceable"><code>number</code></em></code></span></dt><dd><p>This specifies the maximum number of targets to create on the
	    local machine at once.
	    This may be <code class="literal">0</code>, though you should be wary of
	    doing this, as <span class="application">PMake</span> may hang until a
	    remote machine becomes available, if one is not available when it
	    is started.</p></dd><dt><span class="term"><code class="option">-M</code></span></dt><dd><p>This is the flag that provides absolute, complete, full
	    compatibility with <span class="application">Make</span>.  It still
	    allows you to use all but a few of the features of
	    <span class="application">PMake</span>, but it is non-parallel.
	    This is the mode <span class="application">PMake</span> enters if you
	    call it <code class="command">make</code>.</p></dd><dt><span class="term"><code class="option">-P</code></span></dt><dd><p>When creating targets in parallel, several shells are
	    executing at once, each wanting to write its own two cents'-worth
	    to the screen.
	    This output must be captured by <span class="application">PMake</span>
	    in some way  in order to prevent the screen from being filled with
	    garbage even more indecipherable than you usually see.
	    <span class="application">PMake</span> has two ways of doing this, one
	    of which provides for much cleaner output and a clear separation
	    between the output of different jobs, the other of which provides
	    a more immediate response so one can tell what is really
	    happening.  The former is done by notifying you when the creation
	    of a target starts, capturing the output and transferring it to
	    the screen all at once when the job finishes.  The latter is done
	    by catching the output of the shell (and its children) and
	    buffering it until an entire line is received, then printing that
	    line preceded by an indication of which job produced the output.
	    Since I prefer this second method, it is the one used by default.
	    The first method will be used if you give the <code class="option">-P</code>
	    flag to <span class="application">PMake</span>.</p></dd><dt><span class="term"><code class="option">-V</code></span></dt><dd><p>As mentioned before, the <code class="option">-V</code> flag tells
	    <span class="application">PMake</span> to use
	    <span class="application">Make</span>'s style of expanding variables,
	    substituting the empty string for any variable it does not
	    know.</p></dd><dt><span class="term"><code class="option">-W</code></span></dt><dd><p>There are several times when <span class="application">PMake</span>
	    will print a message at you that is only a warning, i.e. it
	    can continue to work in spite of your having done something silly
	    (such as forgotten a leading tab for a shell command).  Sometimes
	    you are well aware of silly things you have done and would like
	    <span class="application">PMake</span> to stop bothering you.  This flag
	    tells it to shut up about anything non-fatal.</p></dd><dt><span class="term"><code class="option">-X</code></span></dt><dd><p>This flag causes <span class="application">PMake</span> to not
	    attempt to export any jobs to another machine.</p></dd></dl></div><p>Several flags may follow a single <code class="literal">-</code>.  Those flags
      that require arguments take them from successive parameters.
      For example:</p><pre class="screen">pmake -fDnI server.mk DEBUG /chip2/X/server/include</pre><p>will cause <span class="application">PMake</span> to read
      <code class="filename">server.mk</code> as the input makefile,
      define the variable <code class="varname">DEBUG</code> as a global variable and
      look  for included makefiles in the directory
      <code class="filename">/chip2/X/server/include</code>.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="summary"></a>2.8. Summary</h2></div></div></div><p>A makefile is made of four types of lines:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Dependency lines</p></li><li class="listitem"><p>Creation commands</p></li><li class="listitem"><p>Variable assignments</p></li><li class="listitem"><p>Comments, include statements and conditional directives</p></li></ul></div><p>A dependency line is a list of one or more targets, an operator
      (<code class="literal">:</code>, <code class="literal">::</code>, or <code class="literal">!</code>),
      and a list of zero or more sources.  Sources may contain wildcards and
      certain local variables.</p><p>A creation command is a regular shell command preceded by a tab.  In
      addition, if the first two characters after the tab
      (and other whitespace) are a combination of <code class="literal">@</code> or
      <code class="literal">-</code>, <span class="application">PMake</span> will cause the
      command to not be printed (if the character is <code class="literal">@</code>) or
      errors from it to be ignored (if <code class="literal">-</code>).  A blank line,
      dependency line or variable assignment terminates a creation script.
      There may be only one creation script for each target with a
      <code class="literal">:</code> or <code class="literal">!</code> operator.</p><p>Variables are places to store text.  They may be unconditionally
      assigned-to using the <code class="literal">=</code> operator, appended-to using
      the <code class="literal">+=</code> operator, conditionally (if the variable is
      undefined) assigned-to with the <code class="literal">?=</code> operator, and
      assigned-to with variable expansion with the <code class="literal">:=</code>
      operator.  The output of a shell command may be assigned to a variable
      using the <code class="literal">!=</code> operator.  Variables may be expanded
      (their value inserted) by enclosing their name in parentheses or curly
      braces, preceded by a dollar sign.  A dollar sign may be escaped with
      another dollar sign.  Variables are not expanded if
      <span class="application">PMake</span> does not know about them.
      There are seven local variables: <code class="varname">.TARGET</code>,
      <code class="varname">.ALLSRC</code>, <code class="varname">.OODATE</code>,
      <code class="varname">.PREFIX</code>, <code class="varname">.IMPSRC</code>,
      <code class="varname">.ARCHIVE</code>, and <code class="varname">.MEMBER</code>.
      Four of them (<code class="varname">.TARGET</code>, <code class="varname">.PREFIX</code>,
      <code class="varname">.ARCHIVE</code>, and <code class="varname">.MEMBER</code>) may be used
      to specify <span class="quote">&#8220;<span class="quote">dynamic sources</span>&#8221;</span>.  Variables are good.  Know
      them.  Love them.  Live them.</p><p>Debugging of makefiles is best accomplished using the
      <code class="option">-n</code>, <code class="option">-d m</code>, and
      <code class="option">-p 2</code> flags.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="shortcuts"></a>Chapter 3. Short-cuts and Other Nice Things</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="section"><a href="#rules">3.1. Transformation Rules</a></span></dt><dt><span class="section"><a href="#including">3.2. Including Other Makefiles</a></span></dt><dt><span class="section"><a href="#savingcmds">3.3. Saving Commands</a></span></dt><dt><span class="section"><a href="#targetattr">3.4. Target Attributes</a></span></dt><dt><span class="section"><a href="#specialtargets">3.5. Special Targets</a></span></dt><dt><span class="section"><a href="#modyvarex">3.6. Modifying Variable Expansion</a></span></dt><dt><span class="section"><a href="#moreexercises">3.7. More Exercises</a></span></dt></dl></div><p>Based on what I have told you so far, you may have gotten the
    impression that <span class="application">PMake</span> is just a way of
    storing away commands and making sure you do not forget to compile
    something.  Good.  That is just what it is.  However, the ways I
    have described have been inelegant, at best, and painful, at
    worst.  This chapter contains things that make the writing of
    makefiles easier and the makefiles themselves shorter and easier
    to modify (and, occasionally, simpler).  In this chapter, I assume
    you are somewhat more familiar with Sprite (or <span class="trademark">UNIX</span>®, if that is
    what you are using) than I did in <a class="xref" href="#basics" title="Chapter 2. The Basics of PMake">Chapter 2, <em>The Basics of PMake</em></a>, just so
    you are on your toes.  So without further ado&#8230;</p><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="rules"></a>3.1. Transformation Rules</h2></div></div></div><p>As you know, a file's name consists of two parts: a base
      name, which gives some hint as to the contents of the file, and
      a suffix, which usually indicates the format of the file.  Over
      the years, as <span class="trademark">UNIX</span>® has developed, naming conventions, with
      regard to suffixes, have also developed that have become almost
      as incontrovertible as Law.  E.g. a file ending in
      <code class="filename">.c</code> is assumed to contain C source code; one
      with a <code class="filename">.o</code> suffix is assumed to be a
      compiled, relocatable object file that may be linked into any
      program; a file with a <code class="filename">.ms</code> suffix is
      usually a text file to be processed by
      <span class="application">Troff</span> with the <code class="literal">-ms</code>
      macro package, and so on.  One of the best aspects of both
      <span class="application">Make</span> and
      <span class="application">PMake</span> comes from their understanding
      of how the suffix of a file pertains to its contents and their
      ability to do things with a file based solely on its suffix.
      This ability comes from something known as a transformation
      rule.  A transformation rule specifies how to change a file with
      one suffix into a file with another suffix.</p><p>A transformation rule looks much like a dependency line,
      except the target is made of two known suffixes stuck
      together.  Suffixes are made known to
      <span class="application">PMake</span> by placing them
      as sources on a dependency line whose target is the special
      target <code class="varname">.SUFFIXES</code>.  E.g.:</p><pre class="programlisting">.SUFFIXES   : .o .c
.c.o        :
	$(CC) $(CFLAGS) -c $(.IMPSRC)</pre><p>The creation script attached to the target is used to
      trans form a file with the first suffix (in this case,
      <code class="filename">.c</code>) into a
      file with the second suffix (here, <code class="filename">.o</code>).
      In addition, the target inherits whatever attributes have
      been applied to the transformation rule.
      The simple rule given above says that to transform a C source
      file into an object file, you compile it using
      <span class="application">cc</span> with the <code class="option">-c</code>
      flag.  This rule is taken straight from the system makefile.
      Many transformation rules (and suffixes) are defined there,
      and I refer you to it for more examples
      (type <code class="command">pmake -h</code> to find out where it
      is).</p><p>There are several things to note about the
      transformation rule given above:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <code class="varname">.IMPSRC</code> variable.
	  This variable is set to the
	  <span class="quote">&#8220;<span class="quote">implied source</span>&#8221;</span> (the file from which
	  the target is  being created; the one with the first
	  suffix), which, in this case, is the
	  <code class="filename">.c</code> file.</p></li><li class="listitem"><p>The <code class="envar">CFLAGS</code> variable.  Almost all of
	  the transformation rules in the system makefile are set
	  up using variables that you can alter in your makefile
	  to tailor the rule to your needs.  In this case, if you
	  want all your C files to be compiled with the
	  <code class="option">-g</code> flag, to provide information for
	  dbx, you would set the <code class="envar">CFLAGS</code> variable to
	  contain <code class="option">-g</code> (<code class="literal">CFLAGS  =
	  -g</code>) and <span class="application">PMake</span>
	  would take care of the rest.</p></li></ol></div><p>To give you a quick example, the makefile in
      <a class="xref" href="#envvars" title="2.3.4. Environment Variables">Section 2.3.4, &#8220;Environment Variables&#8221;</a> could be changed to this:</p><pre class="programlisting">OBJS            = a.o b.o c.o
program         : $(OBJS)
	 $(CC) -o $(.TARGET) $(.ALLSRC)
$(OBJS)         : defs.h</pre><p>The transformation rule I gave above takes the place of the
      6 lines
      <a href="#ftn.idp62966736" class="footnote" id="idp62966736"><sup class="footnote">[1]</sup></a>:</p><pre class="programlisting">a.o             : a.c
	cc -c a.c
b.o             : b.c
	cc -c b.c
c.o             : c.c
	cc -c c.c</pre><p>Now you may be wondering about the dependency between the
      <code class="filename">.o</code>
      and <code class="filename">.c</code> files &#8211; it is not mentioned
      anywhere in the new makefile.  This is because it is not needed:
      one of the effects of applying a transformation rule is the
      target comes to depend on the implied source.  That's why it is
      called the implied source.</p><p>For a more detailed example.  Say you have a makefile like
      this:</p><pre class="programlisting">a.out           : a.o b.o
	$(CC) $(.ALLSRC)</pre><p>and a directory set up like this:</p><pre class="screen">total 4
-rw-rw-r--  1 deboor        34 Sep  7 00:43 Makefile
-rw-rw-r--  1 deboor       119 Oct  3 19:39 a.c
-rw-rw-r--  1 deboor       201 Sep  7 00:43 a.o
-rw-rw-r--  1 deboor        69 Sep  7 00:43 b.c</pre><p>While just typing <code class="command">pmake</code> will do
      the right thing, it is much more informative to type
      <code class="command">pmake -d s</code>.  This will
      show you what <span class="application">PMake</span> is up
      to as it processes the files.  In this case,
      <span class="application">PMake</span> prints the following:</p><pre class="screen">Suff_FindDeps (a.out)
     using existing source a.o
     applying .o -&gt; .out to "a.o"
Suff_FindDeps (a.o)
     trying a.c...got it
     applying .c -&gt; .o to "a.c"
Suff_FindDeps (b.o)
     trying b.c...got it
     applying .c -&gt; .o to "b.c"
Suff_FindDeps (a.c)
     trying a.y...not there
     trying a.l...not there
     trying a.c,v...not there
     trying a.y,v...not there
     trying a.l,v...not there
Suff_FindDeps (b.c)
     trying b.y...not there
     trying b.l...not there
     trying b.c,v...not there
     trying b.y,v...not there
     trying b.l,v...not there
--- a.o ---
cc  -c a.c
--- b.o ---
cc  -c b.c
--- a.out ---
cc a.o b.o</pre><p><code class="computeroutput">Suff_FindDeps</code> is the
      name of a function in <span class="application">PMake</span> that
      is called to check for implied sources for a target using
      transformation rules.  The transformations it tries are,
      naturally enough, limited to the ones that have been defined
      (a transformation may be defined multiple times, by the way,
      but only the most recent one will be used).  You will notice,
      however, that there is a definite order to the suffixes that
      are tried.  This order is set by the relative positions of
      the suffixes on the <code class="varname">.SUFFIXES</code> line
      &#8211; the earlier a suffix appears, the earlier it is
      checked as the source of a transformation.  Once a suffix
      has been defined, the only way to change its position in the
      pecking order is to remove all the suffixes (by having a
      <code class="varname">.SUFFIXES</code> dependency line with no sources)
      and redefine them in the order you want.
      (Previously-defined transformation rules will be
      automatically redefined as the suffixes they involve are
      re-entered.)  Another way to affect the search order is to make
      the dependency explicit.  In the above example,
      <code class="filename">a.out</code> depends on <code class="filename">a.o</code>
      and <code class="filename">b.o</code>.  Since a transformation exists
      from <code class="filename">.o</code> to <code class="filename">.out</code>,
      <span class="application">PMake</span> uses that, as indicated by
      the <code class="computeroutput">using existing source a.o</code>
      message.</p><p>The search for a transformation starts from the suffix of
      the target and continues through all the defined
      transformations, in the order dictated by the suffix ranking,
      until an existing file with the same base (the target name
      minus the suffix and any leading directories) is found.  At that
      point, one or more transformation rules will have been found
      to change the one existing file into the target.</p><p>For example, ignoring what's in the system makefile for
      now, say you have a makefile like this:</p><pre class="screen">.SUFFIXES       : .out .o .c .y .l
.l.c            :
	lex $(.IMPSRC)
	mv lex.yy.c $(.TARGET)
.y.c            :
	yacc $(.IMPSRC)
	mv y.tab.c $(.TARGET)
.c.o            :
	cc -c $(.IMPSRC)
.o.out          :
	cc -o $(.TARGET) $(.IMPSRC)</pre><p>and the single file <code class="filename">jive.l</code>.
      If you were to type <code class="command">pmake -rd ms jive.out</code>,
      you would get the following output for
      <code class="filename">jive.out</code>:</p><pre class="screen">Suff_FindDeps (jive.out)
     trying jive.o...not there
     trying jive.c...not there
     trying jive.y...not there
     trying jive.l...got it
     applying .l -&gt; .c to "jive.l"
     applying .c -&gt; .o to "jive.c"
     applying .o -&gt; .out to "jive.o"</pre><p>and this is why: <span class="application">PMake</span> starts with the
      target <code class="filename">jive.out</code>, figures out its suffix
      (<code class="filename">.out</code>) and looks for things it  can
      transform to a <code class="filename">.out</code> file.  In this case, it
      only finds <code class="filename">.o</code>, so it looks for the file
      <code class="filename">jive.o</code>.  It fails to find it, so it
      looks for transformations into a <code class="filename">.o</code>
      file.  Again it has only one choice: <code class="filename">.c</code>.
      So it looks for <code class="filename">jive.c</code> and, as you
      know, fails to find it.  At this point it has two choices: it can
      create the <code class="filename">.c</code> file from either a
      <code class="filename">.y</code> file or a <code class="filename">.l</code> file.
      Since <code class="filename">.y</code> came first on the
      <code class="varname">.SUFFIXES</code> line, it checks for
      <code class="filename">jive.y</code> first, but can not find it, so it looks
      for <code class="filename">jive.l</code> and, lo and behold, there it is.
      At this point, it has defined a transformation path as follows:</p><div class="literallayout"><p><code class="filename">.l</code>  -&gt;  <code class="filename">.c</code>  -&gt;  <code class="filename">.o</code>  -&gt; <code class="filename">.out</code></p></div><p>and applies the transformation rules accordingly.  For completeness,
      and to give you a better idea of what <span class="application">PMake</span>
      actually did with this three-step transformation, this is what
      <span class="application">PMake</span> printed for the rest of the
      process:</p><pre class="screen">Suff_FindDeps (jive.o)
     using existing source jive.c
     applying .c -&gt; .o to "jive.c"
Suff_FindDeps (jive.c)
     using existing source jive.l
     applying .l -&gt; .c to "jive.l"
Suff_FindDeps (jive.l)
Examining jive.l...modified 17:16:01 Oct 4, 1987...up-to-date
Examining jive.c...non-existent...out-of-date
--- jive.c ---
lex jive.l
... meaningless lex output deleted ...
mv lex.yy.c jive.c
Examining jive.o...non-existent...out-of-date
--- jive.o ---
cc -c jive.c
Examining jive.out...non-existent...out-of-date
--- jive.out ---
cc -o jive.out jive.o</pre><p>One final question remains: what does
      <span class="application">PMake</span> do with targets that have no
      known suffix?  <span class="application">PMake</span> simply pretends
      it actually has a known suffix and searches for
      transformations accordingly.  The suffix it chooses is the
      source for the <code class="buildtarget">.NULL</code> target mentioned
      later.  In the system makefile, <code class="filename">.out</code> is
      chosen as the <span class="quote">&#8220;<span class="quote">null suffix</span>&#8221;</span> because most people
      use <span class="application">PMake</span> to create programs.  You
      are, however, free and welcome to change it to a suffix
      of your own choosing.  The null suffix is ignored, however,
      when <span class="application">PMake</span> is in compatibility
      mode (see <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a>).</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="including"></a>3.2. Including Other Makefiles</h2></div></div></div><p>Just as for programs, it is often useful to extract certain
      parts of a makefile into another file and just include it in
      other makefiles somehow.  Many compilers allow you say something
      like:</p><pre class="programlisting">#include "defs.h"</pre><p>to include the contents of <code class="filename">defs.h</code>
      in the source file.  <span class="application">PMake</span>
      allows you to do the same thing for makefiles, with the
      added ability to use variables in the filenames.  An include
      directive in a makefile looks either like this:</p><pre class="programlisting">#include &lt;file&gt;</pre><p>or this:</p><pre class="programlisting">#include "file"</pre><p>The difference between the two is where
      <span class="application">PMake</span> searches for the file: the first way,
      <span class="application">PMake</span> will look for the file only in the
      system makefile directory (or directories) (to find out what that
      directory is, give <span class="application">PMake</span> the
      <code class="filename">-h</code> flag).
      The system makefile directory search path can be overridden via the
      <code class="option">-m</code> option.  For files in double-quotes, the search
      is more complex:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The directory of the makefile that's including the
	  file.</p></li><li class="listitem"><p>The current directory (the one in which you
	  invoked <span class="application">PMake</span>).</p></li><li class="listitem"><p>The directories given by you using
	  <code class="option">-I</code> flags, in the order in which you
	  gave them.</p></li><li class="listitem"><p>Directories given by
	  <code class="varname">.PATH</code> dependency lines (see
	  <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a>).</p></li><li class="listitem"><p>The system makefile directory.</p></li></ol></div><p>in that order.</p><p>You are free to use <span class="application">PMake</span> variables
      in the filename &#8211; <span class="application">PMake</span>
      will expand them before searching for the file.  You  must
      specify the searching method with either angle brackets or
      double-quotes outside of a variable expansion.  I.e. the following:</p><pre class="programlisting">SYSTEM    = &lt;command.mk&gt;

#include $(SYSTEM)</pre><p>will not work.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="savingcmds"></a>3.3. Saving Commands</h2></div></div></div><p>There may come a time when you will want to save certain
      commands to be executed when everything else is done.  For
      instance:  you are making several different libraries at one
      time and you want to create the members in parallel.  Problem is,
      <span class="application">ranlib</span> is another one of those
      programs that can not be run more than once in the same directory
      at the same time (each one creates a file called
      <code class="filename">__.SYMDEF</code> into which it stuffs information
      for the linker to use.  Two of them running at once will
      overwrite each other's file and the result will be garbage for
      both parties).  You might want a way to save the ranlib
      commands til the end so they can be run one after the other,
      thus keeping them from trashing each other's file.
      <span class="application">PMake</span> allows you to do this by
      inserting an ellipsis (<span class="quote">&#8220;<span class="quote">...</span>&#8221;</span>) as a command between
      commands to be run at once and those to be run later.</p><p>So for the <span class="application">ranlib</span> case above,
      you might do this:</p><pre class="programlisting">lib1.a          : $(LIB1OBJS)
	rm -f $(.TARGET)
	ar cr $(.TARGET) $(.ALLSRC)
	...
	ranlib $(.TARGET)

lib2.a          : $(LIB2OBJS)
	rm -f $(.TARGET)
	ar cr $(.TARGET) $(.ALLSRC)
	...
	ranlib $(.TARGET)</pre><p>This would save both</p><pre class="programlisting">ranlib $(.TARGET)</pre><p>commands until the end, when they would run one after the
      other (using the correct value for the
      <code class="varname">.TARGET</code> variable, of course).</p><p>Commands saved in this manner are only executed if
      <span class="application">PMake</span> manages to re-create
      everything without an error.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="targetattr"></a>3.4. Target Attributes</h2></div></div></div><p><span class="application">PMake</span> allows you to give
      attributes to targets by means of special sources.  Like
      everything else <span class="application">PMake</span> uses, these
      sources begin with a period and are made up of all upper-case
      letters.  There are various reasons for using them, and I will
      try to give examples for most of them.  Others you will have to
      find uses for yourself.  Think of it as <span class="quote">&#8220;<span class="quote">an exercise for
      the reader</span>&#8221;</span>.  By placing one (or more) of these as a
      source on a dependency line, you are <span class="quote">&#8220;<span class="quote">marking the
      target(s) with that attribute</span>&#8221;</span>.  That is just the way I
      phrase it, so you know.</p><p>Any attributes given as sources for a transformation
      rule are applied to the target of the transformation rule
      when the rule is applied.</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="literal">.DONTCARE</code></td><td valign="top">If a target is marked with this attribute and
	      <span class="application">PMake</span> can not figure out
	      how to create it, it will ignore this fact and assume
	      the file is not really needed or actually exists and
	      <span class="application">PMake</span> just can not find
	      it.  This may prove wrong, but the error will be
	      noted later on, not when  <span class="application">PMake</span>
	      tries to create the target so marked.  This attribute also
	      prevents <span class="application">PMake</span> from attempting
	      to touch the target if it is given the
	      <code class="option">-t</code> flag.</td></tr><tr valign="top"><td valign="top"><code class="literal">.EXEC</code></td><td valign="top"><p>This attribute causes its shell script to be
		executed while having no effect on targets that depend
		on it.  This makes the target into a sort of subroutine.
		An example.  Say you have some LISP files that need to
		be compiled and loaded into a LISP process.  To do this,
		you echo LISP commands into a file and execute a LISP
		with this file as its input when  everything is
		done. Say also that you have to load
		other files from another system before you can compile
		your files and further, that you do not want to go
		through the loading and dumping unless one of your
		files has changed.  Your makefile might look a little
		bit like this (remember, this is an  educational example,
		and do not worry about the <code class="buildtarget">COMPILE</code>
		rule, all will soon become clear, grasshopper):

		</p><pre class="programlisting">system          : init a.fasl b.fasl c.fasl
	for i in $(.ALLSRC);
	do
		echo -n '(load "' &gt;&gt; input
		echo -n ${i} &gt;&gt; input
		echo '")' &gt;&gt; input
	done
	echo '(dump "$(.TARGET)")' &gt;&gt; input
	lisp &lt; input

a.fasl          : a.l init COMPILE
b.fasl          : b.l init COMPILE
c.fasl          : c.l init COMPILE
COMPILE         : .USE
	echo '(compile "$(.ALLSRC)")' &gt;&gt; input
init            : .EXEC
	echo '(load-system)' &gt; input</pre><p>

		<code class="literal">.EXEC</code> sources, do not appear in the
		local variables of targets that depend on them (nor are
		they touched if <span class="application">PMake</span> is
		given the <code class="option">-t</code>
		flag).  Note that all the rules, not just that for
		system, include init as a source.  This is because
		none of the other targets can be made until init
		has been made, thus they depend on it.</p></td></tr><tr valign="top"><td valign="top"><code class="literal">.EXPORT</code></td><td valign="top">This is used to mark those targets whose
	      creation should be sent to another machine if at
	      all possible.  This may be used by some exportation
	      schemes if the exportation is expensive.  You
	      should ask your system administrator if it is
	      necessary.</td></tr><tr valign="top"><td valign="top"><code class="literal">.EXPORTSAME</code></td><td valign="top">Tells the export system that the job
	      should be exported to a machine of the same
	      architecture as the current  one.  Certain
	      operations (e.g. running text through nroff) can be
	      performed the same on any architecture (CPU and
	      operating system type), while others (e.g. compiling
	      a program with cc) must be performed on a
	      machine with the same architecture.  Not all export
	      systems will support this attribute.</td></tr><tr valign="top"><td valign="top"><code class="literal">.IGNORE</code></td><td valign="top">Giving a target the
	      <code class="literal">.IGNORE</code> attribute causes
	      <span class="application">PMake</span> to ignore errors
	      from any of the target's commands, as if they all
	      had <code class="literal">-</code> before them.</td></tr><tr valign="top"><td valign="top"><code class="literal">.INVISIBLE</code></td><td valign="top"><p>This allows you to specify one target as a
		source for another without the one affecting the
		other's local variables.  Useful if, say, you
		have a makefile that creates two  programs, one
		of which is used to create the other, so it must
		exist before the other is created. You could say

		</p><pre class="programlisting">prog1           : $(PROG1OBJS) prog2 MAKEINSTALL
prog2           : $(PROG2OBJS) .INVISIBLE MAKEINSTALL</pre><p>

		where <code class="literal">MAKEINSTALL</code>
		is some complex <code class="literal">.USE</code> rule (see
		below) that depends on the <code class="varname">.ALLSRC</code>
		variable containing the right things.  Without the
		<code class="literal">.INVISIBLE</code>
		attribute for <code class="buildtarget">prog2</code>,
		the <code class="literal">MAKEINSTALL</code> rule
		could not be applied.  This is not as useful as it
		should be, and the semantics may change (or the
		whole thing go away) in the not-too-distant
		future.</p></td></tr><tr valign="top"><td valign="top"><code class="literal">.JOIN</code></td><td valign="top"><p>This is another way to avoid performing some
		operations in parallel while permitting
		everything else to be done so.  Specifically it forces
		the target's shell script to be executed only if
		one or more of the sources was out-of-date.  In
		addition, the target's name, in both its
		<code class="varname">.TARGET</code>
		variable and all the local variables of any
		target that depends on it, is replaced by the value
		of its <code class="varname">.ALLSRC</code> variable.  As an
		example, suppose you have a program that has
		four libraries that
		compile in the same directory along with, and at
		the same time as, the program.  You again have
		the problem with ranlib that I mentioned
		earlier, only this time it is more severe: you can not
		just put the ranlib off to the end since the
		program will need those libraries before it can
		be re-created.  You can do something like this:

		</p><pre class="programlisting">program         : $(OBJS) libraries
	cc -o $(.TARGET) $(.ALLSRC)

libraries       : lib1.a lib2.a lib3.a lib4.a .JOIN
	ranlib $(.OODATE)</pre><p>

		In this case, <span class="application">PMake</span> will re-create
		the <code class="literal">$(OBJS)</code>
		as necessary, along with <code class="filename">lib1.a</code>,
		<code class="filename">lib2.a</code>, <code class="filename">lib3.a</code>
		and <code class="filename">lib4.a</code>.  It will then
		execute ranlib on any library that was changed and set
		program's <code class="varname">.ALLSRC</code> variable to contain
		what's in <code class="literal">$(OBJS)</code>
		followed by <span class="quote">&#8220;<span class="quote"><code class="filename">lib1.a</code>
		  <code class="filename">lib2.a</code>
		  <code class="filename">lib3.a</code>
		  <code class="filename">lib4.a</code>.</span>&#8221;</span>  In
		case you are wondering, it is called
		<code class="literal">.JOIN</code> because
		it joins together different threads of the
		<span class="quote">&#8220;<span class="quote">input graph</span>&#8221;</span> at the target marked
		with the attribute.  Another aspect of the
		<code class="literal">.JOIN</code>
		attribute is it keeps the target from being
		created if the <code class="option">-t</code> flag was
		given.</p></td></tr><tr valign="top"><td valign="top"><code class="literal">.MAKE</code></td><td valign="top"><p>The <code class="literal">.MAKE</code>
	      attribute marks its target as being a
	      recursive invocation of PMake.  This forces
	      <span class="application">PMake</span> to execute the
	      script associated with the
	      target (if it is out-of-date) even if you gave
	      the <code class="option">-n</code> or
	      <code class="option">-t</code> flag.  By doing this, you can start
	      at the top of a system and type

	      </p><div class="literallayout"><p><code class="command">pmake -n</code></p></div><p>

	      and have it descend the directory tree (if your
	      makefiles are set up correctly), printing what
	      it would have executed if you had not included
	      the <code class="option">-n</code> flag.</p></td></tr><tr valign="top"><td valign="top"><code class="literal">.NOEXPORT</code></td><td valign="top">If possible,
	      <span class="application">PMake</span> will attempt to
	      export the creation of all targets to another machine
	      (this depends on how <span class="application">PMake</span>
	      was configured).  Sometimes, the creation is so
	      simple, it is pointless to send it to another machine.
	      If you give the target the
	      <code class="literal">.NOEXPORT</code> attribute, it will be run
	      loally, even if you have given
	      <span class="application">PMake</span> the <code class="option">-L
	      0</code> flag.</td></tr><tr valign="top"><td valign="top"><code class="literal">.NOTMAIN</code></td><td valign="top">Normally, if you do not specify a target to
	      make in any other way,
	      <span class="application">PMake</span> will take the first
	      target on the first dependency line of a makefile as
	      the target to create.  That target is known as the
	      <span class="quote">&#8220;<span class="quote">Main Target</span>&#8221;</span> and is labeled as such if
	      you print the dependencies out using the
	      <code class="option">-p</code> flag.  Giving a target this
	      attribute tells <span class="application">PMake</span> that
	      the target is definitely not the Main Target.  This
	      allows you to place targets in an included makefile
	      and have <span class="application">PMake</span> create
	      something else by default.</td></tr><tr valign="top"><td valign="top"><code class="literal">.PRECIOUS</code></td><td valign="top">When <span class="application">PMake</span> is
	      interrupted (you type control-C at the keyboard), it will
	      attempt to clean up after itself by removing any
	      half-made targets.  If a target has the
	      <code class="literal">.PRECIOUS</code> attribute, however,
	      <span class="application">PMake</span> will leave it alone.
	      An additional side effect of the <code class="literal">::</code>
	      operator is to mark the targets as
	      <code class="literal">.PRECIOUS</code>.</td></tr><tr valign="top"><td valign="top"><code class="literal">.SILENT</code></td><td valign="top">Marking a target with this attribute keeps its
	      commands from being printed when they are
	      executed, just as if they had an <code class="literal">@</code>
	      in front of them.</td></tr><tr valign="top"><td valign="top"><code class="literal">.USE</code></td><td valign="top"><p>By giving a target this attribute, you turn it
		into <span class="application"></span>PMake's equivalent of
		a macro.  When the target is
		used as a source for another target, the other target
		acquires the commands, sources and attributes (except
		<code class="literal">.USE</code>) of the source.  If the target
		already has commands, the <code class="literal">.USE</code> target's
		commands are added to the end.  If more than one
		<code class="literal">.USE</code>-marked source is given to a
		target, the rules are applied sequentially.  The typical
		<code class="literal">.USE</code> rule (as I call them) will use
		the sources of the target to which it is applied (as
		stored in the <code class="varname">.ALLSRC</code> variable for
		the target) as its <span class="quote">&#8220;<span class="quote">arguments,</span>&#8221;</span> if you
		will.  For example, you probably noticed that the
		commands for creating <code class="filename">lib1.a</code> and
		<code class="filename">lib2.a</code> in the example in section
		<a class="xref" href="#savingcmds" title="3.3. Saving Commands">Section 3.3, &#8220;Saving Commands&#8221;</a> were exactly the same.
		You can use the <code class="literal">.USE</code> attribute to
		eliminate the repetition, like so:

		</p><pre class="programlisting">lib1.a          : $(LIB1OBJS) MAKELIB
lib2.a          : $(LIB2OBJS) MAKELIB

MAKELIB         : .USE
	rm -f $(.TARGET)
	ar cr $(.TARGET) $(.ALLSRC)
	...
	ranlib $(.TARGET)</pre><p>

		Several system makefiles (not to be confused
		with The System Makefile) make use of these
		<code class="literal">.USE</code> rules to make your life
		easier (they are in the default, system makefile
		directory...take a look).  Note that the
		<code class="literal">.USE</code> rule source itself
		(<code class="buildtarget">MAKELIB</code>) does not appear in
		any of the targets's local variables.  There is no limit
		to the number of times I could use the
		<code class="buildtarget">MAKELIB</code> rule.  If there were
		more libraries, I could continue with
		<code class="literal">lib3.a : $(LIB3OBJS) MAKELIB</code>
		and so on and so forth.</p></td></tr></tbody></table></div></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="specialtargets"></a>3.5. Special Targets</h2></div></div></div><p>As there were in <span class="application">Make</span>, so there
      are certain targets that have special meaning to
      <span class="application">PMake</span>.  When you use one on a
      dependency line,
      it is the only target that may appear on the left-hand-side of the
      operator.  As for the attributes  and variables, all the special
      targets begin with a period and consist of upper-case letters
      only.  I will not describe them all in detail because some of them
      are rather complex and I will describe them in more detail than you
      will want in <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a>.  The targets are as follows:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="buildtarget">.BEGIN</code></td><td valign="top">Any commands attached to this target are
	      executed before anything else is done.  You can use
	      it for any initialization that needs
	      doing.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.DEFAULT</code></td><td valign="top">This is sort of a <code class="literal">.USE</code>
	      rule for any target (that was used only as a source)
	      that <span class="application">PMake</span> can not figure
	      out any other way to create.  It is only <span class="quote">&#8220;<span class="quote">sort
	      of</span>&#8221;</span> a <code class="literal">.USE</code> rule because
	      only the shell script attached to  the
	      <code class="buildtarget">.DEFAULT</code> target is used.
	      The <code class="varname">.IMPSRC</code> variable of a target
	      that inherits <code class="buildtarget">.DEFAULT</code>'s
	      commands is set to the target's own
	      name.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.END</code></td><td valign="top">This serves a function similar to
	      <code class="buildtarget">.BEGIN</code>, in that commands
	      attached to it are executed once everything
	      has been re-created (so long as no errors
	      occurred).  It also serves the extra function of
	      being a place on which <span class="application">PMake</span>
	      can hang commands you put off to the end.  Thus the script
	      for this target will be executed before any of the
	      commands you save with the
	      <span class="quote">&#8220;<span class="quote">...</span>&#8221;</span>.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.EXPORT</code></td><td valign="top">The sources for this target are passed
	      to the exportation system compiled into
	      <span class="application">PMake</span>.  Some systems will use
	      these sources to configure themselves.  You should ask
	      your system administrator about this.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.IGNORE</code></td><td valign="top">This target marks each of its sources
	      with the <code class="literal">.IGNORE</code> attribute.
	      If you do not give it any sources, then it is
	      like giving the <code class="option">-i</code> flag when
	      you invoke <span class="application">PMake</span> &#8211;
	      errors are ignored for all commands.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.INCLUDES</code></td><td valign="top"><p>The sources for this target are taken to be
		suffixes that indicate a file that can be included in
		a program source file.  The suffix must  have
		already been declared with <code class="literal">.SUFFIXES</code>
		(see below).
		Any suffix so marked will have the directories on
		its search path (see <code class="buildtarget">.PATH</code>,
		below) placed in the <code class="varname">.INCLUDES</code>
		variable, each preceded by a <code class="option">-I</code> flag.
		This variable can then be used as an argument for
		the compiler in the normal fashion.  The
		<code class="filename">.h</code> suffix is already marked in
		this way in the system makefile.  E.g. if you have

		  </p><pre class="programlisting">.SUFFIXES       : .bitmap
.PATH.bitmap    : /usr/local/X/lib/bitmaps
.INCLUDES       : .bitmap</pre><p>

		<span class="application">PMake</span> will place
		<code class="literal">-I/usr/local/X/lib/bitmaps</code>
		in the <code class="varname">.INCLUDES</code> variable and you can
		then say

		</p><pre class="programlisting">cc $(.INCLUDES) -c xprogram.c</pre><p>

		(Note: the <code class="varname">.INCLUDES</code> variable is
		not actually filled in until the entire makefile has
		been read.)</p></td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.INTERRUPT</code></td><td valign="top">When <span class="application">PMake</span> is
	      interrupted, it will execute the commands in the
	      script for this target, if it exists.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.LIBS</code></td><td valign="top">This does for libraries what
	      <code class="buildtarget">.INCLUDES</code> does for include
	      files, except the flag used is
	      <code class="option">-L</code>, as required by those linkers
	      that allow you to tell them where to find libraries.
	      The variable used is <code class="varname">.LIBS</code>.
	      Be forewarned that <span class="application">PMake</span>
	      may not have been compiled to do this if the linker
	      on your system does not accept the <code class="option">-L</code>
	      flag, though the <code class="varname">.LIBS</code> variable
	      will always be defined once the makefile has been
	      read.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.MAIN</code></td><td valign="top">If you did not give a target (or targets) to
	      create when you invoked
	      <span class="application">PMake</span>, it will take the
	      sources of this target as the targets to
	      create.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.MAKEFLAGS</code></td><td valign="top">This target provides a way for you to
	      always specify flags for <span class="application">PMake</span>
	      when the makefile is used.  The flags are just as they
	      would be typed to the shell (except you can not use shell
	      variables unless they are in the environment), though
	      the <code class="option">-f</code> and <code class="option">-r</code>
	      flags have no effect.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.NULL</code></td><td valign="top">This allows you to specify what
	      suffix <span class="application">PMake</span> should pretend
	      a file has if, in fact, it has no known suffix.  Only
	      one suffix may be so designated.  The last source on the
	      dependency line is the suffix that is used (you
	      should, however, only give one suffix...).</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.PATH</code></td><td valign="top">If you give sources for this target,
	      <span class="application">PMake</span> will take them as
	      directories in which to search for files it cannot
	      find in the current directory.  If you give no
	      sources, it will clear out any directories added to
	      the search path before.  Since the effects of this
	      all get very complex, we will leave it till <a class="xref" href="#gods" title="Chapter 4. PMake for Gods">Chapter 4, <em>PMake for Gods</em></a> to give you a complete
	      explanation.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.PATH<em class="replaceable"><code>suffix</code></em></code></td><td valign="top">This does a similar thing to
	      <code class="buildtarget">.PATH</code>, but it does it only
	      for files with the given suffix.  The suffix must
	      have been defined already.  Look at Search Paths
	      (<a class="xref" href="#searchpaths" title="4.1. Search Paths">Section 4.1, &#8220;Search Paths&#8221;</a>) for more
	      information.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.PRECIOUS</code></td><td valign="top">Similar to <code class="buildtarget">.IGNORE</code>,
	      this gives the <code class="literal">.PRECIOUS</code> attribute to
	      each source on the dependency line, unless there are
	      no sources, in which case the <code class="literal">.PRECIOUS</code>
	      attribute is given to every target in the file.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.RECURSIVE</code></td><td valign="top">This target applies the <code class="literal">.MAKE</code>
	      attribute to all its sources.  It does nothing if you
	      do not give it any sources.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.SHELL</code></td><td valign="top"><span class="application">PMake</span> is not
	      constrained to only using the Bourne shell to
	      execute the commands you put in the makefile.  You
	      can tell it some other shell to use with this
	      target.  Check out <span class="quote">&#8220;<span class="quote"><a class="xref" href="#ashell" title="4.4. A Shell is a Shell is a Shell">A Shell is a Shell is a Shell</a></span>&#8221;</span> (<a class="xref" href="#ashell" title="4.4. A Shell is a Shell is a Shell">Section 4.4, &#8220;A Shell is a Shell is a Shell&#8221;</a>) for more
	      information.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.SILENT</code></td><td valign="top">When you use
	      <code class="buildtarget">.SILENT</code> as a target, it
	      applies the <code class="literal">.SILENT</code> attribute to
	      each of its sources.  If there are no sources on the
	      dependency line, then it is as if you gave
	      <span class="application">PMake</span> the
	      <code class="option">-s</code> flag and no commands will be
	      echoed.</td></tr><tr valign="top"><td valign="top"><code class="buildtarget">.SUFFIXES</code></td><td valign="top">This is used to give new file suffixes
	      for <span class="application">PMake</span> to handle.
	      Each source is a suffix
	      <span class="application">PMake</span> should
	      recognize.  If you give a
	      <code class="buildtarget">.SUFFIXES</code> dependency line
	      with no sources, <span class="application">PMake</span>
	      will forget about all the suffixes it knew
	      (this also nukes the null suffix).  For those
	      targets that need to have suffixes defined, this
	      is how you do it.</td></tr></tbody></table></div><p>In addition to these targets, a line of the form:</p><pre class="programlisting">attribute : sources</pre><p>applies the attribute to all the targets listed as sources.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="modyvarex"></a>3.6. Modifying Variable Expansion</h2></div></div></div><p>Variables need not always be expanded verbatim.
      <span class="application">PMake</span> defines several modifiers
      that may be applied to a variable's value before it is expanded.
      You apply a modifier by placing it after the variable name with
      a colon between the two, like so:</p><pre class="programlisting">${VARIABLE:modifier}</pre><p>Each modifier is a single character followed by something
      specific to the modifier itself.  You may apply as many
      modifiers as you want &#8211; each one is applied to the
      result of the previous and is separated from the
      previous by another colon.</p><p>There are seven ways to modify a variable's expansion,
      most of which come from the C shell variable modification
      characters:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">Mpattern</code></span></dt><dd><p>This is used to select only those words (a word is a
	    series of characters that are neither spaces nor tabs)
	    that match the given pattern.  The pattern is a
	    wildcard pattern like that used by the shell, where
	    <code class="literal">*</code> means <code class="literal">0</code> or more
	    characters of any sort; <code class="literal">?</code> is any
	    single character; <code class="literal">[abcd]</code> matches any
	    single character that is either <code class="literal">a</code>,
	    <code class="literal">b</code>, <code class="literal">c</code> or
	    <code class="literal">d</code> (there may be any number of
	    characters between the brackets);
	    <code class="literal">[0-9]</code> matches any single character
	    that is between <code class="literal">0</code> and
	    <code class="literal">9</code> (i.e. any digit.  This form may be
	    freely mixed with the other bracket form), and
	    <code class="literal">\</code> is used to escape any of the
	    characters <code class="literal">*</code>, <code class="literal">?</code>,
	    <code class="literal">[</code> or <code class="literal">:</code>, leaving
	    them as regular characters to match themselves in a
	    word.  For example, the system makefile
	    <code class="filename">&lt;makedepend.mk&gt;</code> uses
	    <code class="literal">$(CFLAGS:M-[ID]*)</code> to extract all the
	    <code class="option">-I</code> and <code class="option">-D</code> flags that
	    would be passed to the C compiler.  This allows it to
	    properly locate include files and generate the correct
	    dependencies.</p></dd><dt><span class="term"><code class="literal">Npattern</code></span></dt><dd><p>This is identical to <code class="literal">:M</code> except
	    it substitutes  all words that do not match the given
	    pattern.</p></dd><dt><span class="term"><code class="literal">S/search-string/replacement-string/[g]</code></span></dt><dd><p>Causes the first occurrence of search-string in
	    the variable to be replaced by replacement-string,
	    unless the <code class="option">g</code> flag is given at the end,
	    in which case all occurrences of the string are
	    replaced.  The substitution is performed on each word in
	    the variable in turn.  If search-string begins with a
	    <code class="literal">^</code>, the string must match starting at
	    the beginning of the word.  If search-string ends with a
	    <code class="literal">$</code>, the string must match to the end
	    of the word (these two may be combined to force an exact
	    match).  If a backslash precedes these two characters,
	    however, they lose their special meaning.  Variable
	    expansion also occurs in the normal fashion inside both
	    the search-string and the replacement-string, except
	    that a backslash is used to prevent the expansion of a
	    <code class="literal">$</code>, not another dollar sign, as is
	    usual.  Note that search-string is just a string, not a
	    pattern, so none of the usual regularexpression/wildcard
	    characters have any special meaning save
	    <code class="literal">^</code> and <code class="literal">$</code>.  In the
	    replacement string, the <code class="literal">&amp;</code> character
	    is replaced by the search-string unless it is preceded
	    by a backslash.  You are allowed to use any character
	    except colon or exclamation point to separate the two
	    strings.  This so-called delimiter character may be
	    placed in either string by preceding it with a
	    backslash.</p></dd><dt><span class="term"><code class="literal">T</code></span></dt><dd><p>Replaces each word in the variable expansion by
	    its last component (its <span class="quote">&#8220;<span class="quote">tail</span>&#8221;</span>).
	    For example, given:</p><pre class="programlisting">OBJS = ../lib/a.o b /usr/lib/libm.a
TAILS = $(OBJS:T)</pre><p>the variable <code class="varname">TAILS</code> would expand
	    to <code class="literal">a.o b libm.a.</code></p></dd><dt><span class="term"><code class="literal">H</code></span></dt><dd><p>This is similar to <code class="literal">:T</code>, except
	    that every word is replaced by everything but the tail
	    (the <span class="quote">&#8220;<span class="quote">head</span>&#8221;</span>).  Using the same definition of
	    <code class="varname">OBJS</code>, the string
	    <code class="literal">$(OBJS:H)</code> would expand to
	    <code class="literal">../lib /usr/lib.</code>  Note that the final
	    slash on the heads is removed and anything without
	    a head is replaced by the empty string.</p></dd><dt><span class="term"><code class="literal">E</code></span></dt><dd><p><code class="literal">:E</code> replaces each word by its
	    suffix (<span class="quote">&#8220;<span class="quote">extension</span>&#8221;</span>).  So
	    <code class="literal">$(OBJS:E)</code> would give you
	    <code class="literal">.o .a.</code></p></dd><dt><span class="term"><code class="literal">R</code></span></dt><dd><p>This replaces each word by everything but the
	    suffix (the <span class="quote">&#8220;<span class="quote">root</span>&#8221;</span> of the word).
	    <code class="literal">$(OBJS:R)</code> expands to
	    <code class="literal">../lib/a b /usr/lib/libm</code>.</p></dd></dl></div><p>In addition, the System V style of substitution is also
      supported.  This looks like:</p><pre class="programlisting">$(VARIABLE:search-string=replacement)</pre><p>It must be the last modifier in the chain.  The search is
      anchored at the end of each word, so only suffixes or whole
      words may be replaced.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="moreexercises"></a>3.7. More Exercises</h2></div></div></div><h2 class="title"><a id="idp65804496"></a>Exercise 3.1</h2><p>You have got a set programs, each of which is created from
      its own assembly-language  source file (suffix
      <code class="filename">.asm</code>).  Each program can be assembled into
      two versions, one with error-checking code assembled in and one
      without.  You could assemble them into files with different
      suffixes (<code class="filename">.eobj</code> and
      <code class="filename">.obj</code>, for instance), but your linker only
      understands files that end in <code class="filename">.obj</code>. To top
      it all off, the final executables must have the suffix
      <code class="filename">.exe</code>.  How can you still use
      transformation rules to make your life easier (Hint: assume the
      errorchecking versions have ec tacked onto their prefix)?</p><h2 class="title"><a id="idp65807312"></a>Exercise 3.2</h2><p>Assume, for a moment or two, you want to perform
      a sort of <span class="quote">&#8220;<span class="quote">indirection</span>&#8221;</span> by placing the name of
      a variable into another one, then you want to get the value
      of the first by expanding the second somehow.  Unfortunately,
      <span class="application">PMake</span> does not allow constructs like:</p><pre class="programlisting">$($(FOO))</pre><p>What do you do?  Hint: no further variable expansion is
      performed after modifiers are applied, thus if you
      cause a <code class="literal">$</code> to occur in the expansion,
      that is what will be in the result.</p></div><div class="footnotes"><br /><hr class="footnote-hr" /><div id="ftn.idp62966736" class="footnote"><p><a href="#idp62966736" class="para"><sup class="para">[1] </sup></a>This is also somewhat cleaner, I think, than
	  the dynamic source solution presented in
	  <a class="xref" href="#writeanddebug" title="2.6. Writing and Debugging a Makefile">Section 2.6, &#8220;Writing and Debugging a Makefile&#8221;</a>.</p></div></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="gods"></a>Chapter 4. PMake for Gods</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="section"><a href="#searchpaths">4.1. Search Paths</a></span></dt><dt><span class="section"><a href="#archivesandlibraries">4.2. Archives and Libraries</a></span></dt><dt><span class="section"><a href="#condition">4.3. On the Condition...</a></span></dt><dt><span class="section"><a href="#ashell">4.4. A Shell is a Shell is a Shell</a></span></dt><dt><span class="section"><a href="#compatibility">4.5. Compatibility</a></span></dt><dt><span class="section"><a href="#defcon3">4.6. DEFCON 3 &#8211; Variable Expansion</a></span></dt><dt><span class="section"><a href="#defcon2">4.7. DEFCON 2 &#8211; The Number of the Beast</a></span></dt><dt><span class="section"><a href="#defcon1">4.8. DEFCON 1 &#8211; Imitation is the Not the Highest Form of
      Flattery</a></span></dt><dt><span class="section"><a href="#theway">4.9. The Way Things Work</a></span></dt></dl></div><p>This chapter is devoted to those facilities in
    <span class="application">PMake</span> that allow you to do a great deal
    in a makefile with very little work, as well as do some things you
    could not do in <span class="application">Make</span> without a great
    deal of work (and perhaps the use of other programs).  The problem
    with these features, is they must be handled with care, or you
    will end up with a mess.</p><p>Once more, I assume a greater familiarity with <span class="trademark">UNIX</span>® or Sprite
    than I did in the previous two chapters.</p><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="searchpaths"></a>4.1. Search Paths</h2></div></div></div><p><span class="application">PMake</span> supports the dispersal of
      files into multiple directories by allowing you to specify
      places to look for sources with <code class="buildtarget">.PATH</code>
      targets in the makefile.  The directories you give as sources
      for these targets make up a <span class="quote">&#8220;<span class="quote">search path</span>&#8221;</span>.  Only
      those files used exclusively as sources are actually sought on a
      search path, the assumption being that anything listed as a
      target in the makefile can be created by the makefile and thus
      should be in the current directory.</p><p>There are two types of search paths in
      <span class="application">PMake</span>: one is used for all types of
      files (including included makefiles) and is specified with a
      plain <code class="buildtarget">.PATH</code> target (e.g. <code class="literal">.PATH
      : RCS</code>), while the other is specific to a certain
      type of file, as indicated by the file's suffix.  A specific
      search path is indicated by immediately following the
      <code class="buildtarget">.PATH</code> with the suffix of the file.  For
      instance:</p><pre class="programlisting">.PATH.h         : /sprite/lib/include /sprite/att/lib/include</pre><p>would tell <span class="application">PMake</span> to look in the
      directories <code class="filename">/sprite/lib/include</code> and
      <code class="filename">/sprite/att/lib/include</code> for any
      files whose suffix is <code class="filename">.h</code>.</p><p>The current directory is always consulted first to see if a
      file exists.  Only if it cannot be found there are the
      directories in the specific search path, followed by those in
      the general search path, consulted.</p><p>A search path is also used when expanding wildcard
      characters.  If the pattern has a recognizable suffix on it,
      the path for that suffix will be used for the expansion.
      Otherwise the default search path is employed.</p><p>When a file is found in some directory other than the
      current one, all local variables that would have contained the
      target's name (<code class="varname">.ALLSRC</code>, and
      <code class="varname">.IMPSRC</code>) will instead contain
      the path to the file, as found by
      <span class="application">PMake</span>.
      Thus if you have a file <code class="filename">../lib/mumble.c</code>
      and a makefile like this:</p><pre class="programlisting">.PATH.c         : ../lib
mumble          : mumble.c
	$(CC) -o $(.TARGET) $(.ALLSRC)</pre><p>the command executed to create mumble would be
      <code class="command">cc -o mumble ../lib/mumble.c.</code>
      (as an aside, the command in this case is not strictly
      necessary, since it will be found using transformation rules
      if it is not given.  This is because <code class="filename">.out</code>
      is the null suffix by default and a transformation exists
      from <code class="filename">.c</code> to
      <code class="filename">.out</code>.  Just thought I would throw that in).
      If a file exists in two directories on the same search path,
      the file in the first directory on the path will be the one
      <span class="application">PMake</span> uses.  So if you have
      a large system spread over many directories, it would
      behoove you to follow a naming convention that avoids such
      conflicts.</p><p>Something you should know about the way search paths are
      implemented is that each directory is read, and its contents
      cached, exactly once &#8211; when it is first encountered
      &#8211; so any changes to the directories while
      <span class="application">PMake</span> is running will not be noted
      when searching for implicit sources, nor will they be found when
      <span class="application">PMake</span> attempts to discover when the
      file was last modified, unless the file was created in the
      current directory.  While people have suggested that
      <span class="application">PMake</span> should read the directories
      each time, my experience suggests that the caching seldom causes
      problems.  In addition, not caching the directories slows things
      down enormously because of <span class="application">PMake</span>'s attempts
      to apply transformation rules through non-existent files &#8211; the
      number of extra file-system searches is truly staggering,
      especially if many files without suffixes are used and the null
      suffix is not changed from <code class="filename">.out</code>.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="archivesandlibraries"></a>4.2. Archives and Libraries</h2></div></div></div><p><span class="trademark">UNIX</span>® and Sprite allow you to merge files into an archive
      using the <code class="command">ar</code> command.  Further, if the files
      are relocatable object files, you can run
      <span class="application">ranlib</span> on the archive and get
      yourself a library that you can link into any program you want.
      The main problem with archives is they double the space you need
      to store the archived files, since there is one copy in the
      archive and one copy out by itself.  The problem with libraries
      is you usually think of them as <code class="option">-lm</code> rather
      than <code class="filename">/usr/lib/libm.a</code> and the linker thinks
      they are out-of-date if you so much as look at them.</p><p><span class="application">PMake</span> solves the problem with
      archives by allowing you to tell it to examine the files in the
      archives (so you can remove the individual files without having
      to regenerate them later).  To handle the problem with
      libraries, <span class="application">PMake</span> adds an additional
      way of deciding if a library is out-of-date: if the table of
      contents is older than the library, or is missing, the library
      is out-of-date.</p><p>A library is any target that looks like <code class="option">-lname</code>
      or that ends in a suffix that was marked as a library using the
      <code class="buildtarget">.LIBS</code> target.  <code class="filename">.a</code>
      is so marked in the system makefile.  Members of an archive are
      specified as <code class="literal">archive(member[member...])</code>.
      Thus <code class="literal">libdix.a(window.o)</code> specifies the
      file <code class="filename">window.o</code> in the archive
      <code class="filename">libdix.a</code>.  You may also use
      wildcards to specify the members of the archive.  Just
      remember that most the wildcard characters will only find
      existing files.  A file that is a member of an archive is
      treated specially.  If the file does not exist, but it is
      in the archive, the modification time recorded in the
      archive is used for the file when determining if the file
      is out-of-date.  When figuring out how to make an archived
      member target (not the file itself, but the file in the
      archive &#8211; the archive(member) target), special care
      is taken with the transformation rules, as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>archive(member) is made to depend on member.</p></li><li class="listitem"><p>The transformation from the member's suffix to the
	  archive's suffix is applied to the archive(member) target.</p></li><li class="listitem"><p>The archive(member)'s <code class="varname">.TARGET</code>
	  variable is set to the name of the member if member is
	  actually a target, or the path to the member file if
	  member is only a source.</p></li><li class="listitem"><p>The <code class="varname">.ARCHIVE</code> variable for the
	  archive(member) target is set to the name of the
	  archive.</p></li><li class="listitem"><p>The <code class="varname">.MEMBER</code> variable is set to the
	  actual string inside the parentheses.  In most cases,
	  this will be the same as the <code class="varname">.TARGET</code>
	  variable.</p></li><li class="listitem"><p>The archive(member)'s place in the local variables of
	  the targets that depend on it is taken by the value of its
	  <code class="varname">.TARGET</code> variable.</p></li></ul></div><p>Thus, a program library could be created with the following
      makefile:</p><pre class="programlisting">.o.a            :
	...
	rm -f $(.TARGET:T)
OBJS            = obj1.o obj2.o obj3.o
libprog.a       : libprog.a($(OBJS))
	ar cru $(.TARGET) $(.OODATE)
	ranlib $(.TARGET)</pre><p>This will cause the three object files to be compiled (if
      the corresponding source files were modified after the object
      file or, if that does not exist, the archived object file), the
      out-of-date ones archived in <code class="filename">libprog.a</code>, a
      table of contents placed in the archive and the newly-archived
      object files to be removed.</p><p>All this is used in the <code class="filename">makelib.mk</code> system
      makefile to create a single library with ease.  This makefile looks
      like this:</p><pre class="programlisting">#
# Rules for making libraries. The object files that make up the library
# are removed once they are archived.
#
# To make several libraries in parallel, you should define the variable
# "many_libraries". This will serialize the invocations of ranlib.
#
# To use, do something like this:
#
# OBJECTS = &lt;files in the library&gt;
#
# fish.a: fish.a($(OBJECTS)) MAKELIB
#
#

#ifndef _MAKELIB_MK
_MAKELIB_MK    =

#include  &lt;po.mk&gt;

.po.a .o.a     :
	...
	rm -f $(.MEMBER)

ARFLAGS        ?= crl

#
# Re-archive the out-of-date members and recreate the library's table of
# contents using ranlib. If many_libraries is defined, put the ranlib
# off til the end so many libraries can be made at once.
#
MAKELIB        : .USE .PRECIOUS
	ar $(ARFLAGS) $(.TARGET) $(.OODATE)
#ifndef no_ranlib
# ifdef many_libraries
	...
# endif many_libraries
	ranlib $(.TARGET)
#endif no_ranlib

#endif _MAKELIB_MK</pre></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="condition"></a>4.3. On the Condition...</h2></div></div></div><p>Like the C compiler before it, <span class="application">PMake</span>
      allows you to configure the makefile, based on the current
      environment, using conditional statements.  A conditional looks like
      this:</p><pre class="programlisting">#if boolean expression
lines
#elif another boolean expression
more lines
#else
still more lines
#endif</pre><p>They may be nested to a maximum depth of 30 and may occur
      anywhere (except in a comment, of course).  The
      <code class="literal">#</code> must the very first character on the
      line.</p><p>Each boolean expression is made up of terms that look
      like function calls, the standard C boolean operators
      <code class="literal">&amp;&amp;</code>, <code class="literal">||</code>, and
      <code class="literal">!</code>, and the standard relational operators
      <code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&gt;</code>,
      <code class="literal">&gt;=</code>, <code class="literal">&lt;</code>, and
      <code class="literal">&lt;=</code>, with <code class="literal">==</code> and
      <code class="literal">!=</code> being overloaded to allow string
      comparisons as well.  <code class="literal">&amp;&amp;</code> represents logical
      AND; <code class="literal">||</code> is logical OR and <code class="literal">!</code>
      is logical NOT.  The arithmetic and string operators take
      precedence over all three of these operators, while NOT
      takes precedence over AND, which takes  precedence over OR.
      This precedence may be overridden with parentheses, and an
      expression may be parenthesized to your heart's content.
      Each term looks like a call on one of four functions:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr valign="top"><td valign="top"><code class="literal">make</code></td><td valign="top">The syntax is make(target) where target is
	      a target in the  makefile.  This is true if the
	      given target was specified on the command line, or
	      as the source for a <code class="buildtarget">.MAIN</code>
	      target (note that the sources for
	      <code class="buildtarget">.MAIN</code> are only used if no
	      targets were given on the command
	      line).</td></tr><tr valign="top"><td valign="top"><code class="literal">defined</code></td><td valign="top">The syntax is
	      <code class="literal">defined(variable)</code> and is true
	      if variable is defined.  Certain variables are
	      defined in the system makefile that identify the
	      system on which <span class="application">PMake</span>
	      is being run.</td></tr><tr valign="top"><td valign="top"><code class="literal">exists</code></td><td valign="top">The syntax is
	      <code class="literal">exists(file)</code> and is true if the
	      file can be found on the global search path (i.e.
	      that defined by <code class="varname">.PATH</code> targets, not by
	      <code class="buildtarget">.PATH<em class="replaceable"><code>suffix</code></em></code>
	      targets).</td></tr><tr valign="top"><td valign="top"><code class="literal">empty</code></td><td valign="top">This syntax is much like the others, except
	      the string inside the parentheses is of the same
	      form as you would put between parentheses when
	      expanding a variable, complete with modifiers and
	      everything.  The function returns true if the
	      resulting string is empty.  An undefined
	      variable in this context will cause at the very
	      least a warning message about a malformed
	      conditional, and at the worst will cause the process
	      to stop once it has read the makefile.  If you want
	      to check for a variable being defined or empty,
	      use the expression:
	      <code class="literal">!defined(var) || empty(var)</code>
	      as the definition of <code class="literal">||</code> will
	      prevent the <code class="literal">empty()</code> from being
	      evaluated and causing an error, if the variable
	      is undefined.  This can be used to see if a
	      variable contains a given word, for example:
	      <code class="literal">#if !empty(var:Mword)</code></td></tr></tbody></table></div><p>The arithmetic and string operators may only be used to test
      the value of a variable.  The lefthand side must contain the
      variable expansion, while the righthand side contains either
      a string, enclosed in double-quotes, or a number.  The
      standard C numeric conventions (except for specifying an octal
      number) apply to both sides.  E.g.:</p><pre class="programlisting">#if $(OS) == 4.3

#if $(MACHINE) == "sun3"

#if $(LOAD_ADDR) &gt; 0xc000</pre><p>are all valid conditionals.  In addition, the numeric value
      of a variable can be tested as a boolean as follows:</p><pre class="programlisting">#if $(LOAD)</pre><p>would see if <code class="literal">LOAD</code> contains a
      non-zero value and:</p><pre class="programlisting">#if !$(LOAD)</pre><p>would test if <code class="literal">LOAD</code> contains a
      zero value.</p><p>In addition to the bare <code class="literal">#if</code>, there are other
      forms that apply one of the first two functions to each term.
      They are as follows:</p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody><tr><td><code class="literal">ifdef</code></td><td><code class="literal">defined</code></td></tr><tr><td><code class="literal">ifndef</code></td><td><code class="literal">!defined</code></td></tr><tr><td><code class="literal">ifmake</code></td><td><code class="literal">make</code></td></tr><tr><td><code class="literal">ifnmake</code></td><td><code class="literal">!make</code></td></tr></tbody></table></div><p>There are also the <span class="quote">&#8220;<span class="quote"><code class="literal">else
      if</code></span>&#8221;</span> forms: <code class="literal">elif</code>,
      <code class="literal">elifdef</code>, <code class="literal">elifndef</code>,
      <code class="literal">elifmake</code>, and <code class="literal">elifnmake</code>.</p><p>For instance, if you wish to create two versions of a
      program, one of which is optimized (the production version) and
      the other of which is for debugging (has symbols for dbx),
      you have two choices: you can create two makefiles, one of
      which uses the <code class="option">-g</code> flag for the compilation,
      while the other uses the <code class="option">-O</code> flag, or you
      can use another target (call it debug) to create the debug
      version.  The construct below will take care of this for you.
      I have also made it  so  defining the variable
      <code class="envar">DEBUG</code> (say with <code class="command">pmake -D DEBUG</code>)
      will also cause the debug version to be made.</p><pre class="programlisting">#if defined(DEBUG) || make(debug)
CFLAGS         += -g
#else
CFLAGS         += -O
#endif</pre><p>There are, of course, problems with this approach.  The most
      glaring annoyance is that if you want to go from making a
      debug version to making a production version, you have to
      remove all the object files, or you will get some optimized
      and some debug versions in the same program.  Another
      annoyance is you have to be careful not to make two targets that
      <span class="quote">&#8220;<span class="quote">conflict</span>&#8221;</span> because of some conditionals in the makefile.
      For instance:</p><pre class="programlisting">#if make(print)
FORMATTER = ditroff -Plaser_printer
#endif
#if make(draft)
FORMATTER = nroff -Pdot_matrix_printer
#endif</pre><p>would wreak havoc if you tried <code class="command">pmake draft print</code>
      since you would use the same formatter for each target.  As I said,
      this all gets somewhat complicated.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="ashell"></a>4.4. A Shell is a Shell is a Shell</h2></div></div></div><p>In normal operation, the Bourne Shell (better known
      as <span class="application">sh</span>) is used to execute the
      commands to re-create  targets.  <span class="application">PMake</span>
      also allows you to specify a different shell for it to use when
      executing these commands.  There are several things
      <span class="application">PMake</span> must know about
      the shell you wish to use.  These things are specified as the
      sources for the <code class="buildtarget">.SHELL</code> target by
      keyword, as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">path=path</code></span></dt><dd><p><span class="application">PMake</span> needs to know where
	    the shell actually resides, so it can execute it.  If
	    you specify this and nothing else,
	    <span class="application">PMake</span> will use the last
	    component of the path and look in its table of the
	    shells it knows and use the specification it finds, if
	    any.  Use this if you just want to use a different
	    version of the <span class="application">Bourne</span> or
	    <span class="application">C Shell</span> (yes,
	    <span class="application">PMake</span> knows how to use the
	    <span class="application">C Shell</span> too).</p></dd><dt><span class="term"><code class="literal">name=name</code></span></dt><dd><p>This is the name by which the shell is to be
	    known.  It is a single word and, if no other keywords
	    are specified (other than path), it is the name by
	    which <span class="application">PMake</span> attempts to find
	    a specification for it (as  mentioned above).  You
	    can use this if you would just rather use the C Shell
	    than the <span class="application">Bourne Shell</span>
	    (<code class="literal">.SHELL: name=csh</code> will do it).</p></dd><dt><span class="term"><code class="literal">quiet=echo-off</code> command</span></dt><dd><p>As mentioned before, <span class="application">PMake</span>
	    actually controls whether commands are printed by
	    introducing commands into the shell's input stream.
	    This keyword, and the next two, control what those commands
	    are.  The <code class="literal">quiet</code> keyword is the command
	    used to turn echoing off.  Once it is turned off, echoing is
	    expected to remain off until the <code class="literal">echo-on</code>
	    command is given.</p></dd><dt><span class="term"><code class="literal">echo=echo-on</code> command</span></dt><dd><p>The command <span class="application">PMake</span>
	    should give to turn echoing back on again.</p></dd><dt><span class="term"><code class="literal">filter=printed echo-off</code> command</span></dt><dd><p>Many shells will echo the
	    <code class="literal">echo-off</code> command when it is given.
	    This keyword tells <span class="application">PMake</span> in what
	    format the shell actually prints the <code class="literal">echo-off</code>
	    command.  Wherever <span class="application">PMake</span>
	    sees this string in the shell's output, it will
	    delete it and  any  following whitespace, up to and
	    including the next newline.  See the example at the
	    end of this section for more details.</p></dd><dt><span class="term"><code class="literal">echoFlag=flag</code> to turn echoing on</span></dt><dd><p>Unless a target has been marked
	    <code class="literal">.SILENT</code>, <span class="application">PMake</span>
	    wants to start the shell running with echoing on.  To do
	    this, it passes this flag to the shell as one of its
	    arguments. If either this or the next flag begins with a
	    <code class="literal">-</code>, the flags will be passed to the
	    shell as separate arguments.  Otherwise, the two will
	    be concatenated (if they are used at the same time, of
	    course).</p></dd><dt><span class="term"><code class="literal">errFlag=flag</code> to turn error checking on</span></dt><dd><p>Likewise, unless a  target  is  marked
	    <code class="literal">.IGNORE</code>,
	    <span class="application">PMake</span> wishes error-checking
	    to be on from the very start. To this end, it will pass
	    this flag to the shell as an argument.  The same
	    rules for an initial <code class="literal">-</code> apply as for
	    the <code class="literal">echoFlag</code>.</p></dd><dt><span class="term"><code class="literal">check=command</code> to turn error checking on</span></dt><dd><p>Just as for echo-control, error-control is achieved
	    by inserting  commands into the shell's input stream.
	    This is the command to make the shell check for errors.
	    It also serves another purpose if the shell does not
	    have error-control as commands, but I will get into that
	    in a minute.  Again, once error checking has been turned
	    on, it is expected to remain on until it is turned off
	    again.</p></dd><dt><span class="term"><code class="literal">ignore=command</code>to turn error checking off</span></dt><dd><p>This is the command <span class="application">PMake</span>
	    uses to turn error checking off.  It has another use if
	    the shell does not do errorcontrol, but I will tell you
	    about that...now.</p></dd><dt><span class="term"><code class="literal">hasErrCtl=yes</code> or <code class="literal">no</code></span></dt><dd><p>This takes a value that is either
	    <code class="literal">yes</code> or <code class="literal">no</code>.  Now
	    you might think that the existence of the check and
	    ignore keywords would be enough to tell
	    <span class="application">PMake</span> if the shell can do
	    error-control, but you would be wrong.  If
	    <code class="literal">hasErrCtl</code> is <code class="literal">yes</code>,
	    <span class="application">PMake</span> uses the check and
	    ignore commands in a straight-forward manner.  If this
	    is no, however, their use is rather different.  In this
	    case, the check command is used as a template, in which
	    the string <code class="literal">%s</code> is replaced by the
	    command that is about to be executed, to produce a
	    command for the shell that will echo the command to be
	    executed.  The ignore command is also used as a template,
	    again with <code class="literal">%s</code> replaced by the command
	    to be executed, to produce a command that will
	    execute the command to be executed and ignore any error
	    it returns.  When these strings are used as templates,
	    you must provide newline(s) (<code class="literal">\n</code>) in
	    the appropriate place(s).</p></dd></dl></div><p>The strings that follow these keywords may be enclosed in
      single or double quotes (the quotes will be stripped off) and
      may contain the usual C backslash-characters
      (<code class="literal">\n</code> is newline, <code class="literal">\r</code> is
      return, <code class="literal">\b</code> is backspace,
      <code class="literal">\'</code> escapes a single-quote inside
      single-quotes, <code class="literal">\"</code> escapes a double-quote
      inside double-quotes).  Now for an example.</p><p>This is actually the contents of the &lt;shx.mk&gt; system
      makefile, and causes <span class="application">PMake</span>
      to use the <span class="application">Bourne Shell</span> in such a way
      that  each command is printed as it is executed. That is, if
      more than one command is given on a line, each will be
      printed separately.  Similarly, each time the body of a loop
      is executed, the commands within that loop will be printed,
      etc.  The specification runs like this:</p><pre class="programlisting">#
# This is a shell specification to have the Bourne shell echo
# the commands just before executing them, rather than when it reads
# them. Useful if you want to see how variables are being expanded, etc.
#
.SHELL    : path=/bin/sh \
     quiet="set -" \
     echo="set -x" \
     filter="+ set - " \
     echoFlag=x \
     errFlag=e \
     hasErrCtl=yes \
     check="set -e" \
     ignore="set +e"</pre><p>It tells <span class="application">PMake</span> the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The shell is located in the file
	  <code class="filename">/bin/sh</code>.  It need not tell
	  <span class="application">PMake</span> that the name of the
	  shell is sh as <span class="application">PMake</span> can
	  figure that out for itself (it is the last component of the
	  path).</p></li><li class="listitem"><p>The command to stop echoing is set <code class="literal">-</code>.</p></li><li class="listitem"><p>The command to start echoing is set <code class="option">-x</code>.</p></li><li class="listitem"><p>When the echo off command is executed, the shell
	  will print <code class="literal">+</code> set <code class="literal">-</code>
	  (The <code class="literal">+</code> comes from using the
	  <code class="option">-x</code> flag (rather than the
	  <code class="option">-v</code> flag <span class="application">PMake</span>
	  usually uses)).  <span class="application">PMake</span> will
	  remove all occurrences of this string from the output, so
	  you do not notice extra commands you did not put
	  there.</p></li><li class="listitem"><p>The flag the <span class="application">Bourne Shell</span>
	  will take to start echoing in this way is the
	  <code class="option">-x</code> flag.  The <span class="application">Bourne
	  Shell</span> will only take its flag arguments
	  concatenated as its first argument, so neither this nor
	  the errFlag specification begins with a
	  <code class="literal">-</code>.</p></li><li class="listitem"><p>The flag to use to turn error-checking on from the
	  start is <code class="option">-e</code>.</p></li><li class="listitem"><p>The shell can turn error-checking on and off, and
	  the commands to do so are <code class="literal">set +e</code> and
	  <code class="literal">set -e</code>, respectively.</p></li></ul></div><p>I should note that this specification is for
      <span class="application">Bourne  Shells</span>
      that are not part of Berkeley <span class="trademark">UNIX</span>®, as shells from Berkeley
      do not do error control.  You can get a similar effect,
      however, by changing the last three lines to be:</p><pre class="programlisting">hasErrCtl=no \
check="echo \"+ %s\"\n" \
ignore="sh -c '%s || exit 0\n"</pre><p>This will cause <span class="application">PMake</span> to execute
      the two commands:</p><pre class="programlisting">echo "+ cmd"
sh -c 'cmd || true'</pre><p>for each command for which errors are to be ignored.  (In
      case you are wondering, the thing for ignore tells the shell
      to execute another shell without error checking on and
      always exit 0, since the ||<code class="literal"></code> causes the
      exit 0 to be executed only  if the first command exited
      non-zero, and if the first command exited zero, the shell
      will also exit zero, since that is the last command it
      executed).</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="compatibility"></a>4.5. Compatibility</h2></div></div></div><p>There are three (well, 3 1/2) levels of
      backwards-compatibility built into
      <span class="application">PMake</span>.  Most makefiles will need none
      at all.  Some may need a little bit of work to operate correctly
      when run in parallel.  Each level encompasses the previous
      levels (e.g. <code class="option">-B</code> (one shell per command) implies
      <code class="option">-V</code>).  The three levels are described in the
      following three sections.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="defcon3"></a>4.6. DEFCON 3 &#8211; Variable Expansion</h2></div></div></div><p>As noted before, <span class="application">PMake</span> will not
      expand a variable unless it knows of a value for it.  This can
      cause problems for makefiles that expect to leave variables
      undefined except in special circumstances (e.g. if more flags
      need to be passed to the C compiler or the output from a text
      processor should be sent to a different printer).  If the
      variables are enclosed in curly braces
      (<code class="literal">${PRINTER}</code>), the shell will let them pass.
      If they are enclosed in parentheses, however, the shell will
      declare a syntax error and the make will come to a grinding
      halt.</p><p>You have two choices: change the makefile to define the
      variables (their values can be overridden on the command line,
      since that is where they would have been set if you used
      <span class="application">Make</span>, anyway) or always give the
      <code class="option">-V</code> flag (this can be done with the
      <code class="buildtarget">.MAKEFLAGS</code> target, if you want).</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="defcon2"></a>4.7. DEFCON 2 &#8211; The Number of the Beast</h2></div></div></div><p>Then there are the makefiles that expect certain commands,
      such as changing to a different directory, to not affect
      other commands in a target's creation script.  You can solve
      this is either by going back to executing one shell per
      command (which is what the <code class="option">-B</code> flag forces
      <span class="application">PMake</span> to do), which
      slows the process down a good bit and requires you to use
      semicolons and escaped newlines for shell constructs, or by
      changing the makefile to execute the offending command(s) in
      a subshell (by placing the line inside parentheses), like
      so:</p><pre class="programlisting">install :: .MAKE
      (cd src; $(.PMAKE) install)
      (cd lib; $(.PMAKE) install)
      (cd man; $(.PMAKE) install)</pre><p>This will always execute the three makes (even if the
      <code class="option">-n</code>
      flag was given) because of the combination of the
      <code class="literal">::</code>
      operator and the <code class="literal">.MAKE</code> attribute.
      Each command will change to the proper directory to perform
      the install, leaving the main shell in the directory in
      which it started.</p></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="defcon1"></a>4.8. DEFCON 1 &#8211; Imitation is the Not the Highest Form of
      Flattery</h2></div></div></div><p>The final category of makefile is the one where every command
      requires input, the dependencies are incompletely specified, or
      you simply cannot create more than one target at a time, as
      mentioned earlier.  In addition, you may not have the time or
      desire to upgrade the makefile to run smoothly with
      <span class="application">PMake</span>.  If you are the conservative
      sort, this is the compatibility mode for you.  It is entered
      either by giving <span class="application">PMake</span> the
      <code class="option">-M</code> flag (for <span class="application">Make</span>),
      or by executing <span class="application">PMake</span> as
      <code class="command">make.</code>  In either case,
      <span class="application">PMake</span> performs things exactly like
      <span class="application">Make</span> (while still supporting most
      of the nice new features <span class="application">PMake</span>
      provides).  This includes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>No parallel execution.</p></li><li class="listitem"><p>Targets are made in the exact order specified by the
	  makefile.  The sources for each target are made in strict
	  left-to-right order, etc.</p></li><li class="listitem"><p>A single Bourne shell is used to execute each command,
	  thus the shell's <code class="varname">$$</code> variable is
	  useless, changing directories does not work across command
	  lines, etc.</p></li><li class="listitem"><p>If no special characters exist in a command line,
	  <span class="application">PMake</span> will break the command
	  into words itself and execute the command directly,
	  without executing a shell first.  The characters that
	  cause <span class="application">PMake</span> to execute a shell
	  are: <code class="literal">#</code>, <code class="literal">=</code>,
	  <code class="literal">|</code>, <code class="literal">^</code>,
	  <code class="literal">(</code>, <code class="literal">)</code>,
	  <code class="literal">{</code>, <code class="literal">}</code>,
	  <code class="literal">;</code>, <code class="literal">&amp;</code>,
	  <code class="literal">&gt;</code>, <code class="literal">&lt;</code>,
	  <code class="literal">*</code>, <code class="literal">?</code>,
	  <code class="literal">[</code>, <code class="literal">]</code>,
	  <code class="literal">:</code>, <code class="literal">$</code>,
	  <code class="literal">`</code>, and <code class="literal">\</code>.  You should
	  notice that these are all the characters that are given
	  special meaning by the shell (except <code class="literal">'</code>
	  and <code class="literal">,</code> which
	  <span class="application">PMake</span> deals with all by its
	  lonesome).</p></li><li class="listitem"><p>The use of the null suffix is turned off.</p></li></ul></div></div><div class="section"><div xmlns="" class="titlepage"><div><div><h2 xmlns="http://www.w3.org/1999/xhtml" class="title" style="clear: both"><a id="theway"></a>4.9. The Way Things Work</h2></div></div></div><p>When <span class="application">PMake</span> reads the makefile, it
      parses sources and targets into nodes in a graph.  The graph is
      directed only in the sense that <span class="application">PMake</span>
      knows which way is up.  Each node contains not only links to all
      its parents and children (the nodes that depend on it and those
      on which it depends, respectively), but also a count of the
      number of its children that have already been processed.</p><p>The most important thing to know about how
      <span class="application">PMake</span> uses this graph is that the
      traversal is breadth-first and occurs in two passes.</p><p>After <span class="application">PMake</span> has parsed the
      makefile, it begins with the nodes the user has told it to make
      (either on the command line, or via a
      <code class="buildtarget">.MAIN</code> target, or by the target being
      the first in the file not labeled with the
      <code class="literal">.NOTMAIN</code> attribute) placed in a queue.  It
      continues to take the node off the front of the queue, mark it
      as something that needs to be made, pass the node to
      <code class="literal">Suff_FindDeps</code> (mentioned earlier) to find any
      implicit sources for the node, and place all the node's children
      that have yet to be marked at the end of the queue.  If any of
      the children is a <code class="buildtarget">.USE</code> rule, its
      attributes are applied to the parent, then its commands are
      appended to the parent's list of commands and its children are
      linked to its parent.  The parent's unmade children counter is
      then decremented (since the <code class="buildtarget">.USE</code> node
      has been processed).  You will note that this allows a
      <code class="buildtarget">.USE</code> node to have children that are
      <code class="buildtarget">.USE</code> nodes and the rules will be
      applied in sequence.  If the node has no children, it is placed
      at the end of another queue to be examined in the  second pass.
      This process continues until the first queue is empty.</p><p>At this point, all the leaves of the graph are in the
      examination queue.  <span class="application">PMake</span> removes the
      node at the head of the queue and sees if it is out-of-date.  If
      it is, it is passed to a function that will execute the commands
      for the node asynchronously.  When the commands have completed,
      all the node's parents have their unmade children counter
      decremented and, if the counter is then 0, they are placed on
      the examination queue.  Likewise, if the node is up-to-date.
      Only those parents that were marked on the downward pass are
      processed in this way.  Thus <span class="application">PMake</span>
      traverses the graph back up to the nodes the user instructed it
      to create.  When the examination queue is empty and no shells
      are running to create a target, <span class="application">PMake</span>
      is finished.</p><p>Once all targets have been processed,
      <span class="application">PMake</span> executes the commands attached
      to the <code class="buildtarget">.END</code> target, either explicitly
      or through the use of an ellipsis in a shell script.  If there
      were no errors during the entire process but there are still
      some targets unmade (<span class="application">PMake</span> keeps a
      running count of how many targets are left to be made), there is
      a cycle in the graph.  <span class="application">PMake</span> does a
      depth-first traversal of the graph to find all the targets that
      were not made and prints them out one by one.</p></div></div><div class="chapter"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="answers"></a>Chapter 5. Answers to Exercises</h1></div></div></div><h2 class="title"><a id="idp66053456"></a>Exercise 3.1</h2><p>This is something of a trick question, for which I apologize.
    The trick comes from the <span class="trademark">UNIX</span>® definition of a suffix, which
    <span class="application">PMake</span> does not necessarily share.
    You will have noticed that all the suffixes used in this tutorial
    (and in <span class="trademark">UNIX</span>® in general) begin with a period
    (<code class="filename">.ms</code>, <code class="filename">.c</code>, etc.).
    Now, <span class="application">PMake</span>'s idea of a suffix is more
    like English's: it is the characters at the end of a word.  With
    this in mind, one possible solution to this problem goes as
    follows:</p><pre class="programlisting">.SUFFIXES       : ec.exe .exe ec.obj .obj .asm
ec.objec.exe .obj.exe :
	link -o $(.TARGET) $(.IMPSRC)
.asmec.obj      :
	asm -o $(.TARGET) -DDO_ERROR_CHECKING $(.IMPSRC)
.asm.obj        :
	asm -o $(.TARGET) $(.IMPSRC)</pre><h2 class="title"><a id="idp66057168"></a>Excercise 3.2</h2><p>The trick to this one lies in the <code class="literal">:=</code>
    variable-assignment operator and the <code class="literal">:S</code>
    variable-expansion modifier.  Basically what you want is to take
    the pointer variable, so to speak, and transform it into an
    invocation of the variable at which it points.  You might try
    something like:</p><pre class="programlisting">$(PTR:S/^/\$(/:S/$/))</pre><p>which places <code class="literal">$(</code> at the front of the
    variable name and <code class="literal">)</code> at the end, thus
    transforming <code class="literal">VAR,</code> for example, into
    <code class="literal">$(VAR)</code>, which is just what we want.
    Unfortunately (as you know if you have tried it), since, as it
    says in the hint, <span class="application">PMake</span> does no further
    substitution on the result of a modified expansion, that is all
    you get.  The solution is to make use of <code class="literal">:=</code> to
    place that string into yet another variable, then invoke the other
    variable directly:</p><pre class="programlisting">*PTR            := $(PTR:S/^/\$(/:S/$/)/)</pre><p>You can then use <code class="literal">$(*PTR)</code> to your heart's
    content.</p></div><div class="glossary"><div xmlns="" class="titlepage"><div><div><h1 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="glossary"></a>Glossary of Jargon</h1></div></div></div><dl><dt><span class="glossterm">attribute</span></dt><dd class="glossdef"><p>A property given to a target that causes
	<span class="application">PMake</span> to treat it differently.</p></dd><dt><span class="glossterm"><a id="cmdscript"></a>command script</span></dt><dd class="glossdef"><p>The lines immediately following a dependency line that specify
	commands to execute to create each of the targets on the dependency
	line.  Each line in the command script must begin with a tab.</p></dd><dt><span class="glossterm">command-line variable</span></dt><dd class="glossdef"><p>A variable defined in an argument when
	<span class="application">PMake</span> is first executed.
	Overrides all assignments to the same variable name in the
	makefile.</p></dd><dt><span class="glossterm">conditional</span></dt><dd class="glossdef"><p>A construct much like that used in C that allows a makefile to be
	configured on the fly based on the local environment, or on what is
	being made by that invocation of <span class="application">PMake</span>.</p></dd><dt><span class="glossterm">creation script</span></dt><dd class="glossdef"><p>Commands used to create a target.</p></dd><dt><span class="glossterm">dependency</span></dt><dd class="glossdef"><p>The relationship between a source and a target.  This comes in
	three flavors, as indicated by the operator between the target and the
	source.  <code class="literal">:</code> gives a straight time-wise dependency
	(if the target is older than the source, the target is out-of-date),
	while <code class="literal">!</code> provides simply an ordering and always
	considers the target out-of-date.  <code class="literal">::</code> is much like
	<code class="literal">:</code>, save it creates multiple instances of a target
	each of which depends on its own list of sources.</p></dd><dt><span class="glossterm">dynamic source</span></dt><dd class="glossdef"><p>This refers to a source that has a local variable invocation in
	it.  It allows a single dependency line to specify a different source
	for each target on the line.</p></dd><dt><span class="glossterm">global variable</span></dt><dd class="glossdef"><p>Any variable defined in a makefile.  Takes precedence over
	variables defined in the environment, but not over command-line or
	local variables.</p></dd><dt><span class="glossterm">input graph</span></dt><dd class="glossdef"><p>What <span class="application">PMake</span> constructs from a makefile.
	Consists of nodes made of the targets in the makefile, and the links
	between them (the dependencies).  The links are directed (from source
	to target) and there may not be any cycles (loops) in the graph.</p></dd><dt><span class="glossterm">local variable</span></dt><dd class="glossdef"><p>A variable defined by <span class="application">PMake</span> visible
	only in a target's shell script.
	There are seven local variables, not all of which are defined for
	every target: <code class="varname">.TARGET</code>, <code class="varname">.ALLSRC</code>,
	<code class="varname">.OODATE</code>, <code class="varname">.PREFIX</code>,
	<code class="varname">.IMPSRC</code>, <code class="varname">.ARCHIVE</code>, and
	<code class="varname">.MEMBER</code>.
	<code class="varname">.TARGET</code>, <code class="varname">.PREFIX</code>,
	<code class="varname">.ARCHIVE</code>, and <code class="varname">.MEMBER</code>
	may be used on dependency lines to create
	<span class="quote">&#8220;<span class="quote">dynamic sources</span>&#8221;</span>.</p></dd><dt><span class="glossterm">makefile</span></dt><dd class="glossdef"><p>A file that describes how a system is built.  If you do not know
	what it is after reading this tutorial&#8230;</p></dd><dt><span class="glossterm">modifier</span></dt><dd class="glossdef"><p>A letter, following a colon, used to alter how a variable is
	expanded.  It has no effect on the variable itself.</p></dd><dt><span class="glossterm">operator</span></dt><dd class="glossdef"><p>What separates a source from a target (on a dependency line) and
	specifies the relationship between the two.  There are three:
	<code class="literal">:</code>, <code class="literal">::</code>,
	and <code class="literal">!</code>.</p></dd><dt><span class="glossterm">search path</span></dt><dd class="glossdef"><p>A list of directories in which a file should be sought.
	<span class="application">PMake</span>'s view of the contents of directories
	in a search path does not change once the makefile has been read.
	A file is sought on a search path only if it is exclusively a
	source.</p></dd><dt><span class="glossterm">shell</span></dt><dd class="glossdef"><p>A program to which commands are passed in order to create
	targets.</p></dd><dt><span class="glossterm">source</span></dt><dd class="glossdef"><p>Anything to the right of an operator on a dependency line.
	Targets on the dependency line are usually created
	from the sources.</p></dd><dt><span class="glossterm">special target</span></dt><dd class="glossdef"><p>A target that causes <span class="application">PMake</span> to do
      special things when it is encountered.</p></dd><dt><span class="glossterm">suffix</span></dt><dd class="glossdef"><p>The tail end of a file name.  Usually begins with a period, like
	<code class="filename">.c</code> or <code class="filename">.ms</code>.</p></dd><dt><span class="glossterm">target</span></dt><dd class="glossdef"><p>A word to the left of the operator on a dependency line.
	More generally, any file that <span class="application">PMake</span> might
	create.  A file may be (and often is) both a target and a source (what
	it is depends on how <span class="application">PMake</span> is looking at it
	at the time &#8211; sort of like the wave/particle duality of light,
	you know).</p></dd><dt><span class="glossterm">transformation rule</span></dt><dd class="glossdef"><p>A special construct in a makefile that specifies how to create a
	file of one type from a file of another, as indicated by their
	suffixes.</p></dd><dt><span class="glossterm">variable expansion</span></dt><dd class="glossdef"><p>The process of substituting the value of a variable for a
	reference to it.  Expansion may be altered by means of modifiers.</p></dd><dt><span class="glossterm">variable</span></dt><dd class="glossdef"><p>A place in which to store text that may be retrieved later.
	Also used to define the local environment.
	Conditionals exist that test whether a variable is defined or not.</p></dd></dl></div></div></body></html>